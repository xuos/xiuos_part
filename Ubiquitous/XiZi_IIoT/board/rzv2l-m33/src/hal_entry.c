/*
* Copyright (c) 2020 AIIT XUOS Lab
* XiUOS is licensed under Mulan PSL v2.
* You can use this software according to the terms and conditions of the Mulan PSL v2.
* You may obtain a copy of Mulan PSL v2 at:
*        http://license.coscl.org.cn/MulanPSL2
* THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
* EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
* MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
* See the Mulan PSL v2 for more details.
*/

/**
* @file hal_entry.c
* @brief kernel startup
* @version 1.0 
* @author AIIT XUOS Lab
* @date 2024.1.10
*/

#include "hal_data.h"
#include <board.h>
#include <console.h>
#include <xizi.h>
#include <arch_interrupt.h>
#include <rpmsg_task.h>

// FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
// FSP_CPP_FOOTER

void XiZi_SysTick_Handler(void)
{
    x_base lock = DISABLE_INTERRUPT();

    TickAndTaskTimesliceUpdate();

    ENABLE_INTERRUPT(lock);
}

/**
 * main() is generated by the Configuration editor and is used to generate threads if an RTOS is used.
 * This function is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    /* system irq table must be inited before initialization of Hardware irq  */
	SysInitIsrManager();
    
    InitBoardMemory((void *)HEAP_START, (void *)HEAP_END);
    KPrintf("hal_entry: InitBoardMemory -- HEAP_START = %p, HEAP_END = %p, Size = %dKB !\n"
        ,(void *)HEAP_START,(void *)HEAP_END,(((void *)HEAP_END) - ((void *)HEAP_START)) / 1024);
    
    #ifdef KERNEL_QUEUEMANAGE
        QueuemanagerDoneRegister();
    #endif
    #ifdef KERNEL_BANNER
        ShowBanner();
    #endif

    SysInitOsAssign();
    CreateKServiceKTask();

    CreateEnvInitTask();
    KPrintf("hal_entry: init kernel envirement final!\n");
    
    DISABLE_INTERRUPT();
    KPrintf("hal_entry: disable interrupt now!\n");
    
    g_timer2.p_api->open(g_timer2.p_ctrl, g_timer2.p_cfg);
    g_timer2.p_api->callbackSet(g_timer2.p_ctrl, XiZi_SysTick_Handler, NULL, NULL);
    g_timer2.p_api->start(g_timer2.p_ctrl);

    KPrintf("hal_entry: enable interrupt!\n");
    StartupOsAssign();
}

/*******************************************************************************************************************
* This function is called at various points during the startup process.  This implementation uses the event that is
* called right before main() to set up the pins.
*
* @param[in]  event    Where at in the start up process the code is currently at
**********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open(&g_ioport_ctrl, &g_bsp_pin_cfg);
    }
}
