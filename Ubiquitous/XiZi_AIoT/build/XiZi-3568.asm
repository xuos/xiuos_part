
XiZi-3568.elf:     file format elf64-littleaarch64


Disassembly of section .start_sec:

0000000010000000 <_boot_start>:
    10000000:	9400001d 	bl	10000074 <el2_setup>
    10000004:	d2a00600 	mov	x0, #0x300000              	// #3145728
    10000008:	d5181040 	msr	cpacr_el1, x0
    1000000c:	d5033fdf 	isb
    10000010:	d518403f 	msr	elr_el1, xzr
    10000014:	580006a0 	ldr	x0, 100000e8 <el2_setup+0x74>
    10000018:	d2820001 	mov	x1, #0x1000                	// #4096
    1000001c:	d53800a2 	mrs	x2, mpidr_el1
    10000020:	92400442 	and	x2, x2, #0x3
    10000024:	aa0203e5 	mov	x5, x2
    10000028:	9b017c43 	mul	x3, x2, x1
    1000002c:	cb030000 	sub	x0, x0, x3
    10000030:	9100001f 	mov	sp, x0
    10000034:	d28018a2 	mov	x2, #0xc5                  	// #197
    10000038:	d5184002 	msr	spsr_el1, x2
    1000003c:	d53800a2 	mrs	x2, mpidr_el1
    10000040:	92400442 	and	x2, x2, #0x3
    10000044:	aa0203e5 	mov	x5, x2
    10000048:	f10000bf 	cmp	x5, #0x0
    1000004c:	54000060 	b.eq	10000058 <primary_cpu_init>  // b.none
    10000050:	940000e4 	bl	100003e0 <bootmain>
    10000054:	94000000 	bl	10000054 <_boot_start+0x54>

0000000010000058 <primary_cpu_init>:
    10000058:	580004c1 	ldr	x1, 100000f0 <el2_setup+0x7c>
    1000005c:	580004e2 	ldr	x2, 100000f8 <el2_setup+0x84>
    10000060:	d2800003 	mov	x3, #0x0                   	// #0
    10000064:	eb02003f 	cmp	x1, x2
    10000068:	a8810c23 	stp	x3, x3, [x1], #16
    1000006c:	54ffffcb 	b.lt	10000064 <primary_cpu_init+0xc>  // b.tstop
    10000070:	940000dc 	bl	100003e0 <bootmain>

0000000010000074 <el2_setup>:
    10000074:	d5384240 	mrs	x0, currentel
    10000078:	d342fc00 	lsr	x0, x0, #2
    1000007c:	92400400 	and	x0, x0, #0x3
    10000080:	f100081f 	cmp	x0, #0x2
    10000084:	54000040 	b.eq	1000008c <el2_setup+0x18>  // b.none
    10000088:	d65f03c0 	ret
    1000008c:	d2b00000 	mov	x0, #0x80000000            	// #2147483648
    10000090:	d51c1100 	msr	hcr_el2, x0
    10000094:	d53ce100 	mrs	x0, cnthctl_el2
    10000098:	b2400400 	orr	x0, x0, #0x3
    1000009c:	d51ce100 	msr	cnthctl_el2, x0
    100000a0:	d5380000 	mrs	x0, midr_el1
    100000a4:	d53800a1 	mrs	x1, mpidr_el1
    100000a8:	d51c0000 	msr	vpidr_el2, x0
    100000ac:	d51c00a1 	msr	vmpidr_el2, x1
    100000b0:	d2867fe0 	mov	x0, #0x33ff                	// #13311
    100000b4:	d51c1140 	msr	cptr_el2, x0
    100000b8:	d51c117f 	msr	hstr_el2, xzr
    100000bc:	910003e0 	mov	x0, sp
    100000c0:	d51c4100 	msr	sp_el1, x0
    100000c4:	d5381000 	mrs	x0, sctlr_el1
    100000c8:	b2400000 	orr	x0, x0, #0x1
    100000cc:	927ef800 	and	x0, x0, #0xfffffffffffffffd
    100000d0:	b27e0000 	orr	x0, x0, #0x4
    100000d4:	d5181000 	msr	sctlr_el1, x0
    100000d8:	d28038a0 	mov	x0, #0x1c5                 	// #453
    100000dc:	d51c4000 	msr	spsr_el2, x0
    100000e0:	d51c403e 	msr	elr_el2, x30
    100000e4:	d69f03e0 	eret
    100000e8:	10409000 	.word	0x10409000
    100000ec:	00000000 	.word	0x00000000
    100000f0:	10000498 	.word	0x10000498
    100000f4:	00000000 	.word	0x00000000
    100000f8:	10409000 	.word	0x10409000
    100000fc:	00000000 	.word	0x00000000

0000000010000100 <build_boot_pgdir>:

uint64_t boot_dev_l4pgdirs[NUM_LEVEL3_PDE][NUM_LEVEL4_PTE] __attribute__((aligned(0x1000))) = { 0 };
uint64_t boot_kern_l4pgdirs[NUM_LEVEL3_PDE][NUM_LEVEL4_PTE] __attribute__((aligned(0x1000))) = { 0 };

static void build_boot_pgdir()
{
    10000100:	d100c3ff 	sub	sp, sp, #0x30
    static bool built = false;
    if (!built) {
    10000104:	90002020 	adrp	x0, 10404000 <_bss_inited>
    10000108:	91000400 	add	x0, x0, #0x1
    1000010c:	39400000 	ldrb	w0, [x0]
    10000110:	52000000 	eor	w0, w0, #0x1
    10000114:	12001c00 	and	w0, w0, #0xff
    10000118:	7100001f 	cmp	w0, #0x0
    1000011c:	540012c0 	b.eq	10000374 <build_boot_pgdir+0x274>  // b.none
        uint64_t dev_phy_mem_base = DEV_PHYMEM_BASE;
    10000120:	d2be0000 	mov	x0, #0xf0000000            	// #4026531840
    10000124:	f90003e0 	str	x0, [sp]

        // dev mem
        boot_l2pgdir[(dev_phy_mem_base >> LEVEL2_PDE_SHIFT) & IDX_MASK] = (uint64_t)boot_dev_l3pgdir | L2_TYPE_TAB | L2_PTE_VALID;
    10000128:	f000aa00 	adrp	x0, 11543000 <boot_end_addr+0x113a000>
    1000012c:	f9428c00 	ldr	x0, [x0, #1304]
    10000130:	f94003e1 	ldr	x1, [sp]
    10000134:	d35efc21 	lsr	x1, x1, #30
    10000138:	92402021 	and	x1, x1, #0x1ff
    1000013c:	b2400402 	orr	x2, x0, #0x3
    10000140:	f000aa00 	adrp	x0, 11543000 <boot_end_addr+0x113a000>
    10000144:	f942e000 	ldr	x0, [x0, #1472]
    10000148:	f8217802 	str	x2, [x0, x1, lsl #3]
        boot_l2pgdir[(MMIO_P2V_WO(dev_phy_mem_base) >> LEVEL2_PDE_SHIFT) & IDX_MASK] = (uint64_t)boot_dev_l3pgdir | L2_TYPE_TAB | L2_PTE_VALID;
    1000014c:	f000aa00 	adrp	x0, 11543000 <boot_end_addr+0x113a000>
    10000150:	f9428c00 	ldr	x0, [x0, #1304]
    10000154:	f94003e2 	ldr	x2, [sp]
    10000158:	d2c00801 	mov	x1, #0x4000000000          	// #274877906944
    1000015c:	8b010041 	add	x1, x2, x1
    10000160:	d35efc21 	lsr	x1, x1, #30
    10000164:	92402021 	and	x1, x1, #0x1ff
    10000168:	b2400402 	orr	x2, x0, #0x3
    1000016c:	f000aa00 	adrp	x0, 11543000 <boot_end_addr+0x113a000>
    10000170:	f942e000 	ldr	x0, [x0, #1472]
    10000174:	f8217802 	str	x2, [x0, x1, lsl #3]

        uint64_t cur_mem_paddr = ALIGNDOWN((uint64_t)DEV_PHYMEM_BASE, LEVEL2_PDE_SIZE);
    10000178:	d2b80000 	mov	x0, #0xc0000000            	// #3221225472
    1000017c:	f90017e0 	str	x0, [sp, #40]
        for (size_t i = 0; i < NUM_LEVEL3_PDE; i++) {
    10000180:	f90013ff 	str	xzr, [sp, #32]
    10000184:	14000041 	b	10000288 <build_boot_pgdir+0x188>
            boot_dev_l3pgdir[i] = (uint64_t)boot_dev_l4pgdirs[i] | L3_TYPE_TAB | L3_PTE_VALID;
    10000188:	f94013e0 	ldr	x0, [sp, #32]
    1000018c:	d374cc01 	lsl	x1, x0, #12
    10000190:	f000aa00 	adrp	x0, 11543000 <boot_end_addr+0x113a000>
    10000194:	f942b800 	ldr	x0, [x0, #1392]
    10000198:	8b000020 	add	x0, x1, x0
    1000019c:	b2400402 	orr	x2, x0, #0x3
    100001a0:	f000aa00 	adrp	x0, 11543000 <boot_end_addr+0x113a000>
    100001a4:	f9428c00 	ldr	x0, [x0, #1304]
    100001a8:	f94013e1 	ldr	x1, [sp, #32]
    100001ac:	f8217802 	str	x2, [x0, x1, lsl #3]

            for (size_t j = 0; j < NUM_LEVEL4_PTE; j++) {
    100001b0:	f9000fff 	str	xzr, [sp, #24]
    100001b4:	1400002f 	b	10000270 <build_boot_pgdir+0x170>
                boot_dev_l4pgdirs[i][j] = cur_mem_paddr | L4_TYPE_PAGE | L4_PTE_DEV | L4_PTE_AF | L4_PTE_XN;
    100001b8:	f94017e1 	ldr	x1, [sp, #40]
    100001bc:	d2808060 	mov	x0, #0x403                 	// #1027
    100001c0:	f2e00c00 	movk	x0, #0x60, lsl #48
    100001c4:	aa000022 	orr	x2, x1, x0
    100001c8:	f000aa00 	adrp	x0, 11543000 <boot_end_addr+0x113a000>
    100001cc:	f942b800 	ldr	x0, [x0, #1392]
    100001d0:	f94013e1 	ldr	x1, [sp, #32]
    100001d4:	d377d823 	lsl	x3, x1, #9
    100001d8:	f9400fe1 	ldr	x1, [sp, #24]
    100001dc:	8b010061 	add	x1, x3, x1
    100001e0:	f8217802 	str	x2, [x0, x1, lsl #3]
                if (cur_mem_paddr >= DEV_PHYMEM_BASE && cur_mem_paddr < DEV_PHYMEM_BASE + DEV_MEM_SIZE) {
    100001e4:	f94017e1 	ldr	x1, [sp, #40]
    100001e8:	12a20000 	mov	w0, #0xefffffff            	// #-268435457
    100001ec:	eb00003f 	cmp	x1, x0
    100001f0:	54000209 	b.ls	10000230 <build_boot_pgdir+0x130>  // b.plast
    100001f4:	f94017e1 	ldr	x1, [sp, #40]
    100001f8:	b2407fe0 	mov	x0, #0xffffffff            	// #4294967295
    100001fc:	eb00003f 	cmp	x1, x0
    10000200:	54000188 	b.hi	10000230 <build_boot_pgdir+0x130>  // b.pmore
                    boot_dev_l4pgdirs[i][j] = cur_mem_paddr | 0x403;
    10000204:	f94017e1 	ldr	x1, [sp, #40]
    10000208:	d2808060 	mov	x0, #0x403                 	// #1027
    1000020c:	aa000022 	orr	x2, x1, x0
    10000210:	f000aa00 	adrp	x0, 11543000 <boot_end_addr+0x113a000>
    10000214:	f942b800 	ldr	x0, [x0, #1392]
    10000218:	f94013e1 	ldr	x1, [sp, #32]
    1000021c:	d377d823 	lsl	x3, x1, #9
    10000220:	f9400fe1 	ldr	x1, [sp, #24]
    10000224:	8b010061 	add	x1, x3, x1
    10000228:	f8217802 	str	x2, [x0, x1, lsl #3]
    1000022c:	1400000b 	b	10000258 <build_boot_pgdir+0x158>
                } else {
                    // boot_dev_l4pgdirs[i][j] = cur_mem_paddr | 0x713;
                    boot_dev_l4pgdirs[i][j] = cur_mem_paddr | 0x403;
    10000230:	f94017e1 	ldr	x1, [sp, #40]
    10000234:	d2808060 	mov	x0, #0x403                 	// #1027
    10000238:	aa000022 	orr	x2, x1, x0
    1000023c:	f000aa00 	adrp	x0, 11543000 <boot_end_addr+0x113a000>
    10000240:	f942b800 	ldr	x0, [x0, #1392]
    10000244:	f94013e1 	ldr	x1, [sp, #32]
    10000248:	d377d823 	lsl	x3, x1, #9
    1000024c:	f9400fe1 	ldr	x1, [sp, #24]
    10000250:	8b010061 	add	x1, x3, x1
    10000254:	f8217802 	str	x2, [x0, x1, lsl #3]
                }

                cur_mem_paddr += PAGE_SIZE;
    10000258:	f94017e0 	ldr	x0, [sp, #40]
    1000025c:	91400400 	add	x0, x0, #0x1, lsl #12
    10000260:	f90017e0 	str	x0, [sp, #40]
            for (size_t j = 0; j < NUM_LEVEL4_PTE; j++) {
    10000264:	f9400fe0 	ldr	x0, [sp, #24]
    10000268:	91000400 	add	x0, x0, #0x1
    1000026c:	f9000fe0 	str	x0, [sp, #24]
    10000270:	f9400fe0 	ldr	x0, [sp, #24]
    10000274:	f107fc1f 	cmp	x0, #0x1ff
    10000278:	54fffa09 	b.ls	100001b8 <build_boot_pgdir+0xb8>  // b.plast
        for (size_t i = 0; i < NUM_LEVEL3_PDE; i++) {
    1000027c:	f94013e0 	ldr	x0, [sp, #32]
    10000280:	91000400 	add	x0, x0, #0x1
    10000284:	f90013e0 	str	x0, [sp, #32]
    10000288:	f94013e0 	ldr	x0, [sp, #32]
    1000028c:	f107fc1f 	cmp	x0, #0x1ff
    10000290:	54fff7c9 	b.ls	10000188 <build_boot_pgdir+0x88>  // b.plast
            // }
            // cur_mem_paddr += PAGE_SIZE * 0x200;
        }

        // identical mem
        boot_l2pgdir[(PHY_MEM_BASE >> LEVEL2_PDE_SHIFT) & IDX_MASK] = (uint64_t)boot_kern_l3pgdir | L2_TYPE_TAB | L2_PTE_VALID;
    10000294:	f000aa00 	adrp	x0, 11543000 <boot_end_addr+0x113a000>
    10000298:	f942b400 	ldr	x0, [x0, #1384]
    1000029c:	b2400401 	orr	x1, x0, #0x3
    100002a0:	f000aa00 	adrp	x0, 11543000 <boot_end_addr+0x113a000>
    100002a4:	f942e000 	ldr	x0, [x0, #1472]
    100002a8:	f9000001 	str	x1, [x0]
        boot_l2pgdir[(P2V_WO(PHY_MEM_BASE) >> LEVEL2_PDE_SHIFT) & IDX_MASK] = (uint64_t)boot_kern_l3pgdir | L2_TYPE_TAB | L2_PTE_VALID;
    100002ac:	f000aa00 	adrp	x0, 11543000 <boot_end_addr+0x113a000>
    100002b0:	f942b400 	ldr	x0, [x0, #1384]
    100002b4:	b2400401 	orr	x1, x0, #0x3
    100002b8:	f000aa00 	adrp	x0, 11543000 <boot_end_addr+0x113a000>
    100002bc:	f942e000 	ldr	x0, [x0, #1472]
    100002c0:	f9060001 	str	x1, [x0, #3072]

        cur_mem_paddr = ALIGNDOWN((uint64_t)0x00000000ULL, PAGE_SIZE);
    100002c4:	f90017ff 	str	xzr, [sp, #40]
        for (size_t i = 0; i < NUM_LEVEL3_PDE; i++) {
    100002c8:	f9000bff 	str	xzr, [sp, #16]
    100002cc:	14000023 	b	10000358 <build_boot_pgdir+0x258>
            boot_kern_l3pgdir[i] = (uint64_t)boot_kern_l4pgdirs[i] | L3_TYPE_TAB | L3_PTE_VALID;
    100002d0:	f9400be0 	ldr	x0, [sp, #16]
    100002d4:	d374cc01 	lsl	x1, x0, #12
    100002d8:	f000aa00 	adrp	x0, 11543000 <boot_end_addr+0x113a000>
    100002dc:	f942f000 	ldr	x0, [x0, #1504]
    100002e0:	8b000020 	add	x0, x1, x0
    100002e4:	b2400402 	orr	x2, x0, #0x3
    100002e8:	f000aa00 	adrp	x0, 11543000 <boot_end_addr+0x113a000>
    100002ec:	f942b400 	ldr	x0, [x0, #1384]
    100002f0:	f9400be1 	ldr	x1, [sp, #16]
    100002f4:	f8217802 	str	x2, [x0, x1, lsl #3]

            for (size_t j = 0; j < NUM_LEVEL4_PTE; j++) {
    100002f8:	f90007ff 	str	xzr, [sp, #8]
    100002fc:	14000011 	b	10000340 <build_boot_pgdir+0x240>
                // boot_kern_l4pgdirs[i][j] = cur_mem_paddr | L4_TYPE_PAGE | L4_PTE_NORMAL | L4_PTE_AF;
                boot_kern_l4pgdirs[i][j] = cur_mem_paddr | 0x713;
    10000300:	f94017e1 	ldr	x1, [sp, #40]
    10000304:	d280e260 	mov	x0, #0x713                 	// #1811
    10000308:	aa000022 	orr	x2, x1, x0
    1000030c:	f000aa00 	adrp	x0, 11543000 <boot_end_addr+0x113a000>
    10000310:	f942f000 	ldr	x0, [x0, #1504]
    10000314:	f9400be1 	ldr	x1, [sp, #16]
    10000318:	d377d823 	lsl	x3, x1, #9
    1000031c:	f94007e1 	ldr	x1, [sp, #8]
    10000320:	8b010061 	add	x1, x3, x1
    10000324:	f8217802 	str	x2, [x0, x1, lsl #3]

                cur_mem_paddr += PAGE_SIZE;
    10000328:	f94017e0 	ldr	x0, [sp, #40]
    1000032c:	91400400 	add	x0, x0, #0x1, lsl #12
    10000330:	f90017e0 	str	x0, [sp, #40]
            for (size_t j = 0; j < NUM_LEVEL4_PTE; j++) {
    10000334:	f94007e0 	ldr	x0, [sp, #8]
    10000338:	91000400 	add	x0, x0, #0x1
    1000033c:	f90007e0 	str	x0, [sp, #8]
    10000340:	f94007e0 	ldr	x0, [sp, #8]
    10000344:	f107fc1f 	cmp	x0, #0x1ff
    10000348:	54fffdc9 	b.ls	10000300 <build_boot_pgdir+0x200>  // b.plast
        for (size_t i = 0; i < NUM_LEVEL3_PDE; i++) {
    1000034c:	f9400be0 	ldr	x0, [sp, #16]
    10000350:	91000400 	add	x0, x0, #0x1
    10000354:	f9000be0 	str	x0, [sp, #16]
    10000358:	f9400be0 	ldr	x0, [sp, #16]
    1000035c:	f107fc1f 	cmp	x0, #0x1ff
    10000360:	54fffb89 	b.ls	100002d0 <build_boot_pgdir+0x1d0>  // b.plast
            }
        }

        built = true;
    10000364:	90002020 	adrp	x0, 10404000 <_bss_inited>
    10000368:	91000400 	add	x0, x0, #0x1
    1000036c:	52800021 	mov	w1, #0x1                   	// #1
    10000370:	39000001 	strb	w1, [x0]
    }
}
    10000374:	d503201f 	nop
    10000378:	9100c3ff 	add	sp, sp, #0x30
    1000037c:	d65f03c0 	ret

0000000010000380 <load_boot_pgdir>:

#include "log.h"

static void load_boot_pgdir()
{
    10000380:	d10043ff 	sub	sp, sp, #0x10

    TTBR0_W((uintptr_t)boot_l2pgdir);
    10000384:	f000aa00 	adrp	x0, 11543000 <boot_end_addr+0x113a000>
    10000388:	f942e000 	ldr	x0, [x0, #1472]
    1000038c:	d5182000 	msr	ttbr0_el1, x0
    TTBR1_W(0);
    10000390:	52800000 	mov	w0, #0x0                   	// #0
    10000394:	d5182020 	msr	ttbr1_el1, x0

#define TCR_TRUE_VALUE (0x0000000080813519ULL)
    uint64_t tcr = 0;
    10000398:	f90007ff 	str	xzr, [sp, #8]
    TCR_R(tcr);
    1000039c:	d5382040 	mrs	x0, tcr_el1
    100003a0:	f90007e0 	str	x0, [sp, #8]
    tcr &= (uint64_t)~0xFF;
    100003a4:	f94007e0 	ldr	x0, [sp, #8]
    100003a8:	9278dc00 	and	x0, x0, #0xffffffffffffff00
    100003ac:	f90007e0 	str	x0, [sp, #8]
    tcr |= 0x19;
    100003b0:	f94007e1 	ldr	x1, [sp, #8]
    100003b4:	d2800320 	mov	x0, #0x19                  	// #25
    100003b8:	aa000020 	orr	x0, x1, x0
    100003bc:	f90007e0 	str	x0, [sp, #8]
    TCR_W(tcr);
    100003c0:	f94007e0 	ldr	x0, [sp, #8]
    100003c4:	d5182040 	msr	tcr_el1, x0
    // debug_printf_("pgdir[%d] = %p\r\n", 384, boot_l2pgdir[384]);
    // debug_printf_("test upper address: %x\r\n", *(uintptr_t*)P2V(boot_l2pgdir));

    // flush all TLB
    // debug_printf_("Flushing TLB.\r\n");
    DSB();
    100003c8:	d5033b9f 	dsb	ish
    CLEARTLB(0);
    100003cc:	d508831f 	tlbi	vmalle1is
    ISB();
    100003d0:	d5033fdf 	isb
}
    100003d4:	d503201f 	nop
    100003d8:	910043ff 	add	sp, sp, #0x10
    100003dc:	d65f03c0 	ret

00000000100003e0 <bootmain>:
}

extern void main(void);
static bool _bss_inited = false;
void bootmain()
{
    100003e0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    100003e4:	910003fd 	mov	x29, sp
    build_boot_pgdir();
    100003e8:	97ffff46 	bl	10000100 <build_boot_pgdir>
    load_boot_pgdir();
    100003ec:	97ffffe5 	bl	10000380 <load_boot_pgdir>
    __asm__ __volatile__("add sp, sp, %0" ::"r"(KERN_OFFSET));
    100003f0:	d2c00c00 	mov	x0, #0x6000000000          	// #412316860416
    100003f4:	8b2063ff 	add	sp, sp, x0
    if (!_bss_inited) {
    100003f8:	90002020 	adrp	x0, 10404000 <_bss_inited>
    100003fc:	91000000 	add	x0, x0, #0x0
    10000400:	39400000 	ldrb	w0, [x0]
    10000404:	52000000 	eor	w0, w0, #0x1
    10000408:	12001c00 	and	w0, w0, #0xff
    1000040c:	7100001f 	cmp	w0, #0x0
    10000410:	540001e0 	b.eq	1000044c <bootmain+0x6c>  // b.none
        memset(&kernel_data_begin, 0x00, (size_t)((uint64_t)kernel_data_end - (uint64_t)kernel_data_begin));
    10000414:	f000aa00 	adrp	x0, 11543000 <boot_end_addr+0x113a000>
    10000418:	f942c001 	ldr	x1, [x0, #1408]
    1000041c:	f000aa00 	adrp	x0, 11543000 <boot_end_addr+0x113a000>
    10000420:	f942d800 	ldr	x0, [x0, #1456]
    10000424:	cb000020 	sub	x0, x1, x0
    10000428:	aa0003e2 	mov	x2, x0
    1000042c:	52800001 	mov	w1, #0x0                   	// #0
    10000430:	f000aa00 	adrp	x0, 11543000 <boot_end_addr+0x113a000>
    10000434:	f942d800 	ldr	x0, [x0, #1456]
    10000438:	9400000c 	bl	10000468 <__memset_veneer>
        _bss_inited = true;
    1000043c:	90002020 	adrp	x0, 10404000 <_bss_inited>
    10000440:	91000000 	add	x0, x0, #0x0
    10000444:	52800021 	mov	w1, #0x1                   	// #1
    10000448:	39000001 	strb	w1, [x0]
    }
    main();
    1000044c:	9400000d 	bl	10000480 <__main_veneer>
    10000450:	d503201f 	nop
    10000454:	a8c17bfd 	ldp	x29, x30, [sp], #16
    10000458:	d65f03c0 	ret
    1000045c:	00000000 	udf	#0
    10000460:	1400000e 	b	10000498 <boot_start_addr>
    10000464:	d503201f 	nop

0000000010000468 <__memset_veneer>:
    10000468:	58000090 	ldr	x16, 10000478 <__memset_veneer+0x10>
    1000046c:	10000011 	adr	x17, 1000046c <__memset_veneer+0x4>
    10000470:	8b110210 	add	x16, x16, x17
    10000474:	d61f0200 	br	x16
    10000478:	0040de54 	.word	0x0040de54
    1000047c:	00000060 	.word	0x00000060

0000000010000480 <__main_veneer>:
    10000480:	58000090 	ldr	x16, 10000490 <__main_veneer+0x10>
    10000484:	10000011 	adr	x17, 10000484 <__main_veneer+0x4>
    10000488:	8b110210 	add	x16, x16, x17
    1000048c:	d61f0200 	br	x16
    10000490:	0041fa14 	.word	0x0041fa14
    10000494:	00000060 	.word	0x00000060

0000000010000498 <boot_start_addr>:
	...

0000000010001000 <boot_l2pgdir>:
	...

0000000010002000 <boot_dev_l3pgdir>:
	...

0000000010003000 <boot_kern_l3pgdir>:
	...

0000000010004000 <boot_dev_l4pgdirs>:
	...

0000000010204000 <boot_kern_l4pgdirs>:
	...

0000000010404000 <_bss_inited>:
	...

0000000010404001 <built.0>:
	...

Disassembly of section .text:

000000601040e000 <deregister_tm_clones>:
  601040e000:	b00089a0 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601040e004:	91144000 	add	x0, x0, #0x510
  601040e008:	b00089a1 	adrp	x1, 6011543000 <_binary_default_fs_start+0x96000>
  601040e00c:	91144021 	add	x1, x1, #0x510
  601040e010:	eb00003f 	cmp	x1, x0
  601040e014:	540000c0 	b.eq	601040e02c <deregister_tm_clones+0x2c>  // b.none
  601040e018:	d0000081 	adrp	x1, 6010420000 <main+0x168>
  601040e01c:	f9444421 	ldr	x1, [x1, #2184]
  601040e020:	b4000061 	cbz	x1, 601040e02c <deregister_tm_clones+0x2c>
  601040e024:	aa0103f0 	mov	x16, x1
  601040e028:	d61f0200 	br	x16
  601040e02c:	d65f03c0 	ret

000000601040e030 <register_tm_clones>:
  601040e030:	b00089a0 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601040e034:	91144000 	add	x0, x0, #0x510
  601040e038:	b00089a1 	adrp	x1, 6011543000 <_binary_default_fs_start+0x96000>
  601040e03c:	91144021 	add	x1, x1, #0x510
  601040e040:	cb000021 	sub	x1, x1, x0
  601040e044:	d37ffc22 	lsr	x2, x1, #63
  601040e048:	8b810c41 	add	x1, x2, x1, asr #3
  601040e04c:	9341fc21 	asr	x1, x1, #1
  601040e050:	b40000c1 	cbz	x1, 601040e068 <register_tm_clones+0x38>
  601040e054:	d0000082 	adrp	x2, 6010420000 <main+0x168>
  601040e058:	f9444842 	ldr	x2, [x2, #2192]
  601040e05c:	b4000062 	cbz	x2, 601040e068 <register_tm_clones+0x38>
  601040e060:	aa0203f0 	mov	x16, x2
  601040e064:	d61f0200 	br	x16
  601040e068:	d65f03c0 	ret
  601040e06c:	00000000 	udf	#0

000000601040e070 <__do_global_dtors_aux>:
  601040e070:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  601040e074:	910003fd 	mov	x29, sp
  601040e078:	f9000bf3 	str	x19, [sp, #16]
  601040e07c:	b00089b3 	adrp	x19, 6011543000 <_binary_default_fs_start+0x96000>
  601040e080:	39588260 	ldrb	w0, [x19, #1568]
  601040e084:	35000140 	cbnz	w0, 601040e0ac <__do_global_dtors_aux+0x3c>
  601040e088:	97ffffde 	bl	601040e000 <deregister_tm_clones>
  601040e08c:	d0000080 	adrp	x0, 6010420000 <main+0x168>
  601040e090:	f9444c00 	ldr	x0, [x0, #2200]
  601040e094:	b4000080 	cbz	x0, 601040e0a4 <__do_global_dtors_aux+0x34>
  601040e098:	d0000080 	adrp	x0, 6010420000 <main+0x168>
  601040e09c:	91221000 	add	x0, x0, #0x884
  601040e0a0:	d503201f 	nop
  601040e0a4:	52800020 	mov	w0, #0x1                   	// #1
  601040e0a8:	39188260 	strb	w0, [x19, #1568]
  601040e0ac:	f9400bf3 	ldr	x19, [sp, #16]
  601040e0b0:	a8c27bfd 	ldp	x29, x30, [sp], #32
  601040e0b4:	d65f03c0 	ret
	...

000000601040e0c0 <frame_dummy>:
  601040e0c0:	d0000080 	adrp	x0, 6010420000 <main+0x168>
  601040e0c4:	f9445000 	ldr	x0, [x0, #2208]
  601040e0c8:	b4000140 	cbz	x0, 601040e0f0 <frame_dummy+0x30>
  601040e0cc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601040e0d0:	b00089a1 	adrp	x1, 6011543000 <_binary_default_fs_start+0x96000>
  601040e0d4:	d0000080 	adrp	x0, 6010420000 <main+0x168>
  601040e0d8:	910003fd 	mov	x29, sp
  601040e0dc:	9118a021 	add	x1, x1, #0x628
  601040e0e0:	91221000 	add	x0, x0, #0x884
  601040e0e4:	d503201f 	nop
  601040e0e8:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601040e0ec:	17ffffd1 	b	601040e030 <register_tm_clones>
  601040e0f0:	17ffffd0 	b	601040e030 <register_tm_clones>
  601040e0f4:	00000000 	udf	#0

000000601040e0f8 <_mainCRTStartup>:
  601040e0f8:	58000281 	ldr	x1, 601040e148 <_cpu_init_hook+0x4>
  601040e0fc:	927cec20 	and	x0, x1, #0xfffffffffffffff0
  601040e100:	9100001f 	mov	sp, x0
  601040e104:	d280001d 	mov	x29, #0x0                   	// #0
  601040e108:	a9bf77fd 	stp	x29, x29, [sp, #-16]!
  601040e10c:	910003fd 	mov	x29, sp
  601040e110:	9400000d 	bl	601040e144 <_cpu_init_hook>
  601040e114:	580001e0 	ldr	x0, 601040e150 <_cpu_init_hook+0xc>
  601040e118:	52800001 	mov	w1, #0x0                   	// #0
  601040e11c:	580001e2 	ldr	x2, 601040e158 <_cpu_init_hook+0x14>
  601040e120:	cb000042 	sub	x2, x2, x0
  601040e124:	94000067 	bl	601040e2c0 <memset>
  601040e128:	580001c0 	ldr	x0, 601040e160 <_cpu_init_hook+0x1c>
  601040e12c:	94000011 	bl	601040e170 <atexit>
  601040e130:	9400003c 	bl	601040e220 <__libc_init_array>
  601040e134:	d2800000 	mov	x0, #0x0                   	// #0
  601040e138:	d2800001 	mov	x1, #0x0                   	// #0
  601040e13c:	94004757 	bl	601041fe98 <main>
  601040e140:	14000014 	b	601040e190 <exit>

000000601040e144 <_cpu_init_hook>:
  601040e144:	d65f03c0 	ret
	...
  601040e150:	11543620 	.word	0x11543620
  601040e154:	00000060 	.word	0x00000060
  601040e158:	11b47000 	.word	0x11b47000
  601040e15c:	00000060 	.word	0x00000060
  601040e160:	1040e1d0 	.word	0x1040e1d0
  601040e164:	00000060 	.word	0x00000060
	...

000000601040e170 <atexit>:
  601040e170:	aa0003e1 	mov	x1, x0
  601040e174:	d2800003 	mov	x3, #0x0                   	// #0
  601040e178:	d2800002 	mov	x2, #0x0                   	// #0
  601040e17c:	52800000 	mov	w0, #0x0                   	// #0
  601040e180:	140000c8 	b	601040e4a0 <__register_exitproc>
	...

000000601040e190 <exit>:
  601040e190:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  601040e194:	d2800001 	mov	x1, #0x0                   	// #0
  601040e198:	910003fd 	mov	x29, sp
  601040e19c:	f9000bf3 	str	x19, [sp, #16]
  601040e1a0:	2a0003f3 	mov	w19, w0
  601040e1a4:	940000e7 	bl	601040e540 <__call_exitprocs>
  601040e1a8:	d0000080 	adrp	x0, 6010420000 <main+0x168>
  601040e1ac:	f9446c00 	ldr	x0, [x0, #2264]
  601040e1b0:	f9402c01 	ldr	x1, [x0, #88]
  601040e1b4:	b4000041 	cbz	x1, 601040e1bc <exit+0x2c>
  601040e1b8:	d63f0020 	blr	x1
  601040e1bc:	2a1303e0 	mov	w0, w19
  601040e1c0:	94004808 	bl	60104201e0 <_exit>
	...

000000601040e1d0 <__libc_fini_array>:
  601040e1d0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  601040e1d4:	d0000081 	adrp	x1, 6010420000 <main+0x168>
  601040e1d8:	d0000080 	adrp	x0, 6010420000 <main+0x168>
  601040e1dc:	910003fd 	mov	x29, sp
  601040e1e0:	a90153f3 	stp	x19, x20, [sp, #16]
  601040e1e4:	f9445433 	ldr	x19, [x1, #2216]
  601040e1e8:	f9445814 	ldr	x20, [x0, #2224]
  601040e1ec:	cb140273 	sub	x19, x19, x20
  601040e1f0:	9343fe73 	asr	x19, x19, #3
  601040e1f4:	b40000b3 	cbz	x19, 601040e208 <__libc_fini_array+0x38>
  601040e1f8:	d1000673 	sub	x19, x19, #0x1
  601040e1fc:	f8737a80 	ldr	x0, [x20, x19, lsl #3]
  601040e200:	d63f0000 	blr	x0
  601040e204:	b5ffffb3 	cbnz	x19, 601040e1f8 <__libc_fini_array+0x28>
  601040e208:	a94153f3 	ldp	x19, x20, [sp, #16]
  601040e20c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  601040e210:	14004990 	b	6010420850 <_fini>
	...

000000601040e220 <__libc_init_array>:
  601040e220:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  601040e224:	d0000081 	adrp	x1, 6010420000 <main+0x168>
  601040e228:	d0000080 	adrp	x0, 6010420000 <main+0x168>
  601040e22c:	910003fd 	mov	x29, sp
  601040e230:	a90153f3 	stp	x19, x20, [sp, #16]
  601040e234:	f9445c34 	ldr	x20, [x1, #2232]
  601040e238:	f90013f5 	str	x21, [sp, #32]
  601040e23c:	f9446015 	ldr	x21, [x0, #2240]
  601040e240:	cb150294 	sub	x20, x20, x21
  601040e244:	9343fe94 	asr	x20, x20, #3
  601040e248:	b40000f4 	cbz	x20, 601040e264 <__libc_init_array+0x44>
  601040e24c:	d2800013 	mov	x19, #0x0                   	// #0
  601040e250:	f8737aa0 	ldr	x0, [x21, x19, lsl #3]
  601040e254:	91000673 	add	x19, x19, #0x1
  601040e258:	d63f0000 	blr	x0
  601040e25c:	eb13029f 	cmp	x20, x19
  601040e260:	54ffff81 	b.ne	601040e250 <__libc_init_array+0x30>  // b.any
  601040e264:	9400496e 	bl	601042081c <_init>
  601040e268:	d0000081 	adrp	x1, 6010420000 <main+0x168>
  601040e26c:	d0000080 	adrp	x0, 6010420000 <main+0x168>
  601040e270:	f9446434 	ldr	x20, [x1, #2248]
  601040e274:	f9446815 	ldr	x21, [x0, #2256]
  601040e278:	cb150294 	sub	x20, x20, x21
  601040e27c:	9343fe94 	asr	x20, x20, #3
  601040e280:	b40000f4 	cbz	x20, 601040e29c <__libc_init_array+0x7c>
  601040e284:	d2800013 	mov	x19, #0x0                   	// #0
  601040e288:	f8737aa0 	ldr	x0, [x21, x19, lsl #3]
  601040e28c:	91000673 	add	x19, x19, #0x1
  601040e290:	d63f0000 	blr	x0
  601040e294:	eb13029f 	cmp	x20, x19
  601040e298:	54ffff81 	b.ne	601040e288 <__libc_init_array+0x68>  // b.any
  601040e29c:	a94153f3 	ldp	x19, x20, [sp, #16]
  601040e2a0:	f94013f5 	ldr	x21, [sp, #32]
  601040e2a4:	a8c37bfd 	ldp	x29, x30, [sp], #48
  601040e2a8:	d65f03c0 	ret
	...

000000601040e2c0 <memset>:
  601040e2c0:	4e010c20 	dup	v0.16b, w1
  601040e2c4:	8b020004 	add	x4, x0, x2
  601040e2c8:	f101805f 	cmp	x2, #0x60
  601040e2cc:	540003c8 	b.hi	601040e344 <memset+0x84>  // b.pmore
  601040e2d0:	f100405f 	cmp	x2, #0x10
  601040e2d4:	54000202 	b.cs	601040e314 <memset+0x54>  // b.hs, b.nlast
  601040e2d8:	4e083c01 	mov	x1, v0.d[0]
  601040e2dc:	361800a2 	tbz	w2, #3, 601040e2f0 <memset+0x30>
  601040e2e0:	f9000001 	str	x1, [x0]
  601040e2e4:	f81f8081 	stur	x1, [x4, #-8]
  601040e2e8:	d65f03c0 	ret
  601040e2ec:	d503201f 	nop
  601040e2f0:	36100082 	tbz	w2, #2, 601040e300 <memset+0x40>
  601040e2f4:	b9000001 	str	w1, [x0]
  601040e2f8:	b81fc081 	stur	w1, [x4, #-4]
  601040e2fc:	d65f03c0 	ret
  601040e300:	b4000082 	cbz	x2, 601040e310 <memset+0x50>
  601040e304:	39000001 	strb	w1, [x0]
  601040e308:	36080042 	tbz	w2, #1, 601040e310 <memset+0x50>
  601040e30c:	781fe081 	sturh	w1, [x4, #-2]
  601040e310:	d65f03c0 	ret
  601040e314:	3d800000 	str	q0, [x0]
  601040e318:	373000c2 	tbnz	w2, #6, 601040e330 <memset+0x70>
  601040e31c:	3c9f0080 	stur	q0, [x4, #-16]
  601040e320:	36280062 	tbz	w2, #5, 601040e32c <memset+0x6c>
  601040e324:	3d800400 	str	q0, [x0, #16]
  601040e328:	3c9e0080 	stur	q0, [x4, #-32]
  601040e32c:	d65f03c0 	ret
  601040e330:	3d800400 	str	q0, [x0, #16]
  601040e334:	ad010000 	stp	q0, q0, [x0, #32]
  601040e338:	ad3f0080 	stp	q0, q0, [x4, #-32]
  601040e33c:	d65f03c0 	ret
  601040e340:	d503201f 	nop
  601040e344:	12001c21 	and	w1, w1, #0xff
  601040e348:	927cec03 	and	x3, x0, #0xfffffffffffffff0
  601040e34c:	3d800000 	str	q0, [x0]
  601040e350:	f104005f 	cmp	x2, #0x100
  601040e354:	7a402820 	ccmp	w1, #0x0, #0x0, cs  // cs = hs, nlast
  601040e358:	54000180 	b.eq	601040e388 <memset+0xc8>  // b.none
  601040e35c:	cb030082 	sub	x2, x4, x3
  601040e360:	d1004063 	sub	x3, x3, #0x10
  601040e364:	d1014042 	sub	x2, x2, #0x50
  601040e368:	ad010060 	stp	q0, q0, [x3, #32]
  601040e36c:	ad820060 	stp	q0, q0, [x3, #64]!
  601040e370:	f1010042 	subs	x2, x2, #0x40
  601040e374:	54ffffa8 	b.hi	601040e368 <memset+0xa8>  // b.pmore
  601040e378:	ad3e0080 	stp	q0, q0, [x4, #-64]
  601040e37c:	ad3f0080 	stp	q0, q0, [x4, #-32]
  601040e380:	d65f03c0 	ret
  601040e384:	d503201f 	nop
  601040e388:	d53b00e5 	mrs	x5, dczid_el0
  601040e38c:	3727fe85 	tbnz	w5, #4, 601040e35c <memset+0x9c>
  601040e390:	12000ca5 	and	w5, w5, #0xf
  601040e394:	710010bf 	cmp	w5, #0x4
  601040e398:	54000281 	b.ne	601040e3e8 <memset+0x128>  // b.any
  601040e39c:	3d800460 	str	q0, [x3, #16]
  601040e3a0:	ad010060 	stp	q0, q0, [x3, #32]
  601040e3a4:	927ae463 	and	x3, x3, #0xffffffffffffffc0
  601040e3a8:	ad020060 	stp	q0, q0, [x3, #64]
  601040e3ac:	ad030060 	stp	q0, q0, [x3, #96]
  601040e3b0:	cb030082 	sub	x2, x4, x3
  601040e3b4:	d1040042 	sub	x2, x2, #0x100
  601040e3b8:	91020063 	add	x3, x3, #0x80
  601040e3bc:	d503201f 	nop
  601040e3c0:	d50b7423 	dc	zva, x3
  601040e3c4:	91010063 	add	x3, x3, #0x40
  601040e3c8:	f1010042 	subs	x2, x2, #0x40
  601040e3cc:	54ffffa8 	b.hi	601040e3c0 <memset+0x100>  // b.pmore
  601040e3d0:	ad000060 	stp	q0, q0, [x3]
  601040e3d4:	ad010060 	stp	q0, q0, [x3, #32]
  601040e3d8:	ad3e0080 	stp	q0, q0, [x4, #-64]
  601040e3dc:	ad3f0080 	stp	q0, q0, [x4, #-32]
  601040e3e0:	d65f03c0 	ret
  601040e3e4:	d503201f 	nop
  601040e3e8:	710014bf 	cmp	w5, #0x5
  601040e3ec:	54000241 	b.ne	601040e434 <memset+0x174>  // b.any
  601040e3f0:	3d800460 	str	q0, [x3, #16]
  601040e3f4:	ad010060 	stp	q0, q0, [x3, #32]
  601040e3f8:	ad020060 	stp	q0, q0, [x3, #64]
  601040e3fc:	ad030060 	stp	q0, q0, [x3, #96]
  601040e400:	9279e063 	and	x3, x3, #0xffffffffffffff80
  601040e404:	cb030082 	sub	x2, x4, x3
  601040e408:	d1040042 	sub	x2, x2, #0x100
  601040e40c:	91020063 	add	x3, x3, #0x80
  601040e410:	d50b7423 	dc	zva, x3
  601040e414:	91020063 	add	x3, x3, #0x80
  601040e418:	f1020042 	subs	x2, x2, #0x80
  601040e41c:	54ffffa8 	b.hi	601040e410 <memset+0x150>  // b.pmore
  601040e420:	ad3c0080 	stp	q0, q0, [x4, #-128]
  601040e424:	ad3d0080 	stp	q0, q0, [x4, #-96]
  601040e428:	ad3e0080 	stp	q0, q0, [x4, #-64]
  601040e42c:	ad3f0080 	stp	q0, q0, [x4, #-32]
  601040e430:	d65f03c0 	ret
  601040e434:	52800086 	mov	w6, #0x4                   	// #4
  601040e438:	1ac520c7 	lsl	w7, w6, w5
  601040e43c:	910100e5 	add	x5, x7, #0x40
  601040e440:	eb05005f 	cmp	x2, x5
  601040e444:	54fff8c3 	b.cc	601040e35c <memset+0x9c>  // b.lo, b.ul, b.last
  601040e448:	d10004e6 	sub	x6, x7, #0x1
  601040e44c:	8b070065 	add	x5, x3, x7
  601040e450:	91004063 	add	x3, x3, #0x10
  601040e454:	eb0300a2 	subs	x2, x5, x3
  601040e458:	8a2600a5 	bic	x5, x5, x6
  601040e45c:	540000a0 	b.eq	601040e470 <memset+0x1b0>  // b.none
  601040e460:	ac820060 	stp	q0, q0, [x3], #64
  601040e464:	ad3f0060 	stp	q0, q0, [x3, #-32]
  601040e468:	f1010042 	subs	x2, x2, #0x40
  601040e46c:	54ffffa8 	b.hi	601040e460 <memset+0x1a0>  // b.pmore
  601040e470:	aa0503e3 	mov	x3, x5
  601040e474:	cb050082 	sub	x2, x4, x5
  601040e478:	eb070042 	subs	x2, x2, x7
  601040e47c:	540000a3 	b.cc	601040e490 <memset+0x1d0>  // b.lo, b.ul, b.last
  601040e480:	d50b7423 	dc	zva, x3
  601040e484:	8b070063 	add	x3, x3, x7
  601040e488:	eb070042 	subs	x2, x2, x7
  601040e48c:	54ffffa2 	b.cs	601040e480 <memset+0x1c0>  // b.hs, b.nlast
  601040e490:	8b070042 	add	x2, x2, x7
  601040e494:	d1008063 	sub	x3, x3, #0x20
  601040e498:	17ffffb6 	b	601040e370 <memset+0xb0>
  601040e49c:	00000000 	udf	#0

000000601040e4a0 <__register_exitproc>:
  601040e4a0:	d0000084 	adrp	x4, 6010420000 <main+0x168>
  601040e4a4:	f9446c84 	ldr	x4, [x4, #2264]
  601040e4a8:	f940fc85 	ldr	x5, [x4, #504]
  601040e4ac:	b4000405 	cbz	x5, 601040e52c <__register_exitproc+0x8c>
  601040e4b0:	b94008a4 	ldr	w4, [x5, #8]
  601040e4b4:	71007c9f 	cmp	w4, #0x1f
  601040e4b8:	5400040c 	b.gt	601040e538 <__register_exitproc+0x98>
  601040e4bc:	93407c86 	sxtw	x6, w4
  601040e4c0:	350000e0 	cbnz	w0, 601040e4dc <__register_exitproc+0x3c>
  601040e4c4:	910008c2 	add	x2, x6, #0x2
  601040e4c8:	11000484 	add	w4, w4, #0x1
  601040e4cc:	b90008a4 	str	w4, [x5, #8]
  601040e4d0:	52800000 	mov	w0, #0x0                   	// #0
  601040e4d4:	f82278a1 	str	x1, [x5, x2, lsl #3]
  601040e4d8:	d65f03c0 	ret
  601040e4dc:	8b24cca7 	add	x7, x5, w4, sxtw #3
  601040e4e0:	52800028 	mov	w8, #0x1                   	// #1
  601040e4e4:	1ac42108 	lsl	w8, w8, w4
  601040e4e8:	93407c86 	sxtw	x6, w4
  601040e4ec:	f90088e2 	str	x2, [x7, #272]
  601040e4f0:	b94310a2 	ldr	w2, [x5, #784]
  601040e4f4:	2a080042 	orr	w2, w2, w8
  601040e4f8:	b90310a2 	str	w2, [x5, #784]
  601040e4fc:	f90108e3 	str	x3, [x7, #528]
  601040e500:	7100081f 	cmp	w0, #0x2
  601040e504:	54fffe01 	b.ne	601040e4c4 <__register_exitproc+0x24>  // b.any
  601040e508:	b94314a0 	ldr	w0, [x5, #788]
  601040e50c:	910008c2 	add	x2, x6, #0x2
  601040e510:	11000484 	add	w4, w4, #0x1
  601040e514:	b90008a4 	str	w4, [x5, #8]
  601040e518:	2a080008 	orr	w8, w0, w8
  601040e51c:	b90314a8 	str	w8, [x5, #788]
  601040e520:	52800000 	mov	w0, #0x0                   	// #0
  601040e524:	f82278a1 	str	x1, [x5, x2, lsl #3]
  601040e528:	17ffffec 	b	601040e4d8 <__register_exitproc+0x38>
  601040e52c:	91080085 	add	x5, x4, #0x200
  601040e530:	f900fc85 	str	x5, [x4, #504]
  601040e534:	17ffffdf 	b	601040e4b0 <__register_exitproc+0x10>
  601040e538:	12800000 	mov	w0, #0xffffffff            	// #-1
  601040e53c:	d65f03c0 	ret

000000601040e540 <__call_exitprocs>:
  601040e540:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  601040e544:	d0000082 	adrp	x2, 6010420000 <main+0x168>
  601040e548:	910003fd 	mov	x29, sp
  601040e54c:	a9025bf5 	stp	x21, x22, [sp, #32]
  601040e550:	f9446c56 	ldr	x22, [x2, #2264]
  601040e554:	f940fed5 	ldr	x21, [x22, #504]
  601040e558:	b40002f5 	cbz	x21, 601040e5b4 <__call_exitprocs+0x74>
  601040e55c:	a90363f7 	stp	x23, x24, [sp, #48]
  601040e560:	2a0003f8 	mov	w24, w0
  601040e564:	52800037 	mov	w23, #0x1                   	// #1
  601040e568:	a9046bf9 	stp	x25, x26, [sp, #64]
  601040e56c:	aa0103f9 	mov	x25, x1
  601040e570:	a90153f3 	stp	x19, x20, [sp, #16]
  601040e574:	b9400ab3 	ldr	w19, [x21, #8]
  601040e578:	71000674 	subs	w20, w19, #0x1
  601040e57c:	54000164 	b.mi	601040e5a8 <__call_exitprocs+0x68>  // b.first
  601040e580:	8b33ceb3 	add	x19, x21, w19, sxtw #3
  601040e584:	91002273 	add	x19, x19, #0x8
  601040e588:	b40001d9 	cbz	x25, 601040e5c0 <__call_exitprocs+0x80>
  601040e58c:	f9410260 	ldr	x0, [x19, #512]
  601040e590:	eb19001f 	cmp	x0, x25
  601040e594:	54000160 	b.eq	601040e5c0 <__call_exitprocs+0x80>  // b.none
  601040e598:	51000694 	sub	w20, w20, #0x1
  601040e59c:	d1002273 	sub	x19, x19, #0x8
  601040e5a0:	3100069f 	cmn	w20, #0x1
  601040e5a4:	54ffff21 	b.ne	601040e588 <__call_exitprocs+0x48>  // b.any
  601040e5a8:	a94153f3 	ldp	x19, x20, [sp, #16]
  601040e5ac:	a94363f7 	ldp	x23, x24, [sp, #48]
  601040e5b0:	a9446bf9 	ldp	x25, x26, [sp, #64]
  601040e5b4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  601040e5b8:	a8c57bfd 	ldp	x29, x30, [sp], #80
  601040e5bc:	d65f03c0 	ret
  601040e5c0:	b9400aa2 	ldr	w2, [x21, #8]
  601040e5c4:	f9400263 	ldr	x3, [x19]
  601040e5c8:	51000442 	sub	w2, w2, #0x1
  601040e5cc:	6b14005f 	cmp	w2, w20
  601040e5d0:	54000360 	b.eq	601040e63c <__call_exitprocs+0xfc>  // b.none
  601040e5d4:	f900027f 	str	xzr, [x19]
  601040e5d8:	b4fffe03 	cbz	x3, 601040e598 <__call_exitprocs+0x58>
  601040e5dc:	b94312a1 	ldr	w1, [x21, #784]
  601040e5e0:	910442a0 	add	x0, x21, #0x110
  601040e5e4:	b9400aba 	ldr	w26, [x21, #8]
  601040e5e8:	1ad422e2 	lsl	w2, w23, w20
  601040e5ec:	6a01005f 	tst	w2, w1
  601040e5f0:	54000161 	b.ne	601040e61c <__call_exitprocs+0xdc>  // b.any
  601040e5f4:	d63f0060 	blr	x3
  601040e5f8:	b9400aa1 	ldr	w1, [x21, #8]
  601040e5fc:	f940fec0 	ldr	x0, [x22, #504]
  601040e600:	6b1a003f 	cmp	w1, w26
  601040e604:	54000061 	b.ne	601040e610 <__call_exitprocs+0xd0>  // b.any
  601040e608:	eb15001f 	cmp	x0, x21
  601040e60c:	54fffc60 	b.eq	601040e598 <__call_exitprocs+0x58>  // b.none
  601040e610:	b4fffcc0 	cbz	x0, 601040e5a8 <__call_exitprocs+0x68>
  601040e614:	aa0003f5 	mov	x21, x0
  601040e618:	17ffffd7 	b	601040e574 <__call_exitprocs+0x34>
  601040e61c:	b9420401 	ldr	w1, [x0, #516]
  601040e620:	f9408260 	ldr	x0, [x19, #256]
  601040e624:	6a01005f 	tst	w2, w1
  601040e628:	540000e1 	b.ne	601040e644 <__call_exitprocs+0x104>  // b.any
  601040e62c:	aa0003e1 	mov	x1, x0
  601040e630:	2a1803e0 	mov	w0, w24
  601040e634:	d63f0060 	blr	x3
  601040e638:	17fffff0 	b	601040e5f8 <__call_exitprocs+0xb8>
  601040e63c:	b9000ab4 	str	w20, [x21, #8]
  601040e640:	17ffffe6 	b	601040e5d8 <__call_exitprocs+0x98>
  601040e644:	d63f0060 	blr	x3
  601040e648:	17ffffec 	b	601040e5f8 <__call_exitprocs+0xb8>

000000601040e64c <cpu_start_secondary>:
#define PSCI_CPUON 0xc4000003

extern void _boot_start();
void psci_call(uint64_t fn, uint8_t cpuid, uint64_t entry, uint64_t ctxid);
void cpu_start_secondary(uint8_t cpu_id)
{
  601040e64c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  601040e650:	910003fd 	mov	x29, sp
  601040e654:	39007fe0 	strb	w0, [sp, #31]
    psci_call(PSCI_CPUON, cpu_id, (uintptr_t)&_boot_start, 0);
  601040e658:	b00089a0 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601040e65c:	f942a000 	ldr	x0, [x0, #1344]
  601040e660:	d2800003 	mov	x3, #0x0                   	// #0
  601040e664:	aa0003e2 	mov	x2, x0
  601040e668:	39407fe1 	ldrb	w1, [sp, #31]
  601040e66c:	d2800060 	mov	x0, #0x3                   	// #3
  601040e670:	f2b88000 	movk	x0, #0xc400, lsl #16
  601040e674:	9400000c 	bl	601040e6a4 <psci_call>
}
  601040e678:	d503201f 	nop
  601040e67c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  601040e680:	d65f03c0 	ret

000000601040e684 <start_smp_cache_broadcast>:

void start_smp_cache_broadcast(int cpu_id)
{
  601040e684:	d10043ff 	sub	sp, sp, #0x10
  601040e688:	b9000fe0 	str	w0, [sp, #12]
    return;
  601040e68c:	d503201f 	nop
  601040e690:	910043ff 	add	sp, sp, #0x10
  601040e694:	d65f03c0 	ret

000000601040e698 <cpu_get_current>:
  601040e698:	d53800a0 	mrs	x0, mpidr_el1
  601040e69c:	92400400 	and	x0, x0, #0x3
  601040e6a0:	d65f03c0 	ret

000000601040e6a4 <psci_call>:
  601040e6a4:	d4000002 	hvc	#0x0
  601040e6a8:	d65f03c0 	ret

000000601040e6ac <context_switch>:
  601040e6ac:	910003e9 	mov	x9, sp
  601040e6b0:	910003ea 	mov	x10, sp
  601040e6b4:	d101c129 	sub	x9, x9, #0x70
  601040e6b8:	a900492a 	stp	x10, x18, [x9]
  601040e6bc:	a9015133 	stp	x19, x20, [x9, #16]
  601040e6c0:	a9025935 	stp	x21, x22, [x9, #32]
  601040e6c4:	a9036137 	stp	x23, x24, [x9, #48]
  601040e6c8:	a9046939 	stp	x25, x26, [x9, #64]
  601040e6cc:	a905713b 	stp	x27, x28, [x9, #80]
  601040e6d0:	a906793d 	stp	x29, x30, [x9, #96]
  601040e6d4:	f9000009 	str	x9, [x0]
  601040e6d8:	aa0103e9 	mov	x9, x1
  601040e6dc:	a940492a 	ldp	x10, x18, [x9]
  601040e6e0:	a9415133 	ldp	x19, x20, [x9, #16]
  601040e6e4:	a9425935 	ldp	x21, x22, [x9, #32]
  601040e6e8:	a9436137 	ldp	x23, x24, [x9, #48]
  601040e6ec:	a9446939 	ldp	x25, x26, [x9, #64]
  601040e6f0:	a945713b 	ldp	x27, x28, [x9, #80]
  601040e6f4:	a946793d 	ldp	x29, x30, [x9, #96]
  601040e6f8:	9101c129 	add	x9, x9, #0x70
  601040e6fc:	9100013f 	mov	sp, x9
  601040e700:	d65f03c0 	ret

000000601040e704 <r_cntp_ctl_el0>:
#include <stddef.h>
#include <stdint.h>

// armv8 generic timer
static inline uint32_t r_cntp_ctl_el0()
{
  601040e704:	d10043ff 	sub	sp, sp, #0x10
    uint32_t x;
    __asm__ volatile("mrs %0, cntp_ctl_el0" : "=r"(x));
  601040e708:	d53be220 	mrs	x0, cntp_ctl_el0
  601040e70c:	b9000fe0 	str	w0, [sp, #12]
    return x;
  601040e710:	b9400fe0 	ldr	w0, [sp, #12]
}
  601040e714:	910043ff 	add	sp, sp, #0x10
  601040e718:	d65f03c0 	ret

000000601040e71c <w_cntp_ctl_el0>:

static inline void w_cntp_ctl_el0(uint32_t x)
{
  601040e71c:	d10043ff 	sub	sp, sp, #0x10
  601040e720:	b9000fe0 	str	w0, [sp, #12]
    __asm__ volatile("msr cntp_ctl_el0, %0" : : "r"(x));
  601040e724:	b9400fe0 	ldr	w0, [sp, #12]
  601040e728:	d51be220 	msr	cntp_ctl_el0, x0
}
  601040e72c:	d503201f 	nop
  601040e730:	910043ff 	add	sp, sp, #0x10
  601040e734:	d65f03c0 	ret

000000601040e738 <w_cntp_tval_el0>:
    __asm__ volatile("mrs %0, cntp_tval_el0" : "=r"(x));
    return x;
}

static inline void w_cntp_tval_el0(uint32_t x)
{
  601040e738:	d10043ff 	sub	sp, sp, #0x10
  601040e73c:	b9000fe0 	str	w0, [sp, #12]
    __asm__ volatile("msr cntp_tval_el0, %0" : : "r"(x));
  601040e740:	b9400fe0 	ldr	w0, [sp, #12]
  601040e744:	d51be200 	msr	cntp_tval_el0, x0
}
  601040e748:	d503201f 	nop
  601040e74c:	910043ff 	add	sp, sp, #0x10
  601040e750:	d65f03c0 	ret

000000601040e754 <r_cntvct_el0>:

static inline uint64_t r_cntvct_el0()
{
  601040e754:	d10043ff 	sub	sp, sp, #0x10
    uint64_t x;
    __asm__ volatile("mrs %0, cntvct_el0" : "=r"(x));
  601040e758:	d53be040 	mrs	x0, cntvct_el0
  601040e75c:	f90007e0 	str	x0, [sp, #8]
    return x;
  601040e760:	f94007e0 	ldr	x0, [sp, #8]
}
  601040e764:	910043ff 	add	sp, sp, #0x10
  601040e768:	d65f03c0 	ret

000000601040e76c <r_cntfrq_el0>:

static inline uint32_t r_cntfrq_el0()
{
  601040e76c:	d10043ff 	sub	sp, sp, #0x10
    uint32_t x;
    __asm__ volatile("mrs %0, cntfrq_el0" : "=r"(x));
  601040e770:	d53be000 	mrs	x0, cntfrq_el0
  601040e774:	b9000fe0 	str	w0, [sp, #12]
    return x;
  601040e778:	b9400fe0 	ldr	w0, [sp, #12]
  601040e77c:	910043ff 	add	sp, sp, #0x10
  601040e780:	d65f03c0 	ret

000000601040e784 <enable_timer>:
#define CNTV_CTL_ENABLE (1 << 0)
#define CNTV_CTL_IMASK (1 << 1)
#define CNTV_CTL_ISTATUS (1 << 2)

static void enable_timer()
{
  601040e784:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  601040e788:	910003fd 	mov	x29, sp
    uint32_t c = r_cntp_ctl_el0();
  601040e78c:	97ffffde 	bl	601040e704 <r_cntp_ctl_el0>
  601040e790:	b9001fe0 	str	w0, [sp, #28]
    c |= CNTV_CTL_ENABLE;
  601040e794:	b9401fe0 	ldr	w0, [sp, #28]
  601040e798:	32000000 	orr	w0, w0, #0x1
  601040e79c:	b9001fe0 	str	w0, [sp, #28]
    c &= ~CNTV_CTL_IMASK;
  601040e7a0:	b9401fe0 	ldr	w0, [sp, #28]
  601040e7a4:	121e7800 	and	w0, w0, #0xfffffffd
  601040e7a8:	b9001fe0 	str	w0, [sp, #28]
    w_cntp_ctl_el0(c);
  601040e7ac:	b9401fe0 	ldr	w0, [sp, #28]
  601040e7b0:	97ffffdb 	bl	601040e71c <w_cntp_ctl_el0>
}
  601040e7b4:	d503201f 	nop
  601040e7b8:	a8c27bfd 	ldp	x29, x30, [sp], #32
  601040e7bc:	d65f03c0 	ret

000000601040e7c0 <disable_timer>:

static void disable_timer()
{
  601040e7c0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  601040e7c4:	910003fd 	mov	x29, sp
    uint32_t c = r_cntp_ctl_el0();
  601040e7c8:	97ffffcf 	bl	601040e704 <r_cntp_ctl_el0>
  601040e7cc:	b9001fe0 	str	w0, [sp, #28]
    c |= CNTV_CTL_IMASK;
  601040e7d0:	b9401fe0 	ldr	w0, [sp, #28]
  601040e7d4:	321f0000 	orr	w0, w0, #0x2
  601040e7d8:	b9001fe0 	str	w0, [sp, #28]
    c &= ~CNTV_CTL_ENABLE;
  601040e7dc:	b9401fe0 	ldr	w0, [sp, #28]
  601040e7e0:	121f7800 	and	w0, w0, #0xfffffffe
  601040e7e4:	b9001fe0 	str	w0, [sp, #28]
    w_cntp_ctl_el0(c);
  601040e7e8:	b9401fe0 	ldr	w0, [sp, #28]
  601040e7ec:	97ffffcc 	bl	601040e71c <w_cntp_ctl_el0>
}
  601040e7f0:	d503201f 	nop
  601040e7f4:	a8c27bfd 	ldp	x29, x30, [sp], #32
  601040e7f8:	d65f03c0 	ret

000000601040e7fc <reload_timer>:

static void reload_timer()
{
  601040e7fc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  601040e800:	910003fd 	mov	x29, sp
    // interval 1ms
    static uint32_t ms = 1;
    uint32_t interval = ms * 1000;
  601040e804:	d00000a0 	adrp	x0, 6010424000 <impure_data+0x210>
  601040e808:	9114e000 	add	x0, x0, #0x538
  601040e80c:	b9400001 	ldr	w1, [x0]
  601040e810:	52807d00 	mov	w0, #0x3e8                 	// #1000
  601040e814:	1b007c20 	mul	w0, w1, w0
  601040e818:	b9001fe0 	str	w0, [sp, #28]
    uint32_t interval_clk = interval * (r_cntfrq_el0() / 1000000);
  601040e81c:	97ffffd4 	bl	601040e76c <r_cntfrq_el0>
  601040e820:	2a0003e1 	mov	w1, w0
  601040e824:	529bd060 	mov	w0, #0xde83                	// #56963
  601040e828:	72a86360 	movk	w0, #0x431b, lsl #16
  601040e82c:	9ba07c20 	umull	x0, w1, w0
  601040e830:	d360fc00 	lsr	x0, x0, #32
  601040e834:	53127c00 	lsr	w0, w0, #18
  601040e838:	b9401fe1 	ldr	w1, [sp, #28]
  601040e83c:	1b007c20 	mul	w0, w1, w0
  601040e840:	b9001be0 	str	w0, [sp, #24]
    w_cntp_tval_el0(interval_clk);
  601040e844:	b9401be0 	ldr	w0, [sp, #24]
  601040e848:	97ffffbc 	bl	601040e738 <w_cntp_tval_el0>
}
  601040e84c:	d503201f 	nop
  601040e850:	a8c27bfd 	ldp	x29, x30, [sp], #32
  601040e854:	d65f03c0 	ret

000000601040e858 <_sys_clock_init>:

void _sys_clock_init()
{
  601040e858:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601040e85c:	910003fd 	mov	x29, sp
    disable_timer();
  601040e860:	97ffffd8 	bl	601040e7c0 <disable_timer>
    reload_timer();
  601040e864:	97ffffe6 	bl	601040e7fc <reload_timer>
    enable_timer();
  601040e868:	97ffffc7 	bl	601040e784 <enable_timer>
}
  601040e86c:	d503201f 	nop
  601040e870:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601040e874:	d65f03c0 	ret

000000601040e878 <_get_clock_int>:

static uint32_t _get_clock_int()
{
    return 30;
  601040e878:	528003c0 	mov	w0, #0x1e                  	// #30
}
  601040e87c:	d65f03c0 	ret

000000601040e880 <_get_tick>:

static uint64_t _get_tick()
{
  601040e880:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601040e884:	910003fd 	mov	x29, sp
    return r_cntvct_el0();
  601040e888:	97ffffb3 	bl	601040e754 <r_cntvct_el0>
}
  601040e88c:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601040e890:	d65f03c0 	ret

000000601040e894 <_get_second>:

static uint64_t _get_second()
{
    return 0;
  601040e894:	d2800000 	mov	x0, #0x0                   	// #0
}
  601040e898:	d65f03c0 	ret

000000601040e89c <_is_timer_expired>:

static bool _is_timer_expired()
{
    return true;
  601040e89c:	52800020 	mov	w0, #0x1                   	// #1
}
  601040e8a0:	d65f03c0 	ret

000000601040e8a4 <_clear_clock_intr>:

static void _clear_clock_intr()
{
  601040e8a4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601040e8a8:	910003fd 	mov	x29, sp
    disable_timer();
  601040e8ac:	97ffffc5 	bl	601040e7c0 <disable_timer>
    reload_timer();
  601040e8b0:	97ffffd3 	bl	601040e7fc <reload_timer>
    enable_timer();
  601040e8b4:	97ffffb4 	bl	601040e784 <enable_timer>
}
  601040e8b8:	d503201f 	nop
  601040e8bc:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601040e8c0:	d65f03c0 	ret

000000601040e8c4 <hardkernel_clock_init>:
    .is_timer_expired = _is_timer_expired,
    .clear_clock_intr = _clear_clock_intr,
};

struct XiziClockDriver* hardkernel_clock_init(struct TraceTag* hardkernel_tag)
{
  601040e8c4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  601040e8c8:	910003fd 	mov	x29, sp
  601040e8cc:	f9000fe0 	str	x0, [sp, #24]
    hardkernel_clock_driver.sys_clock_init();
  601040e8d0:	d00000a0 	adrp	x0, 6010424000 <impure_data+0x210>
  601040e8d4:	91150000 	add	x0, x0, #0x540
  601040e8d8:	f9400000 	ldr	x0, [x0]
  601040e8dc:	d63f0000 	blr	x0
    return &hardkernel_clock_driver;
  601040e8e0:	d00000a0 	adrp	x0, 6010424000 <impure_data+0x210>
  601040e8e4:	91150000 	add	x0, x0, #0x540
  601040e8e8:	a8c27bfd 	ldp	x29, x30, [sp], #32
  601040e8ec:	d65f03c0 	ret

000000601040e8f0 <load_pgdir>:

// extern struct MmuCommonDone mmu_common_done;
static struct MmuDriverRightGroup right_group;

void load_pgdir(uintptr_t pgdir_paddr)
{
  601040e8f0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  601040e8f4:	910003fd 	mov	x29, sp
  601040e8f8:	f9000fe0 	str	x0, [sp, #24]
    /* get cache driver */
    struct ICacheDone* p_icache_done = AchieveResource(&right_group.icache_driver_tag);
  601040e8fc:	b00089a0 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601040e900:	91196000 	add	x0, x0, #0x658
  601040e904:	94001da3 	bl	6010415f90 <AchieveResource>
  601040e908:	f90017e0 	str	x0, [sp, #40]
    struct DCacheDone* p_dcache_done = AchieveResource(&right_group.dcache_driver_tag);
  601040e90c:	b00089a0 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601040e910:	91198000 	add	x0, x0, #0x660
  601040e914:	94001d9f 	bl	6010415f90 <AchieveResource>
  601040e918:	f90013e0 	str	x0, [sp, #32]

    TTBR0_W((uint64_t)pgdir_paddr);
  601040e91c:	f9400fe0 	ldr	x0, [sp, #24]
  601040e920:	d5182000 	msr	ttbr0_el1, x0
    DSB();
  601040e924:	d5033b9f 	dsb	ish
    CLEARTLB(0);
  601040e928:	d508831f 	tlbi	vmalle1is
    ISB();
  601040e92c:	d5033fdf 	isb
    p_icache_done->invalidateall();
  601040e930:	f94017e0 	ldr	x0, [sp, #40]
  601040e934:	f9400c00 	ldr	x0, [x0, #24]
  601040e938:	d63f0000 	blr	x0
    p_dcache_done->flushall();
  601040e93c:	f94013e0 	ldr	x0, [sp, #32]
  601040e940:	f9401800 	ldr	x0, [x0, #48]
  601040e944:	d63f0000 	blr	x0
}
  601040e948:	d503201f 	nop
  601040e94c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  601040e950:	d65f03c0 	ret

000000601040e954 <tlb_flush_range>:
{
    __asm__ volatile("tlbi vae1is, %0" ::"r"(va));
}

static void tlb_flush_range(uintptr_t vstart, int len)
{
  601040e954:	d100c3ff 	sub	sp, sp, #0x30
  601040e958:	f90007e0 	str	x0, [sp, #8]
  601040e95c:	b90007e1 	str	w1, [sp, #4]
    uintptr_t vaddr = vstart;
  601040e960:	f94007e0 	ldr	x0, [sp, #8]
  601040e964:	f90017e0 	str	x0, [sp, #40]
    uintptr_t vend = vaddr + len;
  601040e968:	b98007e0 	ldrsw	x0, [sp, #4]
  601040e96c:	f94017e1 	ldr	x1, [sp, #40]
  601040e970:	8b000020 	add	x0, x1, x0
  601040e974:	f90013e0 	str	x0, [sp, #32]
    for (; vaddr < vend; vaddr += PAGE_SIZE) {
  601040e978:	14000009 	b	601040e99c <tlb_flush_range+0x48>
  601040e97c:	f94017e0 	ldr	x0, [sp, #40]
  601040e980:	f9000fe0 	str	x0, [sp, #24]
    __asm__ volatile("tlbi vae1is, %0" ::"r"(va));
  601040e984:	f9400fe0 	ldr	x0, [sp, #24]
  601040e988:	d5088320 	tlbi	vae1is, x0
}
  601040e98c:	d503201f 	nop
    for (; vaddr < vend; vaddr += PAGE_SIZE) {
  601040e990:	f94017e0 	ldr	x0, [sp, #40]
  601040e994:	91400400 	add	x0, x0, #0x1, lsl #12
  601040e998:	f90017e0 	str	x0, [sp, #40]
  601040e99c:	f94017e1 	ldr	x1, [sp, #40]
  601040e9a0:	f94013e0 	ldr	x0, [sp, #32]
  601040e9a4:	eb00003f 	cmp	x1, x0
  601040e9a8:	54fffea3 	b.cc	601040e97c <tlb_flush_range+0x28>  // b.lo, b.ul, b.last
        _tlb_flush(vaddr);
    }
}
  601040e9ac:	d503201f 	nop
  601040e9b0:	d503201f 	nop
  601040e9b4:	9100c3ff 	add	sp, sp, #0x30
  601040e9b8:	d65f03c0 	ret

000000601040e9bc <tlb_flush_all>:

static void tlb_flush_all()
{
    CLEARTLB(0);
  601040e9bc:	d508831f 	tlbi	vmalle1is
}
  601040e9c0:	d503201f 	nop
  601040e9c4:	d65f03c0 	ret

000000601040e9c8 <hardkernel_mmu_init>:
    .TlbFlushAll = tlb_flush_all,
    .TlbFlush = tlb_flush_range,
};

struct MmuCommonDone* hardkernel_mmu_init(struct TraceTag* hardkernel_tag, char* icache_name, char* dcache_name)
{
  601040e9c8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  601040e9cc:	910003fd 	mov	x29, sp
  601040e9d0:	f90017e0 	str	x0, [sp, #40]
  601040e9d4:	f90013e1 	str	x1, [sp, #32]
  601040e9d8:	f9000fe2 	str	x2, [sp, #24]
    /* init right group for mmu driver */
    AchieveResourceTag(&right_group.icache_driver_tag, hardkernel_tag, icache_name);
  601040e9dc:	f94013e2 	ldr	x2, [sp, #32]
  601040e9e0:	f94017e1 	ldr	x1, [sp, #40]
  601040e9e4:	b00089a0 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601040e9e8:	91196000 	add	x0, x0, #0x658
  601040e9ec:	94001d16 	bl	6010415e44 <AchieveResourceTag>
    AchieveResourceTag(&right_group.dcache_driver_tag, hardkernel_tag, dcache_name);
  601040e9f0:	f9400fe2 	ldr	x2, [sp, #24]
  601040e9f4:	f94017e1 	ldr	x1, [sp, #40]
  601040e9f8:	b00089a0 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601040e9fc:	91198000 	add	x0, x0, #0x660
  601040ea00:	94001d11 	bl	6010415e44 <AchieveResourceTag>

    return &mmu_common_done;
  601040ea04:	d00000a0 	adrp	x0, 6010424000 <impure_data+0x210>
  601040ea08:	9115c000 	add	x0, x0, #0x570
  601040ea0c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  601040ea10:	d65f03c0 	ret

000000601040ea14 <GetUsrPteAttr>:
#define ARMV8_PDE_VALID             (0b11 << 0)

// clang-format on

void GetUsrPteAttr(uintptr_t* attr)
{
  601040ea14:	d10043ff 	sub	sp, sp, #0x10
  601040ea18:	f90007e0 	str	x0, [sp, #8]
    // *attr = ARMV8_PTE_AP_U | ARMV8_PTE_AP_RW | ARMV8_PTE_AF | ARMV8_PTE_NORMAL | ARMV8_PTE_VALID;
    *attr = 0x713 | ARMV8_PTE_AP_U;
  601040ea1c:	f94007e0 	ldr	x0, [sp, #8]
  601040ea20:	d280ea61 	mov	x1, #0x753                 	// #1875
  601040ea24:	f9000001 	str	x1, [x0]
}
  601040ea28:	d503201f 	nop
  601040ea2c:	910043ff 	add	sp, sp, #0x10
  601040ea30:	d65f03c0 	ret

000000601040ea34 <GetUsrDevPteAttr>:

void GetUsrDevPteAttr(uintptr_t* attr)
{
  601040ea34:	d10043ff 	sub	sp, sp, #0x10
  601040ea38:	f90007e0 	str	x0, [sp, #8]
    // *attr = ARMV8_PTE_AP_U | ARMV8_PTE_AP_RW | ARMV8_PTE_AF | ARMV8_PTE_DEVICE | ARMV8_PTE_XN | ARMV8_PTE_VALID;
    *attr = 0x403 | ARMV8_PTE_AP_U;
  601040ea3c:	f94007e0 	ldr	x0, [sp, #8]
  601040ea40:	d2808861 	mov	x1, #0x443                 	// #1091
  601040ea44:	f9000001 	str	x1, [x0]
}
  601040ea48:	d503201f 	nop
  601040ea4c:	910043ff 	add	sp, sp, #0x10
  601040ea50:	d65f03c0 	ret

000000601040ea54 <GetDevPteAttr>:

void GetDevPteAttr(uintptr_t* attr)
{
  601040ea54:	d10043ff 	sub	sp, sp, #0x10
  601040ea58:	f90007e0 	str	x0, [sp, #8]
    // *attr = ARMV8_PTE_AP_K | ARMV8_PTE_AP_RW | ARMV8_PTE_AF | ARMV8_PTE_DEVICE | ARMV8_PTE_XN | ARMV8_PTE_VALID;
    *attr = 0x403ULL;
  601040ea5c:	f94007e0 	ldr	x0, [sp, #8]
  601040ea60:	d2808061 	mov	x1, #0x403                 	// #1027
  601040ea64:	f9000001 	str	x1, [x0]
}
  601040ea68:	d503201f 	nop
  601040ea6c:	910043ff 	add	sp, sp, #0x10
  601040ea70:	d65f03c0 	ret

000000601040ea74 <GetKernPteAttr>:

void GetKernPteAttr(uintptr_t* attr)
{
  601040ea74:	d10043ff 	sub	sp, sp, #0x10
  601040ea78:	f90007e0 	str	x0, [sp, #8]
    // *attr = ARMV8_PTE_AP_K | ARMV8_PTE_AP_RW | ARMV8_PTE_AF | ARMV8_PTE_NORMAL | ARMV8_PTE_VALID;
    *attr = 0x713ULL;
  601040ea7c:	f94007e0 	ldr	x0, [sp, #8]
  601040ea80:	d280e261 	mov	x1, #0x713                 	// #1811
  601040ea84:	f9000001 	str	x1, [x0]
}
  601040ea88:	d503201f 	nop
  601040ea8c:	910043ff 	add	sp, sp, #0x10
  601040ea90:	d65f03c0 	ret

000000601040ea94 <GetPdeAttr>:

void GetPdeAttr(uintptr_t* attr)
{
  601040ea94:	d10043ff 	sub	sp, sp, #0x10
  601040ea98:	f90007e0 	str	x0, [sp, #8]
    *attr = ARMV8_PDE_VALID;
  601040ea9c:	f94007e0 	ldr	x0, [sp, #8]
  601040eaa0:	d2800061 	mov	x1, #0x3                   	// #3
  601040eaa4:	f9000001 	str	x1, [x0]
  601040eaa8:	d503201f 	nop
  601040eaac:	910043ff 	add	sp, sp, #0x10
  601040eab0:	d65f03c0 	ret

000000601040eab4 <w_icc_igrpen1_el1>:
    __asm__ volatile("mrs %0, S3_0_C12_C12_7" : "=r"(x));
    return x;
}

static inline void w_icc_igrpen1_el1(uint32_t x)
{
  601040eab4:	d10043ff 	sub	sp, sp, #0x10
  601040eab8:	b9000fe0 	str	w0, [sp, #12]
    __asm__ volatile("msr S3_0_C12_C12_7, %0" : : "r"(x));
  601040eabc:	b9400fe0 	ldr	w0, [sp, #12]
  601040eac0:	d518cce0 	msr	s3_0_c12_c12_7, x0
}
  601040eac4:	d503201f 	nop
  601040eac8:	910043ff 	add	sp, sp, #0x10
  601040eacc:	d65f03c0 	ret

000000601040ead0 <w_icc_pmr_el1>:
    __asm__ volatile("mrs %0, S3_0_C4_C6_0" : "=r"(x));
    return x;
}

static inline void w_icc_pmr_el1(uint32_t x)
{
  601040ead0:	d10043ff 	sub	sp, sp, #0x10
  601040ead4:	b9000fe0 	str	w0, [sp, #12]
    __asm__ volatile("msr S3_0_C4_C6_0, %0" : : "r"(x));
  601040ead8:	b9400fe0 	ldr	w0, [sp, #12]
  601040eadc:	d5184600 	msr	s3_0_c4_c6_0, x0
}
  601040eae0:	d503201f 	nop
  601040eae4:	910043ff 	add	sp, sp, #0x10
  601040eae8:	d65f03c0 	ret

000000601040eaec <gic_read_irq_ack>:

inline uint32_t gic_read_irq_ack()
{
  601040eaec:	d10043ff 	sub	sp, sp, #0x10
    uint32_t x;
    __asm__ volatile("mrs %0, S3_0_C12_C12_0" : "=r"(x));
  601040eaf0:	d538cc00 	mrs	x0, s3_0_c12_c12_0
  601040eaf4:	b9000fe0 	str	w0, [sp, #12]
    return x;
  601040eaf8:	b9400fe0 	ldr	w0, [sp, #12]
}
  601040eafc:	910043ff 	add	sp, sp, #0x10
  601040eb00:	d65f03c0 	ret

000000601040eb04 <gic_write_end_of_irq>:

inline void
gic_write_end_of_irq(uint32_t x)
{
  601040eb04:	d10043ff 	sub	sp, sp, #0x10
  601040eb08:	b9000fe0 	str	w0, [sp, #12]
    __asm__ volatile("msr S3_0_C12_C12_1, %0" : : "r"(x));
  601040eb0c:	b9400fe0 	ldr	w0, [sp, #12]
  601040eb10:	d518cc20 	msr	s3_0_c12_c12_1, x0
}
  601040eb14:	d503201f 	nop
  601040eb18:	910043ff 	add	sp, sp, #0x10
  601040eb1c:	d65f03c0 	ret

000000601040eb20 <icc_sre_el1>:

static inline uint32_t icc_sre_el1()
{
  601040eb20:	d10043ff 	sub	sp, sp, #0x10
    uint32_t x;
    __asm__ volatile("mrs %0, S3_0_C12_C12_5" : "=r"(x));
  601040eb24:	d538cca0 	mrs	x0, s3_0_c12_c12_5
  601040eb28:	b9000fe0 	str	w0, [sp, #12]
    return x;
  601040eb2c:	b9400fe0 	ldr	w0, [sp, #12]
}
  601040eb30:	910043ff 	add	sp, sp, #0x10
  601040eb34:	d65f03c0 	ret

000000601040eb38 <w_icc_sre_el1>:

static inline void w_icc_sre_el1(uint32_t x)
{
  601040eb38:	d10043ff 	sub	sp, sp, #0x10
  601040eb3c:	b9000fe0 	str	w0, [sp, #12]
    __asm__ volatile("msr S3_0_C12_C12_5, %0" : : "r"(x));
  601040eb40:	b9400fe0 	ldr	w0, [sp, #12]
  601040eb44:	d518cca0 	msr	s3_0_c12_c12_5, x0
}
  601040eb48:	d503201f 	nop
  601040eb4c:	910043ff 	add	sp, sp, #0x10
  601040eb50:	d65f03c0 	ret

000000601040eb54 <gicd_write>:

static void gicd_write(uint32_t off, uint32_t val)
{
  601040eb54:	d10043ff 	sub	sp, sp, #0x10
  601040eb58:	b9000fe0 	str	w0, [sp, #12]
  601040eb5c:	b9000be1 	str	w1, [sp, #8]
    *(volatile uint32_t*)(gicv3.gicd + off) = val;
  601040eb60:	b00089a0 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601040eb64:	9119c000 	add	x0, x0, #0x670
  601040eb68:	f9400001 	ldr	x1, [x0]
  601040eb6c:	b9400fe0 	ldr	w0, [sp, #12]
  601040eb70:	8b000020 	add	x0, x1, x0
  601040eb74:	b9400be1 	ldr	w1, [sp, #8]
  601040eb78:	b9000001 	str	w1, [x0]
}
  601040eb7c:	d503201f 	nop
  601040eb80:	910043ff 	add	sp, sp, #0x10
  601040eb84:	d65f03c0 	ret

000000601040eb88 <gicd_read>:

static uint32_t gicd_read(uint32_t off)
{
  601040eb88:	d10043ff 	sub	sp, sp, #0x10
  601040eb8c:	b9000fe0 	str	w0, [sp, #12]
    return *(volatile uint32_t*)(gicv3.gicd + off);
  601040eb90:	b00089a0 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601040eb94:	9119c000 	add	x0, x0, #0x670
  601040eb98:	f9400001 	ldr	x1, [x0]
  601040eb9c:	b9400fe0 	ldr	w0, [sp, #12]
  601040eba0:	8b000020 	add	x0, x1, x0
  601040eba4:	b9400000 	ldr	w0, [x0]
}
  601040eba8:	910043ff 	add	sp, sp, #0x10
  601040ebac:	d65f03c0 	ret

000000601040ebb0 <gicr_write>:

static void gicr_write(uint32_t cpuid, uint32_t off, uint32_t val)
{
  601040ebb0:	d10043ff 	sub	sp, sp, #0x10
  601040ebb4:	b9000fe0 	str	w0, [sp, #12]
  601040ebb8:	b9000be1 	str	w1, [sp, #8]
  601040ebbc:	b90007e2 	str	w2, [sp, #4]
    *(volatile uint32_t*)(gicv3.rdist_addrs[cpuid] + off) = val;
  601040ebc0:	b00089a0 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601040ebc4:	9119c001 	add	x1, x0, #0x670
  601040ebc8:	b9400fe0 	ldr	w0, [sp, #12]
  601040ebcc:	d37df000 	lsl	x0, x0, #3
  601040ebd0:	8b000020 	add	x0, x1, x0
  601040ebd4:	f9400401 	ldr	x1, [x0, #8]
  601040ebd8:	b9400be0 	ldr	w0, [sp, #8]
  601040ebdc:	8b000020 	add	x0, x1, x0
  601040ebe0:	b94007e1 	ldr	w1, [sp, #4]
  601040ebe4:	b9000001 	str	w1, [x0]
}
  601040ebe8:	d503201f 	nop
  601040ebec:	910043ff 	add	sp, sp, #0x10
  601040ebf0:	d65f03c0 	ret

000000601040ebf4 <gicr_read>:

static uint32_t gicr_read(uint32_t cpuid, uint32_t off)
{
  601040ebf4:	d10043ff 	sub	sp, sp, #0x10
  601040ebf8:	b9000fe0 	str	w0, [sp, #12]
  601040ebfc:	b9000be1 	str	w1, [sp, #8]
    return *(volatile uint32_t*)(gicv3.rdist_addrs[cpuid] + off);
  601040ec00:	b00089a0 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601040ec04:	9119c001 	add	x1, x0, #0x670
  601040ec08:	b9400fe0 	ldr	w0, [sp, #12]
  601040ec0c:	d37df000 	lsl	x0, x0, #3
  601040ec10:	8b000020 	add	x0, x1, x0
  601040ec14:	f9400401 	ldr	x1, [x0, #8]
  601040ec18:	b9400be0 	ldr	w0, [sp, #8]
  601040ec1c:	8b000020 	add	x0, x1, x0
  601040ec20:	b9400000 	ldr	w0, [x0]
}
  601040ec24:	910043ff 	add	sp, sp, #0x10
  601040ec28:	d65f03c0 	ret

000000601040ec2c <giccinit>:

static void giccinit()
{
  601040ec2c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601040ec30:	910003fd 	mov	x29, sp
    w_icc_igrpen1_el1(0);
  601040ec34:	52800000 	mov	w0, #0x0                   	// #0
  601040ec38:	97ffff9f 	bl	601040eab4 <w_icc_igrpen1_el1>
    w_icc_pmr_el1(0xff);
  601040ec3c:	52801fe0 	mov	w0, #0xff                  	// #255
  601040ec40:	97ffffa4 	bl	601040ead0 <w_icc_pmr_el1>
}
  601040ec44:	d503201f 	nop
  601040ec48:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601040ec4c:	d65f03c0 	ret

000000601040ec50 <gicdinit>:

static void gicdinit()
{
  601040ec50:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  601040ec54:	910003fd 	mov	x29, sp
    gicd_write(D_CTLR, 0);
  601040ec58:	52800001 	mov	w1, #0x0                   	// #0
  601040ec5c:	52800000 	mov	w0, #0x0                   	// #0
  601040ec60:	97ffffbd 	bl	601040eb54 <gicd_write>

    uint32_t typer = gicd_read(D_TYPER);
  601040ec64:	52800080 	mov	w0, #0x4                   	// #4
  601040ec68:	97ffffc8 	bl	601040eb88 <gicd_read>
  601040ec6c:	b9001be0 	str	w0, [sp, #24]
    uint32_t lines = typer & 0x1f;
  601040ec70:	b9401be0 	ldr	w0, [sp, #24]
  601040ec74:	12001000 	and	w0, w0, #0x1f
  601040ec78:	b90017e0 	str	w0, [sp, #20]

    for (int i = 0; i < lines; i++)
  601040ec7c:	b9001fff 	str	wzr, [sp, #28]
  601040ec80:	14000009 	b	601040eca4 <gicdinit+0x54>
        gicd_write(D_IGROUPR(i), ~0);
  601040ec84:	b9801fe0 	ldrsw	x0, [sp, #28]
  601040ec88:	91008000 	add	x0, x0, #0x20
  601040ec8c:	531e7400 	lsl	w0, w0, #2
  601040ec90:	12800001 	mov	w1, #0xffffffff            	// #-1
  601040ec94:	97ffffb0 	bl	601040eb54 <gicd_write>
    for (int i = 0; i < lines; i++)
  601040ec98:	b9401fe0 	ldr	w0, [sp, #28]
  601040ec9c:	11000400 	add	w0, w0, #0x1
  601040eca0:	b9001fe0 	str	w0, [sp, #28]
  601040eca4:	b9401fe0 	ldr	w0, [sp, #28]
  601040eca8:	b94017e1 	ldr	w1, [sp, #20]
  601040ecac:	6b00003f 	cmp	w1, w0
  601040ecb0:	54fffea8 	b.hi	601040ec84 <gicdinit+0x34>  // b.pmore
}
  601040ecb4:	d503201f 	nop
  601040ecb8:	d503201f 	nop
  601040ecbc:	a8c27bfd 	ldp	x29, x30, [sp], #32
  601040ecc0:	d65f03c0 	ret

000000601040ecc4 <gicrinit>:

static void gicrinit(uint32_t cpuid)
{
  601040ecc4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  601040ecc8:	910003fd 	mov	x29, sp
  601040eccc:	b9001fe0 	str	w0, [sp, #28]
    gicr_write(cpuid, R_CTLR, 0);
  601040ecd0:	52800002 	mov	w2, #0x0                   	// #0
  601040ecd4:	52800001 	mov	w1, #0x0                   	// #0
  601040ecd8:	b9401fe0 	ldr	w0, [sp, #28]
  601040ecdc:	97ffffb5 	bl	601040ebb0 <gicr_write>

    w_icc_sre_el1(icc_sre_el1() | 1);
  601040ece0:	97ffff90 	bl	601040eb20 <icc_sre_el1>
  601040ece4:	32000000 	orr	w0, w0, #0x1
  601040ece8:	97ffff94 	bl	601040eb38 <w_icc_sre_el1>

    gicr_write(cpuid, R_IGROUPR0, ~0);
  601040ecec:	12800002 	mov	w2, #0xffffffff            	// #-1
  601040ecf0:	52801001 	mov	w1, #0x80                  	// #128
  601040ecf4:	72a00021 	movk	w1, #0x1, lsl #16
  601040ecf8:	b9401fe0 	ldr	w0, [sp, #28]
  601040ecfc:	97ffffad 	bl	601040ebb0 <gicr_write>
    gicr_write(cpuid, R_IGRPMODR0, 0);
  601040ed00:	52800002 	mov	w2, #0x0                   	// #0
  601040ed04:	5281a001 	mov	w1, #0xd00                 	// #3328
  601040ed08:	72a00021 	movk	w1, #0x1, lsl #16
  601040ed0c:	b9401fe0 	ldr	w0, [sp, #28]
  601040ed10:	97ffffa8 	bl	601040ebb0 <gicr_write>

    uint32_t waker = gicr_read(cpuid, R_WAKER);
  601040ed14:	52800281 	mov	w1, #0x14                  	// #20
  601040ed18:	b9401fe0 	ldr	w0, [sp, #28]
  601040ed1c:	97ffffb6 	bl	601040ebf4 <gicr_read>
  601040ed20:	b9002fe0 	str	w0, [sp, #44]
    gicr_write(cpuid, R_WAKER, waker & ~(1 << 1));
  601040ed24:	b9402fe0 	ldr	w0, [sp, #44]
  601040ed28:	121e7800 	and	w0, w0, #0xfffffffd
  601040ed2c:	2a0003e2 	mov	w2, w0
  601040ed30:	52800281 	mov	w1, #0x14                  	// #20
  601040ed34:	b9401fe0 	ldr	w0, [sp, #28]
  601040ed38:	97ffff9e 	bl	601040ebb0 <gicr_write>
    while (gicr_read(cpuid, R_WAKER) & (1 << 2))
  601040ed3c:	d503201f 	nop
  601040ed40:	52800281 	mov	w1, #0x14                  	// #20
  601040ed44:	b9401fe0 	ldr	w0, [sp, #28]
  601040ed48:	97ffffab 	bl	601040ebf4 <gicr_read>
  601040ed4c:	121e0000 	and	w0, w0, #0x4
  601040ed50:	7100001f 	cmp	w0, #0x0
  601040ed54:	54ffff61 	b.ne	601040ed40 <gicrinit+0x7c>  // b.any
        ;
}
  601040ed58:	d503201f 	nop
  601040ed5c:	d503201f 	nop
  601040ed60:	a8c37bfd 	ldp	x29, x30, [sp], #48
  601040ed64:	d65f03c0 	ret

000000601040ed68 <gic_enable>:

void gic_enable()
{
  601040ed68:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601040ed6c:	910003fd 	mov	x29, sp
    gicd_write(D_CTLR, (1 << 1));
  601040ed70:	52800041 	mov	w1, #0x2                   	// #2
  601040ed74:	52800000 	mov	w0, #0x0                   	// #0
  601040ed78:	97ffff77 	bl	601040eb54 <gicd_write>
    w_icc_igrpen1_el1(1);
  601040ed7c:	52800020 	mov	w0, #0x1                   	// #1
  601040ed80:	97ffff4d 	bl	601040eab4 <w_icc_igrpen1_el1>
}
  601040ed84:	d503201f 	nop
  601040ed88:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601040ed8c:	d65f03c0 	ret

000000601040ed90 <gic_init>:

void gic_init()
{
  601040ed90:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  601040ed94:	910003fd 	mov	x29, sp
    gicv3.gicd = (char*)GICV3;
  601040ed98:	b00089a0 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601040ed9c:	9119c000 	add	x0, x0, #0x670
  601040eda0:	d2bfa801 	mov	x1, #0xfd400000            	// #4248829952
  601040eda4:	f2c00801 	movk	x1, #0x40, lsl #32
  601040eda8:	f9000001 	str	x1, [x0]
    for (int i = 0; i < NR_CPU; i++) {
  601040edac:	b9001fff 	str	wzr, [sp, #28]
  601040edb0:	14000011 	b	601040edf4 <gic_init+0x64>
        gicv3.rdist_addrs[i] = (char*)(GICV3_REDIST + (i) * 0x20000);
  601040edb4:	b9401fe0 	ldr	w0, [sp, #28]
  601040edb8:	530f3800 	lsl	w0, w0, #17
  601040edbc:	93407c01 	sxtw	x1, w0
  601040edc0:	d2bfa8c0 	mov	x0, #0xfd460000            	// #4249223168
  601040edc4:	f2c00800 	movk	x0, #0x40, lsl #32
  601040edc8:	8b000020 	add	x0, x1, x0
  601040edcc:	aa0003e2 	mov	x2, x0
  601040edd0:	b00089a0 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601040edd4:	9119c001 	add	x1, x0, #0x670
  601040edd8:	b9801fe0 	ldrsw	x0, [sp, #28]
  601040eddc:	d37df000 	lsl	x0, x0, #3
  601040ede0:	8b000020 	add	x0, x1, x0
  601040ede4:	f9000402 	str	x2, [x0, #8]
    for (int i = 0; i < NR_CPU; i++) {
  601040ede8:	b9401fe0 	ldr	w0, [sp, #28]
  601040edec:	11000400 	add	w0, w0, #0x1
  601040edf0:	b9001fe0 	str	w0, [sp, #28]
  601040edf4:	b9401fe0 	ldr	w0, [sp, #28]
  601040edf8:	7100001f 	cmp	w0, #0x0
  601040edfc:	54fffdcd 	b.le	601040edb4 <gic_init+0x24>
    }

    gicdinit();
  601040ee00:	97ffff94 	bl	601040ec50 <gicdinit>
}
  601040ee04:	d503201f 	nop
  601040ee08:	a8c27bfd 	ldp	x29, x30, [sp], #32
  601040ee0c:	d65f03c0 	ret

000000601040ee10 <gicv3inithart>:

void gicv3inithart(uint32_t cpu_id)
{
  601040ee10:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  601040ee14:	910003fd 	mov	x29, sp
  601040ee18:	b9001fe0 	str	w0, [sp, #28]
    giccinit();
  601040ee1c:	97ffff84 	bl	601040ec2c <giccinit>
    gicrinit(cpu_id);
  601040ee20:	b9401fe0 	ldr	w0, [sp, #28]
  601040ee24:	97ffffa8 	bl	601040ecc4 <gicrinit>

    gic_enable();
  601040ee28:	97ffffd0 	bl	601040ed68 <gic_enable>
}
  601040ee2c:	d503201f 	nop
  601040ee30:	a8c27bfd 	ldp	x29, x30, [sp], #32
  601040ee34:	d65f03c0 	ret

000000601040ee38 <gic_enable_int>:

static void
gic_enable_int(uint32_t intid)
{
  601040ee38:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  601040ee3c:	910003fd 	mov	x29, sp
  601040ee40:	b9001fe0 	str	w0, [sp, #28]
    uint32_t is = gicd_read(D_ISENABLER(intid / 32));
  601040ee44:	b9401fe0 	ldr	w0, [sp, #28]
  601040ee48:	53057c00 	lsr	w0, w0, #5
  601040ee4c:	11010000 	add	w0, w0, #0x40
  601040ee50:	531e7400 	lsl	w0, w0, #2
  601040ee54:	97ffff4d 	bl	601040eb88 <gicd_read>
  601040ee58:	b9002fe0 	str	w0, [sp, #44]
    is |= 1 << (intid % 32);
  601040ee5c:	b9401fe0 	ldr	w0, [sp, #28]
  601040ee60:	12001000 	and	w0, w0, #0x1f
  601040ee64:	52800021 	mov	w1, #0x1                   	// #1
  601040ee68:	1ac02020 	lsl	w0, w1, w0
  601040ee6c:	2a0003e1 	mov	w1, w0
  601040ee70:	b9402fe0 	ldr	w0, [sp, #44]
  601040ee74:	2a010000 	orr	w0, w0, w1
  601040ee78:	b9002fe0 	str	w0, [sp, #44]
    gicd_write(D_ISENABLER(intid / 32), is);
  601040ee7c:	b9401fe0 	ldr	w0, [sp, #28]
  601040ee80:	53057c00 	lsr	w0, w0, #5
  601040ee84:	11010000 	add	w0, w0, #0x40
  601040ee88:	531e7400 	lsl	w0, w0, #2
  601040ee8c:	b9402fe1 	ldr	w1, [sp, #44]
  601040ee90:	97ffff31 	bl	601040eb54 <gicd_write>
}
  601040ee94:	d503201f 	nop
  601040ee98:	a8c37bfd 	ldp	x29, x30, [sp], #48
  601040ee9c:	d65f03c0 	ret

000000601040eea0 <gic_int_enabled>:

int gic_int_enabled(uint32_t intid)
{
  601040eea0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  601040eea4:	910003fd 	mov	x29, sp
  601040eea8:	b9001fe0 	str	w0, [sp, #28]
    uint32_t is = gicd_read(D_ISENABLER(intid / 32));
  601040eeac:	b9401fe0 	ldr	w0, [sp, #28]
  601040eeb0:	53057c00 	lsr	w0, w0, #5
  601040eeb4:	11010000 	add	w0, w0, #0x40
  601040eeb8:	531e7400 	lsl	w0, w0, #2
  601040eebc:	97ffff33 	bl	601040eb88 <gicd_read>
  601040eec0:	b9002fe0 	str	w0, [sp, #44]
    return is & (1 << (intid % 32));
  601040eec4:	b9401fe0 	ldr	w0, [sp, #28]
  601040eec8:	12001000 	and	w0, w0, #0x1f
  601040eecc:	52800021 	mov	w1, #0x1                   	// #1
  601040eed0:	1ac02020 	lsl	w0, w1, w0
  601040eed4:	2a0003e1 	mov	w1, w0
  601040eed8:	b9402fe0 	ldr	w0, [sp, #44]
  601040eedc:	0a000020 	and	w0, w1, w0
}
  601040eee0:	a8c37bfd 	ldp	x29, x30, [sp], #48
  601040eee4:	d65f03c0 	ret

000000601040eee8 <gic_clear_pending>:

static void
gic_clear_pending(uint32_t intid)
{
  601040eee8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  601040eeec:	910003fd 	mov	x29, sp
  601040eef0:	b9001fe0 	str	w0, [sp, #28]
    uint32_t ic = gicd_read(D_ICPENDR(intid / 32));
  601040eef4:	b9401fe0 	ldr	w0, [sp, #28]
  601040eef8:	53057c00 	lsr	w0, w0, #5
  601040eefc:	11028000 	add	w0, w0, #0xa0
  601040ef00:	531e7400 	lsl	w0, w0, #2
  601040ef04:	97ffff21 	bl	601040eb88 <gicd_read>
  601040ef08:	b9002fe0 	str	w0, [sp, #44]
    ic |= 1 << (intid % 32);
  601040ef0c:	b9401fe0 	ldr	w0, [sp, #28]
  601040ef10:	12001000 	and	w0, w0, #0x1f
  601040ef14:	52800021 	mov	w1, #0x1                   	// #1
  601040ef18:	1ac02020 	lsl	w0, w1, w0
  601040ef1c:	2a0003e1 	mov	w1, w0
  601040ef20:	b9402fe0 	ldr	w0, [sp, #44]
  601040ef24:	2a010000 	orr	w0, w0, w1
  601040ef28:	b9002fe0 	str	w0, [sp, #44]
    gicd_write(D_ICPENDR(intid / 32), ic);
  601040ef2c:	b9401fe0 	ldr	w0, [sp, #28]
  601040ef30:	53057c00 	lsr	w0, w0, #5
  601040ef34:	11028000 	add	w0, w0, #0xa0
  601040ef38:	531e7400 	lsl	w0, w0, #2
  601040ef3c:	b9402fe1 	ldr	w1, [sp, #44]
  601040ef40:	97ffff05 	bl	601040eb54 <gicd_write>
}
  601040ef44:	d503201f 	nop
  601040ef48:	a8c37bfd 	ldp	x29, x30, [sp], #48
  601040ef4c:	d65f03c0 	ret

000000601040ef50 <gic_set_prio0>:

static void
gic_set_prio0(uint32_t intid)
{
  601040ef50:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  601040ef54:	910003fd 	mov	x29, sp
  601040ef58:	b9001fe0 	str	w0, [sp, #28]
    // set priority to 0
    uint32_t p = gicd_read(D_IPRIORITYR(intid / 4));
  601040ef5c:	b9401fe0 	ldr	w0, [sp, #28]
  601040ef60:	53027c00 	lsr	w0, w0, #2
  601040ef64:	11040000 	add	w0, w0, #0x100
  601040ef68:	531e7400 	lsl	w0, w0, #2
  601040ef6c:	97ffff07 	bl	601040eb88 <gicd_read>
  601040ef70:	b9002fe0 	str	w0, [sp, #44]
    p &= ~((uint32_t)0xff << (intid % 4 * 8)); // set prio 0
  601040ef74:	b9401fe0 	ldr	w0, [sp, #28]
  601040ef78:	12000400 	and	w0, w0, #0x3
  601040ef7c:	531d7000 	lsl	w0, w0, #3
  601040ef80:	52801fe1 	mov	w1, #0xff                  	// #255
  601040ef84:	1ac02020 	lsl	w0, w1, w0
  601040ef88:	2a2003e0 	mvn	w0, w0
  601040ef8c:	b9402fe1 	ldr	w1, [sp, #44]
  601040ef90:	0a000020 	and	w0, w1, w0
  601040ef94:	b9002fe0 	str	w0, [sp, #44]
    gicd_write(D_IPRIORITYR(intid / 4), p);
  601040ef98:	b9401fe0 	ldr	w0, [sp, #28]
  601040ef9c:	53027c00 	lsr	w0, w0, #2
  601040efa0:	11040000 	add	w0, w0, #0x100
  601040efa4:	531e7400 	lsl	w0, w0, #2
  601040efa8:	b9402fe1 	ldr	w1, [sp, #44]
  601040efac:	97fffeea 	bl	601040eb54 <gicd_write>
}
  601040efb0:	d503201f 	nop
  601040efb4:	a8c37bfd 	ldp	x29, x30, [sp], #48
  601040efb8:	d65f03c0 	ret

000000601040efbc <gic_set_target>:

static void gic_set_target(uint32_t intid, uint32_t cpuid)
{
  601040efbc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  601040efc0:	910003fd 	mov	x29, sp
  601040efc4:	b9001fe0 	str	w0, [sp, #28]
  601040efc8:	b9001be1 	str	w1, [sp, #24]
    uint32_t itargetsr = gicd_read(D_ITARGETSR(intid / 4));
  601040efcc:	b9401fe0 	ldr	w0, [sp, #28]
  601040efd0:	53027c00 	lsr	w0, w0, #2
  601040efd4:	11080000 	add	w0, w0, #0x200
  601040efd8:	531e7400 	lsl	w0, w0, #2
  601040efdc:	97fffeeb 	bl	601040eb88 <gicd_read>
  601040efe0:	b9002fe0 	str	w0, [sp, #44]
    itargetsr &= ~((uint32_t)0xff << (intid % 4 * 8));
  601040efe4:	b9401fe0 	ldr	w0, [sp, #28]
  601040efe8:	12000400 	and	w0, w0, #0x3
  601040efec:	531d7000 	lsl	w0, w0, #3
  601040eff0:	52801fe1 	mov	w1, #0xff                  	// #255
  601040eff4:	1ac02020 	lsl	w0, w1, w0
  601040eff8:	2a2003e0 	mvn	w0, w0
  601040effc:	b9402fe1 	ldr	w1, [sp, #44]
  601040f000:	0a000020 	and	w0, w1, w0
  601040f004:	b9002fe0 	str	w0, [sp, #44]
    gicd_write(D_ITARGETSR(intid / 4), itargetsr | ((uint32_t)(1 << cpuid) << (intid % 4 * 8)));
  601040f008:	b9401fe0 	ldr	w0, [sp, #28]
  601040f00c:	53027c00 	lsr	w0, w0, #2
  601040f010:	11080000 	add	w0, w0, #0x200
  601040f014:	531e7402 	lsl	w2, w0, #2
  601040f018:	b9401be0 	ldr	w0, [sp, #24]
  601040f01c:	52800021 	mov	w1, #0x1                   	// #1
  601040f020:	1ac02020 	lsl	w0, w1, w0
  601040f024:	2a0003e1 	mov	w1, w0
  601040f028:	b9401fe0 	ldr	w0, [sp, #28]
  601040f02c:	12000400 	and	w0, w0, #0x3
  601040f030:	531d7000 	lsl	w0, w0, #3
  601040f034:	1ac02021 	lsl	w1, w1, w0
  601040f038:	b9402fe0 	ldr	w0, [sp, #44]
  601040f03c:	2a000020 	orr	w0, w1, w0
  601040f040:	2a0003e1 	mov	w1, w0
  601040f044:	2a0203e0 	mov	w0, w2
  601040f048:	97fffec3 	bl	601040eb54 <gicd_write>
}
  601040f04c:	d503201f 	nop
  601040f050:	a8c37bfd 	ldp	x29, x30, [sp], #48
  601040f054:	d65f03c0 	ret

000000601040f058 <gicr_enable_int>:

static void
gicr_enable_int(uint32_t cpuid, uint32_t intid)
{
  601040f058:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  601040f05c:	910003fd 	mov	x29, sp
  601040f060:	b9001fe0 	str	w0, [sp, #28]
  601040f064:	b9001be1 	str	w1, [sp, #24]
    uint32_t is = gicr_read(cpuid, R_ISENABLER0);
  601040f068:	52802001 	mov	w1, #0x100                 	// #256
  601040f06c:	72a00021 	movk	w1, #0x1, lsl #16
  601040f070:	b9401fe0 	ldr	w0, [sp, #28]
  601040f074:	97fffee0 	bl	601040ebf4 <gicr_read>
  601040f078:	b9002fe0 	str	w0, [sp, #44]
    is |= 1 << (intid % 32);
  601040f07c:	b9401be0 	ldr	w0, [sp, #24]
  601040f080:	12001000 	and	w0, w0, #0x1f
  601040f084:	52800021 	mov	w1, #0x1                   	// #1
  601040f088:	1ac02020 	lsl	w0, w1, w0
  601040f08c:	2a0003e1 	mov	w1, w0
  601040f090:	b9402fe0 	ldr	w0, [sp, #44]
  601040f094:	2a010000 	orr	w0, w0, w1
  601040f098:	b9002fe0 	str	w0, [sp, #44]
    gicr_write(cpuid, R_ISENABLER0, is);
  601040f09c:	b9402fe2 	ldr	w2, [sp, #44]
  601040f0a0:	52802001 	mov	w1, #0x100                 	// #256
  601040f0a4:	72a00021 	movk	w1, #0x1, lsl #16
  601040f0a8:	b9401fe0 	ldr	w0, [sp, #28]
  601040f0ac:	97fffec1 	bl	601040ebb0 <gicr_write>
}
  601040f0b0:	d503201f 	nop
  601040f0b4:	a8c37bfd 	ldp	x29, x30, [sp], #48
  601040f0b8:	d65f03c0 	ret

000000601040f0bc <gicr_clear_pending>:

static void
gicr_clear_pending(uint32_t cpuid, uint32_t intid)
{
  601040f0bc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  601040f0c0:	910003fd 	mov	x29, sp
  601040f0c4:	b9001fe0 	str	w0, [sp, #28]
  601040f0c8:	b9001be1 	str	w1, [sp, #24]
    uint32_t ic = gicr_read(cpuid, R_ICPENDR0);
  601040f0cc:	52805001 	mov	w1, #0x280                 	// #640
  601040f0d0:	72a00021 	movk	w1, #0x1, lsl #16
  601040f0d4:	b9401fe0 	ldr	w0, [sp, #28]
  601040f0d8:	97fffec7 	bl	601040ebf4 <gicr_read>
  601040f0dc:	b9002fe0 	str	w0, [sp, #44]
    ic |= 1 << (intid % 32);
  601040f0e0:	b9401be0 	ldr	w0, [sp, #24]
  601040f0e4:	12001000 	and	w0, w0, #0x1f
  601040f0e8:	52800021 	mov	w1, #0x1                   	// #1
  601040f0ec:	1ac02020 	lsl	w0, w1, w0
  601040f0f0:	2a0003e1 	mov	w1, w0
  601040f0f4:	b9402fe0 	ldr	w0, [sp, #44]
  601040f0f8:	2a010000 	orr	w0, w0, w1
  601040f0fc:	b9002fe0 	str	w0, [sp, #44]
    gicr_write(cpuid, R_ICPENDR0, ic);
  601040f100:	b9402fe2 	ldr	w2, [sp, #44]
  601040f104:	52805001 	mov	w1, #0x280                 	// #640
  601040f108:	72a00021 	movk	w1, #0x1, lsl #16
  601040f10c:	b9401fe0 	ldr	w0, [sp, #28]
  601040f110:	97fffea8 	bl	601040ebb0 <gicr_write>
}
  601040f114:	d503201f 	nop
  601040f118:	a8c37bfd 	ldp	x29, x30, [sp], #48
  601040f11c:	d65f03c0 	ret

000000601040f120 <gicr_set_prio0>:

static void
gicr_set_prio0(uint32_t cpuid, uint32_t intid)
{
  601040f120:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  601040f124:	910003fd 	mov	x29, sp
  601040f128:	b9001fe0 	str	w0, [sp, #28]
  601040f12c:	b9001be1 	str	w1, [sp, #24]
    uint32_t p = gicr_read(cpuid, R_IPRIORITYR(intid / 4));
  601040f130:	b9401be0 	ldr	w0, [sp, #24]
  601040f134:	121e7401 	and	w1, w0, #0xfffffffc
  601040f138:	52808000 	mov	w0, #0x400                 	// #1024
  601040f13c:	72a00020 	movk	w0, #0x1, lsl #16
  601040f140:	0b000020 	add	w0, w1, w0
  601040f144:	2a0003e1 	mov	w1, w0
  601040f148:	b9401fe0 	ldr	w0, [sp, #28]
  601040f14c:	97fffeaa 	bl	601040ebf4 <gicr_read>
  601040f150:	b9002fe0 	str	w0, [sp, #44]
    p &= ~((uint32_t)0xff << (intid % 4 * 8)); // set prio 0
  601040f154:	b9401be0 	ldr	w0, [sp, #24]
  601040f158:	12000400 	and	w0, w0, #0x3
  601040f15c:	531d7000 	lsl	w0, w0, #3
  601040f160:	52801fe1 	mov	w1, #0xff                  	// #255
  601040f164:	1ac02020 	lsl	w0, w1, w0
  601040f168:	2a2003e0 	mvn	w0, w0
  601040f16c:	b9402fe1 	ldr	w1, [sp, #44]
  601040f170:	0a000020 	and	w0, w1, w0
  601040f174:	b9002fe0 	str	w0, [sp, #44]
    gicr_write(cpuid, R_IPRIORITYR(intid / 4), p);
  601040f178:	b9401be0 	ldr	w0, [sp, #24]
  601040f17c:	121e7401 	and	w1, w0, #0xfffffffc
  601040f180:	52808000 	mov	w0, #0x400                 	// #1024
  601040f184:	72a00020 	movk	w0, #0x1, lsl #16
  601040f188:	0b000020 	add	w0, w1, w0
  601040f18c:	b9402fe2 	ldr	w2, [sp, #44]
  601040f190:	2a0003e1 	mov	w1, w0
  601040f194:	b9401fe0 	ldr	w0, [sp, #28]
  601040f198:	97fffe86 	bl	601040ebb0 <gicr_write>
}
  601040f19c:	d503201f 	nop
  601040f1a0:	a8c37bfd 	ldp	x29, x30, [sp], #48
  601040f1a4:	d65f03c0 	ret

000000601040f1a8 <gic_setup_ppi>:

void gic_setup_ppi(uint32_t cpuid, uint32_t intid)
{
  601040f1a8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  601040f1ac:	910003fd 	mov	x29, sp
  601040f1b0:	b9001fe0 	str	w0, [sp, #28]
  601040f1b4:	b9001be1 	str	w1, [sp, #24]
    gicr_set_prio0(cpuid, intid);
  601040f1b8:	b9401be1 	ldr	w1, [sp, #24]
  601040f1bc:	b9401fe0 	ldr	w0, [sp, #28]
  601040f1c0:	97ffffd8 	bl	601040f120 <gicr_set_prio0>
    gicr_clear_pending(cpuid, intid);
  601040f1c4:	b9401be1 	ldr	w1, [sp, #24]
  601040f1c8:	b9401fe0 	ldr	w0, [sp, #28]
  601040f1cc:	97ffffbc 	bl	601040f0bc <gicr_clear_pending>
    gicr_enable_int(cpuid, intid);
  601040f1d0:	b9401be1 	ldr	w1, [sp, #24]
  601040f1d4:	b9401fe0 	ldr	w0, [sp, #28]
  601040f1d8:	97ffffa0 	bl	601040f058 <gicr_enable_int>
}
  601040f1dc:	d503201f 	nop
  601040f1e0:	a8c27bfd 	ldp	x29, x30, [sp], #32
  601040f1e4:	d65f03c0 	ret

000000601040f1e8 <gic_setup_spi>:

void gic_setup_spi(uint32_t cpuid, uint32_t intid)
{
  601040f1e8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  601040f1ec:	910003fd 	mov	x29, sp
  601040f1f0:	b9001fe0 	str	w0, [sp, #28]
  601040f1f4:	b9001be1 	str	w1, [sp, #24]
    gic_set_prio0(intid);
  601040f1f8:	b9401be0 	ldr	w0, [sp, #24]
  601040f1fc:	97ffff55 	bl	601040ef50 <gic_set_prio0>
    gic_set_target(intid, cpuid);
  601040f200:	b9401fe1 	ldr	w1, [sp, #28]
  601040f204:	b9401be0 	ldr	w0, [sp, #24]
  601040f208:	97ffff6d 	bl	601040efbc <gic_set_target>
    gic_clear_pending(intid);
  601040f20c:	b9401be0 	ldr	w0, [sp, #24]
  601040f210:	97ffff36 	bl	601040eee8 <gic_clear_pending>
    gic_enable_int(intid);
  601040f214:	b9401be0 	ldr	w0, [sp, #24]
  601040f218:	97ffff08 	bl	601040ee38 <gic_enable_int>
}
  601040f21c:	d503201f 	nop
  601040f220:	a8c27bfd 	ldp	x29, x30, [sp], #32
  601040f224:	d65f03c0 	ret

000000601040f228 <gic_iar_irq>:

// irq from iar
int gic_iar_irq(uint32_t iar)
{
  601040f228:	d10043ff 	sub	sp, sp, #0x10
  601040f22c:	b9000fe0 	str	w0, [sp, #12]
    return iar & 0x3ff;
  601040f230:	b9400fe0 	ldr	w0, [sp, #12]
  601040f234:	12002400 	and	w0, w0, #0x3ff
}
  601040f238:	910043ff 	add	sp, sp, #0x10
  601040f23c:	d65f03c0 	ret

000000601040f240 <gic_iar>:

// interrupt acknowledge register:
// ask GIC what interrupt we should serve.
uint32_t gic_iar()
{
  601040f240:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601040f244:	910003fd 	mov	x29, sp
    return gic_read_irq_ack();
  601040f248:	97fffe29 	bl	601040eaec <gic_read_irq_ack>
}
  601040f24c:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601040f250:	d65f03c0 	ret

000000601040f254 <gic_eoi>:

// tell GIC we've served this IRQ.
void gic_eoi(uint32_t iar)
{
  601040f254:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  601040f258:	910003fd 	mov	x29, sp
  601040f25c:	b9001fe0 	str	w0, [sp, #28]
    gic_write_end_of_irq(iar);
  601040f260:	b9401fe0 	ldr	w0, [sp, #28]
  601040f264:	97fffe28 	bl	601040eb04 <gic_write_end_of_irq>
}
  601040f268:	d503201f 	nop
  601040f26c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  601040f270:	d65f03c0 	ret

000000601040f274 <w_vbar_el1>:
 * @author AIIT XUOS Lab
 * @date 2024.05.09
 */

static inline void w_vbar_el1(uint64_t x)
{
  601040f274:	d10043ff 	sub	sp, sp, #0x10
  601040f278:	f90007e0 	str	x0, [sp, #8]
    __asm__ volatile("msr vbar_el1, %0" : : "r"(x));
  601040f27c:	f94007e0 	ldr	x0, [sp, #8]
  601040f280:	d518c000 	msr	vbar_el1, x0
}
  601040f284:	d503201f 	nop
  601040f288:	910043ff 	add	sp, sp, #0x10
  601040f28c:	d65f03c0 	ret

000000601040f290 <intr_on>:
}

// enable interrupts(irq)
static inline void intr_on()
{
    __asm__ volatile("msr daifclr, #0xf" ::: "memory");
  601040f290:	d5034fff 	msr	daifclr, #0xf
}
  601040f294:	d503201f 	nop
  601040f298:	d65f03c0 	ret

000000601040f29c <intr_off>:

// disable interrupts(irq)
static inline void intr_off()
{
    __asm__ volatile("msr daifset, #0xf" ::: "memory");
  601040f29c:	d5034fdf 	msr	daifset, #0xf
  601040f2a0:	d503201f 	nop
  601040f2a4:	d65f03c0 	ret

000000601040f2a8 <panic>:
#include "multicores.h"

static struct XiziTrapDriver xizi_trap_driver;

void panic(char* s)
{
  601040f2a8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  601040f2ac:	910003fd 	mov	x29, sp
  601040f2b0:	f9000fe0 	str	x0, [sp, #24]
    KPrintf("panic: %s\n", s);
  601040f2b4:	f9400fe1 	ldr	x1, [sp, #24]
  601040f2b8:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f2bc:	91238000 	add	x0, x0, #0x8e0
  601040f2c0:	940013ae 	bl	6010414178 <printf_>
    for (;;)
  601040f2c4:	14000000 	b	601040f2c4 <panic+0x1c>

000000601040f2c8 <_sys_irq_init>:
        ;
}

extern void alltraps();
static void _sys_irq_init(int cpu_id)
{
  601040f2c8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  601040f2cc:	910003fd 	mov	x29, sp
  601040f2d0:	b9001fe0 	str	w0, [sp, #28]
    // primary core init intr
    xizi_trap_driver.switch_hw_irqtbl((uintptr_t*)alltraps);
  601040f2d4:	b00000a0 	adrp	x0, 6010424000 <impure_data+0x210>
  601040f2d8:	9116c000 	add	x0, x0, #0x5b0
  601040f2dc:	f9445001 	ldr	x1, [x0, #2208]
  601040f2e0:	900089a0 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601040f2e4:	f942d000 	ldr	x0, [x0, #1440]
  601040f2e8:	d63f0020 	blr	x1

    if (cpu_id == 0) {
  601040f2ec:	b9401fe0 	ldr	w0, [sp, #28]
  601040f2f0:	7100001f 	cmp	w0, #0x0
  601040f2f4:	54000041 	b.ne	601040f2fc <_sys_irq_init+0x34>  // b.any
        gic_init();
  601040f2f8:	97fffea6 	bl	601040ed90 <gic_init>
    }
    gicv3inithart(cpu_id);
  601040f2fc:	b9401fe0 	ldr	w0, [sp, #28]
  601040f300:	97fffec4 	bl	601040ee10 <gicv3inithart>
}
  601040f304:	d503201f 	nop
  601040f308:	a8c27bfd 	ldp	x29, x30, [sp], #32
  601040f30c:	d65f03c0 	ret

000000601040f310 <_cpu_irq_enable>:

static void _cpu_irq_enable(void)
{
  601040f310:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601040f314:	910003fd 	mov	x29, sp
    intr_on();
  601040f318:	97ffffde 	bl	601040f290 <intr_on>
}
  601040f31c:	d503201f 	nop
  601040f320:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601040f324:	d65f03c0 	ret

000000601040f328 <_cpu_irq_disable>:

static void _cpu_irq_disable(void)
{
  601040f328:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601040f32c:	910003fd 	mov	x29, sp
    intr_off();
  601040f330:	97ffffdb 	bl	601040f29c <intr_off>
}
  601040f334:	d503201f 	nop
  601040f338:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601040f33c:	d65f03c0 	ret

000000601040f340 <_single_irq_enable>:

static void _single_irq_enable(int irq, int cpu, int prio)
{
  601040f340:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  601040f344:	910003fd 	mov	x29, sp
  601040f348:	b9001fe0 	str	w0, [sp, #28]
  601040f34c:	b9001be1 	str	w1, [sp, #24]
  601040f350:	b90017e2 	str	w2, [sp, #20]
    gic_setup_ppi((uint32_t)cpu, (uint32_t)irq);
  601040f354:	b9401be0 	ldr	w0, [sp, #24]
  601040f358:	b9401fe1 	ldr	w1, [sp, #28]
  601040f35c:	97ffff93 	bl	601040f1a8 <gic_setup_ppi>
}
  601040f360:	d503201f 	nop
  601040f364:	a8c27bfd 	ldp	x29, x30, [sp], #32
  601040f368:	d65f03c0 	ret

000000601040f36c <_single_irq_disable>:

static void _single_irq_disable(int irq, int cpu)
{
  601040f36c:	d10043ff 	sub	sp, sp, #0x10
  601040f370:	b9000fe0 	str	w0, [sp, #12]
  601040f374:	b9000be1 	str	w1, [sp, #8]
    return;
  601040f378:	d503201f 	nop
}
  601040f37c:	910043ff 	add	sp, sp, #0x10
  601040f380:	d65f03c0 	ret

000000601040f384 <_switch_hw_irqtbl>:

static inline uintptr_t* _switch_hw_irqtbl(uintptr_t* new_tbl_base)
{
  601040f384:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  601040f388:	910003fd 	mov	x29, sp
  601040f38c:	f9000fe0 	str	x0, [sp, #24]
    w_vbar_el1((uint64_t)new_tbl_base);
  601040f390:	f9400fe0 	ldr	x0, [sp, #24]
  601040f394:	97ffffb8 	bl	601040f274 <w_vbar_el1>

    return NULL;
  601040f398:	d2800000 	mov	x0, #0x0                   	// #0
}
  601040f39c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  601040f3a0:	d65f03c0 	ret

000000601040f3a4 <_bind_irq_handler>:

static void _bind_irq_handler(int irq, irq_handler_t handler)
{
  601040f3a4:	d10043ff 	sub	sp, sp, #0x10
  601040f3a8:	b9000fe0 	str	w0, [sp, #12]
  601040f3ac:	f90003e1 	str	x1, [sp]
    xizi_trap_driver.sw_irqtbl[irq].handler = handler;
  601040f3b0:	b00000a0 	adrp	x0, 6010424000 <impure_data+0x210>
  601040f3b4:	9116c000 	add	x0, x0, #0x5b0
  601040f3b8:	b9800fe1 	ldrsw	x1, [sp, #12]
  601040f3bc:	f94003e2 	ldr	x2, [sp]
  601040f3c0:	f8217802 	str	x2, [x0, x1, lsl #3]
}
  601040f3c4:	d503201f 	nop
  601040f3c8:	910043ff 	add	sp, sp, #0x10
  601040f3cc:	d65f03c0 	ret

000000601040f3d0 <_hw_before_irq>:

static uint32_t _hw_before_irq()
{
  601040f3d0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  601040f3d4:	910003fd 	mov	x29, sp

    uint32_t iar = gic_read_irq_ack();
  601040f3d8:	97fffdc5 	bl	601040eaec <gic_read_irq_ack>
  601040f3dc:	b9001fe0 	str	w0, [sp, #28]
    return iar;
  601040f3e0:	b9401fe0 	ldr	w0, [sp, #28]
}
  601040f3e4:	a8c27bfd 	ldp	x29, x30, [sp], #32
  601040f3e8:	d65f03c0 	ret

000000601040f3ec <_hw_cur_int_num>:

static uint32_t _hw_cur_int_num(uint32_t int_info)
{
  601040f3ec:	d10043ff 	sub	sp, sp, #0x10
  601040f3f0:	b9000fe0 	str	w0, [sp, #12]
    return int_info & 0x3FF;
  601040f3f4:	b9400fe0 	ldr	w0, [sp, #12]
  601040f3f8:	12002400 	and	w0, w0, #0x3ff
}
  601040f3fc:	910043ff 	add	sp, sp, #0x10
  601040f400:	d65f03c0 	ret

000000601040f404 <_hw_after_irq>:

static void _hw_after_irq(uint32_t int_info)
{
  601040f404:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  601040f408:	910003fd 	mov	x29, sp
  601040f40c:	b9001fe0 	str	w0, [sp, #28]
    gic_write_end_of_irq(int_info);
  601040f410:	b9401fe0 	ldr	w0, [sp, #28]
  601040f414:	97fffdbc 	bl	601040eb04 <gic_write_end_of_irq>
}
  601040f418:	d503201f 	nop
  601040f41c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  601040f420:	d65f03c0 	ret

000000601040f424 <_cur_cpu_id>:

int _cur_cpu_id()
{
  601040f424:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601040f428:	910003fd 	mov	x29, sp
    return cpu_get_current();
  601040f42c:	97fffc9b 	bl	601040e698 <cpu_get_current>
}
  601040f430:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601040f434:	d65f03c0 	ret

000000601040f438 <hardkernel_intr_init>:
    .hw_cur_int_num = _hw_cur_int_num,
    .hw_after_irq = _hw_after_irq,
};

struct XiziTrapDriver* hardkernel_intr_init(struct TraceTag* hardkernel_tag)
{
  601040f438:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  601040f43c:	910003fd 	mov	x29, sp
  601040f440:	f9000fe0 	str	x0, [sp, #24]
    xizi_trap_driver.sys_irq_init(0);
  601040f444:	b00000a0 	adrp	x0, 6010424000 <impure_data+0x210>
  601040f448:	9116c000 	add	x0, x0, #0x5b0
  601040f44c:	f9443801 	ldr	x1, [x0, #2160]
  601040f450:	52800000 	mov	w0, #0x0                   	// #0
  601040f454:	d63f0020 	blr	x1
    xizi_trap_driver.cpu_irq_disable();
  601040f458:	b00000a0 	adrp	x0, 6010424000 <impure_data+0x210>
  601040f45c:	9116c000 	add	x0, x0, #0x5b0
  601040f460:	f9444400 	ldr	x0, [x0, #2184]
  601040f464:	d63f0000 	blr	x0
    return &xizi_trap_driver;
  601040f468:	b00000a0 	adrp	x0, 6010424000 <impure_data+0x210>
  601040f46c:	9116c000 	add	x0, x0, #0x5b0
  601040f470:	a8c27bfd 	ldp	x29, x30, [sp], #32
  601040f474:	d65f03c0 	ret

000000601040f478 <r_esr_el1>:
{
  601040f478:	d10043ff 	sub	sp, sp, #0x10
    __asm__ volatile("mrs %0, esr_el1" : "=r"(x));
  601040f47c:	d5385200 	mrs	x0, esr_el1
  601040f480:	f90007e0 	str	x0, [sp, #8]
    return x;
  601040f484:	f94007e0 	ldr	x0, [sp, #8]
}
  601040f488:	910043ff 	add	sp, sp, #0x10
  601040f48c:	d65f03c0 	ret

000000601040f490 <w_esr_el1>:
{
  601040f490:	d10043ff 	sub	sp, sp, #0x10
  601040f494:	f90007e0 	str	x0, [sp, #8]
    __asm__ volatile("msr esr_el1, %0" : : "r"(x));
  601040f498:	f94007e0 	ldr	x0, [sp, #8]
  601040f49c:	d5185200 	msr	esr_el1, x0
}
  601040f4a0:	d503201f 	nop
  601040f4a4:	910043ff 	add	sp, sp, #0x10
  601040f4a8:	d65f03c0 	ret

000000601040f4ac <r_elr_el1>:
{
  601040f4ac:	d10043ff 	sub	sp, sp, #0x10
    __asm__ volatile("mrs %0, elr_el1" : "=r"(x));
  601040f4b0:	d5384020 	mrs	x0, elr_el1
  601040f4b4:	f90007e0 	str	x0, [sp, #8]
    return x;
  601040f4b8:	f94007e0 	ldr	x0, [sp, #8]
}
  601040f4bc:	910043ff 	add	sp, sp, #0x10
  601040f4c0:	d65f03c0 	ret

000000601040f4c4 <r_far_el1>:
{
  601040f4c4:	d10043ff 	sub	sp, sp, #0x10
    __asm__ volatile("mrs %0, far_el1" : "=r"(x));
  601040f4c8:	d5386000 	mrs	x0, far_el1
  601040f4cc:	f90007e0 	str	x0, [sp, #8]
    return x;
  601040f4d0:	f94007e0 	ldr	x0, [sp, #8]
}
  601040f4d4:	910043ff 	add	sp, sp, #0x10
  601040f4d8:	d65f03c0 	ret

000000601040f4dc <cur_cpuid>:
};

struct XiziTrapDriver* hardkernel_intr_init(struct TraceTag* hardkernel_tag);

static inline int cur_cpuid(void)
{
  601040f4dc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601040f4e0:	910003fd 	mov	x29, sp
    return cpu_get_current();
  601040f4e4:	97fffc6d 	bl	601040e698 <cpu_get_current>
}
  601040f4e8:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601040f4ec:	d65f03c0 	ret

000000601040f4f0 <cur_cpu>:
};

extern struct CPU global_cpus[NR_CPU];

static inline struct CPU* cur_cpu(void)
{
  601040f4f0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601040f4f4:	910003fd 	mov	x29, sp
    return &global_cpus[cur_cpuid()];
  601040f4f8:	97fffff9 	bl	601040f4dc <cur_cpuid>
  601040f4fc:	93407c01 	sxtw	x1, w0
  601040f500:	d2800300 	mov	x0, #0x18                  	// #24
  601040f504:	9b007c21 	mul	x1, x1, x0
  601040f508:	900089a0 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601040f50c:	f942f400 	ldr	x0, [x0, #1512]
  601040f510:	8b000020 	add	x0, x1, x0
}
  601040f514:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601040f518:	d65f03c0 	ret

000000601040f51c <kernel_abort_handler>:

extern void dabort_handler(struct trapframe* r);
extern void iabort_handler(struct trapframe* r);

void kernel_abort_handler(struct trapframe* tf)
{
  601040f51c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  601040f520:	910003fd 	mov	x29, sp
  601040f524:	f9000bf3 	str	x19, [sp, #16]
  601040f528:	f90017e0 	str	x0, [sp, #40]
    uint64_t esr = r_esr_el1();
  601040f52c:	97ffffd3 	bl	601040f478 <r_esr_el1>
  601040f530:	f90027e0 	str	x0, [sp, #72]
    switch ((esr >> 0x1A) & 0x3F) {
  601040f534:	f94027e0 	ldr	x0, [sp, #72]
  601040f538:	d35afc00 	lsr	x0, x0, #26
  601040f53c:	92401400 	and	x0, x0, #0x3f
  601040f540:	f100841f 	cmp	x0, #0x21
  601040f544:	54000088 	b.hi	601040f554 <kernel_abort_handler+0x38>  // b.pmore
  601040f548:	f100801f 	cmp	x0, #0x20
  601040f54c:	54000102 	b.cs	601040f56c <kernel_abort_handler+0x50>  // b.hs, b.nlast
  601040f550:	1400000a 	b	601040f578 <kernel_abort_handler+0x5c>
  601040f554:	d1009000 	sub	x0, x0, #0x24
  601040f558:	f100041f 	cmp	x0, #0x1
  601040f55c:	540000e8 	b.hi	601040f578 <kernel_abort_handler+0x5c>  // b.pmore
    case 0b100100:
    case 0b100101:
        dabort_handler(tf);
  601040f560:	f94017e0 	ldr	x0, [sp, #40]
  601040f564:	94002b83 	bl	601041a370 <dabort_handler>
        break;
  601040f568:	14000034 	b	601040f638 <kernel_abort_handler+0x11c>
    case 0b100000:
    case 0b100001:
        iabort_handler(tf);
  601040f56c:	f94017e0 	ldr	x0, [sp, #40]
  601040f570:	94002bf1 	bl	601041a534 <iabort_handler>
        break;
  601040f574:	14000031 	b	601040f638 <kernel_abort_handler+0x11c>
    default: {
        uint64_t ec = (esr >> 26) & 0x3f;
  601040f578:	f94027e0 	ldr	x0, [sp, #72]
  601040f57c:	d35afc00 	lsr	x0, x0, #26
  601040f580:	92401400 	and	x0, x0, #0x3f
  601040f584:	f90023e0 	str	x0, [sp, #64]
        uint64_t iss = esr & 0x1ffffff;
  601040f588:	f94027e0 	ldr	x0, [sp, #72]
  601040f58c:	92406000 	and	x0, x0, #0x1ffffff
  601040f590:	f9001fe0 	str	x0, [sp, #56]
        ERROR("esr:  %016lx %016lx %016lx\n", esr, ec, iss);
  601040f594:	52800762 	mov	w2, #0x3b                  	// #59
  601040f598:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f59c:	912b8001 	add	x1, x0, #0xae0
  601040f5a0:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f5a4:	9123c000 	add	x0, x0, #0x8f0
  601040f5a8:	940012f4 	bl	6010414178 <printf_>
  601040f5ac:	f9401fe3 	ldr	x3, [sp, #56]
  601040f5b0:	f94023e2 	ldr	x2, [sp, #64]
  601040f5b4:	f94027e1 	ldr	x1, [sp, #72]
  601040f5b8:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f5bc:	91240000 	add	x0, x0, #0x900
  601040f5c0:	940012ee 	bl	6010414178 <printf_>
        ERROR("elr = %016lx far = %016lx\n", r_elr_el1(), r_far_el1());
  601040f5c4:	52800782 	mov	w2, #0x3c                  	// #60
  601040f5c8:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f5cc:	912b8001 	add	x1, x0, #0xae0
  601040f5d0:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f5d4:	9123c000 	add	x0, x0, #0x8f0
  601040f5d8:	940012e8 	bl	6010414178 <printf_>
  601040f5dc:	97ffffb4 	bl	601040f4ac <r_elr_el1>
  601040f5e0:	aa0003f3 	mov	x19, x0
  601040f5e4:	97ffffb8 	bl	601040f4c4 <r_far_el1>
  601040f5e8:	aa0003e2 	mov	x2, x0
  601040f5ec:	aa1303e1 	mov	x1, x19
  601040f5f0:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f5f4:	91248000 	add	x0, x0, #0x920
  601040f5f8:	940012e0 	bl	6010414178 <printf_>
        ERROR("Current Task: %s.\n", cur_cpu()->task->name);
  601040f5fc:	528007a2 	mov	w2, #0x3d                  	// #61
  601040f600:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f604:	912b8001 	add	x1, x0, #0xae0
  601040f608:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f60c:	9123c000 	add	x0, x0, #0x8f0
  601040f610:	940012da 	bl	6010414178 <printf_>
  601040f614:	97ffffb7 	bl	601040f4f0 <cur_cpu>
  601040f618:	f9400400 	ldr	x0, [x0, #8]
  601040f61c:	aa0003e1 	mov	x1, x0
  601040f620:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f624:	91250000 	add	x0, x0, #0x940
  601040f628:	940012d4 	bl	6010414178 <printf_>
        panic("Unimplemented Error Occured.\n");
  601040f62c:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f630:	91256000 	add	x0, x0, #0x958
  601040f634:	97ffff1d 	bl	601040f2a8 <panic>
    }
    }
    panic("Return from abort handler.\n");
  601040f638:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f63c:	9125e000 	add	x0, x0, #0x978
  601040f640:	97ffff1a 	bl	601040f2a8 <panic>
}
  601040f644:	d503201f 	nop
  601040f648:	f9400bf3 	ldr	x19, [sp, #16]
  601040f64c:	a8c57bfd 	ldp	x29, x30, [sp], #80
  601040f650:	d65f03c0 	ret

000000601040f654 <kernel_intr_handler>:

void kernel_intr_handler(struct trapframe* tf)
{
  601040f654:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  601040f658:	910003fd 	mov	x29, sp
  601040f65c:	f9000fe0 	str	x0, [sp, #24]
    panic("Intr at kernel mode should never happen by design.\n");
  601040f660:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f664:	91266000 	add	x0, x0, #0x998
  601040f668:	97ffff10 	bl	601040f2a8 <panic>
}
  601040f66c:	d503201f 	nop
  601040f670:	a8c27bfd 	ldp	x29, x30, [sp], #32
  601040f674:	d65f03c0 	ret

000000601040f678 <syscall_arch_handler>:

extern void context_switch(struct context**, struct context*);
void syscall_arch_handler(struct trapframe* tf)
{
  601040f678:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  601040f67c:	910003fd 	mov	x29, sp
  601040f680:	f9000bf3 	str	x19, [sp, #16]
  601040f684:	f90017e0 	str	x0, [sp, #40]

    uint64_t esr = r_esr_el1();
  601040f688:	97ffff7c 	bl	601040f478 <r_esr_el1>
  601040f68c:	f9002fe0 	str	x0, [sp, #88]
    uint64_t ec = (esr >> 0x1A) & 0x3F;
  601040f690:	f9402fe0 	ldr	x0, [sp, #88]
  601040f694:	d35afc00 	lsr	x0, x0, #26
  601040f698:	92401400 	and	x0, x0, #0x3f
  601040f69c:	f9002be0 	str	x0, [sp, #80]
    switch (ec) {
  601040f6a0:	f9402be0 	ldr	x0, [sp, #80]
  601040f6a4:	f100941f 	cmp	x0, #0x25
  601040f6a8:	54000308 	b.hi	601040f708 <syscall_arch_handler+0x90>  // b.pmore
  601040f6ac:	f9402be0 	ldr	x0, [sp, #80]
  601040f6b0:	f100901f 	cmp	x0, #0x24
  601040f6b4:	540001e2 	b.cs	601040f6f0 <syscall_arch_handler+0x78>  // b.hs, b.nlast
  601040f6b8:	f9402be0 	ldr	x0, [sp, #80]
  601040f6bc:	f100541f 	cmp	x0, #0x15
  601040f6c0:	54000120 	b.eq	601040f6e4 <syscall_arch_handler+0x6c>  // b.none
  601040f6c4:	f9402be0 	ldr	x0, [sp, #80]
  601040f6c8:	f100541f 	cmp	x0, #0x15
  601040f6cc:	540001e3 	b.cc	601040f708 <syscall_arch_handler+0x90>  // b.lo, b.ul, b.last
  601040f6d0:	f9402be0 	ldr	x0, [sp, #80]
  601040f6d4:	d1008000 	sub	x0, x0, #0x20
  601040f6d8:	f100041f 	cmp	x0, #0x1
  601040f6dc:	54000168 	b.hi	601040f708 <syscall_arch_handler+0x90>  // b.pmore
  601040f6e0:	14000007 	b	601040f6fc <syscall_arch_handler+0x84>
    case 0B010101:
        software_irq_dispatch(tf);
  601040f6e4:	f94017e0 	ldr	x0, [sp, #40]
  601040f6e8:	94002a99 	bl	601041a14c <software_irq_dispatch>
        break;
  601040f6ec:	1400008a 	b	601040f914 <syscall_arch_handler+0x29c>
    case 0b100100:
    case 0b100101:
        dabort_handler(tf);
  601040f6f0:	f94017e0 	ldr	x0, [sp, #40]
  601040f6f4:	94002b1f 	bl	601041a370 <dabort_handler>
        break;
  601040f6f8:	14000087 	b	601040f914 <syscall_arch_handler+0x29c>
    case 0b100000:
    case 0b100001:
        iabort_handler(tf);
  601040f6fc:	f94017e0 	ldr	x0, [sp, #40]
  601040f700:	94002b8d 	bl	601041a534 <iabort_handler>
        break;
  601040f704:	14000084 	b	601040f914 <syscall_arch_handler+0x29c>
    default: {
        ERROR("USYSCALL: unexpected\n");
  601040f708:	52800b82 	mov	w2, #0x5c                  	// #92
  601040f70c:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f710:	912be001 	add	x1, x0, #0xaf8
  601040f714:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f718:	9123c000 	add	x0, x0, #0x8f0
  601040f71c:	94001297 	bl	6010414178 <printf_>
  601040f720:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f724:	91274000 	add	x0, x0, #0x9d0
  601040f728:	94001294 	bl	6010414178 <printf_>
        ERROR("          esr: %016lx\n", esr);
  601040f72c:	52800ba2 	mov	w2, #0x5d                  	// #93
  601040f730:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f734:	912be001 	add	x1, x0, #0xaf8
  601040f738:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f73c:	9123c000 	add	x0, x0, #0x8f0
  601040f740:	9400128e 	bl	6010414178 <printf_>
  601040f744:	f9402fe1 	ldr	x1, [sp, #88]
  601040f748:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f74c:	9127a000 	add	x0, x0, #0x9e8
  601040f750:	9400128a 	bl	6010414178 <printf_>
        ERROR("          elr = %016lx far = %016lx\n", r_elr_el1(), r_far_el1());
  601040f754:	52800bc2 	mov	w2, #0x5e                  	// #94
  601040f758:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f75c:	912be001 	add	x1, x0, #0xaf8
  601040f760:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f764:	9123c000 	add	x0, x0, #0x8f0
  601040f768:	94001284 	bl	6010414178 <printf_>
  601040f76c:	97ffff50 	bl	601040f4ac <r_elr_el1>
  601040f770:	aa0003f3 	mov	x19, x0
  601040f774:	97ffff54 	bl	601040f4c4 <r_far_el1>
  601040f778:	aa0003e2 	mov	x2, x0
  601040f77c:	aa1303e1 	mov	x1, x19
  601040f780:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f784:	91280000 	add	x0, x0, #0xa00
  601040f788:	9400127c 	bl	6010414178 <printf_>
        w_esr_el1(0);
  601040f78c:	d2800000 	mov	x0, #0x0                   	// #0
  601040f790:	97ffff40 	bl	601040f490 <w_esr_el1>
        extern void dump_tf(struct trapframe * tf);
        dump_tf(tf);
  601040f794:	f94017e0 	ldr	x0, [sp, #40]
  601040f798:	9400006a 	bl	601040f940 <dump_tf>

        uint32_t sctlr = 0;
  601040f79c:	b9004fff 	str	wzr, [sp, #76]
        SCTLR_R(sctlr);
  601040f7a0:	d5381000 	mrs	x0, sctlr_el1
  601040f7a4:	b9004fe0 	str	w0, [sp, #76]
        DEBUG("SCTLR: %x\n", sctlr);
  601040f7a8:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f7ac:	912be001 	add	x1, x0, #0xaf8
  601040f7b0:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f7b4:	9128a000 	add	x0, x0, #0xa28
  601040f7b8:	94001270 	bl	6010414178 <printf_>
  601040f7bc:	b9404fe1 	ldr	w1, [sp, #76]
  601040f7c0:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f7c4:	9128e000 	add	x0, x0, #0xa38
  601040f7c8:	9400126c 	bl	6010414178 <printf_>
        uint32_t spsr = 0;
  601040f7cc:	b9004bff 	str	wzr, [sp, #72]
        __asm__ volatile("mrs %0, spsr_el1" : "=r"(spsr)::"memory");
  601040f7d0:	d5384000 	mrs	x0, spsr_el1
  601040f7d4:	b9004be0 	str	w0, [sp, #72]
        DEBUG("SPSR: %x\n", spsr);
  601040f7d8:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f7dc:	912be001 	add	x1, x0, #0xaf8
  601040f7e0:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f7e4:	9128a000 	add	x0, x0, #0xa28
  601040f7e8:	94001264 	bl	6010414178 <printf_>
  601040f7ec:	b9404be1 	ldr	w1, [sp, #72]
  601040f7f0:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f7f4:	91292000 	add	x0, x0, #0xa48
  601040f7f8:	94001260 	bl	6010414178 <printf_>
        uint64_t tcr = 0;
  601040f7fc:	f90023ff 	str	xzr, [sp, #64]
        __asm__ volatile("mrs %0, tcr_el1" : "=r"(tcr)::"memory");
  601040f800:	d5382040 	mrs	x0, tcr_el1
  601040f804:	f90023e0 	str	x0, [sp, #64]
        DEBUG("TCR: %x\n", tcr);
  601040f808:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f80c:	912be001 	add	x1, x0, #0xaf8
  601040f810:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f814:	9128a000 	add	x0, x0, #0xa28
  601040f818:	94001258 	bl	6010414178 <printf_>
  601040f81c:	f94023e1 	ldr	x1, [sp, #64]
  601040f820:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f824:	91296000 	add	x0, x0, #0xa58
  601040f828:	94001254 	bl	6010414178 <printf_>
        uint64_t mair = 0;
  601040f82c:	f9001fff 	str	xzr, [sp, #56]
        __asm__ volatile("mrs %0, mair_el1" : "=r"(mair)::"memory");
  601040f830:	d538a200 	mrs	x0, mair_el1
  601040f834:	f9001fe0 	str	x0, [sp, #56]
        DEBUG("MAIR: %x\n", mair);
  601040f838:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f83c:	912be001 	add	x1, x0, #0xaf8
  601040f840:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f844:	9128a000 	add	x0, x0, #0xa28
  601040f848:	9400124c 	bl	6010414178 <printf_>
  601040f84c:	f9401fe1 	ldr	x1, [sp, #56]
  601040f850:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f854:	9129a000 	add	x0, x0, #0xa68
  601040f858:	94001248 	bl	6010414178 <printf_>

        // kill error task
        xizi_enter_kernel();
  601040f85c:	9400299d 	bl	6010419ed0 <xizi_enter_kernel>
        assert(cur_cpu()->task != NULL);
  601040f860:	97ffff24 	bl	601040f4f0 <cur_cpu>
  601040f864:	f9400400 	ldr	x0, [x0, #8]
  601040f868:	f100001f 	cmp	x0, #0x0
  601040f86c:	540001e1 	b.ne	601040f8a8 <syscall_arch_handler+0x230>  // b.any
  601040f870:	52800e42 	mov	w2, #0x72                  	// #114
  601040f874:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f878:	912be001 	add	x1, x0, #0xaf8
  601040f87c:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f880:	9123c000 	add	x0, x0, #0x8f0
  601040f884:	9400123d 	bl	6010414178 <printf_>
  601040f888:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f88c:	9129e001 	add	x1, x0, #0xa78
  601040f890:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f894:	912a4000 	add	x0, x0, #0xa90
  601040f898:	94001238 	bl	6010414178 <printf_>
  601040f89c:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f8a0:	912a8000 	add	x0, x0, #0xaa0
  601040f8a4:	97fffe81 	bl	601040f2a8 <panic>
        ERROR("Error Task: %s\n", cur_cpu()->task->name);
  601040f8a8:	52800e62 	mov	w2, #0x73                  	// #115
  601040f8ac:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f8b0:	912be001 	add	x1, x0, #0xaf8
  601040f8b4:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f8b8:	9123c000 	add	x0, x0, #0x8f0
  601040f8bc:	9400122f 	bl	6010414178 <printf_>
  601040f8c0:	97ffff0c 	bl	601040f4f0 <cur_cpu>
  601040f8c4:	f9400400 	ldr	x0, [x0, #8]
  601040f8c8:	aa0003e1 	mov	x1, x0
  601040f8cc:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f8d0:	912aa000 	add	x0, x0, #0xaa8
  601040f8d4:	94001229 	bl	6010414178 <printf_>
        sys_exit(cur_cpu()->task);
  601040f8d8:	97ffff06 	bl	601040f4f0 <cur_cpu>
  601040f8dc:	f9400400 	ldr	x0, [x0, #8]
  601040f8e0:	94003e0a 	bl	601041f108 <sys_exit>
        context_switch(&cur_cpu()->task->thread_context.context, cur_cpu()->scheduler);
  601040f8e4:	97ffff03 	bl	601040f4f0 <cur_cpu>
  601040f8e8:	f9400400 	ldr	x0, [x0, #8]
  601040f8ec:	91010013 	add	x19, x0, #0x40
  601040f8f0:	97ffff00 	bl	601040f4f0 <cur_cpu>
  601040f8f4:	f9400800 	ldr	x0, [x0, #16]
  601040f8f8:	aa0003e1 	mov	x1, x0
  601040f8fc:	aa1303e0 	mov	x0, x19
  601040f900:	97fffb6b 	bl	601040e6ac <context_switch>
        panic("dabort end should never be reashed.\n");
  601040f904:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f908:	912ae000 	add	x0, x0, #0xab8
  601040f90c:	97fffe67 	bl	601040f2a8 <panic>
    }
    }
  601040f910:	d503201f 	nop
  601040f914:	d503201f 	nop
  601040f918:	f9400bf3 	ldr	x19, [sp, #16]
  601040f91c:	a8c67bfd 	ldp	x29, x30, [sp], #96
  601040f920:	d65f03c0 	ret

000000601040f924 <w_esr_el1>:
{
  601040f924:	d10043ff 	sub	sp, sp, #0x10
  601040f928:	f90007e0 	str	x0, [sp, #8]
    __asm__ volatile("msr esr_el1, %0" : : "r"(x));
  601040f92c:	f94007e0 	ldr	x0, [sp, #8]
  601040f930:	d5185200 	msr	esr_el1, x0
}
  601040f934:	d503201f 	nop
  601040f938:	910043ff 	add	sp, sp, #0x10
  601040f93c:	d65f03c0 	ret

000000601040f940 <dump_tf>:
#include "multicores.h"
#include "task.h"
#include "trap_common.h"

void dump_tf(struct trapframe* tf)
{
  601040f940:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  601040f944:	910003fd 	mov	x29, sp
  601040f948:	f9000fe0 	str	x0, [sp, #24]
    KPrintf("   sp:   0x%016lx\n", tf->sp);
  601040f94c:	f9400fe0 	ldr	x0, [sp, #24]
  601040f950:	f9408400 	ldr	x0, [x0, #264]
  601040f954:	aa0003e1 	mov	x1, x0
  601040f958:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f95c:	912c4000 	add	x0, x0, #0xb10
  601040f960:	94001206 	bl	6010414178 <printf_>
    KPrintf("   pc:   0x%016lx\n", tf->pc);
  601040f964:	f9400fe0 	ldr	x0, [sp, #24]
  601040f968:	f9407c00 	ldr	x0, [x0, #248]
  601040f96c:	aa0003e1 	mov	x1, x0
  601040f970:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f974:	912ca000 	add	x0, x0, #0xb28
  601040f978:	94001200 	bl	6010414178 <printf_>
    KPrintf("   spsr: 0x%016lx\n", tf->spsr);
  601040f97c:	f9400fe0 	ldr	x0, [sp, #24]
  601040f980:	f9408000 	ldr	x0, [x0, #256]
  601040f984:	aa0003e1 	mov	x1, x0
  601040f988:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f98c:	912d0000 	add	x0, x0, #0xb40
  601040f990:	940011fa 	bl	6010414178 <printf_>
    KPrintf("     x0: 0x%016lx\n", tf->x0);
  601040f994:	f9400fe0 	ldr	x0, [sp, #24]
  601040f998:	f9400000 	ldr	x0, [x0]
  601040f99c:	aa0003e1 	mov	x1, x0
  601040f9a0:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f9a4:	912d6000 	add	x0, x0, #0xb58
  601040f9a8:	940011f4 	bl	6010414178 <printf_>
    KPrintf("     x1: 0x%016lx\n", tf->x1);
  601040f9ac:	f9400fe0 	ldr	x0, [sp, #24]
  601040f9b0:	f9400400 	ldr	x0, [x0, #8]
  601040f9b4:	aa0003e1 	mov	x1, x0
  601040f9b8:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f9bc:	912dc000 	add	x0, x0, #0xb70
  601040f9c0:	940011ee 	bl	6010414178 <printf_>
    KPrintf("     x2: 0x%016lx\n", tf->x2);
  601040f9c4:	f9400fe0 	ldr	x0, [sp, #24]
  601040f9c8:	f9400800 	ldr	x0, [x0, #16]
  601040f9cc:	aa0003e1 	mov	x1, x0
  601040f9d0:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f9d4:	912e2000 	add	x0, x0, #0xb88
  601040f9d8:	940011e8 	bl	6010414178 <printf_>
    KPrintf("     x3: 0x%016lx\n", tf->x3);
  601040f9dc:	f9400fe0 	ldr	x0, [sp, #24]
  601040f9e0:	f9400c00 	ldr	x0, [x0, #24]
  601040f9e4:	aa0003e1 	mov	x1, x0
  601040f9e8:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040f9ec:	912e8000 	add	x0, x0, #0xba0
  601040f9f0:	940011e2 	bl	6010414178 <printf_>
    KPrintf("     x4: 0x%016lx\n", tf->x4);
  601040f9f4:	f9400fe0 	ldr	x0, [sp, #24]
  601040f9f8:	f9401000 	ldr	x0, [x0, #32]
  601040f9fc:	aa0003e1 	mov	x1, x0
  601040fa00:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040fa04:	912ee000 	add	x0, x0, #0xbb8
  601040fa08:	940011dc 	bl	6010414178 <printf_>
    KPrintf("     x5: 0x%016lx\n", tf->x5);
  601040fa0c:	f9400fe0 	ldr	x0, [sp, #24]
  601040fa10:	f9401400 	ldr	x0, [x0, #40]
  601040fa14:	aa0003e1 	mov	x1, x0
  601040fa18:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040fa1c:	912f4000 	add	x0, x0, #0xbd0
  601040fa20:	940011d6 	bl	6010414178 <printf_>
    KPrintf("     x6: 0x%016lx\n", tf->x6);
  601040fa24:	f9400fe0 	ldr	x0, [sp, #24]
  601040fa28:	f9401800 	ldr	x0, [x0, #48]
  601040fa2c:	aa0003e1 	mov	x1, x0
  601040fa30:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040fa34:	912fa000 	add	x0, x0, #0xbe8
  601040fa38:	940011d0 	bl	6010414178 <printf_>
    KPrintf("     x7: 0x%016lx\n", tf->x7);
  601040fa3c:	f9400fe0 	ldr	x0, [sp, #24]
  601040fa40:	f9401c00 	ldr	x0, [x0, #56]
  601040fa44:	aa0003e1 	mov	x1, x0
  601040fa48:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040fa4c:	91300000 	add	x0, x0, #0xc00
  601040fa50:	940011ca 	bl	6010414178 <printf_>
    KPrintf("     x8: 0x%016lx\n", tf->x8);
  601040fa54:	f9400fe0 	ldr	x0, [sp, #24]
  601040fa58:	f9402000 	ldr	x0, [x0, #64]
  601040fa5c:	aa0003e1 	mov	x1, x0
  601040fa60:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040fa64:	91306000 	add	x0, x0, #0xc18
  601040fa68:	940011c4 	bl	6010414178 <printf_>
    KPrintf("     x9: 0x%016lx\n", tf->x9);
  601040fa6c:	f9400fe0 	ldr	x0, [sp, #24]
  601040fa70:	f9402400 	ldr	x0, [x0, #72]
  601040fa74:	aa0003e1 	mov	x1, x0
  601040fa78:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040fa7c:	9130c000 	add	x0, x0, #0xc30
  601040fa80:	940011be 	bl	6010414178 <printf_>
    KPrintf("    x10: 0x%016lx\n", tf->x10);
  601040fa84:	f9400fe0 	ldr	x0, [sp, #24]
  601040fa88:	f9402800 	ldr	x0, [x0, #80]
  601040fa8c:	aa0003e1 	mov	x1, x0
  601040fa90:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040fa94:	91312000 	add	x0, x0, #0xc48
  601040fa98:	940011b8 	bl	6010414178 <printf_>
    KPrintf("    x11: 0x%016lx\n", tf->x11);
  601040fa9c:	f9400fe0 	ldr	x0, [sp, #24]
  601040faa0:	f9402c00 	ldr	x0, [x0, #88]
  601040faa4:	aa0003e1 	mov	x1, x0
  601040faa8:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040faac:	91318000 	add	x0, x0, #0xc60
  601040fab0:	940011b2 	bl	6010414178 <printf_>
    KPrintf("    x12: 0x%016lx\n", tf->x12);
  601040fab4:	f9400fe0 	ldr	x0, [sp, #24]
  601040fab8:	f9403000 	ldr	x0, [x0, #96]
  601040fabc:	aa0003e1 	mov	x1, x0
  601040fac0:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040fac4:	9131e000 	add	x0, x0, #0xc78
  601040fac8:	940011ac 	bl	6010414178 <printf_>
    KPrintf("    x13: 0x%016lx\n", tf->x13);
  601040facc:	f9400fe0 	ldr	x0, [sp, #24]
  601040fad0:	f9403400 	ldr	x0, [x0, #104]
  601040fad4:	aa0003e1 	mov	x1, x0
  601040fad8:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040fadc:	91324000 	add	x0, x0, #0xc90
  601040fae0:	940011a6 	bl	6010414178 <printf_>
    KPrintf("    x14: 0x%016lx\n", tf->x14);
  601040fae4:	f9400fe0 	ldr	x0, [sp, #24]
  601040fae8:	f9403800 	ldr	x0, [x0, #112]
  601040faec:	aa0003e1 	mov	x1, x0
  601040faf0:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040faf4:	9132a000 	add	x0, x0, #0xca8
  601040faf8:	940011a0 	bl	6010414178 <printf_>
    KPrintf("    x15: 0x%016lx\n", tf->x15);
  601040fafc:	f9400fe0 	ldr	x0, [sp, #24]
  601040fb00:	f9403c00 	ldr	x0, [x0, #120]
  601040fb04:	aa0003e1 	mov	x1, x0
  601040fb08:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040fb0c:	91330000 	add	x0, x0, #0xcc0
  601040fb10:	9400119a 	bl	6010414178 <printf_>
    KPrintf("    x16: 0x%016lx\n", tf->x16);
  601040fb14:	f9400fe0 	ldr	x0, [sp, #24]
  601040fb18:	f9404000 	ldr	x0, [x0, #128]
  601040fb1c:	aa0003e1 	mov	x1, x0
  601040fb20:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040fb24:	91336000 	add	x0, x0, #0xcd8
  601040fb28:	94001194 	bl	6010414178 <printf_>
    KPrintf("    x17: 0x%016lx\n", tf->x17);
  601040fb2c:	f9400fe0 	ldr	x0, [sp, #24]
  601040fb30:	f9404400 	ldr	x0, [x0, #136]
  601040fb34:	aa0003e1 	mov	x1, x0
  601040fb38:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040fb3c:	9133c000 	add	x0, x0, #0xcf0
  601040fb40:	9400118e 	bl	6010414178 <printf_>
    KPrintf("    x18: 0x%016lx\n", tf->x18);
  601040fb44:	f9400fe0 	ldr	x0, [sp, #24]
  601040fb48:	f9404800 	ldr	x0, [x0, #144]
  601040fb4c:	aa0003e1 	mov	x1, x0
  601040fb50:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040fb54:	91342000 	add	x0, x0, #0xd08
  601040fb58:	94001188 	bl	6010414178 <printf_>
    KPrintf("    x19: 0x%016lx\n", tf->x19);
  601040fb5c:	f9400fe0 	ldr	x0, [sp, #24]
  601040fb60:	f9404c00 	ldr	x0, [x0, #152]
  601040fb64:	aa0003e1 	mov	x1, x0
  601040fb68:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040fb6c:	91348000 	add	x0, x0, #0xd20
  601040fb70:	94001182 	bl	6010414178 <printf_>
    KPrintf("    x20: 0x%016lx\n", tf->x20);
  601040fb74:	f9400fe0 	ldr	x0, [sp, #24]
  601040fb78:	f9405000 	ldr	x0, [x0, #160]
  601040fb7c:	aa0003e1 	mov	x1, x0
  601040fb80:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040fb84:	9134e000 	add	x0, x0, #0xd38
  601040fb88:	9400117c 	bl	6010414178 <printf_>
    KPrintf("    x21: 0x%016lx\n", tf->x21);
  601040fb8c:	f9400fe0 	ldr	x0, [sp, #24]
  601040fb90:	f9405400 	ldr	x0, [x0, #168]
  601040fb94:	aa0003e1 	mov	x1, x0
  601040fb98:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040fb9c:	91354000 	add	x0, x0, #0xd50
  601040fba0:	94001176 	bl	6010414178 <printf_>
    KPrintf("    x22: 0x%016lx\n", tf->x22);
  601040fba4:	f9400fe0 	ldr	x0, [sp, #24]
  601040fba8:	f9405800 	ldr	x0, [x0, #176]
  601040fbac:	aa0003e1 	mov	x1, x0
  601040fbb0:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040fbb4:	9135a000 	add	x0, x0, #0xd68
  601040fbb8:	94001170 	bl	6010414178 <printf_>
    KPrintf("    x23: 0x%016lx\n", tf->x23);
  601040fbbc:	f9400fe0 	ldr	x0, [sp, #24]
  601040fbc0:	f9405c00 	ldr	x0, [x0, #184]
  601040fbc4:	aa0003e1 	mov	x1, x0
  601040fbc8:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040fbcc:	91360000 	add	x0, x0, #0xd80
  601040fbd0:	9400116a 	bl	6010414178 <printf_>
    KPrintf("    x24: 0x%016lx\n", tf->x24);
  601040fbd4:	f9400fe0 	ldr	x0, [sp, #24]
  601040fbd8:	f9406000 	ldr	x0, [x0, #192]
  601040fbdc:	aa0003e1 	mov	x1, x0
  601040fbe0:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040fbe4:	91366000 	add	x0, x0, #0xd98
  601040fbe8:	94001164 	bl	6010414178 <printf_>
    KPrintf("    x25: 0x%016lx\n", tf->x25);
  601040fbec:	f9400fe0 	ldr	x0, [sp, #24]
  601040fbf0:	f9406400 	ldr	x0, [x0, #200]
  601040fbf4:	aa0003e1 	mov	x1, x0
  601040fbf8:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040fbfc:	9136c000 	add	x0, x0, #0xdb0
  601040fc00:	9400115e 	bl	6010414178 <printf_>
    KPrintf("    x26: 0x%016lx\n", tf->x26);
  601040fc04:	f9400fe0 	ldr	x0, [sp, #24]
  601040fc08:	f9406800 	ldr	x0, [x0, #208]
  601040fc0c:	aa0003e1 	mov	x1, x0
  601040fc10:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040fc14:	91372000 	add	x0, x0, #0xdc8
  601040fc18:	94001158 	bl	6010414178 <printf_>
    KPrintf("    x27: 0x%016lx\n", tf->x27);
  601040fc1c:	f9400fe0 	ldr	x0, [sp, #24]
  601040fc20:	f9406c00 	ldr	x0, [x0, #216]
  601040fc24:	aa0003e1 	mov	x1, x0
  601040fc28:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040fc2c:	91378000 	add	x0, x0, #0xde0
  601040fc30:	94001152 	bl	6010414178 <printf_>
    KPrintf("    x28: 0x%016lx\n", tf->x28);
  601040fc34:	f9400fe0 	ldr	x0, [sp, #24]
  601040fc38:	f9407000 	ldr	x0, [x0, #224]
  601040fc3c:	aa0003e1 	mov	x1, x0
  601040fc40:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040fc44:	9137e000 	add	x0, x0, #0xdf8
  601040fc48:	9400114c 	bl	6010414178 <printf_>
    KPrintf("    x29: 0x%016lx\n", tf->x29);
  601040fc4c:	f9400fe0 	ldr	x0, [sp, #24]
  601040fc50:	f9407400 	ldr	x0, [x0, #232]
  601040fc54:	aa0003e1 	mov	x1, x0
  601040fc58:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040fc5c:	91384000 	add	x0, x0, #0xe10
  601040fc60:	94001146 	bl	6010414178 <printf_>
    KPrintf("    x30: 0x%016lx\n", tf->x30);
  601040fc64:	f9400fe0 	ldr	x0, [sp, #24]
  601040fc68:	f9407800 	ldr	x0, [x0, #240]
  601040fc6c:	aa0003e1 	mov	x1, x0
  601040fc70:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040fc74:	9138a000 	add	x0, x0, #0xe28
  601040fc78:	94001140 	bl	6010414178 <printf_>
}
  601040fc7c:	d503201f 	nop
  601040fc80:	a8c27bfd 	ldp	x29, x30, [sp], #32
  601040fc84:	d65f03c0 	ret

000000601040fc88 <dabort_reason>:

void dabort_reason(struct trapframe* r)
{
  601040fc88:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  601040fc8c:	910003fd 	mov	x29, sp
  601040fc90:	f9000fe0 	str	x0, [sp, #24]
    uint32_t fault_status, fault_address;
    __asm__ __volatile__("mrs %0, esr_el1" : "=r"(fault_status));
  601040fc94:	d5385200 	mrs	x0, esr_el1
  601040fc98:	b9002fe0 	str	w0, [sp, #44]
    __asm__ __volatile__("mrs %0, far_el1" : "=r"(fault_address));
  601040fc9c:	d5386000 	mrs	x0, far_el1
  601040fca0:	b9002be0 	str	w0, [sp, #40]
    w_esr_el1(0);
  601040fca4:	d2800000 	mov	x0, #0x0                   	// #0
  601040fca8:	97ffff1f 	bl	601040f924 <w_esr_el1>
    LOG("program counter: 0x%016lx caused\n", r->pc);
  601040fcac:	d0000080 	adrp	x0, 6010421000 <__func__.0+0x508>
  601040fcb0:	9102c001 	add	x1, x0, #0xb0
  601040fcb4:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040fcb8:	91390000 	add	x0, x0, #0xe40
  601040fcbc:	9400112f 	bl	6010414178 <printf_>
  601040fcc0:	f9400fe0 	ldr	x0, [sp, #24]
  601040fcc4:	f9407c00 	ldr	x0, [x0, #248]
  601040fcc8:	aa0003e1 	mov	x1, x0
  601040fccc:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040fcd0:	91394000 	add	x0, x0, #0xe50
  601040fcd4:	94001129 	bl	6010414178 <printf_>
    LOG("data abort at 0x%016lx, status 0x%016lx\n", fault_address, fault_status);
  601040fcd8:	d0000080 	adrp	x0, 6010421000 <__func__.0+0x508>
  601040fcdc:	9102c001 	add	x1, x0, #0xb0
  601040fce0:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040fce4:	91390000 	add	x0, x0, #0xe40
  601040fce8:	94001124 	bl	6010414178 <printf_>
  601040fcec:	b9402fe2 	ldr	w2, [sp, #44]
  601040fcf0:	b9402be1 	ldr	w1, [sp, #40]
  601040fcf4:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040fcf8:	9139e000 	add	x0, x0, #0xe78
  601040fcfc:	9400111f 	bl	6010414178 <printf_>
    if ((fault_status & 0x3f) == 0x21) // Alignment failure
  601040fd00:	b9402fe0 	ldr	w0, [sp, #44]
  601040fd04:	12001400 	and	w0, w0, #0x3f
  601040fd08:	7100841f 	cmp	w0, #0x21
  601040fd0c:	540000a1 	b.ne	601040fd20 <dabort_reason+0x98>  // b.any
        KPrintf("reason: alignment\n");
  601040fd10:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040fd14:	913aa000 	add	x0, x0, #0xea8
  601040fd18:	94001118 	bl	6010414178 <printf_>
  601040fd1c:	14000064 	b	601040feac <dabort_reason+0x224>
    else if ((fault_status & 0x3f) == 0x4) // Translation fault, level 0
  601040fd20:	b9402fe0 	ldr	w0, [sp, #44]
  601040fd24:	12001400 	and	w0, w0, #0x3f
  601040fd28:	7100101f 	cmp	w0, #0x4
  601040fd2c:	540000a1 	b.ne	601040fd40 <dabort_reason+0xb8>  // b.any
        KPrintf("reason: sect. translation level 0\n");
  601040fd30:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040fd34:	913b0000 	add	x0, x0, #0xec0
  601040fd38:	94001110 	bl	6010414178 <printf_>
  601040fd3c:	1400005c 	b	601040feac <dabort_reason+0x224>
    else if ((fault_status & 0x3f) == 0x5) // Translation fault, level 1
  601040fd40:	b9402fe0 	ldr	w0, [sp, #44]
  601040fd44:	12001400 	and	w0, w0, #0x3f
  601040fd48:	7100141f 	cmp	w0, #0x5
  601040fd4c:	540000a1 	b.ne	601040fd60 <dabort_reason+0xd8>  // b.any
        KPrintf("reason: sect. translation level 1\n");
  601040fd50:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040fd54:	913ba000 	add	x0, x0, #0xee8
  601040fd58:	94001108 	bl	6010414178 <printf_>
  601040fd5c:	14000054 	b	601040feac <dabort_reason+0x224>
    else if ((fault_status & 0x3f) == 0x6) // Translation fault, level 2
  601040fd60:	b9402fe0 	ldr	w0, [sp, #44]
  601040fd64:	12001400 	and	w0, w0, #0x3f
  601040fd68:	7100181f 	cmp	w0, #0x6
  601040fd6c:	540000a1 	b.ne	601040fd80 <dabort_reason+0xf8>  // b.any
        KPrintf("reason: sect. translation level 2\n");
  601040fd70:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040fd74:	913c4000 	add	x0, x0, #0xf10
  601040fd78:	94001100 	bl	6010414178 <printf_>
  601040fd7c:	1400004c 	b	601040feac <dabort_reason+0x224>
    else if ((fault_status & 0x3f) == 0x7) // Translation fault, level 3
  601040fd80:	b9402fe0 	ldr	w0, [sp, #44]
  601040fd84:	12001400 	and	w0, w0, #0x3f
  601040fd88:	71001c1f 	cmp	w0, #0x7
  601040fd8c:	540000a1 	b.ne	601040fda0 <dabort_reason+0x118>  // b.any
        KPrintf("reason: sect. translation level 3\n");
  601040fd90:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040fd94:	913ce000 	add	x0, x0, #0xf38
  601040fd98:	940010f8 	bl	6010414178 <printf_>
  601040fd9c:	14000044 	b	601040feac <dabort_reason+0x224>
    else if ((fault_status & 0x3f) == 0x3d) // Section Domain fault
  601040fda0:	b9402fe0 	ldr	w0, [sp, #44]
  601040fda4:	12001400 	and	w0, w0, #0x3f
  601040fda8:	7100f41f 	cmp	w0, #0x3d
  601040fdac:	540000a1 	b.ne	601040fdc0 <dabort_reason+0x138>  // b.any
        KPrintf("reason: sect. domain\n");
  601040fdb0:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040fdb4:	913d8000 	add	x0, x0, #0xf60
  601040fdb8:	940010f0 	bl	6010414178 <printf_>
  601040fdbc:	1400003c 	b	601040feac <dabort_reason+0x224>
    else if ((fault_status & 0x3f) == 0xd) // Permission level 1
  601040fdc0:	b9402fe0 	ldr	w0, [sp, #44]
  601040fdc4:	12001400 	and	w0, w0, #0x3f
  601040fdc8:	7100341f 	cmp	w0, #0xd
  601040fdcc:	540000a1 	b.ne	601040fde0 <dabort_reason+0x158>  // b.any
        KPrintf("reason: sect. permission level 1\n");
  601040fdd0:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040fdd4:	913de000 	add	x0, x0, #0xf78
  601040fdd8:	940010e8 	bl	6010414178 <printf_>
  601040fddc:	14000034 	b	601040feac <dabort_reason+0x224>
    else if ((fault_status & 0x3f) == 0xe) // Permission level 2
  601040fde0:	b9402fe0 	ldr	w0, [sp, #44]
  601040fde4:	12001400 	and	w0, w0, #0x3f
  601040fde8:	7100381f 	cmp	w0, #0xe
  601040fdec:	540000a1 	b.ne	601040fe00 <dabort_reason+0x178>  // b.any
        KPrintf("reason: sect. permission level 2\n");
  601040fdf0:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040fdf4:	913e8000 	add	x0, x0, #0xfa0
  601040fdf8:	940010e0 	bl	6010414178 <printf_>
  601040fdfc:	1400002c 	b	601040feac <dabort_reason+0x224>
    else if ((fault_status & 0x3f) == 0xf) // Permission level 3
  601040fe00:	b9402fe0 	ldr	w0, [sp, #44]
  601040fe04:	12001400 	and	w0, w0, #0x3f
  601040fe08:	71003c1f 	cmp	w0, #0xf
  601040fe0c:	540000a1 	b.ne	601040fe20 <dabort_reason+0x198>  // b.any
        KPrintf("reason: sect. permission level 3\n");
  601040fe10:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040fe14:	913f2000 	add	x0, x0, #0xfc8
  601040fe18:	940010d8 	bl	6010414178 <printf_>
  601040fe1c:	14000024 	b	601040feac <dabort_reason+0x224>
    else if ((fault_status & 0x3f) == 0x14) // External abort
  601040fe20:	b9402fe0 	ldr	w0, [sp, #44]
  601040fe24:	12001400 	and	w0, w0, #0x3f
  601040fe28:	7100501f 	cmp	w0, #0x14
  601040fe2c:	540000a1 	b.ne	601040fe40 <dabort_reason+0x1b8>  // b.any
        KPrintf("reason: ext. abort\n");
  601040fe30:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040fe34:	913fc000 	add	x0, x0, #0xff0
  601040fe38:	940010d0 	bl	6010414178 <printf_>
  601040fe3c:	1400001c 	b	601040feac <dabort_reason+0x224>
    else if ((fault_status & 0x3f) == 0x9) // Access flag fault, level 1
  601040fe40:	b9402fe0 	ldr	w0, [sp, #44]
  601040fe44:	12001400 	and	w0, w0, #0x3f
  601040fe48:	7100241f 	cmp	w0, #0x9
  601040fe4c:	540000a1 	b.ne	601040fe60 <dabort_reason+0x1d8>  // b.any
        KPrintf("reason: sect. Access flag fault level 1\n");
  601040fe50:	d0000080 	adrp	x0, 6010421000 <__func__.0+0x508>
  601040fe54:	91002000 	add	x0, x0, #0x8
  601040fe58:	940010c8 	bl	6010414178 <printf_>
  601040fe5c:	14000014 	b	601040feac <dabort_reason+0x224>
    else if ((fault_status & 0x3f) == 0xa) // Access flag fault, level 2
  601040fe60:	b9402fe0 	ldr	w0, [sp, #44]
  601040fe64:	12001400 	and	w0, w0, #0x3f
  601040fe68:	7100281f 	cmp	w0, #0xa
  601040fe6c:	540000a1 	b.ne	601040fe80 <dabort_reason+0x1f8>  // b.any
        KPrintf("reason: sect. Access flag fault level 2\n");
  601040fe70:	d0000080 	adrp	x0, 6010421000 <__func__.0+0x508>
  601040fe74:	9100e000 	add	x0, x0, #0x38
  601040fe78:	940010c0 	bl	6010414178 <printf_>
  601040fe7c:	1400000c 	b	601040feac <dabort_reason+0x224>
    else if ((fault_status & 0x3f) == 0xb) // Access flag fault, level 3
  601040fe80:	b9402fe0 	ldr	w0, [sp, #44]
  601040fe84:	12001400 	and	w0, w0, #0x3f
  601040fe88:	71002c1f 	cmp	w0, #0xb
  601040fe8c:	540000a1 	b.ne	601040fea0 <dabort_reason+0x218>  // b.any
        KPrintf("reason: sect. Access flag fault level 3\n");
  601040fe90:	d0000080 	adrp	x0, 6010421000 <__func__.0+0x508>
  601040fe94:	9101a000 	add	x0, x0, #0x68
  601040fe98:	940010b8 	bl	6010414178 <printf_>
  601040fe9c:	14000004 	b	601040feac <dabort_reason+0x224>
    else
        KPrintf("reason: unknown???\n");
  601040fea0:	d0000080 	adrp	x0, 6010421000 <__func__.0+0x508>
  601040fea4:	91026000 	add	x0, x0, #0x98
  601040fea8:	940010b4 	bl	6010414178 <printf_>

    dump_tf(r);
  601040feac:	f9400fe0 	ldr	x0, [sp, #24]
  601040feb0:	97fffea4 	bl	601040f940 <dump_tf>
    return;
  601040feb4:	d503201f 	nop
}
  601040feb8:	a8c37bfd 	ldp	x29, x30, [sp], #48
  601040febc:	d65f03c0 	ret

000000601040fec0 <iabort_reason>:

void iabort_reason(struct trapframe* r)
{
  601040fec0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  601040fec4:	910003fd 	mov	x29, sp
  601040fec8:	f9000fe0 	str	x0, [sp, #24]
    uint32_t fault_status, fault_address;
    __asm__ __volatile__("mrs %0, esr_el1" : "=r"(fault_status));
  601040fecc:	d5385200 	mrs	x0, esr_el1
  601040fed0:	b9002fe0 	str	w0, [sp, #44]
    __asm__ __volatile__("mrs %0, far_el1" : "=r"(fault_address));
  601040fed4:	d5386000 	mrs	x0, far_el1
  601040fed8:	b9002be0 	str	w0, [sp, #40]
    LOG("program counter: 0x%016lx caused\n", r->pc);
  601040fedc:	d0000080 	adrp	x0, 6010421000 <__func__.0+0x508>
  601040fee0:	91030001 	add	x1, x0, #0xc0
  601040fee4:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040fee8:	91390000 	add	x0, x0, #0xe40
  601040feec:	940010a3 	bl	6010414178 <printf_>
  601040fef0:	f9400fe0 	ldr	x0, [sp, #24]
  601040fef4:	f9407c00 	ldr	x0, [x0, #248]
  601040fef8:	aa0003e1 	mov	x1, x0
  601040fefc:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040ff00:	91394000 	add	x0, x0, #0xe50
  601040ff04:	9400109d 	bl	6010414178 <printf_>
    LOG("data abort at 0x%016lx, status 0x%016lx\n", fault_address, fault_status);
  601040ff08:	d0000080 	adrp	x0, 6010421000 <__func__.0+0x508>
  601040ff0c:	91030001 	add	x1, x0, #0xc0
  601040ff10:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040ff14:	91390000 	add	x0, x0, #0xe40
  601040ff18:	94001098 	bl	6010414178 <printf_>
  601040ff1c:	b9402fe2 	ldr	w2, [sp, #44]
  601040ff20:	b9402be1 	ldr	w1, [sp, #40]
  601040ff24:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040ff28:	9139e000 	add	x0, x0, #0xe78
  601040ff2c:	94001093 	bl	6010414178 <printf_>
    w_esr_el1(0);
  601040ff30:	d2800000 	mov	x0, #0x0                   	// #0
  601040ff34:	97fffe7c 	bl	601040f924 <w_esr_el1>
    if ((fault_status & 0x3f) == 0x21) // Alignment failure
  601040ff38:	b9402fe0 	ldr	w0, [sp, #44]
  601040ff3c:	12001400 	and	w0, w0, #0x3f
  601040ff40:	7100841f 	cmp	w0, #0x21
  601040ff44:	540000a1 	b.ne	601040ff58 <iabort_reason+0x98>  // b.any
        KPrintf("reason: alignment\n");
  601040ff48:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040ff4c:	913aa000 	add	x0, x0, #0xea8
  601040ff50:	9400108a 	bl	6010414178 <printf_>
  601040ff54:	14000064 	b	60104100e4 <iabort_reason+0x224>
    else if ((fault_status & 0x3f) == 0x4) // Translation fault, level 0
  601040ff58:	b9402fe0 	ldr	w0, [sp, #44]
  601040ff5c:	12001400 	and	w0, w0, #0x3f
  601040ff60:	7100101f 	cmp	w0, #0x4
  601040ff64:	540000a1 	b.ne	601040ff78 <iabort_reason+0xb8>  // b.any
        KPrintf("reason: sect. translation level 0\n");
  601040ff68:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040ff6c:	913b0000 	add	x0, x0, #0xec0
  601040ff70:	94001082 	bl	6010414178 <printf_>
  601040ff74:	1400005c 	b	60104100e4 <iabort_reason+0x224>
    else if ((fault_status & 0x3f) == 0x5) // Translation fault, level 1
  601040ff78:	b9402fe0 	ldr	w0, [sp, #44]
  601040ff7c:	12001400 	and	w0, w0, #0x3f
  601040ff80:	7100141f 	cmp	w0, #0x5
  601040ff84:	540000a1 	b.ne	601040ff98 <iabort_reason+0xd8>  // b.any
        KPrintf("reason: sect. translation level 1\n");
  601040ff88:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040ff8c:	913ba000 	add	x0, x0, #0xee8
  601040ff90:	9400107a 	bl	6010414178 <printf_>
  601040ff94:	14000054 	b	60104100e4 <iabort_reason+0x224>
    else if ((fault_status & 0x3f) == 0x6) // Translation fault, level 2
  601040ff98:	b9402fe0 	ldr	w0, [sp, #44]
  601040ff9c:	12001400 	and	w0, w0, #0x3f
  601040ffa0:	7100181f 	cmp	w0, #0x6
  601040ffa4:	540000a1 	b.ne	601040ffb8 <iabort_reason+0xf8>  // b.any
        KPrintf("reason: sect. translation level 2\n");
  601040ffa8:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040ffac:	913c4000 	add	x0, x0, #0xf10
  601040ffb0:	94001072 	bl	6010414178 <printf_>
  601040ffb4:	1400004c 	b	60104100e4 <iabort_reason+0x224>
    else if ((fault_status & 0x3f) == 0x7) // Translation fault, level 3
  601040ffb8:	b9402fe0 	ldr	w0, [sp, #44]
  601040ffbc:	12001400 	and	w0, w0, #0x3f
  601040ffc0:	71001c1f 	cmp	w0, #0x7
  601040ffc4:	540000a1 	b.ne	601040ffd8 <iabort_reason+0x118>  // b.any
        KPrintf("reason: sect. translation level 3\n");
  601040ffc8:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040ffcc:	913ce000 	add	x0, x0, #0xf38
  601040ffd0:	9400106a 	bl	6010414178 <printf_>
  601040ffd4:	14000044 	b	60104100e4 <iabort_reason+0x224>
    else if ((fault_status & 0x3f) == 0x3d) // Section Domain fault
  601040ffd8:	b9402fe0 	ldr	w0, [sp, #44]
  601040ffdc:	12001400 	and	w0, w0, #0x3f
  601040ffe0:	7100f41f 	cmp	w0, #0x3d
  601040ffe4:	540000a1 	b.ne	601040fff8 <iabort_reason+0x138>  // b.any
        KPrintf("reason: sect. domain\n");
  601040ffe8:	b0000080 	adrp	x0, 6010420000 <main+0x168>
  601040ffec:	913d8000 	add	x0, x0, #0xf60
  601040fff0:	94001062 	bl	6010414178 <printf_>
  601040fff4:	1400003c 	b	60104100e4 <iabort_reason+0x224>
    else if ((fault_status & 0x3f) == 0xd) // Permission level 1
  601040fff8:	b9402fe0 	ldr	w0, [sp, #44]
  601040fffc:	12001400 	and	w0, w0, #0x3f
  6010410000:	7100341f 	cmp	w0, #0xd
  6010410004:	540000a1 	b.ne	6010410018 <iabort_reason+0x158>  // b.any
        KPrintf("reason: sect. permission level 1\n");
  6010410008:	90000080 	adrp	x0, 6010420000 <main+0x168>
  601041000c:	913de000 	add	x0, x0, #0xf78
  6010410010:	9400105a 	bl	6010414178 <printf_>
  6010410014:	14000034 	b	60104100e4 <iabort_reason+0x224>
    else if ((fault_status & 0x3f) == 0xe) // Permission level 2
  6010410018:	b9402fe0 	ldr	w0, [sp, #44]
  601041001c:	12001400 	and	w0, w0, #0x3f
  6010410020:	7100381f 	cmp	w0, #0xe
  6010410024:	540000a1 	b.ne	6010410038 <iabort_reason+0x178>  // b.any
        KPrintf("reason: sect. permission level 2\n");
  6010410028:	90000080 	adrp	x0, 6010420000 <main+0x168>
  601041002c:	913e8000 	add	x0, x0, #0xfa0
  6010410030:	94001052 	bl	6010414178 <printf_>
  6010410034:	1400002c 	b	60104100e4 <iabort_reason+0x224>
    else if ((fault_status & 0x3f) == 0xf) // Permission level 3
  6010410038:	b9402fe0 	ldr	w0, [sp, #44]
  601041003c:	12001400 	and	w0, w0, #0x3f
  6010410040:	71003c1f 	cmp	w0, #0xf
  6010410044:	540000a1 	b.ne	6010410058 <iabort_reason+0x198>  // b.any
        KPrintf("reason: sect. permission level 3\n");
  6010410048:	90000080 	adrp	x0, 6010420000 <main+0x168>
  601041004c:	913f2000 	add	x0, x0, #0xfc8
  6010410050:	9400104a 	bl	6010414178 <printf_>
  6010410054:	14000024 	b	60104100e4 <iabort_reason+0x224>
    else if ((fault_status & 0x3f) == 0x14) // External abort
  6010410058:	b9402fe0 	ldr	w0, [sp, #44]
  601041005c:	12001400 	and	w0, w0, #0x3f
  6010410060:	7100501f 	cmp	w0, #0x14
  6010410064:	540000a1 	b.ne	6010410078 <iabort_reason+0x1b8>  // b.any
        KPrintf("reason: ext. abort\n");
  6010410068:	90000080 	adrp	x0, 6010420000 <main+0x168>
  601041006c:	913fc000 	add	x0, x0, #0xff0
  6010410070:	94001042 	bl	6010414178 <printf_>
  6010410074:	1400001c 	b	60104100e4 <iabort_reason+0x224>
    else if ((fault_status & 0x3f) == 0x9) // Access flag fault, level 1
  6010410078:	b9402fe0 	ldr	w0, [sp, #44]
  601041007c:	12001400 	and	w0, w0, #0x3f
  6010410080:	7100241f 	cmp	w0, #0x9
  6010410084:	540000a1 	b.ne	6010410098 <iabort_reason+0x1d8>  // b.any
        KPrintf("reason: sect. Access flag fault level 1\n");
  6010410088:	b0000080 	adrp	x0, 6010421000 <__func__.0+0x508>
  601041008c:	91002000 	add	x0, x0, #0x8
  6010410090:	9400103a 	bl	6010414178 <printf_>
  6010410094:	14000014 	b	60104100e4 <iabort_reason+0x224>
    else if ((fault_status & 0x3f) == 0xa) // Access flag fault, level 2
  6010410098:	b9402fe0 	ldr	w0, [sp, #44]
  601041009c:	12001400 	and	w0, w0, #0x3f
  60104100a0:	7100281f 	cmp	w0, #0xa
  60104100a4:	540000a1 	b.ne	60104100b8 <iabort_reason+0x1f8>  // b.any
        KPrintf("reason: sect. Access flag fault level 2\n");
  60104100a8:	b0000080 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104100ac:	9100e000 	add	x0, x0, #0x38
  60104100b0:	94001032 	bl	6010414178 <printf_>
  60104100b4:	1400000c 	b	60104100e4 <iabort_reason+0x224>
    else if ((fault_status & 0x3f) == 0xb) // Access flag fault, level 3
  60104100b8:	b9402fe0 	ldr	w0, [sp, #44]
  60104100bc:	12001400 	and	w0, w0, #0x3f
  60104100c0:	71002c1f 	cmp	w0, #0xb
  60104100c4:	540000a1 	b.ne	60104100d8 <iabort_reason+0x218>  // b.any
        KPrintf("reason: sect. Access flag fault level 3\n");
  60104100c8:	b0000080 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104100cc:	9101a000 	add	x0, x0, #0x68
  60104100d0:	9400102a 	bl	6010414178 <printf_>
  60104100d4:	14000004 	b	60104100e4 <iabort_reason+0x224>
    else
        KPrintf("reason: unknown???\n");
  60104100d8:	b0000080 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104100dc:	91026000 	add	x0, x0, #0x98
  60104100e0:	94001026 	bl	6010414178 <printf_>

    dump_tf(r);
  60104100e4:	f9400fe0 	ldr	x0, [sp, #24]
  60104100e8:	97fffe16 	bl	601040f940 <dump_tf>
    return;
  60104100ec:	d503201f 	nop
  60104100f0:	a8c37bfd 	ldp	x29, x30, [sp], #48
  60104100f4:	d65f03c0 	ret
	...

0000006010410800 <alltraps>:
  6010410800:	140001e1 	b	6010410f84 <badtrap>
  6010410804:	d503201f 	nop
  6010410808:	d503201f 	nop
  601041080c:	d503201f 	nop
  6010410810:	d503201f 	nop
  6010410814:	d503201f 	nop
  6010410818:	d503201f 	nop
  601041081c:	d503201f 	nop
  6010410820:	d503201f 	nop
  6010410824:	d503201f 	nop
  6010410828:	d503201f 	nop
  601041082c:	d503201f 	nop
  6010410830:	d503201f 	nop
  6010410834:	d503201f 	nop
  6010410838:	d503201f 	nop
  601041083c:	d503201f 	nop
  6010410840:	d503201f 	nop
  6010410844:	d503201f 	nop
  6010410848:	d503201f 	nop
  601041084c:	d503201f 	nop
  6010410850:	d503201f 	nop
  6010410854:	d503201f 	nop
  6010410858:	d503201f 	nop
  601041085c:	d503201f 	nop
  6010410860:	d503201f 	nop
  6010410864:	d503201f 	nop
  6010410868:	d503201f 	nop
  601041086c:	d503201f 	nop
  6010410870:	d503201f 	nop
  6010410874:	d503201f 	nop
  6010410878:	d503201f 	nop
  601041087c:	d503201f 	nop
  6010410880:	140001c1 	b	6010410f84 <badtrap>
  6010410884:	d503201f 	nop
  6010410888:	d503201f 	nop
  601041088c:	d503201f 	nop
  6010410890:	d503201f 	nop
  6010410894:	d503201f 	nop
  6010410898:	d503201f 	nop
  601041089c:	d503201f 	nop
  60104108a0:	d503201f 	nop
  60104108a4:	d503201f 	nop
  60104108a8:	d503201f 	nop
  60104108ac:	d503201f 	nop
  60104108b0:	d503201f 	nop
  60104108b4:	d503201f 	nop
  60104108b8:	d503201f 	nop
  60104108bc:	d503201f 	nop
  60104108c0:	d503201f 	nop
  60104108c4:	d503201f 	nop
  60104108c8:	d503201f 	nop
  60104108cc:	d503201f 	nop
  60104108d0:	d503201f 	nop
  60104108d4:	d503201f 	nop
  60104108d8:	d503201f 	nop
  60104108dc:	d503201f 	nop
  60104108e0:	d503201f 	nop
  60104108e4:	d503201f 	nop
  60104108e8:	d503201f 	nop
  60104108ec:	d503201f 	nop
  60104108f0:	d503201f 	nop
  60104108f4:	d503201f 	nop
  60104108f8:	d503201f 	nop
  60104108fc:	d503201f 	nop
  6010410900:	140001a1 	b	6010410f84 <badtrap>
  6010410904:	d503201f 	nop
  6010410908:	d503201f 	nop
  601041090c:	d503201f 	nop
  6010410910:	d503201f 	nop
  6010410914:	d503201f 	nop
  6010410918:	d503201f 	nop
  601041091c:	d503201f 	nop
  6010410920:	d503201f 	nop
  6010410924:	d503201f 	nop
  6010410928:	d503201f 	nop
  601041092c:	d503201f 	nop
  6010410930:	d503201f 	nop
  6010410934:	d503201f 	nop
  6010410938:	d503201f 	nop
  601041093c:	d503201f 	nop
  6010410940:	d503201f 	nop
  6010410944:	d503201f 	nop
  6010410948:	d503201f 	nop
  601041094c:	d503201f 	nop
  6010410950:	d503201f 	nop
  6010410954:	d503201f 	nop
  6010410958:	d503201f 	nop
  601041095c:	d503201f 	nop
  6010410960:	d503201f 	nop
  6010410964:	d503201f 	nop
  6010410968:	d503201f 	nop
  601041096c:	d503201f 	nop
  6010410970:	d503201f 	nop
  6010410974:	d503201f 	nop
  6010410978:	d503201f 	nop
  601041097c:	d503201f 	nop
  6010410980:	14000181 	b	6010410f84 <badtrap>
  6010410984:	d503201f 	nop
  6010410988:	d503201f 	nop
  601041098c:	d503201f 	nop
  6010410990:	d503201f 	nop
  6010410994:	d503201f 	nop
  6010410998:	d503201f 	nop
  601041099c:	d503201f 	nop
  60104109a0:	d503201f 	nop
  60104109a4:	d503201f 	nop
  60104109a8:	d503201f 	nop
  60104109ac:	d503201f 	nop
  60104109b0:	d503201f 	nop
  60104109b4:	d503201f 	nop
  60104109b8:	d503201f 	nop
  60104109bc:	d503201f 	nop
  60104109c0:	d503201f 	nop
  60104109c4:	d503201f 	nop
  60104109c8:	d503201f 	nop
  60104109cc:	d503201f 	nop
  60104109d0:	d503201f 	nop
  60104109d4:	d503201f 	nop
  60104109d8:	d503201f 	nop
  60104109dc:	d503201f 	nop
  60104109e0:	d503201f 	nop
  60104109e4:	d503201f 	nop
  60104109e8:	d503201f 	nop
  60104109ec:	d503201f 	nop
  60104109f0:	d503201f 	nop
  60104109f4:	d503201f 	nop
  60104109f8:	d503201f 	nop
  60104109fc:	d503201f 	nop
  6010410a00:	1400017a 	b	6010410fe8 <el1sync>
  6010410a04:	d503201f 	nop
  6010410a08:	d503201f 	nop
  6010410a0c:	d503201f 	nop
  6010410a10:	d503201f 	nop
  6010410a14:	d503201f 	nop
  6010410a18:	d503201f 	nop
  6010410a1c:	d503201f 	nop
  6010410a20:	d503201f 	nop
  6010410a24:	d503201f 	nop
  6010410a28:	d503201f 	nop
  6010410a2c:	d503201f 	nop
  6010410a30:	d503201f 	nop
  6010410a34:	d503201f 	nop
  6010410a38:	d503201f 	nop
  6010410a3c:	d503201f 	nop
  6010410a40:	d503201f 	nop
  6010410a44:	d503201f 	nop
  6010410a48:	d503201f 	nop
  6010410a4c:	d503201f 	nop
  6010410a50:	d503201f 	nop
  6010410a54:	d503201f 	nop
  6010410a58:	d503201f 	nop
  6010410a5c:	d503201f 	nop
  6010410a60:	d503201f 	nop
  6010410a64:	d503201f 	nop
  6010410a68:	d503201f 	nop
  6010410a6c:	d503201f 	nop
  6010410a70:	d503201f 	nop
  6010410a74:	d503201f 	nop
  6010410a78:	d503201f 	nop
  6010410a7c:	d503201f 	nop
  6010410a80:	14000173 	b	601041104c <el1irq>
  6010410a84:	d503201f 	nop
  6010410a88:	d503201f 	nop
  6010410a8c:	d503201f 	nop
  6010410a90:	d503201f 	nop
  6010410a94:	d503201f 	nop
  6010410a98:	d503201f 	nop
  6010410a9c:	d503201f 	nop
  6010410aa0:	d503201f 	nop
  6010410aa4:	d503201f 	nop
  6010410aa8:	d503201f 	nop
  6010410aac:	d503201f 	nop
  6010410ab0:	d503201f 	nop
  6010410ab4:	d503201f 	nop
  6010410ab8:	d503201f 	nop
  6010410abc:	d503201f 	nop
  6010410ac0:	d503201f 	nop
  6010410ac4:	d503201f 	nop
  6010410ac8:	d503201f 	nop
  6010410acc:	d503201f 	nop
  6010410ad0:	d503201f 	nop
  6010410ad4:	d503201f 	nop
  6010410ad8:	d503201f 	nop
  6010410adc:	d503201f 	nop
  6010410ae0:	d503201f 	nop
  6010410ae4:	d503201f 	nop
  6010410ae8:	d503201f 	nop
  6010410aec:	d503201f 	nop
  6010410af0:	d503201f 	nop
  6010410af4:	d503201f 	nop
  6010410af8:	d503201f 	nop
  6010410afc:	d503201f 	nop
  6010410b00:	14000121 	b	6010410f84 <badtrap>
  6010410b04:	d503201f 	nop
  6010410b08:	d503201f 	nop
  6010410b0c:	d503201f 	nop
  6010410b10:	d503201f 	nop
  6010410b14:	d503201f 	nop
  6010410b18:	d503201f 	nop
  6010410b1c:	d503201f 	nop
  6010410b20:	d503201f 	nop
  6010410b24:	d503201f 	nop
  6010410b28:	d503201f 	nop
  6010410b2c:	d503201f 	nop
  6010410b30:	d503201f 	nop
  6010410b34:	d503201f 	nop
  6010410b38:	d503201f 	nop
  6010410b3c:	d503201f 	nop
  6010410b40:	d503201f 	nop
  6010410b44:	d503201f 	nop
  6010410b48:	d503201f 	nop
  6010410b4c:	d503201f 	nop
  6010410b50:	d503201f 	nop
  6010410b54:	d503201f 	nop
  6010410b58:	d503201f 	nop
  6010410b5c:	d503201f 	nop
  6010410b60:	d503201f 	nop
  6010410b64:	d503201f 	nop
  6010410b68:	d503201f 	nop
  6010410b6c:	d503201f 	nop
  6010410b70:	d503201f 	nop
  6010410b74:	d503201f 	nop
  6010410b78:	d503201f 	nop
  6010410b7c:	d503201f 	nop
  6010410b80:	14000101 	b	6010410f84 <badtrap>
  6010410b84:	d503201f 	nop
  6010410b88:	d503201f 	nop
  6010410b8c:	d503201f 	nop
  6010410b90:	d503201f 	nop
  6010410b94:	d503201f 	nop
  6010410b98:	d503201f 	nop
  6010410b9c:	d503201f 	nop
  6010410ba0:	d503201f 	nop
  6010410ba4:	d503201f 	nop
  6010410ba8:	d503201f 	nop
  6010410bac:	d503201f 	nop
  6010410bb0:	d503201f 	nop
  6010410bb4:	d503201f 	nop
  6010410bb8:	d503201f 	nop
  6010410bbc:	d503201f 	nop
  6010410bc0:	d503201f 	nop
  6010410bc4:	d503201f 	nop
  6010410bc8:	d503201f 	nop
  6010410bcc:	d503201f 	nop
  6010410bd0:	d503201f 	nop
  6010410bd4:	d503201f 	nop
  6010410bd8:	d503201f 	nop
  6010410bdc:	d503201f 	nop
  6010410be0:	d503201f 	nop
  6010410be4:	d503201f 	nop
  6010410be8:	d503201f 	nop
  6010410bec:	d503201f 	nop
  6010410bf0:	d503201f 	nop
  6010410bf4:	d503201f 	nop
  6010410bf8:	d503201f 	nop
  6010410bfc:	d503201f 	nop
  6010410c00:	14000141 	b	6010411104 <el0sync>
  6010410c04:	d503201f 	nop
  6010410c08:	d503201f 	nop
  6010410c0c:	d503201f 	nop
  6010410c10:	d503201f 	nop
  6010410c14:	d503201f 	nop
  6010410c18:	d503201f 	nop
  6010410c1c:	d503201f 	nop
  6010410c20:	d503201f 	nop
  6010410c24:	d503201f 	nop
  6010410c28:	d503201f 	nop
  6010410c2c:	d503201f 	nop
  6010410c30:	d503201f 	nop
  6010410c34:	d503201f 	nop
  6010410c38:	d503201f 	nop
  6010410c3c:	d503201f 	nop
  6010410c40:	d503201f 	nop
  6010410c44:	d503201f 	nop
  6010410c48:	d503201f 	nop
  6010410c4c:	d503201f 	nop
  6010410c50:	d503201f 	nop
  6010410c54:	d503201f 	nop
  6010410c58:	d503201f 	nop
  6010410c5c:	d503201f 	nop
  6010410c60:	d503201f 	nop
  6010410c64:	d503201f 	nop
  6010410c68:	d503201f 	nop
  6010410c6c:	d503201f 	nop
  6010410c70:	d503201f 	nop
  6010410c74:	d503201f 	nop
  6010410c78:	d503201f 	nop
  6010410c7c:	d503201f 	nop
  6010410c80:	1400014f 	b	60104111bc <el0irq>
  6010410c84:	d503201f 	nop
  6010410c88:	d503201f 	nop
  6010410c8c:	d503201f 	nop
  6010410c90:	d503201f 	nop
  6010410c94:	d503201f 	nop
  6010410c98:	d503201f 	nop
  6010410c9c:	d503201f 	nop
  6010410ca0:	d503201f 	nop
  6010410ca4:	d503201f 	nop
  6010410ca8:	d503201f 	nop
  6010410cac:	d503201f 	nop
  6010410cb0:	d503201f 	nop
  6010410cb4:	d503201f 	nop
  6010410cb8:	d503201f 	nop
  6010410cbc:	d503201f 	nop
  6010410cc0:	d503201f 	nop
  6010410cc4:	d503201f 	nop
  6010410cc8:	d503201f 	nop
  6010410ccc:	d503201f 	nop
  6010410cd0:	d503201f 	nop
  6010410cd4:	d503201f 	nop
  6010410cd8:	d503201f 	nop
  6010410cdc:	d503201f 	nop
  6010410ce0:	d503201f 	nop
  6010410ce4:	d503201f 	nop
  6010410ce8:	d503201f 	nop
  6010410cec:	d503201f 	nop
  6010410cf0:	d503201f 	nop
  6010410cf4:	d503201f 	nop
  6010410cf8:	d503201f 	nop
  6010410cfc:	d503201f 	nop
  6010410d00:	140000a1 	b	6010410f84 <badtrap>
  6010410d04:	d503201f 	nop
  6010410d08:	d503201f 	nop
  6010410d0c:	d503201f 	nop
  6010410d10:	d503201f 	nop
  6010410d14:	d503201f 	nop
  6010410d18:	d503201f 	nop
  6010410d1c:	d503201f 	nop
  6010410d20:	d503201f 	nop
  6010410d24:	d503201f 	nop
  6010410d28:	d503201f 	nop
  6010410d2c:	d503201f 	nop
  6010410d30:	d503201f 	nop
  6010410d34:	d503201f 	nop
  6010410d38:	d503201f 	nop
  6010410d3c:	d503201f 	nop
  6010410d40:	d503201f 	nop
  6010410d44:	d503201f 	nop
  6010410d48:	d503201f 	nop
  6010410d4c:	d503201f 	nop
  6010410d50:	d503201f 	nop
  6010410d54:	d503201f 	nop
  6010410d58:	d503201f 	nop
  6010410d5c:	d503201f 	nop
  6010410d60:	d503201f 	nop
  6010410d64:	d503201f 	nop
  6010410d68:	d503201f 	nop
  6010410d6c:	d503201f 	nop
  6010410d70:	d503201f 	nop
  6010410d74:	d503201f 	nop
  6010410d78:	d503201f 	nop
  6010410d7c:	d503201f 	nop
  6010410d80:	14000081 	b	6010410f84 <badtrap>
  6010410d84:	d503201f 	nop
  6010410d88:	d503201f 	nop
  6010410d8c:	d503201f 	nop
  6010410d90:	d503201f 	nop
  6010410d94:	d503201f 	nop
  6010410d98:	d503201f 	nop
  6010410d9c:	d503201f 	nop
  6010410da0:	d503201f 	nop
  6010410da4:	d503201f 	nop
  6010410da8:	d503201f 	nop
  6010410dac:	d503201f 	nop
  6010410db0:	d503201f 	nop
  6010410db4:	d503201f 	nop
  6010410db8:	d503201f 	nop
  6010410dbc:	d503201f 	nop
  6010410dc0:	d503201f 	nop
  6010410dc4:	d503201f 	nop
  6010410dc8:	d503201f 	nop
  6010410dcc:	d503201f 	nop
  6010410dd0:	d503201f 	nop
  6010410dd4:	d503201f 	nop
  6010410dd8:	d503201f 	nop
  6010410ddc:	d503201f 	nop
  6010410de0:	d503201f 	nop
  6010410de4:	d503201f 	nop
  6010410de8:	d503201f 	nop
  6010410dec:	d503201f 	nop
  6010410df0:	d503201f 	nop
  6010410df4:	d503201f 	nop
  6010410df8:	d503201f 	nop
  6010410dfc:	d503201f 	nop
  6010410e00:	14000061 	b	6010410f84 <badtrap>
  6010410e04:	d503201f 	nop
  6010410e08:	d503201f 	nop
  6010410e0c:	d503201f 	nop
  6010410e10:	d503201f 	nop
  6010410e14:	d503201f 	nop
  6010410e18:	d503201f 	nop
  6010410e1c:	d503201f 	nop
  6010410e20:	d503201f 	nop
  6010410e24:	d503201f 	nop
  6010410e28:	d503201f 	nop
  6010410e2c:	d503201f 	nop
  6010410e30:	d503201f 	nop
  6010410e34:	d503201f 	nop
  6010410e38:	d503201f 	nop
  6010410e3c:	d503201f 	nop
  6010410e40:	d503201f 	nop
  6010410e44:	d503201f 	nop
  6010410e48:	d503201f 	nop
  6010410e4c:	d503201f 	nop
  6010410e50:	d503201f 	nop
  6010410e54:	d503201f 	nop
  6010410e58:	d503201f 	nop
  6010410e5c:	d503201f 	nop
  6010410e60:	d503201f 	nop
  6010410e64:	d503201f 	nop
  6010410e68:	d503201f 	nop
  6010410e6c:	d503201f 	nop
  6010410e70:	d503201f 	nop
  6010410e74:	d503201f 	nop
  6010410e78:	d503201f 	nop
  6010410e7c:	d503201f 	nop
  6010410e80:	14000041 	b	6010410f84 <badtrap>
  6010410e84:	d503201f 	nop
  6010410e88:	d503201f 	nop
  6010410e8c:	d503201f 	nop
  6010410e90:	d503201f 	nop
  6010410e94:	d503201f 	nop
  6010410e98:	d503201f 	nop
  6010410e9c:	d503201f 	nop
  6010410ea0:	d503201f 	nop
  6010410ea4:	d503201f 	nop
  6010410ea8:	d503201f 	nop
  6010410eac:	d503201f 	nop
  6010410eb0:	d503201f 	nop
  6010410eb4:	d503201f 	nop
  6010410eb8:	d503201f 	nop
  6010410ebc:	d503201f 	nop
  6010410ec0:	d503201f 	nop
  6010410ec4:	d503201f 	nop
  6010410ec8:	d503201f 	nop
  6010410ecc:	d503201f 	nop
  6010410ed0:	d503201f 	nop
  6010410ed4:	d503201f 	nop
  6010410ed8:	d503201f 	nop
  6010410edc:	d503201f 	nop
  6010410ee0:	d503201f 	nop
  6010410ee4:	d503201f 	nop
  6010410ee8:	d503201f 	nop
  6010410eec:	d503201f 	nop
  6010410ef0:	d503201f 	nop
  6010410ef4:	d503201f 	nop
  6010410ef8:	d503201f 	nop
  6010410efc:	d503201f 	nop
  6010410f00:	14000021 	b	6010410f84 <badtrap>
  6010410f04:	d503201f 	nop
  6010410f08:	d503201f 	nop
  6010410f0c:	d503201f 	nop
  6010410f10:	d503201f 	nop
  6010410f14:	d503201f 	nop
  6010410f18:	d503201f 	nop
  6010410f1c:	d503201f 	nop
  6010410f20:	d503201f 	nop
  6010410f24:	d503201f 	nop
  6010410f28:	d503201f 	nop
  6010410f2c:	d503201f 	nop
  6010410f30:	d503201f 	nop
  6010410f34:	d503201f 	nop
  6010410f38:	d503201f 	nop
  6010410f3c:	d503201f 	nop
  6010410f40:	d503201f 	nop
  6010410f44:	d503201f 	nop
  6010410f48:	d503201f 	nop
  6010410f4c:	d503201f 	nop
  6010410f50:	d503201f 	nop
  6010410f54:	d503201f 	nop
  6010410f58:	d503201f 	nop
  6010410f5c:	d503201f 	nop
  6010410f60:	d503201f 	nop
  6010410f64:	d503201f 	nop
  6010410f68:	d503201f 	nop
  6010410f6c:	d503201f 	nop
  6010410f70:	d503201f 	nop
  6010410f74:	d503201f 	nop
  6010410f78:	d503201f 	nop
  6010410f7c:	d503201f 	nop
  6010410f80:	14000001 	b	6010410f84 <badtrap>

0000006010410f84 <badtrap>:
  6010410f84:	d5034fdf 	msr	daifset, #0xf
  6010410f88:	d10443ff 	sub	sp, sp, #0x110
  6010410f8c:	a90007e0 	stp	x0, x1, [sp]
  6010410f90:	a9010fe2 	stp	x2, x3, [sp, #16]
  6010410f94:	a90217e4 	stp	x4, x5, [sp, #32]
  6010410f98:	a9031fe6 	stp	x6, x7, [sp, #48]
  6010410f9c:	a90427e8 	stp	x8, x9, [sp, #64]
  6010410fa0:	a9052fea 	stp	x10, x11, [sp, #80]
  6010410fa4:	a90637ec 	stp	x12, x13, [sp, #96]
  6010410fa8:	a9073fee 	stp	x14, x15, [sp, #112]
  6010410fac:	a90847f0 	stp	x16, x17, [sp, #128]
  6010410fb0:	a9094ff2 	stp	x18, x19, [sp, #144]
  6010410fb4:	a90a57f4 	stp	x20, x21, [sp, #160]
  6010410fb8:	a90b5ff6 	stp	x22, x23, [sp, #176]
  6010410fbc:	a90c67f8 	stp	x24, x25, [sp, #192]
  6010410fc0:	a90d6ffa 	stp	x26, x27, [sp, #208]
  6010410fc4:	a90e77fc 	stp	x28, x29, [sp, #224]
  6010410fc8:	d5384029 	mrs	x9, elr_el1
  6010410fcc:	d538400a 	mrs	x10, spsr_el1
  6010410fd0:	910443eb 	add	x11, sp, #0x110
  6010410fd4:	a90f27fe 	stp	x30, x9, [sp, #240]
  6010410fd8:	a9102fea 	stp	x10, x11, [sp, #256]
  6010410fdc:	910003e0 	mov	x0, sp
  6010410fe0:	97fff99d 	bl	601040f654 <kernel_intr_handler>
  6010410fe4:	14000000 	b	6010410fe4 <badtrap+0x60>

0000006010410fe8 <el1sync>:
  6010410fe8:	d5034fdf 	msr	daifset, #0xf
  6010410fec:	d10443ff 	sub	sp, sp, #0x110
  6010410ff0:	a90007e0 	stp	x0, x1, [sp]
  6010410ff4:	a9010fe2 	stp	x2, x3, [sp, #16]
  6010410ff8:	a90217e4 	stp	x4, x5, [sp, #32]
  6010410ffc:	a9031fe6 	stp	x6, x7, [sp, #48]
  6010411000:	a90427e8 	stp	x8, x9, [sp, #64]
  6010411004:	a9052fea 	stp	x10, x11, [sp, #80]
  6010411008:	a90637ec 	stp	x12, x13, [sp, #96]
  601041100c:	a9073fee 	stp	x14, x15, [sp, #112]
  6010411010:	a90847f0 	stp	x16, x17, [sp, #128]
  6010411014:	a9094ff2 	stp	x18, x19, [sp, #144]
  6010411018:	a90a57f4 	stp	x20, x21, [sp, #160]
  601041101c:	a90b5ff6 	stp	x22, x23, [sp, #176]
  6010411020:	a90c67f8 	stp	x24, x25, [sp, #192]
  6010411024:	a90d6ffa 	stp	x26, x27, [sp, #208]
  6010411028:	a90e77fc 	stp	x28, x29, [sp, #224]
  601041102c:	d5384029 	mrs	x9, elr_el1
  6010411030:	d538400a 	mrs	x10, spsr_el1
  6010411034:	910443eb 	add	x11, sp, #0x110
  6010411038:	a90f27fe 	stp	x30, x9, [sp, #240]
  601041103c:	a9102fea 	stp	x10, x11, [sp, #256]
  6010411040:	910003e0 	mov	x0, sp
  6010411044:	97fff936 	bl	601040f51c <kernel_abort_handler>
  6010411048:	14000000 	b	6010411048 <el1sync+0x60>

000000601041104c <el1irq>:
  601041104c:	d5034fdf 	msr	daifset, #0xf
  6010411050:	d10443ff 	sub	sp, sp, #0x110
  6010411054:	a90007e0 	stp	x0, x1, [sp]
  6010411058:	a9010fe2 	stp	x2, x3, [sp, #16]
  601041105c:	a90217e4 	stp	x4, x5, [sp, #32]
  6010411060:	a9031fe6 	stp	x6, x7, [sp, #48]
  6010411064:	a90427e8 	stp	x8, x9, [sp, #64]
  6010411068:	a9052fea 	stp	x10, x11, [sp, #80]
  601041106c:	a90637ec 	stp	x12, x13, [sp, #96]
  6010411070:	a9073fee 	stp	x14, x15, [sp, #112]
  6010411074:	a90847f0 	stp	x16, x17, [sp, #128]
  6010411078:	a9094ff2 	stp	x18, x19, [sp, #144]
  601041107c:	a90a57f4 	stp	x20, x21, [sp, #160]
  6010411080:	a90b5ff6 	stp	x22, x23, [sp, #176]
  6010411084:	a90c67f8 	stp	x24, x25, [sp, #192]
  6010411088:	a90d6ffa 	stp	x26, x27, [sp, #208]
  601041108c:	a90e77fc 	stp	x28, x29, [sp, #224]
  6010411090:	d5384029 	mrs	x9, elr_el1
  6010411094:	d538400a 	mrs	x10, spsr_el1
  6010411098:	d538410b 	mrs	x11, sp_el0
  601041109c:	a90f27fe 	stp	x30, x9, [sp, #240]
  60104110a0:	a9102fea 	stp	x10, x11, [sp, #256]
  60104110a4:	910003e0 	mov	x0, sp
  60104110a8:	940022e9 	bl	6010419c4c <intr_irq_dispatch>
  60104110ac:	a94f27fe 	ldp	x30, x9, [sp, #240]
  60104110b0:	a9502fea 	ldp	x10, x11, [sp, #256]
  60104110b4:	d5184029 	msr	elr_el1, x9
  60104110b8:	d518400a 	msr	spsr_el1, x10
  60104110bc:	d518410b 	msr	sp_el0, x11
  60104110c0:	a94007e0 	ldp	x0, x1, [sp]
  60104110c4:	a9410fe2 	ldp	x2, x3, [sp, #16]
  60104110c8:	a94217e4 	ldp	x4, x5, [sp, #32]
  60104110cc:	a9431fe6 	ldp	x6, x7, [sp, #48]
  60104110d0:	a94427e8 	ldp	x8, x9, [sp, #64]
  60104110d4:	a9452fea 	ldp	x10, x11, [sp, #80]
  60104110d8:	a94637ec 	ldp	x12, x13, [sp, #96]
  60104110dc:	a9473fee 	ldp	x14, x15, [sp, #112]
  60104110e0:	a94847f0 	ldp	x16, x17, [sp, #128]
  60104110e4:	a9494ff2 	ldp	x18, x19, [sp, #144]
  60104110e8:	a94a57f4 	ldp	x20, x21, [sp, #160]
  60104110ec:	a94b5ff6 	ldp	x22, x23, [sp, #176]
  60104110f0:	a94c67f8 	ldp	x24, x25, [sp, #192]
  60104110f4:	a94d6ffa 	ldp	x26, x27, [sp, #208]
  60104110f8:	a94e77fc 	ldp	x28, x29, [sp, #224]
  60104110fc:	910443ff 	add	sp, sp, #0x110
  6010411100:	d69f03e0 	eret

0000006010411104 <el0sync>:
  6010411104:	d5034fdf 	msr	daifset, #0xf
  6010411108:	d10443ff 	sub	sp, sp, #0x110
  601041110c:	a90007e0 	stp	x0, x1, [sp]
  6010411110:	a9010fe2 	stp	x2, x3, [sp, #16]
  6010411114:	a90217e4 	stp	x4, x5, [sp, #32]
  6010411118:	a9031fe6 	stp	x6, x7, [sp, #48]
  601041111c:	a90427e8 	stp	x8, x9, [sp, #64]
  6010411120:	a9052fea 	stp	x10, x11, [sp, #80]
  6010411124:	a90637ec 	stp	x12, x13, [sp, #96]
  6010411128:	a9073fee 	stp	x14, x15, [sp, #112]
  601041112c:	a90847f0 	stp	x16, x17, [sp, #128]
  6010411130:	a9094ff2 	stp	x18, x19, [sp, #144]
  6010411134:	a90a57f4 	stp	x20, x21, [sp, #160]
  6010411138:	a90b5ff6 	stp	x22, x23, [sp, #176]
  601041113c:	a90c67f8 	stp	x24, x25, [sp, #192]
  6010411140:	a90d6ffa 	stp	x26, x27, [sp, #208]
  6010411144:	a90e77fc 	stp	x28, x29, [sp, #224]
  6010411148:	d5384029 	mrs	x9, elr_el1
  601041114c:	d538400a 	mrs	x10, spsr_el1
  6010411150:	d538410b 	mrs	x11, sp_el0
  6010411154:	a90f27fe 	stp	x30, x9, [sp, #240]
  6010411158:	a9102fea 	stp	x10, x11, [sp, #256]
  601041115c:	910003e0 	mov	x0, sp
  6010411160:	97fff946 	bl	601040f678 <syscall_arch_handler>
  6010411164:	a94f27fe 	ldp	x30, x9, [sp, #240]
  6010411168:	a9502fea 	ldp	x10, x11, [sp, #256]
  601041116c:	d5184029 	msr	elr_el1, x9
  6010411170:	d518400a 	msr	spsr_el1, x10
  6010411174:	d518410b 	msr	sp_el0, x11
  6010411178:	a94007e0 	ldp	x0, x1, [sp]
  601041117c:	a9410fe2 	ldp	x2, x3, [sp, #16]
  6010411180:	a94217e4 	ldp	x4, x5, [sp, #32]
  6010411184:	a9431fe6 	ldp	x6, x7, [sp, #48]
  6010411188:	a94427e8 	ldp	x8, x9, [sp, #64]
  601041118c:	a9452fea 	ldp	x10, x11, [sp, #80]
  6010411190:	a94637ec 	ldp	x12, x13, [sp, #96]
  6010411194:	a9473fee 	ldp	x14, x15, [sp, #112]
  6010411198:	a94847f0 	ldp	x16, x17, [sp, #128]
  601041119c:	a9494ff2 	ldp	x18, x19, [sp, #144]
  60104111a0:	a94a57f4 	ldp	x20, x21, [sp, #160]
  60104111a4:	a94b5ff6 	ldp	x22, x23, [sp, #176]
  60104111a8:	a94c67f8 	ldp	x24, x25, [sp, #192]
  60104111ac:	a94d6ffa 	ldp	x26, x27, [sp, #208]
  60104111b0:	a94e77fc 	ldp	x28, x29, [sp, #224]
  60104111b4:	910443ff 	add	sp, sp, #0x110
  60104111b8:	d69f03e0 	eret

00000060104111bc <el0irq>:
  60104111bc:	d5034fdf 	msr	daifset, #0xf
  60104111c0:	d10443ff 	sub	sp, sp, #0x110
  60104111c4:	a90007e0 	stp	x0, x1, [sp]
  60104111c8:	a9010fe2 	stp	x2, x3, [sp, #16]
  60104111cc:	a90217e4 	stp	x4, x5, [sp, #32]
  60104111d0:	a9031fe6 	stp	x6, x7, [sp, #48]
  60104111d4:	a90427e8 	stp	x8, x9, [sp, #64]
  60104111d8:	a9052fea 	stp	x10, x11, [sp, #80]
  60104111dc:	a90637ec 	stp	x12, x13, [sp, #96]
  60104111e0:	a9073fee 	stp	x14, x15, [sp, #112]
  60104111e4:	a90847f0 	stp	x16, x17, [sp, #128]
  60104111e8:	a9094ff2 	stp	x18, x19, [sp, #144]
  60104111ec:	a90a57f4 	stp	x20, x21, [sp, #160]
  60104111f0:	a90b5ff6 	stp	x22, x23, [sp, #176]
  60104111f4:	a90c67f8 	stp	x24, x25, [sp, #192]
  60104111f8:	a90d6ffa 	stp	x26, x27, [sp, #208]
  60104111fc:	a90e77fc 	stp	x28, x29, [sp, #224]
  6010411200:	d5384029 	mrs	x9, elr_el1
  6010411204:	d538400a 	mrs	x10, spsr_el1
  6010411208:	d538410b 	mrs	x11, sp_el0
  601041120c:	a90f27fe 	stp	x30, x9, [sp, #240]
  6010411210:	a9102fea 	stp	x10, x11, [sp, #256]
  6010411214:	910003e0 	mov	x0, sp
  6010411218:	9400228d 	bl	6010419c4c <intr_irq_dispatch>

000000601041121c <trap_return>:
  601041121c:	a94f27fe 	ldp	x30, x9, [sp, #240]
  6010411220:	a9502fea 	ldp	x10, x11, [sp, #256]
  6010411224:	d5184029 	msr	elr_el1, x9
  6010411228:	d518400a 	msr	spsr_el1, x10
  601041122c:	d518410b 	msr	sp_el0, x11
  6010411230:	a94007e0 	ldp	x0, x1, [sp]
  6010411234:	a9410fe2 	ldp	x2, x3, [sp, #16]
  6010411238:	a94217e4 	ldp	x4, x5, [sp, #32]
  601041123c:	a9431fe6 	ldp	x6, x7, [sp, #48]
  6010411240:	a94427e8 	ldp	x8, x9, [sp, #64]
  6010411244:	a9452fea 	ldp	x10, x11, [sp, #80]
  6010411248:	a94637ec 	ldp	x12, x13, [sp, #96]
  601041124c:	a9473fee 	ldp	x14, x15, [sp, #112]
  6010411250:	a94847f0 	ldp	x16, x17, [sp, #128]
  6010411254:	a9494ff2 	ldp	x18, x19, [sp, #144]
  6010411258:	a94a57f4 	ldp	x20, x21, [sp, #160]
  601041125c:	a94b5ff6 	ldp	x22, x23, [sp, #176]
  6010411260:	a94c67f8 	ldp	x24, x25, [sp, #192]
  6010411264:	a94d6ffa 	ldp	x26, x27, [sp, #208]
  6010411268:	a94e77fc 	ldp	x28, x29, [sp, #224]
  601041126c:	910443ff 	add	sp, sp, #0x110
  6010411270:	d69f03e0 	eret

0000006010411274 <_spinlock_lock>:
  6010411274:	52800022 	mov	w2, #0x1                   	// #1
  6010411278:	d50320bf 	sevl
  601041127c:	d503205f 	wfe
  6010411280:	085ffc01 	ldaxrb	w1, [x0]
  6010411284:	7103fc3f 	cmp	w1, #0xff
  6010411288:	54ffff61 	b.ne	6010411274 <_spinlock_lock>  // b.any
  601041128c:	d53800a1 	mrs	x1, mpidr_el1
  6010411290:	92400421 	and	x1, x1, #0x3
  6010411294:	08027c01 	stxrb	w2, w1, [x0]
  6010411298:	f100005f 	cmp	x2, #0x0
  601041129c:	54fffec1 	b.ne	6010411274 <_spinlock_lock>  // b.any
  60104112a0:	d5033bbf 	dmb	ish
  60104112a4:	d2800000 	mov	x0, #0x0                   	// #0
  60104112a8:	d65f03c0 	ret

00000060104112ac <_spinlock_unlock>:
  60104112ac:	d53800a1 	mrs	x1, mpidr_el1
  60104112b0:	92400421 	and	x1, x1, #0x3
  60104112b4:	b9400002 	ldr	w2, [x0]
  60104112b8:	6b02003f 	cmp	w1, w2
  60104112bc:	54000101 	b.ne	60104112dc <_spinlock_unlock+0x30>  // b.any
  60104112c0:	d5033bbf 	dmb	ish
  60104112c4:	52801fe1 	mov	w1, #0xff                  	// #255
  60104112c8:	b9000001 	str	w1, [x0]
  60104112cc:	d5033b9f 	dsb	ish
  60104112d0:	d50320bf 	sevl
  60104112d4:	d2800000 	mov	x0, #0x0                   	// #0
  60104112d8:	d65f03c0 	ret
  60104112dc:	d2800020 	mov	x0, #0x1                   	// #1
  60104112e0:	d65f03c0 	ret

00000060104112e4 <cur_cpuid>:
{
  60104112e4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  60104112e8:	910003fd 	mov	x29, sp
    return cpu_get_current();
  60104112ec:	97fff4eb 	bl	601040e698 <cpu_get_current>
}
  60104112f0:	a8c17bfd 	ldp	x29, x30, [sp], #16
  60104112f4:	d65f03c0 	ret

00000060104112f8 <module_spinlock_use_intr_init>:

static struct double_list_node lock_request_guard;
static struct lock_node core_lock_request[NR_CPU];
static struct spinlock request_lock;
bool module_spinlock_use_intr_init(void)
{
  60104112f8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  60104112fc:	910003fd 	mov	x29, sp
    for (int i = 0; i < NR_CPU; i++) {
  6010411300:	b9002fff 	str	wzr, [sp, #44]
  6010411304:	1400001a 	b	601041136c <module_spinlock_use_intr_init+0x74>
        core_lock_request[i].cpu_id = i;
  6010411308:	d0008980 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041130c:	911a4001 	add	x1, x0, #0x690
  6010411310:	b9802fe2 	ldrsw	x2, [sp, #44]
  6010411314:	d2800300 	mov	x0, #0x18                  	// #24
  6010411318:	9b007c40 	mul	x0, x2, x0
  601041131c:	8b000020 	add	x0, x1, x0
  6010411320:	b9402fe1 	ldr	w1, [sp, #44]
  6010411324:	b9001001 	str	w1, [x0, #16]
        doubleListNodeInit(&core_lock_request[i].node);
  6010411328:	b9802fe1 	ldrsw	x1, [sp, #44]
  601041132c:	d2800300 	mov	x0, #0x18                  	// #24
  6010411330:	9b007c21 	mul	x1, x1, x0
  6010411334:	d0008980 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010411338:	911a4000 	add	x0, x0, #0x690
  601041133c:	8b000020 	add	x0, x1, x0
  6010411340:	f90013e0 	str	x0, [sp, #32]
         item = DOUBLE_LIST_ENTRY(item->member.prev, __typeof__(*item), member))

__attribute__((always_inline))
static void inline doubleListNodeInit(struct double_list_node *list)
{
    list->next = list;
  6010411344:	f94013e0 	ldr	x0, [sp, #32]
  6010411348:	f94013e1 	ldr	x1, [sp, #32]
  601041134c:	f9000001 	str	x1, [x0]
    list->prev = list;
  6010411350:	f94013e0 	ldr	x0, [sp, #32]
  6010411354:	f94013e1 	ldr	x1, [sp, #32]
  6010411358:	f9000401 	str	x1, [x0, #8]
}
  601041135c:	d503201f 	nop
    for (int i = 0; i < NR_CPU; i++) {
  6010411360:	b9402fe0 	ldr	w0, [sp, #44]
  6010411364:	11000400 	add	w0, w0, #0x1
  6010411368:	b9002fe0 	str	w0, [sp, #44]
  601041136c:	b9402fe0 	ldr	w0, [sp, #44]
  6010411370:	7100001f 	cmp	w0, #0x0
  6010411374:	54fffcad 	b.le	6010411308 <module_spinlock_use_intr_init+0x10>
  6010411378:	d0008980 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041137c:	911a0000 	add	x0, x0, #0x680
  6010411380:	f9000fe0 	str	x0, [sp, #24]
    list->next = list;
  6010411384:	f9400fe0 	ldr	x0, [sp, #24]
  6010411388:	f9400fe1 	ldr	x1, [sp, #24]
  601041138c:	f9000001 	str	x1, [x0]
    list->prev = list;
  6010411390:	f9400fe0 	ldr	x0, [sp, #24]
  6010411394:	f9400fe1 	ldr	x1, [sp, #24]
  6010411398:	f9000401 	str	x1, [x0, #8]
}
  601041139c:	d503201f 	nop
    }
    doubleListNodeInit(&lock_request_guard);
    spinlock_init(&request_lock, "requestlock");
  60104113a0:	90000080 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104113a4:	91034001 	add	x1, x0, #0xd0
  60104113a8:	d0008980 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  60104113ac:	911b0000 	add	x0, x0, #0x6c0
  60104113b0:	94000004 	bl	60104113c0 <spinlock_init>
    return true;
  60104113b4:	52800020 	mov	w0, #0x1                   	// #1
}
  60104113b8:	a8c37bfd 	ldp	x29, x30, [sp], #48
  60104113bc:	d65f03c0 	ret

00000060104113c0 <spinlock_init>:
    SPINLOCK_LOCK_NOWAIT = 0,
    SPINLOCK_LOCK_WAITFOREVER = 0xFFFFFFFF,
};

__attribute__((optimize("O0"))) void spinlock_init(struct spinlock* lock, char* name)
{
  60104113c0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  60104113c4:	910003fd 	mov	x29, sp
  60104113c8:	f9000fe0 	str	x0, [sp, #24]
  60104113cc:	f9000be1 	str	x1, [sp, #16]
    lock->owner_cpu = SPINLOCK_STATE_UNLOCK;
  60104113d0:	f9400fe0 	ldr	x0, [sp, #24]
  60104113d4:	52801fe1 	mov	w1, #0xff                  	// #255
  60104113d8:	b9000001 	str	w1, [x0]
    strncpy(lock->name, name, 24);
  60104113dc:	f9400fe0 	ldr	x0, [sp, #24]
  60104113e0:	91001000 	add	x0, x0, #0x4
  60104113e4:	d2800302 	mov	x2, #0x18                  	// #24
  60104113e8:	f9400be1 	ldr	x1, [sp, #16]
  60104113ec:	94003ce5 	bl	6010420780 <strncpy>
}
  60104113f0:	d503201f 	nop
  60104113f4:	a8c27bfd 	ldp	x29, x30, [sp], #32
  60104113f8:	d65f03c0 	ret

00000060104113fc <spinlock_lock>:

extern int _spinlock_lock(struct spinlock* lock, uint32_t timeout);
extern void _spinlock_unlock(struct spinlock* lock);

__attribute__((optimize("O0"))) void spinlock_lock(struct spinlock* lock)
{
  60104113fc:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  6010411400:	910003fd 	mov	x29, sp
  6010411404:	f9000fe0 	str	x0, [sp, #24]
    int cur_cpu_id = cur_cpuid();
  6010411408:	97ffffb7 	bl	60104112e4 <cur_cpuid>
  601041140c:	b9005fe0 	str	w0, [sp, #92]
    if (lock->owner_cpu != SPINLOCK_STATE_UNLOCK && lock->owner_cpu == cur_cpu_id) {
  6010411410:	f9400fe0 	ldr	x0, [sp, #24]
  6010411414:	b9400000 	ldr	w0, [x0]
  6010411418:	7103fc1f 	cmp	w0, #0xff
  601041141c:	540002e0 	b.eq	6010411478 <spinlock_lock+0x7c>  // b.none
  6010411420:	f9400fe0 	ldr	x0, [sp, #24]
  6010411424:	b9400001 	ldr	w1, [x0]
  6010411428:	b9405fe0 	ldr	w0, [sp, #92]
  601041142c:	6b00003f 	cmp	w1, w0
  6010411430:	54000241 	b.ne	6010411478 <spinlock_lock+0x7c>  // b.any
        ERROR("spinlock %s lock double locked by core %d\n", lock->name, lock->owner_cpu);
  6010411434:	52800882 	mov	w2, #0x44                  	// #68
  6010411438:	90000080 	adrp	x0, 6010421000 <__func__.0+0x508>
  601041143c:	9105a001 	add	x1, x0, #0x168
  6010411440:	90000080 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010411444:	91038000 	add	x0, x0, #0xe0
  6010411448:	94000b4c 	bl	6010414178 <printf_>
  601041144c:	f9400fe0 	ldr	x0, [sp, #24]
  6010411450:	91001001 	add	x1, x0, #0x4
  6010411454:	f9400fe0 	ldr	x0, [sp, #24]
  6010411458:	b9400000 	ldr	w0, [x0]
  601041145c:	2a0003e2 	mov	w2, w0
  6010411460:	90000080 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010411464:	9103c000 	add	x0, x0, #0xf0
  6010411468:	94000b44 	bl	6010414178 <printf_>
        panic("");
  601041146c:	90000080 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010411470:	91048000 	add	x0, x0, #0x120
  6010411474:	97fff78d 	bl	601040f2a8 <panic>
    }

    struct double_list_node* p_lock_node = &core_lock_request[cur_cpu_id].node;
  6010411478:	b9805fe1 	ldrsw	x1, [sp, #92]
  601041147c:	d2800300 	mov	x0, #0x18                  	// #24
  6010411480:	9b007c21 	mul	x1, x1, x0
  6010411484:	d0008980 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010411488:	911a4000 	add	x0, x0, #0x690
  601041148c:	8b000020 	add	x0, x1, x0
  6010411490:	f9002be0 	str	x0, [sp, #80]
    _spinlock_lock(&request_lock, SPINLOCK_LOCK_WAITFOREVER);
  6010411494:	12800001 	mov	w1, #0xffffffff            	// #-1
  6010411498:	d0008980 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041149c:	911b0000 	add	x0, x0, #0x6c0
  60104114a0:	97ffff75 	bl	6010411274 <_spinlock_lock>
  60104114a4:	f9402be0 	ldr	x0, [sp, #80]
  60104114a8:	f90027e0 	str	x0, [sp, #72]
  60104114ac:	d0008980 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  60104114b0:	911a0000 	add	x0, x0, #0x680
  60104114b4:	f90023e0 	str	x0, [sp, #64]
    _double_list_add(new_node, head, head->next);
}

__attribute__((always_inline)) static void inline doubleListAddOnBack(struct double_list_node* new_node, struct double_list_node* head)
{
    _double_list_add(new_node, head->prev, head);
  60104114b8:	f94023e0 	ldr	x0, [sp, #64]
  60104114bc:	f9400400 	ldr	x0, [x0, #8]
  60104114c0:	f94027e1 	ldr	x1, [sp, #72]
  60104114c4:	f9001fe1 	str	x1, [sp, #56]
  60104114c8:	f9001be0 	str	x0, [sp, #48]
  60104114cc:	f94023e0 	ldr	x0, [sp, #64]
  60104114d0:	f90017e0 	str	x0, [sp, #40]
    next->prev = new_node;
  60104114d4:	f94017e0 	ldr	x0, [sp, #40]
  60104114d8:	f9401fe1 	ldr	x1, [sp, #56]
  60104114dc:	f9000401 	str	x1, [x0, #8]
    new_node->next = next;
  60104114e0:	f9401fe0 	ldr	x0, [sp, #56]
  60104114e4:	f94017e1 	ldr	x1, [sp, #40]
  60104114e8:	f9000001 	str	x1, [x0]
    new_node->prev = prev;
  60104114ec:	f9401fe0 	ldr	x0, [sp, #56]
  60104114f0:	f9401be1 	ldr	x1, [sp, #48]
  60104114f4:	f9000401 	str	x1, [x0, #8]
    prev->next = new_node;
  60104114f8:	f9401be0 	ldr	x0, [sp, #48]
  60104114fc:	f9401fe1 	ldr	x1, [sp, #56]
  6010411500:	f9000001 	str	x1, [x0]
}
  6010411504:	d503201f 	nop
}
  6010411508:	d503201f 	nop
    doubleListAddOnBack(p_lock_node, &lock_request_guard);
    _spinlock_unlock(&request_lock);
  601041150c:	d0008980 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010411510:	911b0000 	add	x0, x0, #0x6c0
  6010411514:	97ffff66 	bl	60104112ac <_spinlock_unlock>

    while (lock_request_guard.next != p_lock_node)
  6010411518:	d503201f 	nop
  601041151c:	d0008980 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010411520:	911a0000 	add	x0, x0, #0x680
  6010411524:	f9400000 	ldr	x0, [x0]
  6010411528:	f9402be1 	ldr	x1, [sp, #80]
  601041152c:	eb00003f 	cmp	x1, x0
  6010411530:	54ffff61 	b.ne	601041151c <spinlock_lock+0x120>  // b.any
        ;

    _spinlock_lock(lock, SPINLOCK_LOCK_WAITFOREVER);
  6010411534:	12800001 	mov	w1, #0xffffffff            	// #-1
  6010411538:	f9400fe0 	ldr	x0, [sp, #24]
  601041153c:	97ffff4e 	bl	6010411274 <_spinlock_lock>
}
  6010411540:	d503201f 	nop
  6010411544:	a8c67bfd 	ldp	x29, x30, [sp], #96
  6010411548:	d65f03c0 	ret

000000601041154c <spinlock_unlock>:

__attribute__((optimize("O0"))) void spinlock_unlock(struct spinlock* lock)
{
  601041154c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  6010411550:	910003fd 	mov	x29, sp
  6010411554:	f9000fe0 	str	x0, [sp, #24]
    struct double_list_node* p_lock_node = &core_lock_request[cur_cpuid()].node;
  6010411558:	97ffff63 	bl	60104112e4 <cur_cpuid>
  601041155c:	93407c01 	sxtw	x1, w0
  6010411560:	d2800300 	mov	x0, #0x18                  	// #24
  6010411564:	9b007c21 	mul	x1, x1, x0
  6010411568:	d0008980 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041156c:	911a4000 	add	x0, x0, #0x690
  6010411570:	8b000020 	add	x0, x1, x0
  6010411574:	f9001fe0 	str	x0, [sp, #56]
    assert(lock_request_guard.next == p_lock_node);
  6010411578:	d0008980 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041157c:	911a0000 	add	x0, x0, #0x680
  6010411580:	f9400000 	ldr	x0, [x0]
  6010411584:	f9401fe1 	ldr	x1, [sp, #56]
  6010411588:	eb00003f 	cmp	x1, x0
  601041158c:	540001e0 	b.eq	60104115c8 <spinlock_unlock+0x7c>  // b.none
  6010411590:	52800ac2 	mov	w2, #0x56                  	// #86
  6010411594:	90000080 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010411598:	9105e001 	add	x1, x0, #0x178
  601041159c:	90000080 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104115a0:	91038000 	add	x0, x0, #0xe0
  60104115a4:	94000af5 	bl	6010414178 <printf_>
  60104115a8:	90000080 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104115ac:	9104a001 	add	x1, x0, #0x128
  60104115b0:	90000080 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104115b4:	91054000 	add	x0, x0, #0x150
  60104115b8:	94000af0 	bl	6010414178 <printf_>
  60104115bc:	90000080 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104115c0:	91058000 	add	x0, x0, #0x160
  60104115c4:	97fff739 	bl	601040f2a8 <panic>
    _spinlock_lock(&request_lock, SPINLOCK_LOCK_WAITFOREVER);
  60104115c8:	12800001 	mov	w1, #0xffffffff            	// #-1
  60104115cc:	d0008980 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  60104115d0:	911b0000 	add	x0, x0, #0x6c0
  60104115d4:	97ffff28 	bl	6010411274 <_spinlock_lock>
    _double_list_del(p_lock_node->prev, p_lock_node->next);
  60104115d8:	f9401fe0 	ldr	x0, [sp, #56]
  60104115dc:	f9400401 	ldr	x1, [x0, #8]
  60104115e0:	f9401fe0 	ldr	x0, [sp, #56]
  60104115e4:	f9400000 	ldr	x0, [x0]
  60104115e8:	f9001be1 	str	x1, [sp, #48]
  60104115ec:	f90017e0 	str	x0, [sp, #40]
    next->prev = prev;
  60104115f0:	f94017e0 	ldr	x0, [sp, #40]
  60104115f4:	f9401be1 	ldr	x1, [sp, #48]
  60104115f8:	f9000401 	str	x1, [x0, #8]
    prev->next = next;
  60104115fc:	f9401be0 	ldr	x0, [sp, #48]
  6010411600:	f94017e1 	ldr	x1, [sp, #40]
  6010411604:	f9000001 	str	x1, [x0]
}
  6010411608:	d503201f 	nop
    _spinlock_unlock(&request_lock);
  601041160c:	d0008980 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010411610:	911b0000 	add	x0, x0, #0x6c0
  6010411614:	97ffff26 	bl	60104112ac <_spinlock_unlock>

    _spinlock_unlock(lock);
  6010411618:	f9400fe0 	ldr	x0, [sp, #24]
  601041161c:	97ffff24 	bl	60104112ac <_spinlock_unlock>
}
  6010411620:	d503201f 	nop
  6010411624:	a8c47bfd 	ldp	x29, x30, [sp], #64
  6010411628:	d65f03c0 	ret

000000601041162c <spinlock_try_lock>:

__attribute__((optimize("O0"))) bool spinlock_try_lock(struct spinlock* lock)
{
  601041162c:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
  6010411630:	910003fd 	mov	x29, sp
  6010411634:	f9000fe0 	str	x0, [sp, #24]
    int cur_cpu_id = cur_cpuid();
  6010411638:	97ffff2b 	bl	60104112e4 <cur_cpuid>
  601041163c:	b9006fe0 	str	w0, [sp, #108]
    if (lock->owner_cpu != SPINLOCK_STATE_UNLOCK && lock->owner_cpu == cur_cpu_id) {
  6010411640:	f9400fe0 	ldr	x0, [sp, #24]
  6010411644:	b9400000 	ldr	w0, [x0]
  6010411648:	7103fc1f 	cmp	w0, #0xff
  601041164c:	540002e0 	b.eq	60104116a8 <spinlock_try_lock+0x7c>  // b.none
  6010411650:	f9400fe0 	ldr	x0, [sp, #24]
  6010411654:	b9400001 	ldr	w1, [x0]
  6010411658:	b9406fe0 	ldr	w0, [sp, #108]
  601041165c:	6b00003f 	cmp	w1, w0
  6010411660:	54000241 	b.ne	60104116a8 <spinlock_try_lock+0x7c>  // b.any
        ERROR("spinlock %s lock double locked by core %d\n", lock->name, lock->owner_cpu);
  6010411664:	52800c42 	mov	w2, #0x62                  	// #98
  6010411668:	90000080 	adrp	x0, 6010421000 <__func__.0+0x508>
  601041166c:	91062001 	add	x1, x0, #0x188
  6010411670:	90000080 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010411674:	91038000 	add	x0, x0, #0xe0
  6010411678:	94000ac0 	bl	6010414178 <printf_>
  601041167c:	f9400fe0 	ldr	x0, [sp, #24]
  6010411680:	91001001 	add	x1, x0, #0x4
  6010411684:	f9400fe0 	ldr	x0, [sp, #24]
  6010411688:	b9400000 	ldr	w0, [x0]
  601041168c:	2a0003e2 	mov	w2, w0
  6010411690:	90000080 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010411694:	9103c000 	add	x0, x0, #0xf0
  6010411698:	94000ab8 	bl	6010414178 <printf_>
        panic("");
  601041169c:	90000080 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104116a0:	91048000 	add	x0, x0, #0x120
  60104116a4:	97fff701 	bl	601040f2a8 <panic>
    }

    struct double_list_node* p_lock_node = &core_lock_request[cur_cpu_id].node;
  60104116a8:	b9806fe1 	ldrsw	x1, [sp, #108]
  60104116ac:	d2800300 	mov	x0, #0x18                  	// #24
  60104116b0:	9b007c21 	mul	x1, x1, x0
  60104116b4:	d0008980 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  60104116b8:	911a4000 	add	x0, x0, #0x690
  60104116bc:	8b000020 	add	x0, x1, x0
  60104116c0:	f90033e0 	str	x0, [sp, #96]
    _spinlock_lock(&request_lock, SPINLOCK_LOCK_WAITFOREVER);
  60104116c4:	12800001 	mov	w1, #0xffffffff            	// #-1
  60104116c8:	d0008980 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  60104116cc:	911b0000 	add	x0, x0, #0x6c0
  60104116d0:	97fffee9 	bl	6010411274 <_spinlock_lock>
  60104116d4:	f94033e0 	ldr	x0, [sp, #96]
  60104116d8:	f9002fe0 	str	x0, [sp, #88]
  60104116dc:	d0008980 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  60104116e0:	911a0000 	add	x0, x0, #0x680
  60104116e4:	f9002be0 	str	x0, [sp, #80]
    _double_list_add(new_node, head->prev, head);
  60104116e8:	f9402be0 	ldr	x0, [sp, #80]
  60104116ec:	f9400400 	ldr	x0, [x0, #8]
  60104116f0:	f9402fe1 	ldr	x1, [sp, #88]
  60104116f4:	f90027e1 	str	x1, [sp, #72]
  60104116f8:	f90023e0 	str	x0, [sp, #64]
  60104116fc:	f9402be0 	ldr	x0, [sp, #80]
  6010411700:	f9001fe0 	str	x0, [sp, #56]
    next->prev = new_node;
  6010411704:	f9401fe0 	ldr	x0, [sp, #56]
  6010411708:	f94027e1 	ldr	x1, [sp, #72]
  601041170c:	f9000401 	str	x1, [x0, #8]
    new_node->next = next;
  6010411710:	f94027e0 	ldr	x0, [sp, #72]
  6010411714:	f9401fe1 	ldr	x1, [sp, #56]
  6010411718:	f9000001 	str	x1, [x0]
    new_node->prev = prev;
  601041171c:	f94027e0 	ldr	x0, [sp, #72]
  6010411720:	f94023e1 	ldr	x1, [sp, #64]
  6010411724:	f9000401 	str	x1, [x0, #8]
    prev->next = new_node;
  6010411728:	f94023e0 	ldr	x0, [sp, #64]
  601041172c:	f94027e1 	ldr	x1, [sp, #72]
  6010411730:	f9000001 	str	x1, [x0]
}
  6010411734:	d503201f 	nop
}
  6010411738:	d503201f 	nop
    doubleListAddOnBack(p_lock_node, &lock_request_guard);
    if (lock_request_guard.next != p_lock_node) {
  601041173c:	d0008980 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010411740:	911a0000 	add	x0, x0, #0x680
  6010411744:	f9400000 	ldr	x0, [x0]
  6010411748:	f94033e1 	ldr	x1, [sp, #96]
  601041174c:	eb00003f 	cmp	x1, x0
  6010411750:	54000260 	b.eq	601041179c <spinlock_try_lock+0x170>  // b.none
        _double_list_del(p_lock_node->prev, p_lock_node->next);
  6010411754:	f94033e0 	ldr	x0, [sp, #96]
  6010411758:	f9400401 	ldr	x1, [x0, #8]
  601041175c:	f94033e0 	ldr	x0, [sp, #96]
  6010411760:	f9400000 	ldr	x0, [x0]
  6010411764:	f9001be1 	str	x1, [sp, #48]
  6010411768:	f90017e0 	str	x0, [sp, #40]
    next->prev = prev;
  601041176c:	f94017e0 	ldr	x0, [sp, #40]
  6010411770:	f9401be1 	ldr	x1, [sp, #48]
  6010411774:	f9000401 	str	x1, [x0, #8]
    prev->next = next;
  6010411778:	f9401be0 	ldr	x0, [sp, #48]
  601041177c:	f94017e1 	ldr	x1, [sp, #40]
  6010411780:	f9000001 	str	x1, [x0]
}
  6010411784:	d503201f 	nop
        _spinlock_unlock(&request_lock);
  6010411788:	d0008980 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041178c:	911b0000 	add	x0, x0, #0x6c0
  6010411790:	97fffec7 	bl	60104112ac <_spinlock_unlock>
        return false;
  6010411794:	52800000 	mov	w0, #0x0                   	// #0
  6010411798:	14000008 	b	60104117b8 <spinlock_try_lock+0x18c>
    }
    _spinlock_unlock(&request_lock);
  601041179c:	d0008980 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  60104117a0:	911b0000 	add	x0, x0, #0x6c0
  60104117a4:	97fffec2 	bl	60104112ac <_spinlock_unlock>
    _spinlock_lock(lock, SPINLOCK_LOCK_WAITFOREVER);
  60104117a8:	12800001 	mov	w1, #0xffffffff            	// #-1
  60104117ac:	f9400fe0 	ldr	x0, [sp, #24]
  60104117b0:	97fffeb1 	bl	6010411274 <_spinlock_lock>

    return true;
  60104117b4:	52800020 	mov	w0, #0x1                   	// #1
}
  60104117b8:	a8c77bfd 	ldp	x29, x30, [sp], #112
  60104117bc:	d65f03c0 	ret

00000060104117c0 <is_spinlock_hold_by_current_cpu>:

bool is_spinlock_hold_by_current_cpu(struct spinlock* lock)
{
  60104117c0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  60104117c4:	910003fd 	mov	x29, sp
  60104117c8:	f9000bf3 	str	x19, [sp, #16]
  60104117cc:	f90017e0 	str	x0, [sp, #40]
    return lock->owner_cpu == cur_cpuid();
  60104117d0:	f94017e0 	ldr	x0, [sp, #40]
  60104117d4:	b9400013 	ldr	w19, [x0]
  60104117d8:	97fffec3 	bl	60104112e4 <cur_cpuid>
  60104117dc:	6b00027f 	cmp	w19, w0
  60104117e0:	1a9f17e0 	cset	w0, eq  // eq = none
  60104117e4:	12001c00 	and	w0, w0, #0xff
  60104117e8:	f9400bf3 	ldr	x19, [sp, #16]
  60104117ec:	a8c37bfd 	ldp	x29, x30, [sp], #48
  60104117f0:	d65f03c0 	ret

00000060104117f4 <uartinit>:
// static char uart_tx_buf[UART_TX_BUF_SIZE];
uint64_t uart_tx_w; // write next to uart_tx_buf[uart_tx_w % UART_TX_BUF_SIZE]
uint64_t uart_tx_r; // read next from uart_tx_buf[uart_tx_r % UART_TX_BUF_SIZE]

void uartinit(void)
{
  60104117f4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  60104117f8:	910003fd 	mov	x29, sp
    // UART_WRITE_REG(CR, 0x301);

    // // enable transmit and receive interrupts.
    // UART_WRITE_REG(IMSC, INT_RX_ENABLE | INT_TX_ENABLE);

    _debug_uart_init();
  60104117fc:	94000042 	bl	6010411904 <_debug_uart_init>
}
  6010411800:	d503201f 	nop
  6010411804:	a8c17bfd 	ldp	x29, x30, [sp], #16
  6010411808:	d65f03c0 	ret

000000601041180c <uartstart>:

    //     // maybe uartputc() is waiting for space in the buffer.

    //     UART_WRITE_REG(DR, c);
    // }
}
  601041180c:	d503201f 	nop
  6010411810:	d65f03c0 	ret

0000006010411814 <uartputc>:

void uartputc(uint8_t c)
{
  6010411814:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  6010411818:	910003fd 	mov	x29, sp
  601041181c:	39007fe0 	strb	w0, [sp, #31]
    //     ;
    // uart_tx_buf[uart_tx_w % UART_TX_BUF_SIZE] = c;
    // uart_tx_w += 1;
    // uartstart();
    // return;
    _debug_uart_putc((int)c);
  6010411820:	39407fe0 	ldrb	w0, [sp, #31]
  6010411824:	9400006f 	bl	60104119e0 <_debug_uart_putc>
}
  6010411828:	d503201f 	nop
  601041182c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  6010411830:	d65f03c0 	ret

0000006010411834 <uartgetc>:
{
    // if (UART_READ_REG(FR) & FR_RXFE)
    //     return 0xFF;
    // else
    //     return UART_READ_REG(DR);
    return 0xFF;
  6010411834:	52801fe0 	mov	w0, #0xff                  	// #255
}
  6010411838:	d65f03c0 	ret

000000601041183c <UartGetIrqnum>:

static uint32_t UartGetIrqnum()
{
    return 0;
  601041183c:	52800000 	mov	w0, #0x0                   	// #0
}
  6010411840:	d65f03c0 	ret

0000006010411844 <hardkernel_uart_init>:
    .putc = uartputc,
    .getc = uartgetc,
};

struct XiziSerialDriver* hardkernel_uart_init(struct TraceTag* hardkernel_tag)
{
  6010411844:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  6010411848:	910003fd 	mov	x29, sp
  601041184c:	f9000fe0 	str	x0, [sp, #24]
    hardkernel_serial_driver.sys_serial_init();
  6010411850:	f0000080 	adrp	x0, 6010424000 <impure_data+0x210>
  6010411854:	9139e000 	add	x0, x0, #0xe78
  6010411858:	f9400000 	ldr	x0, [x0]
  601041185c:	d63f0000 	blr	x0
    return &hardkernel_serial_driver;
  6010411860:	f0000080 	adrp	x0, 6010424000 <impure_data+0x210>
  6010411864:	9139e000 	add	x0, x0, #0xe78
  6010411868:	a8c27bfd 	ldp	x29, x30, [sp], #32
  601041186c:	d65f03c0 	ret

0000006010411870 <serial_out_shift>:
#define serial_din(reg)                                                          \
    serial_in_shift((char*)com_port + ((char*)reg - (char*)com_port) * (1 << 2), \
        2)

static inline void serial_out_shift(void* addr, int shift, int value)
{
  6010411870:	d10043ff 	sub	sp, sp, #0x10
  6010411874:	f90007e0 	str	x0, [sp, #8]
  6010411878:	b90007e1 	str	w1, [sp, #4]
  601041187c:	b90003e2 	str	w2, [sp]
    out_le32(addr, value);
  6010411880:	b94003e1 	ldr	w1, [sp]
  6010411884:	f94007e0 	ldr	x0, [sp, #8]
  6010411888:	b9000001 	str	w1, [x0]
}
  601041188c:	d503201f 	nop
  6010411890:	910043ff 	add	sp, sp, #0x10
  6010411894:	d65f03c0 	ret

0000006010411898 <serial_in_shift>:

static inline int serial_in_shift(void* addr, int shift)
{
  6010411898:	d10043ff 	sub	sp, sp, #0x10
  601041189c:	f90007e0 	str	x0, [sp, #8]
  60104118a0:	b90007e1 	str	w1, [sp, #4]
    return in_le32(addr);
  60104118a4:	f94007e0 	ldr	x0, [sp, #8]
  60104118a8:	b9400000 	ldr	w0, [x0]
}
  60104118ac:	910043ff 	add	sp, sp, #0x10
  60104118b0:	d65f03c0 	ret

00000060104118b4 <ns16550_calc_divisor>:
        typeof(divisor) __d = divisor;                                                                                                       \
        (((typeof(x))-1) > 0 || ((typeof(divisor))-1) > 0 || (__x) > 0) ? (((__x) + ((__d) / 2)) / (__d)) : (((__x) - ((__d) / 2)) / (__d)); \
    })

int ns16550_calc_divisor(NS16550_t port, int clock, int baudrate)
{
  60104118b4:	d10083ff 	sub	sp, sp, #0x20
  60104118b8:	f90007e0 	str	x0, [sp, #8]
  60104118bc:	b90007e1 	str	w1, [sp, #4]
  60104118c0:	b90003e2 	str	w2, [sp]
    const unsigned int mode_x_div = 16;
  60104118c4:	52800200 	mov	w0, #0x10                  	// #16
  60104118c8:	b9001fe0 	str	w0, [sp, #28]

    return DIV_ROUND_CLOSEST(clock, mode_x_div * baudrate);
  60104118cc:	b94007e0 	ldr	w0, [sp, #4]
  60104118d0:	b9001be0 	str	w0, [sp, #24]
  60104118d4:	b94003e0 	ldr	w0, [sp]
  60104118d8:	b9401fe1 	ldr	w1, [sp, #28]
  60104118dc:	1b007c20 	mul	w0, w1, w0
  60104118e0:	b90017e0 	str	w0, [sp, #20]
  60104118e4:	b94017e0 	ldr	w0, [sp, #20]
  60104118e8:	53017c01 	lsr	w1, w0, #1
  60104118ec:	b9401be0 	ldr	w0, [sp, #24]
  60104118f0:	0b000021 	add	w1, w1, w0
  60104118f4:	b94017e0 	ldr	w0, [sp, #20]
  60104118f8:	1ac00820 	udiv	w0, w1, w0
}
  60104118fc:	910083ff 	add	sp, sp, #0x20
  6010411900:	d65f03c0 	ret

0000006010411904 <_debug_uart_init>:

void _debug_uart_init(void)
{
  6010411904:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  6010411908:	910003fd 	mov	x29, sp
    struct NS16550* com_port = (struct NS16550*)UART_ADDR;
  601041190c:	d2bfccc0 	mov	x0, #0xfe660000            	// #4268097536
  6010411910:	f2c00800 	movk	x0, #0x40, lsl #32
  6010411914:	f9000fe0 	str	x0, [sp, #24]
     * We copy the code from above because it is already horribly messy.
     * Trying to refactor to nicely remove the duplication doesn't seem
     * feasible. The better fix is to move all users of this driver to
     * driver model.
     */
    int baud_divisor = ns16550_calc_divisor(com_port, 24000000,
  6010411918:	529c6c02 	mov	w2, #0xe360                	// #58208
  601041191c:	72a002c2 	movk	w2, #0x16, lsl #16
  6010411920:	5286c001 	mov	w1, #0x3600                	// #13824
  6010411924:	72a02dc1 	movk	w1, #0x16e, lsl #16
  6010411928:	f9400fe0 	ldr	x0, [sp, #24]
  601041192c:	97ffffe2 	bl	60104118b4 <ns16550_calc_divisor>
  6010411930:	b90017e0 	str	w0, [sp, #20]
        1500000);
    serial_dout(&com_port->ier, CONFIG_SYS_NS16550_IER);
  6010411934:	f9400fe0 	ldr	x0, [sp, #24]
  6010411938:	91001000 	add	x0, x0, #0x4
  601041193c:	52800002 	mov	w2, #0x0                   	// #0
  6010411940:	52800041 	mov	w1, #0x2                   	// #2
  6010411944:	97ffffcb 	bl	6010411870 <serial_out_shift>
    serial_dout(&com_port->mcr, UART_MCRVAL);
  6010411948:	f9400fe0 	ldr	x0, [sp, #24]
  601041194c:	91004000 	add	x0, x0, #0x10
  6010411950:	52800062 	mov	w2, #0x3                   	// #3
  6010411954:	52800041 	mov	w1, #0x2                   	// #2
  6010411958:	97ffffc6 	bl	6010411870 <serial_out_shift>
    serial_dout(&com_port->fcr, UART_FCR_DEFVAL);
  601041195c:	f9400fe0 	ldr	x0, [sp, #24]
  6010411960:	91002000 	add	x0, x0, #0x8
  6010411964:	528000e2 	mov	w2, #0x7                   	// #7
  6010411968:	52800041 	mov	w1, #0x2                   	// #2
  601041196c:	97ffffc1 	bl	6010411870 <serial_out_shift>

    serial_dout(&com_port->lcr, UART_LCR_BKSE | UART_LCRVAL);
  6010411970:	f9400fe0 	ldr	x0, [sp, #24]
  6010411974:	91003000 	add	x0, x0, #0xc
  6010411978:	52801062 	mov	w2, #0x83                  	// #131
  601041197c:	52800041 	mov	w1, #0x2                   	// #2
  6010411980:	97ffffbc 	bl	6010411870 <serial_out_shift>
    serial_dout(&com_port->dll, baud_divisor & 0xff);
  6010411984:	b94017e0 	ldr	w0, [sp, #20]
  6010411988:	12001c00 	and	w0, w0, #0xff
  601041198c:	2a0003e2 	mov	w2, w0
  6010411990:	52800041 	mov	w1, #0x2                   	// #2
  6010411994:	f9400fe0 	ldr	x0, [sp, #24]
  6010411998:	97ffffb6 	bl	6010411870 <serial_out_shift>
    serial_dout(&com_port->dlm, (baud_divisor >> 8) & 0xff);
  601041199c:	f9400fe0 	ldr	x0, [sp, #24]
  60104119a0:	91001003 	add	x3, x0, #0x4
  60104119a4:	b94017e0 	ldr	w0, [sp, #20]
  60104119a8:	13087c00 	asr	w0, w0, #8
  60104119ac:	12001c00 	and	w0, w0, #0xff
  60104119b0:	2a0003e2 	mov	w2, w0
  60104119b4:	52800041 	mov	w1, #0x2                   	// #2
  60104119b8:	aa0303e0 	mov	x0, x3
  60104119bc:	97ffffad 	bl	6010411870 <serial_out_shift>
    serial_dout(&com_port->lcr, UART_LCRVAL);
  60104119c0:	f9400fe0 	ldr	x0, [sp, #24]
  60104119c4:	91003000 	add	x0, x0, #0xc
  60104119c8:	52800062 	mov	w2, #0x3                   	// #3
  60104119cc:	52800041 	mov	w1, #0x2                   	// #2
  60104119d0:	97ffffa8 	bl	6010411870 <serial_out_shift>
}
  60104119d4:	d503201f 	nop
  60104119d8:	a8c27bfd 	ldp	x29, x30, [sp], #32
  60104119dc:	d65f03c0 	ret

00000060104119e0 <_debug_uart_putc>:

void _debug_uart_putc(int ch)
{
  60104119e0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  60104119e4:	910003fd 	mov	x29, sp
  60104119e8:	b9001fe0 	str	w0, [sp, #28]
    static struct NS16550* com_port = (struct NS16550*)UART_ADDR;

    if (ch == '\n') {
  60104119ec:	b9401fe0 	ldr	w0, [sp, #28]
  60104119f0:	7100281f 	cmp	w0, #0xa
  60104119f4:	54000061 	b.ne	6010411a00 <_debug_uart_putc+0x20>  // b.any
        _debug_uart_putc('\r');
  60104119f8:	528001a0 	mov	w0, #0xd                   	// #13
  60104119fc:	97fffff9 	bl	60104119e0 <_debug_uart_putc>
    }

    while (!(serial_din(&com_port->lsr) & UART_LSR_THRE))
  6010411a00:	d503201f 	nop
  6010411a04:	f0000080 	adrp	x0, 6010424000 <impure_data+0x210>
  6010411a08:	913a6000 	add	x0, x0, #0xe98
  6010411a0c:	f9400000 	ldr	x0, [x0]
  6010411a10:	91005000 	add	x0, x0, #0x14
  6010411a14:	52800041 	mov	w1, #0x2                   	// #2
  6010411a18:	97ffffa0 	bl	6010411898 <serial_in_shift>
  6010411a1c:	121b0000 	and	w0, w0, #0x20
  6010411a20:	7100001f 	cmp	w0, #0x0
  6010411a24:	54ffff00 	b.eq	6010411a04 <_debug_uart_putc+0x24>  // b.none
        ;
    serial_dout(&com_port->thr, ch);
  6010411a28:	f0000080 	adrp	x0, 6010424000 <impure_data+0x210>
  6010411a2c:	913a6000 	add	x0, x0, #0xe98
  6010411a30:	f9400000 	ldr	x0, [x0]
  6010411a34:	b9401fe2 	ldr	w2, [sp, #28]
  6010411a38:	52800041 	mov	w1, #0x2                   	// #2
  6010411a3c:	97ffff8d 	bl	6010411870 <serial_out_shift>
}
  6010411a40:	d503201f 	nop
  6010411a44:	a8c27bfd 	ldp	x29, x30, [sp], #32
  6010411a48:	d65f03c0 	ret

0000006010411a4c <_debug_uart_getc>:

int _debug_uart_getc(void)
{
  6010411a4c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  6010411a50:	910003fd 	mov	x29, sp
    static struct NS16550* com_port = (struct NS16550*)UART_ADDR;

    while (!(serial_din(&com_port->lsr) & UART_LSR_DR))
  6010411a54:	d503201f 	nop
  6010411a58:	f0000080 	adrp	x0, 6010424000 <impure_data+0x210>
  6010411a5c:	913a8000 	add	x0, x0, #0xea0
  6010411a60:	f9400000 	ldr	x0, [x0]
  6010411a64:	91005000 	add	x0, x0, #0x14
  6010411a68:	52800041 	mov	w1, #0x2                   	// #2
  6010411a6c:	97ffff8b 	bl	6010411898 <serial_in_shift>
  6010411a70:	12000000 	and	w0, w0, #0x1
  6010411a74:	7100001f 	cmp	w0, #0x0
  6010411a78:	54ffff00 	b.eq	6010411a58 <_debug_uart_getc+0xc>  // b.none
        ;

    return serial_din(&com_port->rbr);
  6010411a7c:	f0000080 	adrp	x0, 6010424000 <impure_data+0x210>
  6010411a80:	913a8000 	add	x0, x0, #0xea0
  6010411a84:	f9400000 	ldr	x0, [x0]
  6010411a88:	52800041 	mov	w1, #0x2                   	// #2
  6010411a8c:	97ffff83 	bl	6010411898 <serial_in_shift>
  6010411a90:	a8c17bfd 	ldp	x29, x30, [sp], #16
  6010411a94:	d65f03c0 	ret

0000006010411a98 <proxy>:
};

static struct PrintProxy* const proxy()
{
    static struct PrintProxy serial_proxy;
    return &serial_proxy;
  6010411a98:	d0008980 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010411a9c:	911bc000 	add	x0, x0, #0x6f0
}
  6010411aa0:	d65f03c0 	ret

0000006010411aa4 <serial_init>:

int serial_init(struct TraceTag* uart_driver_tag)
{
  6010411aa4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  6010411aa8:	910003fd 	mov	x29, sp
  6010411aac:	a90153f3 	stp	x19, x20, [sp, #16]
  6010411ab0:	f90017e0 	str	x0, [sp, #40]
    proxy()->uart_driver_tag = *uart_driver_tag;
  6010411ab4:	97fffff9 	bl	6010411a98 <proxy>
  6010411ab8:	aa0003e1 	mov	x1, x0
  6010411abc:	f94017e0 	ldr	x0, [sp, #40]
  6010411ac0:	f9400000 	ldr	x0, [x0]
  6010411ac4:	f9000020 	str	x0, [x1]
    proxy()->serial = AchieveResource(&proxy()->uart_driver_tag);
  6010411ac8:	97fffff4 	bl	6010411a98 <proxy>
  6010411acc:	aa0003f4 	mov	x20, x0
  6010411ad0:	97fffff2 	bl	6010411a98 <proxy>
  6010411ad4:	aa0003f3 	mov	x19, x0
  6010411ad8:	aa1403e0 	mov	x0, x20
  6010411adc:	9400112d 	bl	6010415f90 <AchieveResource>
  6010411ae0:	f9000660 	str	x0, [x19, #8]
    return 0;
  6010411ae4:	52800000 	mov	w0, #0x0                   	// #0
}
  6010411ae8:	a94153f3 	ldp	x19, x20, [sp, #16]
  6010411aec:	a8c37bfd 	ldp	x29, x30, [sp], #48
  6010411af0:	d65f03c0 	ret

0000006010411af4 <_out_buffer>:
    void* arg;
} out_fct_wrap_type;

// internal buffer output
static inline void _out_buffer(char character, void* buffer, size_t idx, size_t maxlen)
{
  6010411af4:	d10083ff 	sub	sp, sp, #0x20
  6010411af8:	39007fe0 	strb	w0, [sp, #31]
  6010411afc:	f9000be1 	str	x1, [sp, #16]
  6010411b00:	f90007e2 	str	x2, [sp, #8]
  6010411b04:	f90003e3 	str	x3, [sp]
    if (idx < maxlen) {
  6010411b08:	f94007e1 	ldr	x1, [sp, #8]
  6010411b0c:	f94003e0 	ldr	x0, [sp]
  6010411b10:	eb00003f 	cmp	x1, x0
  6010411b14:	540000c2 	b.cs	6010411b2c <_out_buffer+0x38>  // b.hs, b.nlast
        ((char*)buffer)[idx] = character;
  6010411b18:	f9400be1 	ldr	x1, [sp, #16]
  6010411b1c:	f94007e0 	ldr	x0, [sp, #8]
  6010411b20:	8b000020 	add	x0, x1, x0
  6010411b24:	39407fe1 	ldrb	w1, [sp, #31]
  6010411b28:	39000001 	strb	w1, [x0]
    }
}
  6010411b2c:	d503201f 	nop
  6010411b30:	910083ff 	add	sp, sp, #0x20
  6010411b34:	d65f03c0 	ret

0000006010411b38 <_out_null>:

// internal null output
static inline void _out_null(char character, void* buffer, size_t idx, size_t maxlen)
{
  6010411b38:	d10083ff 	sub	sp, sp, #0x20
  6010411b3c:	39007fe0 	strb	w0, [sp, #31]
  6010411b40:	f9000be1 	str	x1, [sp, #16]
  6010411b44:	f90007e2 	str	x2, [sp, #8]
  6010411b48:	f90003e3 	str	x3, [sp]
    (void)character;
    (void)buffer;
    (void)idx;
    (void)maxlen;
}
  6010411b4c:	d503201f 	nop
  6010411b50:	910083ff 	add	sp, sp, #0x20
  6010411b54:	d65f03c0 	ret

0000006010411b58 <_out_char>:

// internal _putchar wrapper
static inline void _out_char(char character, void* buffer, size_t idx, size_t maxlen)
{
  6010411b58:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  6010411b5c:	910003fd 	mov	x29, sp
  6010411b60:	3900bfe0 	strb	w0, [sp, #47]
  6010411b64:	f90013e1 	str	x1, [sp, #32]
  6010411b68:	f9000fe2 	str	x2, [sp, #24]
  6010411b6c:	f9000be3 	str	x3, [sp, #16]
    (void)buffer;
    (void)idx;
    (void)maxlen;
    if (character) {
  6010411b70:	3940bfe0 	ldrb	w0, [sp, #47]
  6010411b74:	7100001f 	cmp	w0, #0x0
  6010411b78:	540000c0 	b.eq	6010411b90 <_out_char+0x38>  // b.none
        _putchar(character);
  6010411b7c:	97ffffc7 	bl	6010411a98 <proxy>
  6010411b80:	f9400400 	ldr	x0, [x0, #8]
  6010411b84:	f9400c01 	ldr	x1, [x0, #24]
  6010411b88:	3940bfe0 	ldrb	w0, [sp, #47]
  6010411b8c:	d63f0020 	blr	x1
    }
}
  6010411b90:	d503201f 	nop
  6010411b94:	a8c37bfd 	ldp	x29, x30, [sp], #48
  6010411b98:	d65f03c0 	ret

0000006010411b9c <_out_fct>:

// internal output function wrapper
static inline void _out_fct(char character, void* buffer, size_t idx, size_t maxlen)
{
  6010411b9c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  6010411ba0:	910003fd 	mov	x29, sp
  6010411ba4:	3900bfe0 	strb	w0, [sp, #47]
  6010411ba8:	f90013e1 	str	x1, [sp, #32]
  6010411bac:	f9000fe2 	str	x2, [sp, #24]
  6010411bb0:	f9000be3 	str	x3, [sp, #16]
    (void)idx;
    (void)maxlen;
    if (character) {
  6010411bb4:	3940bfe0 	ldrb	w0, [sp, #47]
  6010411bb8:	7100001f 	cmp	w0, #0x0
  6010411bbc:	54000100 	b.eq	6010411bdc <_out_fct+0x40>  // b.none
        // buffer is the output fct pointer
        ((out_fct_wrap_type*)buffer)->fct(character, ((out_fct_wrap_type*)buffer)->arg);
  6010411bc0:	f94013e0 	ldr	x0, [sp, #32]
  6010411bc4:	f9400002 	ldr	x2, [x0]
  6010411bc8:	f94013e0 	ldr	x0, [sp, #32]
  6010411bcc:	f9400400 	ldr	x0, [x0, #8]
  6010411bd0:	aa0003e1 	mov	x1, x0
  6010411bd4:	3940bfe0 	ldrb	w0, [sp, #47]
  6010411bd8:	d63f0040 	blr	x2
    }
}
  6010411bdc:	d503201f 	nop
  6010411be0:	a8c37bfd 	ldp	x29, x30, [sp], #48
  6010411be4:	d65f03c0 	ret

0000006010411be8 <_strnlen_s>:

// internal secure strlen
// \return The length of the string (excluding the terminating 0) limited by 'maxsize'
static inline unsigned int _strnlen_s(const char* str, size_t maxsize)
{
  6010411be8:	d10083ff 	sub	sp, sp, #0x20
  6010411bec:	f90007e0 	str	x0, [sp, #8]
  6010411bf0:	f90003e1 	str	x1, [sp]
    const char* s;
    for (s = str; *s && maxsize--; ++s)
  6010411bf4:	f94007e0 	ldr	x0, [sp, #8]
  6010411bf8:	f9000fe0 	str	x0, [sp, #24]
  6010411bfc:	14000004 	b	6010411c0c <_strnlen_s+0x24>
  6010411c00:	f9400fe0 	ldr	x0, [sp, #24]
  6010411c04:	91000400 	add	x0, x0, #0x1
  6010411c08:	f9000fe0 	str	x0, [sp, #24]
  6010411c0c:	f9400fe0 	ldr	x0, [sp, #24]
  6010411c10:	39400000 	ldrb	w0, [x0]
  6010411c14:	7100001f 	cmp	w0, #0x0
  6010411c18:	540000c0 	b.eq	6010411c30 <_strnlen_s+0x48>  // b.none
  6010411c1c:	f94003e0 	ldr	x0, [sp]
  6010411c20:	d1000401 	sub	x1, x0, #0x1
  6010411c24:	f90003e1 	str	x1, [sp]
  6010411c28:	f100001f 	cmp	x0, #0x0
  6010411c2c:	54fffea1 	b.ne	6010411c00 <_strnlen_s+0x18>  // b.any
        ;
    return (unsigned int)(s - str);
  6010411c30:	f9400fe1 	ldr	x1, [sp, #24]
  6010411c34:	f94007e0 	ldr	x0, [sp, #8]
  6010411c38:	cb000020 	sub	x0, x1, x0
}
  6010411c3c:	910083ff 	add	sp, sp, #0x20
  6010411c40:	d65f03c0 	ret

0000006010411c44 <_is_digit>:

// internal test if char is a digit (0-9)
// \return true if char is a digit
static inline bool _is_digit(char ch)
{
  6010411c44:	d10043ff 	sub	sp, sp, #0x10
  6010411c48:	39003fe0 	strb	w0, [sp, #15]
    return (ch >= '0') && (ch <= '9');
  6010411c4c:	39403fe0 	ldrb	w0, [sp, #15]
  6010411c50:	7100bc1f 	cmp	w0, #0x2f
  6010411c54:	540000c9 	b.ls	6010411c6c <_is_digit+0x28>  // b.plast
  6010411c58:	39403fe0 	ldrb	w0, [sp, #15]
  6010411c5c:	7100e41f 	cmp	w0, #0x39
  6010411c60:	54000068 	b.hi	6010411c6c <_is_digit+0x28>  // b.pmore
  6010411c64:	52800020 	mov	w0, #0x1                   	// #1
  6010411c68:	14000002 	b	6010411c70 <_is_digit+0x2c>
  6010411c6c:	52800000 	mov	w0, #0x0                   	// #0
  6010411c70:	12000000 	and	w0, w0, #0x1
  6010411c74:	12001c00 	and	w0, w0, #0xff
}
  6010411c78:	910043ff 	add	sp, sp, #0x10
  6010411c7c:	d65f03c0 	ret

0000006010411c80 <_atoi>:

// internal ASCII string to unsigned int conversion
static unsigned int _atoi(const char** str)
{
  6010411c80:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  6010411c84:	910003fd 	mov	x29, sp
  6010411c88:	f9000fe0 	str	x0, [sp, #24]
    unsigned int i = 0U;
  6010411c8c:	b9002fff 	str	wzr, [sp, #44]
    while (_is_digit(**str)) {
  6010411c90:	1400000d 	b	6010411cc4 <_atoi+0x44>
        i = i * 10U + (unsigned int)(*((*str)++) - '0');
  6010411c94:	b9402fe1 	ldr	w1, [sp, #44]
  6010411c98:	52800140 	mov	w0, #0xa                   	// #10
  6010411c9c:	1b007c21 	mul	w1, w1, w0
  6010411ca0:	f9400fe0 	ldr	x0, [sp, #24]
  6010411ca4:	f9400000 	ldr	x0, [x0]
  6010411ca8:	91000403 	add	x3, x0, #0x1
  6010411cac:	f9400fe2 	ldr	x2, [sp, #24]
  6010411cb0:	f9000043 	str	x3, [x2]
  6010411cb4:	39400000 	ldrb	w0, [x0]
  6010411cb8:	0b000020 	add	w0, w1, w0
  6010411cbc:	5100c000 	sub	w0, w0, #0x30
  6010411cc0:	b9002fe0 	str	w0, [sp, #44]
    while (_is_digit(**str)) {
  6010411cc4:	f9400fe0 	ldr	x0, [sp, #24]
  6010411cc8:	f9400000 	ldr	x0, [x0]
  6010411ccc:	39400000 	ldrb	w0, [x0]
  6010411cd0:	97ffffdd 	bl	6010411c44 <_is_digit>
  6010411cd4:	12001c00 	and	w0, w0, #0xff
  6010411cd8:	7100001f 	cmp	w0, #0x0
  6010411cdc:	54fffdc1 	b.ne	6010411c94 <_atoi+0x14>  // b.any
    }
    return i;
  6010411ce0:	b9402fe0 	ldr	w0, [sp, #44]
}
  6010411ce4:	a8c37bfd 	ldp	x29, x30, [sp], #48
  6010411ce8:	d65f03c0 	ret

0000006010411cec <_out_rev>:

// output the specified string in reverse, taking care of any zero-padding
static size_t _out_rev(out_fct_type out, char* buffer, size_t idx, size_t maxlen, const char* buf, size_t len, unsigned int width, unsigned int flags)
{
  6010411cec:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  6010411cf0:	910003fd 	mov	x29, sp
  6010411cf4:	f90027e0 	str	x0, [sp, #72]
  6010411cf8:	f90023e1 	str	x1, [sp, #64]
  6010411cfc:	f9001fe2 	str	x2, [sp, #56]
  6010411d00:	f9001be3 	str	x3, [sp, #48]
  6010411d04:	f90017e4 	str	x4, [sp, #40]
  6010411d08:	f90013e5 	str	x5, [sp, #32]
  6010411d0c:	b9001fe6 	str	w6, [sp, #28]
  6010411d10:	b9001be7 	str	w7, [sp, #24]
    const size_t start_idx = idx;
  6010411d14:	f9401fe0 	ldr	x0, [sp, #56]
  6010411d18:	f9002be0 	str	x0, [sp, #80]

    // pad spaces up to given width
    if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
  6010411d1c:	b9401be0 	ldr	w0, [sp, #24]
  6010411d20:	121f0000 	and	w0, w0, #0x2
  6010411d24:	7100001f 	cmp	w0, #0x0
  6010411d28:	54000521 	b.ne	6010411dcc <_out_rev+0xe0>  // b.any
  6010411d2c:	b9401be0 	ldr	w0, [sp, #24]
  6010411d30:	12000000 	and	w0, w0, #0x1
  6010411d34:	7100001f 	cmp	w0, #0x0
  6010411d38:	540004a1 	b.ne	6010411dcc <_out_rev+0xe0>  // b.any
        for (size_t i = len; i < width; i++) {
  6010411d3c:	f94013e0 	ldr	x0, [sp, #32]
  6010411d40:	f9002fe0 	str	x0, [sp, #88]
  6010411d44:	1400000d 	b	6010411d78 <_out_rev+0x8c>
            out(' ', buffer, idx++, maxlen);
  6010411d48:	f9401fe0 	ldr	x0, [sp, #56]
  6010411d4c:	91000401 	add	x1, x0, #0x1
  6010411d50:	f9001fe1 	str	x1, [sp, #56]
  6010411d54:	f94027e4 	ldr	x4, [sp, #72]
  6010411d58:	f9401be3 	ldr	x3, [sp, #48]
  6010411d5c:	aa0003e2 	mov	x2, x0
  6010411d60:	f94023e1 	ldr	x1, [sp, #64]
  6010411d64:	52800400 	mov	w0, #0x20                  	// #32
  6010411d68:	d63f0080 	blr	x4
        for (size_t i = len; i < width; i++) {
  6010411d6c:	f9402fe0 	ldr	x0, [sp, #88]
  6010411d70:	91000400 	add	x0, x0, #0x1
  6010411d74:	f9002fe0 	str	x0, [sp, #88]
  6010411d78:	b9401fe0 	ldr	w0, [sp, #28]
  6010411d7c:	f9402fe1 	ldr	x1, [sp, #88]
  6010411d80:	eb00003f 	cmp	x1, x0
  6010411d84:	54fffe23 	b.cc	6010411d48 <_out_rev+0x5c>  // b.lo, b.ul, b.last
        }
    }

    // reverse string
    while (len) {
  6010411d88:	14000011 	b	6010411dcc <_out_rev+0xe0>
        out(buf[--len], buffer, idx++, maxlen);
  6010411d8c:	f94013e0 	ldr	x0, [sp, #32]
  6010411d90:	d1000400 	sub	x0, x0, #0x1
  6010411d94:	f90013e0 	str	x0, [sp, #32]
  6010411d98:	f94017e1 	ldr	x1, [sp, #40]
  6010411d9c:	f94013e0 	ldr	x0, [sp, #32]
  6010411da0:	8b000020 	add	x0, x1, x0
  6010411da4:	39400005 	ldrb	w5, [x0]
  6010411da8:	f9401fe0 	ldr	x0, [sp, #56]
  6010411dac:	91000401 	add	x1, x0, #0x1
  6010411db0:	f9001fe1 	str	x1, [sp, #56]
  6010411db4:	f94027e4 	ldr	x4, [sp, #72]
  6010411db8:	f9401be3 	ldr	x3, [sp, #48]
  6010411dbc:	aa0003e2 	mov	x2, x0
  6010411dc0:	f94023e1 	ldr	x1, [sp, #64]
  6010411dc4:	2a0503e0 	mov	w0, w5
  6010411dc8:	d63f0080 	blr	x4
    while (len) {
  6010411dcc:	f94013e0 	ldr	x0, [sp, #32]
  6010411dd0:	f100001f 	cmp	x0, #0x0
  6010411dd4:	54fffdc1 	b.ne	6010411d8c <_out_rev+0xa0>  // b.any
    }

    // append pad spaces up to given width
    if (flags & FLAGS_LEFT) {
  6010411dd8:	b9401be0 	ldr	w0, [sp, #24]
  6010411ddc:	121f0000 	and	w0, w0, #0x2
  6010411de0:	7100001f 	cmp	w0, #0x0
  6010411de4:	54000220 	b.eq	6010411e28 <_out_rev+0x13c>  // b.none
        while (idx - start_idx < width) {
  6010411de8:	1400000a 	b	6010411e10 <_out_rev+0x124>
            out(' ', buffer, idx++, maxlen);
  6010411dec:	f9401fe0 	ldr	x0, [sp, #56]
  6010411df0:	91000401 	add	x1, x0, #0x1
  6010411df4:	f9001fe1 	str	x1, [sp, #56]
  6010411df8:	f94027e4 	ldr	x4, [sp, #72]
  6010411dfc:	f9401be3 	ldr	x3, [sp, #48]
  6010411e00:	aa0003e2 	mov	x2, x0
  6010411e04:	f94023e1 	ldr	x1, [sp, #64]
  6010411e08:	52800400 	mov	w0, #0x20                  	// #32
  6010411e0c:	d63f0080 	blr	x4
        while (idx - start_idx < width) {
  6010411e10:	f9401fe1 	ldr	x1, [sp, #56]
  6010411e14:	f9402be0 	ldr	x0, [sp, #80]
  6010411e18:	cb000021 	sub	x1, x1, x0
  6010411e1c:	b9401fe0 	ldr	w0, [sp, #28]
  6010411e20:	eb00003f 	cmp	x1, x0
  6010411e24:	54fffe43 	b.cc	6010411dec <_out_rev+0x100>  // b.lo, b.ul, b.last
        }
    }

    return idx;
  6010411e28:	f9401fe0 	ldr	x0, [sp, #56]
}
  6010411e2c:	a8c67bfd 	ldp	x29, x30, [sp], #96
  6010411e30:	d65f03c0 	ret

0000006010411e34 <_ntoa_format>:

// internal itoa format
static size_t _ntoa_format(out_fct_type out, char* buffer, size_t idx, size_t maxlen, char* buf, size_t len, bool negative, unsigned int base, unsigned int prec, unsigned int width, unsigned int flags)
{
  6010411e34:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  6010411e38:	910003fd 	mov	x29, sp
  6010411e3c:	f90027e0 	str	x0, [sp, #72]
  6010411e40:	f90023e1 	str	x1, [sp, #64]
  6010411e44:	f9001fe2 	str	x2, [sp, #56]
  6010411e48:	f9001be3 	str	x3, [sp, #48]
  6010411e4c:	f90017e4 	str	x4, [sp, #40]
  6010411e50:	f90013e5 	str	x5, [sp, #32]
  6010411e54:	39007fe6 	strb	w6, [sp, #31]
  6010411e58:	b9001be7 	str	w7, [sp, #24]
    // pad leading zeros
    if (!(flags & FLAGS_LEFT)) {
  6010411e5c:	b94063e0 	ldr	w0, [sp, #96]
  6010411e60:	121f0000 	and	w0, w0, #0x2
  6010411e64:	7100001f 	cmp	w0, #0x0
  6010411e68:	54000681 	b.ne	6010411f38 <_ntoa_format+0x104>  // b.any
        if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
  6010411e6c:	b9405be0 	ldr	w0, [sp, #88]
  6010411e70:	7100001f 	cmp	w0, #0x0
  6010411e74:	540002e0 	b.eq	6010411ed0 <_ntoa_format+0x9c>  // b.none
  6010411e78:	b94063e0 	ldr	w0, [sp, #96]
  6010411e7c:	12000000 	and	w0, w0, #0x1
  6010411e80:	7100001f 	cmp	w0, #0x0
  6010411e84:	54000260 	b.eq	6010411ed0 <_ntoa_format+0x9c>  // b.none
  6010411e88:	39407fe0 	ldrb	w0, [sp, #31]
  6010411e8c:	7100001f 	cmp	w0, #0x0
  6010411e90:	540000a1 	b.ne	6010411ea4 <_ntoa_format+0x70>  // b.any
  6010411e94:	b94063e0 	ldr	w0, [sp, #96]
  6010411e98:	121e0400 	and	w0, w0, #0xc
  6010411e9c:	7100001f 	cmp	w0, #0x0
  6010411ea0:	54000180 	b.eq	6010411ed0 <_ntoa_format+0x9c>  // b.none
            width--;
  6010411ea4:	b9405be0 	ldr	w0, [sp, #88]
  6010411ea8:	51000400 	sub	w0, w0, #0x1
  6010411eac:	b9005be0 	str	w0, [sp, #88]
        }
        while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  6010411eb0:	14000008 	b	6010411ed0 <_ntoa_format+0x9c>
            buf[len++] = '0';
  6010411eb4:	f94013e0 	ldr	x0, [sp, #32]
  6010411eb8:	91000401 	add	x1, x0, #0x1
  6010411ebc:	f90013e1 	str	x1, [sp, #32]
  6010411ec0:	f94017e1 	ldr	x1, [sp, #40]
  6010411ec4:	8b000020 	add	x0, x1, x0
  6010411ec8:	52800601 	mov	w1, #0x30                  	// #48
  6010411ecc:	39000001 	strb	w1, [x0]
        while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  6010411ed0:	b94053e0 	ldr	w0, [sp, #80]
  6010411ed4:	f94013e1 	ldr	x1, [sp, #32]
  6010411ed8:	eb00003f 	cmp	x1, x0
  6010411edc:	54000182 	b.cs	6010411f0c <_ntoa_format+0xd8>  // b.hs, b.nlast
  6010411ee0:	f94013e0 	ldr	x0, [sp, #32]
  6010411ee4:	f1007c1f 	cmp	x0, #0x1f
  6010411ee8:	54fffe69 	b.ls	6010411eb4 <_ntoa_format+0x80>  // b.plast
        }
        while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  6010411eec:	14000008 	b	6010411f0c <_ntoa_format+0xd8>
            buf[len++] = '0';
  6010411ef0:	f94013e0 	ldr	x0, [sp, #32]
  6010411ef4:	91000401 	add	x1, x0, #0x1
  6010411ef8:	f90013e1 	str	x1, [sp, #32]
  6010411efc:	f94017e1 	ldr	x1, [sp, #40]
  6010411f00:	8b000020 	add	x0, x1, x0
  6010411f04:	52800601 	mov	w1, #0x30                  	// #48
  6010411f08:	39000001 	strb	w1, [x0]
        while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  6010411f0c:	b94063e0 	ldr	w0, [sp, #96]
  6010411f10:	12000000 	and	w0, w0, #0x1
  6010411f14:	7100001f 	cmp	w0, #0x0
  6010411f18:	54000100 	b.eq	6010411f38 <_ntoa_format+0x104>  // b.none
  6010411f1c:	b9405be0 	ldr	w0, [sp, #88]
  6010411f20:	f94013e1 	ldr	x1, [sp, #32]
  6010411f24:	eb00003f 	cmp	x1, x0
  6010411f28:	54000082 	b.cs	6010411f38 <_ntoa_format+0x104>  // b.hs, b.nlast
  6010411f2c:	f94013e0 	ldr	x0, [sp, #32]
  6010411f30:	f1007c1f 	cmp	x0, #0x1f
  6010411f34:	54fffde9 	b.ls	6010411ef0 <_ntoa_format+0xbc>  // b.plast
        }
    }

    // handle hash
    if (flags & FLAGS_HASH) {
  6010411f38:	b94063e0 	ldr	w0, [sp, #96]
  6010411f3c:	121c0000 	and	w0, w0, #0x10
  6010411f40:	7100001f 	cmp	w0, #0x0
  6010411f44:	54000ae0 	b.eq	60104120a0 <_ntoa_format+0x26c>  // b.none
        if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
  6010411f48:	b94063e0 	ldr	w0, [sp, #96]
  6010411f4c:	12160000 	and	w0, w0, #0x400
  6010411f50:	7100001f 	cmp	w0, #0x0
  6010411f54:	54000301 	b.ne	6010411fb4 <_ntoa_format+0x180>  // b.any
  6010411f58:	f94013e0 	ldr	x0, [sp, #32]
  6010411f5c:	f100001f 	cmp	x0, #0x0
  6010411f60:	540002a0 	b.eq	6010411fb4 <_ntoa_format+0x180>  // b.none
  6010411f64:	b94053e0 	ldr	w0, [sp, #80]
  6010411f68:	f94013e1 	ldr	x1, [sp, #32]
  6010411f6c:	eb00003f 	cmp	x1, x0
  6010411f70:	540000a0 	b.eq	6010411f84 <_ntoa_format+0x150>  // b.none
  6010411f74:	b9405be0 	ldr	w0, [sp, #88]
  6010411f78:	f94013e1 	ldr	x1, [sp, #32]
  6010411f7c:	eb00003f 	cmp	x1, x0
  6010411f80:	540001a1 	b.ne	6010411fb4 <_ntoa_format+0x180>  // b.any
            len--;
  6010411f84:	f94013e0 	ldr	x0, [sp, #32]
  6010411f88:	d1000400 	sub	x0, x0, #0x1
  6010411f8c:	f90013e0 	str	x0, [sp, #32]
            if (len && (base == 16U)) {
  6010411f90:	f94013e0 	ldr	x0, [sp, #32]
  6010411f94:	f100001f 	cmp	x0, #0x0
  6010411f98:	540000e0 	b.eq	6010411fb4 <_ntoa_format+0x180>  // b.none
  6010411f9c:	b9401be0 	ldr	w0, [sp, #24]
  6010411fa0:	7100401f 	cmp	w0, #0x10
  6010411fa4:	54000081 	b.ne	6010411fb4 <_ntoa_format+0x180>  // b.any
                len--;
  6010411fa8:	f94013e0 	ldr	x0, [sp, #32]
  6010411fac:	d1000400 	sub	x0, x0, #0x1
  6010411fb0:	f90013e0 	str	x0, [sp, #32]
            }
        }
        if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  6010411fb4:	b9401be0 	ldr	w0, [sp, #24]
  6010411fb8:	7100401f 	cmp	w0, #0x10
  6010411fbc:	54000201 	b.ne	6010411ffc <_ntoa_format+0x1c8>  // b.any
  6010411fc0:	b94063e0 	ldr	w0, [sp, #96]
  6010411fc4:	121b0000 	and	w0, w0, #0x20
  6010411fc8:	7100001f 	cmp	w0, #0x0
  6010411fcc:	54000181 	b.ne	6010411ffc <_ntoa_format+0x1c8>  // b.any
  6010411fd0:	f94013e0 	ldr	x0, [sp, #32]
  6010411fd4:	f1007c1f 	cmp	x0, #0x1f
  6010411fd8:	54000128 	b.hi	6010411ffc <_ntoa_format+0x1c8>  // b.pmore
            buf[len++] = 'x';
  6010411fdc:	f94013e0 	ldr	x0, [sp, #32]
  6010411fe0:	91000401 	add	x1, x0, #0x1
  6010411fe4:	f90013e1 	str	x1, [sp, #32]
  6010411fe8:	f94017e1 	ldr	x1, [sp, #40]
  6010411fec:	8b000020 	add	x0, x1, x0
  6010411ff0:	52800f01 	mov	w1, #0x78                  	// #120
  6010411ff4:	39000001 	strb	w1, [x0]
  6010411ff8:	14000020 	b	6010412078 <_ntoa_format+0x244>
        } else if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  6010411ffc:	b9401be0 	ldr	w0, [sp, #24]
  6010412000:	7100401f 	cmp	w0, #0x10
  6010412004:	54000201 	b.ne	6010412044 <_ntoa_format+0x210>  // b.any
  6010412008:	b94063e0 	ldr	w0, [sp, #96]
  601041200c:	121b0000 	and	w0, w0, #0x20
  6010412010:	7100001f 	cmp	w0, #0x0
  6010412014:	54000180 	b.eq	6010412044 <_ntoa_format+0x210>  // b.none
  6010412018:	f94013e0 	ldr	x0, [sp, #32]
  601041201c:	f1007c1f 	cmp	x0, #0x1f
  6010412020:	54000128 	b.hi	6010412044 <_ntoa_format+0x210>  // b.pmore
            buf[len++] = 'X';
  6010412024:	f94013e0 	ldr	x0, [sp, #32]
  6010412028:	91000401 	add	x1, x0, #0x1
  601041202c:	f90013e1 	str	x1, [sp, #32]
  6010412030:	f94017e1 	ldr	x1, [sp, #40]
  6010412034:	8b000020 	add	x0, x1, x0
  6010412038:	52800b01 	mov	w1, #0x58                  	// #88
  601041203c:	39000001 	strb	w1, [x0]
  6010412040:	1400000e 	b	6010412078 <_ntoa_format+0x244>
        } else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  6010412044:	b9401be0 	ldr	w0, [sp, #24]
  6010412048:	7100081f 	cmp	w0, #0x2
  601041204c:	54000161 	b.ne	6010412078 <_ntoa_format+0x244>  // b.any
  6010412050:	f94013e0 	ldr	x0, [sp, #32]
  6010412054:	f1007c1f 	cmp	x0, #0x1f
  6010412058:	54000108 	b.hi	6010412078 <_ntoa_format+0x244>  // b.pmore
            buf[len++] = 'b';
  601041205c:	f94013e0 	ldr	x0, [sp, #32]
  6010412060:	91000401 	add	x1, x0, #0x1
  6010412064:	f90013e1 	str	x1, [sp, #32]
  6010412068:	f94017e1 	ldr	x1, [sp, #40]
  601041206c:	8b000020 	add	x0, x1, x0
  6010412070:	52800c41 	mov	w1, #0x62                  	// #98
  6010412074:	39000001 	strb	w1, [x0]
        }
        if (len < PRINTF_NTOA_BUFFER_SIZE) {
  6010412078:	f94013e0 	ldr	x0, [sp, #32]
  601041207c:	f1007c1f 	cmp	x0, #0x1f
  6010412080:	54000108 	b.hi	60104120a0 <_ntoa_format+0x26c>  // b.pmore
            buf[len++] = '0';
  6010412084:	f94013e0 	ldr	x0, [sp, #32]
  6010412088:	91000401 	add	x1, x0, #0x1
  601041208c:	f90013e1 	str	x1, [sp, #32]
  6010412090:	f94017e1 	ldr	x1, [sp, #40]
  6010412094:	8b000020 	add	x0, x1, x0
  6010412098:	52800601 	mov	w1, #0x30                  	// #48
  601041209c:	39000001 	strb	w1, [x0]
        }
    }

    if (len < PRINTF_NTOA_BUFFER_SIZE) {
  60104120a0:	f94013e0 	ldr	x0, [sp, #32]
  60104120a4:	f1007c1f 	cmp	x0, #0x1f
  60104120a8:	54000468 	b.hi	6010412134 <_ntoa_format+0x300>  // b.pmore
        if (negative) {
  60104120ac:	39407fe0 	ldrb	w0, [sp, #31]
  60104120b0:	7100001f 	cmp	w0, #0x0
  60104120b4:	54000120 	b.eq	60104120d8 <_ntoa_format+0x2a4>  // b.none
            buf[len++] = '-';
  60104120b8:	f94013e0 	ldr	x0, [sp, #32]
  60104120bc:	91000401 	add	x1, x0, #0x1
  60104120c0:	f90013e1 	str	x1, [sp, #32]
  60104120c4:	f94017e1 	ldr	x1, [sp, #40]
  60104120c8:	8b000020 	add	x0, x1, x0
  60104120cc:	528005a1 	mov	w1, #0x2d                  	// #45
  60104120d0:	39000001 	strb	w1, [x0]
  60104120d4:	14000018 	b	6010412134 <_ntoa_format+0x300>
        } else if (flags & FLAGS_PLUS) {
  60104120d8:	b94063e0 	ldr	w0, [sp, #96]
  60104120dc:	121e0000 	and	w0, w0, #0x4
  60104120e0:	7100001f 	cmp	w0, #0x0
  60104120e4:	54000120 	b.eq	6010412108 <_ntoa_format+0x2d4>  // b.none
            buf[len++] = '+'; // ignore the space if the '+' exists
  60104120e8:	f94013e0 	ldr	x0, [sp, #32]
  60104120ec:	91000401 	add	x1, x0, #0x1
  60104120f0:	f90013e1 	str	x1, [sp, #32]
  60104120f4:	f94017e1 	ldr	x1, [sp, #40]
  60104120f8:	8b000020 	add	x0, x1, x0
  60104120fc:	52800561 	mov	w1, #0x2b                  	// #43
  6010412100:	39000001 	strb	w1, [x0]
  6010412104:	1400000c 	b	6010412134 <_ntoa_format+0x300>
        } else if (flags & FLAGS_SPACE) {
  6010412108:	b94063e0 	ldr	w0, [sp, #96]
  601041210c:	121d0000 	and	w0, w0, #0x8
  6010412110:	7100001f 	cmp	w0, #0x0
  6010412114:	54000100 	b.eq	6010412134 <_ntoa_format+0x300>  // b.none
            buf[len++] = ' ';
  6010412118:	f94013e0 	ldr	x0, [sp, #32]
  601041211c:	91000401 	add	x1, x0, #0x1
  6010412120:	f90013e1 	str	x1, [sp, #32]
  6010412124:	f94017e1 	ldr	x1, [sp, #40]
  6010412128:	8b000020 	add	x0, x1, x0
  601041212c:	52800401 	mov	w1, #0x20                  	// #32
  6010412130:	39000001 	strb	w1, [x0]
        }
    }

    return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
  6010412134:	b94063e7 	ldr	w7, [sp, #96]
  6010412138:	b9405be6 	ldr	w6, [sp, #88]
  601041213c:	f94013e5 	ldr	x5, [sp, #32]
  6010412140:	f94017e4 	ldr	x4, [sp, #40]
  6010412144:	f9401be3 	ldr	x3, [sp, #48]
  6010412148:	f9401fe2 	ldr	x2, [sp, #56]
  601041214c:	f94023e1 	ldr	x1, [sp, #64]
  6010412150:	f94027e0 	ldr	x0, [sp, #72]
  6010412154:	97fffee6 	bl	6010411cec <_out_rev>
}
  6010412158:	a8c57bfd 	ldp	x29, x30, [sp], #80
  601041215c:	d65f03c0 	ret

0000006010412160 <_ntoa_long>:

// internal itoa for 'long' type
static size_t _ntoa_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long value, bool negative, unsigned long base, unsigned int prec, unsigned int width, unsigned int flags)
{
  6010412160:	d10283ff 	sub	sp, sp, #0xa0
  6010412164:	a9027bfd 	stp	x29, x30, [sp, #32]
  6010412168:	910083fd 	add	x29, sp, #0x20
  601041216c:	f90037e0 	str	x0, [sp, #104]
  6010412170:	f90033e1 	str	x1, [sp, #96]
  6010412174:	f9002fe2 	str	x2, [sp, #88]
  6010412178:	f9002be3 	str	x3, [sp, #80]
  601041217c:	f90027e4 	str	x4, [sp, #72]
  6010412180:	39011fe5 	strb	w5, [sp, #71]
  6010412184:	f9001fe6 	str	x6, [sp, #56]
  6010412188:	b90043e7 	str	w7, [sp, #64]
    char buf[PRINTF_NTOA_BUFFER_SIZE];
    size_t len = 0U;
  601041218c:	f9004fff 	str	xzr, [sp, #152]

    // no hash for 0 values
    if (!value) {
  6010412190:	f94027e0 	ldr	x0, [sp, #72]
  6010412194:	f100001f 	cmp	x0, #0x0
  6010412198:	54000081 	b.ne	60104121a8 <_ntoa_long+0x48>  // b.any
        flags &= ~FLAGS_HASH;
  601041219c:	b940abe0 	ldr	w0, [sp, #168]
  60104121a0:	121b7800 	and	w0, w0, #0xffffffef
  60104121a4:	b900abe0 	str	w0, [sp, #168]
    }

    // write if precision != 0 and value is != 0
    if (!(flags & FLAGS_PRECISION) || value) {
  60104121a8:	b940abe0 	ldr	w0, [sp, #168]
  60104121ac:	12160000 	and	w0, w0, #0x400
  60104121b0:	7100001f 	cmp	w0, #0x0
  60104121b4:	54000080 	b.eq	60104121c4 <_ntoa_long+0x64>  // b.none
  60104121b8:	f94027e0 	ldr	x0, [sp, #72]
  60104121bc:	f100001f 	cmp	x0, #0x0
  60104121c0:	54000540 	b.eq	6010412268 <_ntoa_long+0x108>  // b.none
        do {
            const char digit = (char)(value % base);
  60104121c4:	f94027e0 	ldr	x0, [sp, #72]
  60104121c8:	f9401fe1 	ldr	x1, [sp, #56]
  60104121cc:	9ac10802 	udiv	x2, x0, x1
  60104121d0:	f9401fe1 	ldr	x1, [sp, #56]
  60104121d4:	9b017c41 	mul	x1, x2, x1
  60104121d8:	cb010000 	sub	x0, x0, x1
  60104121dc:	39025fe0 	strb	w0, [sp, #151]
            buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  60104121e0:	39425fe0 	ldrb	w0, [sp, #151]
  60104121e4:	7100241f 	cmp	w0, #0x9
  60104121e8:	540000a8 	b.hi	60104121fc <_ntoa_long+0x9c>  // b.pmore
  60104121ec:	39425fe0 	ldrb	w0, [sp, #151]
  60104121f0:	1100c000 	add	w0, w0, #0x30
  60104121f4:	12001c01 	and	w1, w0, #0xff
  60104121f8:	1400000d 	b	601041222c <_ntoa_long+0xcc>
  60104121fc:	b940abe0 	ldr	w0, [sp, #168]
  6010412200:	121b0000 	and	w0, w0, #0x20
  6010412204:	7100001f 	cmp	w0, #0x0
  6010412208:	54000060 	b.eq	6010412214 <_ntoa_long+0xb4>  // b.none
  601041220c:	52800820 	mov	w0, #0x41                  	// #65
  6010412210:	14000002 	b	6010412218 <_ntoa_long+0xb8>
  6010412214:	52800c20 	mov	w0, #0x61                  	// #97
  6010412218:	39425fe1 	ldrb	w1, [sp, #151]
  601041221c:	0b010000 	add	w0, w0, w1
  6010412220:	12001c00 	and	w0, w0, #0xff
  6010412224:	51002800 	sub	w0, w0, #0xa
  6010412228:	12001c01 	and	w1, w0, #0xff
  601041222c:	f9404fe0 	ldr	x0, [sp, #152]
  6010412230:	91000402 	add	x2, x0, #0x1
  6010412234:	f9004fe2 	str	x2, [sp, #152]
  6010412238:	9101c3e2 	add	x2, sp, #0x70
  601041223c:	38206841 	strb	w1, [x2, x0]
            value /= base;
  6010412240:	f94027e1 	ldr	x1, [sp, #72]
  6010412244:	f9401fe0 	ldr	x0, [sp, #56]
  6010412248:	9ac00820 	udiv	x0, x1, x0
  601041224c:	f90027e0 	str	x0, [sp, #72]
        } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
  6010412250:	f94027e0 	ldr	x0, [sp, #72]
  6010412254:	f100001f 	cmp	x0, #0x0
  6010412258:	54000080 	b.eq	6010412268 <_ntoa_long+0x108>  // b.none
  601041225c:	f9404fe0 	ldr	x0, [sp, #152]
  6010412260:	f1007c1f 	cmp	x0, #0x1f
  6010412264:	54fffb09 	b.ls	60104121c4 <_ntoa_long+0x64>  // b.plast
    }

    return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
  6010412268:	f9401fe0 	ldr	x0, [sp, #56]
  601041226c:	2a0003e2 	mov	w2, w0
  6010412270:	9101c3e1 	add	x1, sp, #0x70
  6010412274:	b940abe0 	ldr	w0, [sp, #168]
  6010412278:	b90013e0 	str	w0, [sp, #16]
  601041227c:	b940a3e0 	ldr	w0, [sp, #160]
  6010412280:	b9000be0 	str	w0, [sp, #8]
  6010412284:	b94043e0 	ldr	w0, [sp, #64]
  6010412288:	b90003e0 	str	w0, [sp]
  601041228c:	2a0203e7 	mov	w7, w2
  6010412290:	39411fe6 	ldrb	w6, [sp, #71]
  6010412294:	f9404fe5 	ldr	x5, [sp, #152]
  6010412298:	aa0103e4 	mov	x4, x1
  601041229c:	f9402be3 	ldr	x3, [sp, #80]
  60104122a0:	f9402fe2 	ldr	x2, [sp, #88]
  60104122a4:	f94033e1 	ldr	x1, [sp, #96]
  60104122a8:	f94037e0 	ldr	x0, [sp, #104]
  60104122ac:	97fffee2 	bl	6010411e34 <_ntoa_format>
}
  60104122b0:	a9427bfd 	ldp	x29, x30, [sp, #32]
  60104122b4:	910283ff 	add	sp, sp, #0xa0
  60104122b8:	d65f03c0 	ret

00000060104122bc <_ntoa_long_long>:

// internal itoa for 'long long' type
#if defined(PRINTF_SUPPORT_LONG_LONG)
static size_t _ntoa_long_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long long value, bool negative, unsigned long long base, unsigned int prec, unsigned int width, unsigned int flags)
{
  60104122bc:	d10283ff 	sub	sp, sp, #0xa0
  60104122c0:	a9027bfd 	stp	x29, x30, [sp, #32]
  60104122c4:	910083fd 	add	x29, sp, #0x20
  60104122c8:	f90037e0 	str	x0, [sp, #104]
  60104122cc:	f90033e1 	str	x1, [sp, #96]
  60104122d0:	f9002fe2 	str	x2, [sp, #88]
  60104122d4:	f9002be3 	str	x3, [sp, #80]
  60104122d8:	f90027e4 	str	x4, [sp, #72]
  60104122dc:	39011fe5 	strb	w5, [sp, #71]
  60104122e0:	f9001fe6 	str	x6, [sp, #56]
  60104122e4:	b90043e7 	str	w7, [sp, #64]
    char buf[PRINTF_NTOA_BUFFER_SIZE];
    size_t len = 0U;
  60104122e8:	f9004fff 	str	xzr, [sp, #152]

    // no hash for 0 values
    if (!value) {
  60104122ec:	f94027e0 	ldr	x0, [sp, #72]
  60104122f0:	f100001f 	cmp	x0, #0x0
  60104122f4:	54000081 	b.ne	6010412304 <_ntoa_long_long+0x48>  // b.any
        flags &= ~FLAGS_HASH;
  60104122f8:	b940abe0 	ldr	w0, [sp, #168]
  60104122fc:	121b7800 	and	w0, w0, #0xffffffef
  6010412300:	b900abe0 	str	w0, [sp, #168]
    }

    // write if precision != 0 and value is != 0
    if (!(flags & FLAGS_PRECISION) || value) {
  6010412304:	b940abe0 	ldr	w0, [sp, #168]
  6010412308:	12160000 	and	w0, w0, #0x400
  601041230c:	7100001f 	cmp	w0, #0x0
  6010412310:	54000080 	b.eq	6010412320 <_ntoa_long_long+0x64>  // b.none
  6010412314:	f94027e0 	ldr	x0, [sp, #72]
  6010412318:	f100001f 	cmp	x0, #0x0
  601041231c:	54000540 	b.eq	60104123c4 <_ntoa_long_long+0x108>  // b.none
        do {
            const char digit = (char)(value % base);
  6010412320:	f94027e0 	ldr	x0, [sp, #72]
  6010412324:	f9401fe1 	ldr	x1, [sp, #56]
  6010412328:	9ac10802 	udiv	x2, x0, x1
  601041232c:	f9401fe1 	ldr	x1, [sp, #56]
  6010412330:	9b017c41 	mul	x1, x2, x1
  6010412334:	cb010000 	sub	x0, x0, x1
  6010412338:	39025fe0 	strb	w0, [sp, #151]
            buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  601041233c:	39425fe0 	ldrb	w0, [sp, #151]
  6010412340:	7100241f 	cmp	w0, #0x9
  6010412344:	540000a8 	b.hi	6010412358 <_ntoa_long_long+0x9c>  // b.pmore
  6010412348:	39425fe0 	ldrb	w0, [sp, #151]
  601041234c:	1100c000 	add	w0, w0, #0x30
  6010412350:	12001c01 	and	w1, w0, #0xff
  6010412354:	1400000d 	b	6010412388 <_ntoa_long_long+0xcc>
  6010412358:	b940abe0 	ldr	w0, [sp, #168]
  601041235c:	121b0000 	and	w0, w0, #0x20
  6010412360:	7100001f 	cmp	w0, #0x0
  6010412364:	54000060 	b.eq	6010412370 <_ntoa_long_long+0xb4>  // b.none
  6010412368:	52800820 	mov	w0, #0x41                  	// #65
  601041236c:	14000002 	b	6010412374 <_ntoa_long_long+0xb8>
  6010412370:	52800c20 	mov	w0, #0x61                  	// #97
  6010412374:	39425fe1 	ldrb	w1, [sp, #151]
  6010412378:	0b010000 	add	w0, w0, w1
  601041237c:	12001c00 	and	w0, w0, #0xff
  6010412380:	51002800 	sub	w0, w0, #0xa
  6010412384:	12001c01 	and	w1, w0, #0xff
  6010412388:	f9404fe0 	ldr	x0, [sp, #152]
  601041238c:	91000402 	add	x2, x0, #0x1
  6010412390:	f9004fe2 	str	x2, [sp, #152]
  6010412394:	9101c3e2 	add	x2, sp, #0x70
  6010412398:	38206841 	strb	w1, [x2, x0]
            value /= base;
  601041239c:	f94027e1 	ldr	x1, [sp, #72]
  60104123a0:	f9401fe0 	ldr	x0, [sp, #56]
  60104123a4:	9ac00820 	udiv	x0, x1, x0
  60104123a8:	f90027e0 	str	x0, [sp, #72]
        } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
  60104123ac:	f94027e0 	ldr	x0, [sp, #72]
  60104123b0:	f100001f 	cmp	x0, #0x0
  60104123b4:	54000080 	b.eq	60104123c4 <_ntoa_long_long+0x108>  // b.none
  60104123b8:	f9404fe0 	ldr	x0, [sp, #152]
  60104123bc:	f1007c1f 	cmp	x0, #0x1f
  60104123c0:	54fffb09 	b.ls	6010412320 <_ntoa_long_long+0x64>  // b.plast
    }

    return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
  60104123c4:	f9401fe0 	ldr	x0, [sp, #56]
  60104123c8:	2a0003e2 	mov	w2, w0
  60104123cc:	9101c3e1 	add	x1, sp, #0x70
  60104123d0:	b940abe0 	ldr	w0, [sp, #168]
  60104123d4:	b90013e0 	str	w0, [sp, #16]
  60104123d8:	b940a3e0 	ldr	w0, [sp, #160]
  60104123dc:	b9000be0 	str	w0, [sp, #8]
  60104123e0:	b94043e0 	ldr	w0, [sp, #64]
  60104123e4:	b90003e0 	str	w0, [sp]
  60104123e8:	2a0203e7 	mov	w7, w2
  60104123ec:	39411fe6 	ldrb	w6, [sp, #71]
  60104123f0:	f9404fe5 	ldr	x5, [sp, #152]
  60104123f4:	aa0103e4 	mov	x4, x1
  60104123f8:	f9402be3 	ldr	x3, [sp, #80]
  60104123fc:	f9402fe2 	ldr	x2, [sp, #88]
  6010412400:	f94033e1 	ldr	x1, [sp, #96]
  6010412404:	f94037e0 	ldr	x0, [sp, #104]
  6010412408:	97fffe8b 	bl	6010411e34 <_ntoa_format>
}
  601041240c:	a9427bfd 	ldp	x29, x30, [sp, #32]
  6010412410:	910283ff 	add	sp, sp, #0xa0
  6010412414:	d65f03c0 	ret

0000006010412418 <_ftoa>:
static size_t _etoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value, unsigned int prec, unsigned int width, unsigned int flags);
#endif

// internal ftoa for fixed decimal floating point
static size_t _ftoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value, unsigned int prec, unsigned int width, unsigned int flags)
{
  6010412418:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
  601041241c:	910003fd 	mov	x29, sp
  6010412420:	f90027e0 	str	x0, [sp, #72]
  6010412424:	f90023e1 	str	x1, [sp, #64]
  6010412428:	f9001fe2 	str	x2, [sp, #56]
  601041242c:	f9001be3 	str	x3, [sp, #48]
  6010412430:	fd0017e0 	str	d0, [sp, #40]
  6010412434:	b90027e4 	str	w4, [sp, #36]
  6010412438:	b90023e5 	str	w5, [sp, #32]
  601041243c:	b9001fe6 	str	w6, [sp, #28]
    char buf[PRINTF_FTOA_BUFFER_SIZE];
    size_t len = 0U;
  6010412440:	f9004fff 	str	xzr, [sp, #152]
    double diff = 0.0;
  6010412444:	f9003fff 	str	xzr, [sp, #120]

    // powers of 10
    static const double pow10[] = { 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 };

    // test for special values
    if (value != value)
  6010412448:	fd4017e1 	ldr	d1, [sp, #40]
  601041244c:	fd4017e0 	ldr	d0, [sp, #40]
  6010412450:	1e602020 	fcmp	d1, d0
  6010412454:	54000180 	b.eq	6010412484 <_ftoa+0x6c>  // b.none
        return _out_rev(out, buffer, idx, maxlen, "nan", 3, width, flags);
  6010412458:	b9401fe7 	ldr	w7, [sp, #28]
  601041245c:	b94023e6 	ldr	w6, [sp, #32]
  6010412460:	d2800065 	mov	x5, #0x3                   	// #3
  6010412464:	f0000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010412468:	91068004 	add	x4, x0, #0x1a0
  601041246c:	f9401be3 	ldr	x3, [sp, #48]
  6010412470:	f9401fe2 	ldr	x2, [sp, #56]
  6010412474:	f94023e1 	ldr	x1, [sp, #64]
  6010412478:	f94027e0 	ldr	x0, [sp, #72]
  601041247c:	97fffe1c 	bl	6010411cec <_out_rev>
  6010412480:	14000173 	b	6010412a4c <_ftoa+0x634>
    if (value < -DBL_MAX)
  6010412484:	fd4017e0 	ldr	d0, [sp, #40]
  6010412488:	92e00200 	mov	x0, #0xffefffffffffffff    	// #-4503599627370497
  601041248c:	9e670001 	fmov	d1, x0
  6010412490:	1e612010 	fcmpe	d0, d1
  6010412494:	54000044 	b.mi	601041249c <_ftoa+0x84>  // b.first
  6010412498:	1400000c 	b	60104124c8 <_ftoa+0xb0>
        return _out_rev(out, buffer, idx, maxlen, "fni-", 4, width, flags);
  601041249c:	b9401fe7 	ldr	w7, [sp, #28]
  60104124a0:	b94023e6 	ldr	w6, [sp, #32]
  60104124a4:	d2800085 	mov	x5, #0x4                   	// #4
  60104124a8:	f0000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104124ac:	9106a004 	add	x4, x0, #0x1a8
  60104124b0:	f9401be3 	ldr	x3, [sp, #48]
  60104124b4:	f9401fe2 	ldr	x2, [sp, #56]
  60104124b8:	f94023e1 	ldr	x1, [sp, #64]
  60104124bc:	f94027e0 	ldr	x0, [sp, #72]
  60104124c0:	97fffe0b 	bl	6010411cec <_out_rev>
  60104124c4:	14000162 	b	6010412a4c <_ftoa+0x634>
    if (value > DBL_MAX)
  60104124c8:	fd4017e0 	ldr	d0, [sp, #40]
  60104124cc:	92f00200 	mov	x0, #0x7fefffffffffffff    	// #9218868437227405311
  60104124d0:	9e670001 	fmov	d1, x0
  60104124d4:	1e612010 	fcmpe	d0, d1
  60104124d8:	5400004c 	b.gt	60104124e0 <_ftoa+0xc8>
  60104124dc:	1400001b 	b	6010412548 <_ftoa+0x130>
        return _out_rev(out, buffer, idx, maxlen, (flags & FLAGS_PLUS) ? "fni+" : "fni", (flags & FLAGS_PLUS) ? 4U : 3U, width, flags);
  60104124e0:	b9401fe0 	ldr	w0, [sp, #28]
  60104124e4:	121e0000 	and	w0, w0, #0x4
  60104124e8:	7100001f 	cmp	w0, #0x0
  60104124ec:	54000080 	b.eq	60104124fc <_ftoa+0xe4>  // b.none
  60104124f0:	f0000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104124f4:	9106c000 	add	x0, x0, #0x1b0
  60104124f8:	14000003 	b	6010412504 <_ftoa+0xec>
  60104124fc:	f0000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010412500:	9106e000 	add	x0, x0, #0x1b8
  6010412504:	b9401fe1 	ldr	w1, [sp, #28]
  6010412508:	121e0021 	and	w1, w1, #0x4
  601041250c:	7100003f 	cmp	w1, #0x0
  6010412510:	54000060 	b.eq	601041251c <_ftoa+0x104>  // b.none
  6010412514:	d2800081 	mov	x1, #0x4                   	// #4
  6010412518:	14000002 	b	6010412520 <_ftoa+0x108>
  601041251c:	d2800061 	mov	x1, #0x3                   	// #3
  6010412520:	b9401fe7 	ldr	w7, [sp, #28]
  6010412524:	b94023e6 	ldr	w6, [sp, #32]
  6010412528:	aa0103e5 	mov	x5, x1
  601041252c:	aa0003e4 	mov	x4, x0
  6010412530:	f9401be3 	ldr	x3, [sp, #48]
  6010412534:	f9401fe2 	ldr	x2, [sp, #56]
  6010412538:	f94023e1 	ldr	x1, [sp, #64]
  601041253c:	f94027e0 	ldr	x0, [sp, #72]
  6010412540:	97fffdeb 	bl	6010411cec <_out_rev>
  6010412544:	14000142 	b	6010412a4c <_ftoa+0x634>

    // test for very large values
    // standard printf behavior is to print EVERY whole number digit -- which could be 100s of characters overflowing your buffers == bad
    if ((value > PRINTF_MAX_FLOAT) || (value < -PRINTF_MAX_FLOAT)) {
  6010412548:	fd4017e0 	ldr	d0, [sp, #40]
  601041254c:	d2d9aca0 	mov	x0, #0xcd6500000000        	// #225833675390976
  6010412550:	f2e839a0 	movk	x0, #0x41cd, lsl #48
  6010412554:	9e670001 	fmov	d1, x0
  6010412558:	1e612010 	fcmpe	d0, d1
  601041255c:	5400010c 	b.gt	601041257c <_ftoa+0x164>
  6010412560:	fd4017e0 	ldr	d0, [sp, #40]
  6010412564:	d2d9aca0 	mov	x0, #0xcd6500000000        	// #225833675390976
  6010412568:	f2f839a0 	movk	x0, #0xc1cd, lsl #48
  601041256c:	9e670001 	fmov	d1, x0
  6010412570:	1e612010 	fcmpe	d0, d1
  6010412574:	54000044 	b.mi	601041257c <_ftoa+0x164>  // b.first
  6010412578:	1400000b 	b	60104125a4 <_ftoa+0x18c>
#if defined(PRINTF_SUPPORT_EXPONENTIAL)
        return _etoa(out, buffer, idx, maxlen, value, prec, width, flags);
  601041257c:	b9401fe6 	ldr	w6, [sp, #28]
  6010412580:	b94023e5 	ldr	w5, [sp, #32]
  6010412584:	b94027e4 	ldr	w4, [sp, #36]
  6010412588:	fd4017e0 	ldr	d0, [sp, #40]
  601041258c:	f9401be3 	ldr	x3, [sp, #48]
  6010412590:	f9401fe2 	ldr	x2, [sp, #56]
  6010412594:	f94023e1 	ldr	x1, [sp, #64]
  6010412598:	f94027e0 	ldr	x0, [sp, #72]
  601041259c:	9400012e 	bl	6010412a54 <_etoa>
  60104125a0:	1400012b 	b	6010412a4c <_ftoa+0x634>
        return 0U;
#endif
    }

    // test for negative
    bool negative = false;
  60104125a4:	39025fff 	strb	wzr, [sp, #151]
    if (value < 0) {
  60104125a8:	fd4017e0 	ldr	d0, [sp, #40]
  60104125ac:	1e602018 	fcmpe	d0, #0.0
  60104125b0:	54000044 	b.mi	60104125b8 <_ftoa+0x1a0>  // b.first
  60104125b4:	14000007 	b	60104125d0 <_ftoa+0x1b8>
        negative = true;
  60104125b8:	52800020 	mov	w0, #0x1                   	// #1
  60104125bc:	39025fe0 	strb	w0, [sp, #151]
        value = 0 - value;
  60104125c0:	2f00e401 	movi	d1, #0x0
  60104125c4:	fd4017e0 	ldr	d0, [sp, #40]
  60104125c8:	1e603820 	fsub	d0, d1, d0
  60104125cc:	fd0017e0 	str	d0, [sp, #40]
    }

    // set default precision, if not set explicitly
    if (!(flags & FLAGS_PRECISION)) {
  60104125d0:	b9401fe0 	ldr	w0, [sp, #28]
  60104125d4:	12160000 	and	w0, w0, #0x400
  60104125d8:	7100001f 	cmp	w0, #0x0
  60104125dc:	540001a1 	b.ne	6010412610 <_ftoa+0x1f8>  // b.any
        prec = PRINTF_DEFAULT_FLOAT_PRECISION;
  60104125e0:	528000c0 	mov	w0, #0x6                   	// #6
  60104125e4:	b90027e0 	str	w0, [sp, #36]
    }
    // limit precision to 9, cause a prec >= 10 can lead to overflow errors
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
  60104125e8:	1400000a 	b	6010412610 <_ftoa+0x1f8>
        buf[len++] = '0';
  60104125ec:	f9404fe0 	ldr	x0, [sp, #152]
  60104125f0:	91000401 	add	x1, x0, #0x1
  60104125f4:	f9004fe1 	str	x1, [sp, #152]
  60104125f8:	910143e1 	add	x1, sp, #0x50
  60104125fc:	52800602 	mov	w2, #0x30                  	// #48
  6010412600:	38206822 	strb	w2, [x1, x0]
        prec--;
  6010412604:	b94027e0 	ldr	w0, [sp, #36]
  6010412608:	51000400 	sub	w0, w0, #0x1
  601041260c:	b90027e0 	str	w0, [sp, #36]
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
  6010412610:	f9404fe0 	ldr	x0, [sp, #152]
  6010412614:	f1007c1f 	cmp	x0, #0x1f
  6010412618:	54000088 	b.hi	6010412628 <_ftoa+0x210>  // b.pmore
  601041261c:	b94027e0 	ldr	w0, [sp, #36]
  6010412620:	7100241f 	cmp	w0, #0x9
  6010412624:	54fffe48 	b.hi	60104125ec <_ftoa+0x1d4>  // b.pmore
    }

    int whole = (int)value;
  6010412628:	fd4017e0 	ldr	d0, [sp, #40]
  601041262c:	1e780000 	fcvtzs	w0, d0
  6010412630:	b90093e0 	str	w0, [sp, #144]
    double tmp = (value - whole) * pow10[prec];
  6010412634:	b94093e0 	ldr	w0, [sp, #144]
  6010412638:	1e620000 	scvtf	d0, w0
  601041263c:	fd4017e1 	ldr	d1, [sp, #40]
  6010412640:	1e603821 	fsub	d1, d1, d0
  6010412644:	f0000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010412648:	910c4000 	add	x0, x0, #0x310
  601041264c:	b94027e1 	ldr	w1, [sp, #36]
  6010412650:	fc617800 	ldr	d0, [x0, x1, lsl #3]
  6010412654:	1e600820 	fmul	d0, d1, d0
  6010412658:	fd003be0 	str	d0, [sp, #112]
    unsigned long frac = (unsigned long)tmp;
  601041265c:	fd403be0 	ldr	d0, [sp, #112]
  6010412660:	7ee1b800 	fcvtzu	d0, d0
  6010412664:	fd0047e0 	str	d0, [sp, #136]
    diff = tmp - frac;
  6010412668:	fd4047e0 	ldr	d0, [sp, #136]
  601041266c:	7e61d800 	ucvtf	d0, d0
  6010412670:	fd403be1 	ldr	d1, [sp, #112]
  6010412674:	1e603820 	fsub	d0, d1, d0
  6010412678:	fd003fe0 	str	d0, [sp, #120]

    if (diff > 0.5) {
  601041267c:	fd403fe1 	ldr	d1, [sp, #120]
  6010412680:	1e6c1000 	fmov	d0, #5.000000000000000000e-01
  6010412684:	1e602030 	fcmpe	d1, d0
  6010412688:	5400004c 	b.gt	6010412690 <_ftoa+0x278>
  601041268c:	14000012 	b	60104126d4 <_ftoa+0x2bc>
        ++frac;
  6010412690:	f94047e0 	ldr	x0, [sp, #136]
  6010412694:	91000400 	add	x0, x0, #0x1
  6010412698:	f90047e0 	str	x0, [sp, #136]
        // handle rollover, e.g. case 0.99 with prec 1 is 1.0
        if (frac >= pow10[prec]) {
  601041269c:	fd4047e0 	ldr	d0, [sp, #136]
  60104126a0:	7e61d801 	ucvtf	d1, d0
  60104126a4:	f0000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104126a8:	910c4000 	add	x0, x0, #0x310
  60104126ac:	b94027e1 	ldr	w1, [sp, #36]
  60104126b0:	fc617800 	ldr	d0, [x0, x1, lsl #3]
  60104126b4:	1e602030 	fcmpe	d1, d0
  60104126b8:	5400004a 	b.ge	60104126c0 <_ftoa+0x2a8>  // b.tcont
  60104126bc:	14000014 	b	601041270c <_ftoa+0x2f4>
            frac = 0;
  60104126c0:	f90047ff 	str	xzr, [sp, #136]
            ++whole;
  60104126c4:	b94093e0 	ldr	w0, [sp, #144]
  60104126c8:	11000400 	add	w0, w0, #0x1
  60104126cc:	b90093e0 	str	w0, [sp, #144]
  60104126d0:	1400000f 	b	601041270c <_ftoa+0x2f4>
        }
    } else if (diff < 0.5) {
  60104126d4:	fd403fe1 	ldr	d1, [sp, #120]
  60104126d8:	1e6c1000 	fmov	d0, #5.000000000000000000e-01
  60104126dc:	1e602030 	fcmpe	d1, d0
  60104126e0:	54000164 	b.mi	601041270c <_ftoa+0x2f4>  // b.first
    } else if ((frac == 0U) || (frac & 1U)) {
  60104126e4:	f94047e0 	ldr	x0, [sp, #136]
  60104126e8:	f100001f 	cmp	x0, #0x0
  60104126ec:	540000a0 	b.eq	6010412700 <_ftoa+0x2e8>  // b.none
  60104126f0:	f94047e0 	ldr	x0, [sp, #136]
  60104126f4:	92400000 	and	x0, x0, #0x1
  60104126f8:	f100001f 	cmp	x0, #0x0
  60104126fc:	54000080 	b.eq	601041270c <_ftoa+0x2f4>  // b.none
        // if halfway, round up if odd OR if last digit is 0
        ++frac;
  6010412700:	f94047e0 	ldr	x0, [sp, #136]
  6010412704:	91000400 	add	x0, x0, #0x1
  6010412708:	f90047e0 	str	x0, [sp, #136]
    }

    if (prec == 0U) {
  601041270c:	b94027e0 	ldr	w0, [sp, #36]
  6010412710:	7100001f 	cmp	w0, #0x0
  6010412714:	54000381 	b.ne	6010412784 <_ftoa+0x36c>  // b.any
        diff = value - (double)whole;
  6010412718:	b94093e0 	ldr	w0, [sp, #144]
  601041271c:	1e620000 	scvtf	d0, w0
  6010412720:	fd4017e1 	ldr	d1, [sp, #40]
  6010412724:	1e603820 	fsub	d0, d1, d0
  6010412728:	fd003fe0 	str	d0, [sp, #120]
        if ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) {
  601041272c:	fd403fe1 	ldr	d1, [sp, #120]
  6010412730:	1e6c1000 	fmov	d0, #5.000000000000000000e-01
  6010412734:	1e602030 	fcmpe	d1, d0
  6010412738:	1a9f57e0 	cset	w0, mi  // mi = first
  601041273c:	12001c00 	and	w0, w0, #0xff
  6010412740:	52000000 	eor	w0, w0, #0x1
  6010412744:	12001c00 	and	w0, w0, #0xff
  6010412748:	7100001f 	cmp	w0, #0x0
  601041274c:	540000c1 	b.ne	6010412764 <_ftoa+0x34c>  // b.any
  6010412750:	fd403fe1 	ldr	d1, [sp, #120]
  6010412754:	1e6c1000 	fmov	d0, #5.000000000000000000e-01
  6010412758:	1e602030 	fcmpe	d1, d0
  601041275c:	5400004c 	b.gt	6010412764 <_ftoa+0x34c>
  6010412760:	14000047 	b	601041287c <_ftoa+0x464>
  6010412764:	b94093e0 	ldr	w0, [sp, #144]
  6010412768:	12000000 	and	w0, w0, #0x1
  601041276c:	7100001f 	cmp	w0, #0x0
  6010412770:	54000c60 	b.eq	60104128fc <_ftoa+0x4e4>  // b.none
            // exactly 0.5 and ODD, then round up
            // 1.5 -> 2, but 2.5 -> 2
            ++whole;
  6010412774:	b94093e0 	ldr	w0, [sp, #144]
  6010412778:	11000400 	add	w0, w0, #0x1
  601041277c:	b90093e0 	str	w0, [sp, #144]
  6010412780:	1400005f 	b	60104128fc <_ftoa+0x4e4>
        }
    } else {
        unsigned int count = prec;
  6010412784:	b94027e0 	ldr	w0, [sp, #36]
  6010412788:	b90087e0 	str	w0, [sp, #132]
        // now do fractional part, as an unsigned number
        while (len < PRINTF_FTOA_BUFFER_SIZE) {
  601041278c:	1400001f 	b	6010412808 <_ftoa+0x3f0>
            --count;
  6010412790:	b94087e0 	ldr	w0, [sp, #132]
  6010412794:	51000400 	sub	w0, w0, #0x1
  6010412798:	b90087e0 	str	w0, [sp, #132]
            buf[len++] = (char)(48U + (frac % 10U));
  601041279c:	f94047e2 	ldr	x2, [sp, #136]
  60104127a0:	b202e7e0 	mov	x0, #0xcccccccccccccccc    	// #-3689348814741910324
  60104127a4:	f29999a0 	movk	x0, #0xcccd
  60104127a8:	9bc07c40 	umulh	x0, x2, x0
  60104127ac:	d343fc01 	lsr	x1, x0, #3
  60104127b0:	aa0103e0 	mov	x0, x1
  60104127b4:	d37ef400 	lsl	x0, x0, #2
  60104127b8:	8b010000 	add	x0, x0, x1
  60104127bc:	8b000000 	add	x0, x0, x0
  60104127c0:	cb000041 	sub	x1, x2, x0
  60104127c4:	12001c21 	and	w1, w1, #0xff
  60104127c8:	f9404fe0 	ldr	x0, [sp, #152]
  60104127cc:	91000402 	add	x2, x0, #0x1
  60104127d0:	f9004fe2 	str	x2, [sp, #152]
  60104127d4:	1100c021 	add	w1, w1, #0x30
  60104127d8:	12001c22 	and	w2, w1, #0xff
  60104127dc:	910143e1 	add	x1, sp, #0x50
  60104127e0:	38206822 	strb	w2, [x1, x0]
            if (!(frac /= 10U)) {
  60104127e4:	f94047e1 	ldr	x1, [sp, #136]
  60104127e8:	b202e7e0 	mov	x0, #0xcccccccccccccccc    	// #-3689348814741910324
  60104127ec:	f29999a0 	movk	x0, #0xcccd
  60104127f0:	9bc07c20 	umulh	x0, x1, x0
  60104127f4:	d343fc00 	lsr	x0, x0, #3
  60104127f8:	f90047e0 	str	x0, [sp, #136]
  60104127fc:	f94047e0 	ldr	x0, [sp, #136]
  6010412800:	f100001f 	cmp	x0, #0x0
  6010412804:	540000a0 	b.eq	6010412818 <_ftoa+0x400>  // b.none
        while (len < PRINTF_FTOA_BUFFER_SIZE) {
  6010412808:	f9404fe0 	ldr	x0, [sp, #152]
  601041280c:	f1007c1f 	cmp	x0, #0x1f
  6010412810:	54fffc09 	b.ls	6010412790 <_ftoa+0x378>  // b.plast
  6010412814:	14000009 	b	6010412838 <_ftoa+0x420>
                break;
  6010412818:	d503201f 	nop
            }
        }
        // add extra 0s
        while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
  601041281c:	14000007 	b	6010412838 <_ftoa+0x420>
            buf[len++] = '0';
  6010412820:	f9404fe0 	ldr	x0, [sp, #152]
  6010412824:	91000401 	add	x1, x0, #0x1
  6010412828:	f9004fe1 	str	x1, [sp, #152]
  601041282c:	910143e1 	add	x1, sp, #0x50
  6010412830:	52800602 	mov	w2, #0x30                  	// #48
  6010412834:	38206822 	strb	w2, [x1, x0]
        while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
  6010412838:	f9404fe0 	ldr	x0, [sp, #152]
  601041283c:	f1007c1f 	cmp	x0, #0x1f
  6010412840:	540000c8 	b.hi	6010412858 <_ftoa+0x440>  // b.pmore
  6010412844:	b94087e0 	ldr	w0, [sp, #132]
  6010412848:	51000401 	sub	w1, w0, #0x1
  601041284c:	b90087e1 	str	w1, [sp, #132]
  6010412850:	7100001f 	cmp	w0, #0x0
  6010412854:	54fffe61 	b.ne	6010412820 <_ftoa+0x408>  // b.any
        }
        if (len < PRINTF_FTOA_BUFFER_SIZE) {
  6010412858:	f9404fe0 	ldr	x0, [sp, #152]
  601041285c:	f1007c1f 	cmp	x0, #0x1f
  6010412860:	540004e8 	b.hi	60104128fc <_ftoa+0x4e4>  // b.pmore
            // add decimal
            buf[len++] = '.';
  6010412864:	f9404fe0 	ldr	x0, [sp, #152]
  6010412868:	91000401 	add	x1, x0, #0x1
  601041286c:	f9004fe1 	str	x1, [sp, #152]
  6010412870:	910143e1 	add	x1, sp, #0x50
  6010412874:	528005c2 	mov	w2, #0x2e                  	// #46
  6010412878:	38206822 	strb	w2, [x1, x0]
        }
    }

    // do whole part, number is reversed
    while (len < PRINTF_FTOA_BUFFER_SIZE) {
  601041287c:	14000020 	b	60104128fc <_ftoa+0x4e4>
        buf[len++] = (char)(48 + (whole % 10));
  6010412880:	b94093e0 	ldr	w0, [sp, #144]
  6010412884:	528ccce1 	mov	w1, #0x6667                	// #26215
  6010412888:	72acccc1 	movk	w1, #0x6666, lsl #16
  601041288c:	9b217c01 	smull	x1, w0, w1
  6010412890:	d360fc21 	lsr	x1, x1, #32
  6010412894:	13027c22 	asr	w2, w1, #2
  6010412898:	131f7c01 	asr	w1, w0, #31
  601041289c:	4b010041 	sub	w1, w2, w1
  60104128a0:	52800142 	mov	w2, #0xa                   	// #10
  60104128a4:	1b027c21 	mul	w1, w1, w2
  60104128a8:	4b010001 	sub	w1, w0, w1
  60104128ac:	12001c21 	and	w1, w1, #0xff
  60104128b0:	f9404fe0 	ldr	x0, [sp, #152]
  60104128b4:	91000402 	add	x2, x0, #0x1
  60104128b8:	f9004fe2 	str	x2, [sp, #152]
  60104128bc:	1100c021 	add	w1, w1, #0x30
  60104128c0:	12001c22 	and	w2, w1, #0xff
  60104128c4:	910143e1 	add	x1, sp, #0x50
  60104128c8:	38206822 	strb	w2, [x1, x0]
        if (!(whole /= 10)) {
  60104128cc:	b94093e0 	ldr	w0, [sp, #144]
  60104128d0:	528ccce1 	mov	w1, #0x6667                	// #26215
  60104128d4:	72acccc1 	movk	w1, #0x6666, lsl #16
  60104128d8:	9b217c01 	smull	x1, w0, w1
  60104128dc:	d360fc21 	lsr	x1, x1, #32
  60104128e0:	13027c21 	asr	w1, w1, #2
  60104128e4:	131f7c00 	asr	w0, w0, #31
  60104128e8:	4b000020 	sub	w0, w1, w0
  60104128ec:	b90093e0 	str	w0, [sp, #144]
  60104128f0:	b94093e0 	ldr	w0, [sp, #144]
  60104128f4:	7100001f 	cmp	w0, #0x0
  60104128f8:	540000a0 	b.eq	601041290c <_ftoa+0x4f4>  // b.none
    while (len < PRINTF_FTOA_BUFFER_SIZE) {
  60104128fc:	f9404fe0 	ldr	x0, [sp, #152]
  6010412900:	f1007c1f 	cmp	x0, #0x1f
  6010412904:	54fffbe9 	b.ls	6010412880 <_ftoa+0x468>  // b.plast
  6010412908:	14000002 	b	6010412910 <_ftoa+0x4f8>
            break;
  601041290c:	d503201f 	nop
        }
    }

    // pad leading zeros
    if (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD)) {
  6010412910:	b9401fe0 	ldr	w0, [sp, #28]
  6010412914:	121f0000 	and	w0, w0, #0x2
  6010412918:	7100001f 	cmp	w0, #0x0
  601041291c:	54000401 	b.ne	601041299c <_ftoa+0x584>  // b.any
  6010412920:	b9401fe0 	ldr	w0, [sp, #28]
  6010412924:	12000000 	and	w0, w0, #0x1
  6010412928:	7100001f 	cmp	w0, #0x0
  601041292c:	54000380 	b.eq	601041299c <_ftoa+0x584>  // b.none
        if (width && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
  6010412930:	b94023e0 	ldr	w0, [sp, #32]
  6010412934:	7100001f 	cmp	w0, #0x0
  6010412938:	54000240 	b.eq	6010412980 <_ftoa+0x568>  // b.none
  601041293c:	39425fe0 	ldrb	w0, [sp, #151]
  6010412940:	7100001f 	cmp	w0, #0x0
  6010412944:	540000a1 	b.ne	6010412958 <_ftoa+0x540>  // b.any
  6010412948:	b9401fe0 	ldr	w0, [sp, #28]
  601041294c:	121e0400 	and	w0, w0, #0xc
  6010412950:	7100001f 	cmp	w0, #0x0
  6010412954:	54000160 	b.eq	6010412980 <_ftoa+0x568>  // b.none
            width--;
  6010412958:	b94023e0 	ldr	w0, [sp, #32]
  601041295c:	51000400 	sub	w0, w0, #0x1
  6010412960:	b90023e0 	str	w0, [sp, #32]
        }
        while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
  6010412964:	14000007 	b	6010412980 <_ftoa+0x568>
            buf[len++] = '0';
  6010412968:	f9404fe0 	ldr	x0, [sp, #152]
  601041296c:	91000401 	add	x1, x0, #0x1
  6010412970:	f9004fe1 	str	x1, [sp, #152]
  6010412974:	910143e1 	add	x1, sp, #0x50
  6010412978:	52800602 	mov	w2, #0x30                  	// #48
  601041297c:	38206822 	strb	w2, [x1, x0]
        while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
  6010412980:	b94023e0 	ldr	w0, [sp, #32]
  6010412984:	f9404fe1 	ldr	x1, [sp, #152]
  6010412988:	eb00003f 	cmp	x1, x0
  601041298c:	54000082 	b.cs	601041299c <_ftoa+0x584>  // b.hs, b.nlast
  6010412990:	f9404fe0 	ldr	x0, [sp, #152]
  6010412994:	f1007c1f 	cmp	x0, #0x1f
  6010412998:	54fffe89 	b.ls	6010412968 <_ftoa+0x550>  // b.plast
        }
    }

    if (len < PRINTF_FTOA_BUFFER_SIZE) {
  601041299c:	f9404fe0 	ldr	x0, [sp, #152]
  60104129a0:	f1007c1f 	cmp	x0, #0x1f
  60104129a4:	54000408 	b.hi	6010412a24 <_ftoa+0x60c>  // b.pmore
        if (negative) {
  60104129a8:	39425fe0 	ldrb	w0, [sp, #151]
  60104129ac:	7100001f 	cmp	w0, #0x0
  60104129b0:	54000100 	b.eq	60104129d0 <_ftoa+0x5b8>  // b.none
            buf[len++] = '-';
  60104129b4:	f9404fe0 	ldr	x0, [sp, #152]
  60104129b8:	91000401 	add	x1, x0, #0x1
  60104129bc:	f9004fe1 	str	x1, [sp, #152]
  60104129c0:	910143e1 	add	x1, sp, #0x50
  60104129c4:	528005a2 	mov	w2, #0x2d                  	// #45
  60104129c8:	38206822 	strb	w2, [x1, x0]
  60104129cc:	14000016 	b	6010412a24 <_ftoa+0x60c>
        } else if (flags & FLAGS_PLUS) {
  60104129d0:	b9401fe0 	ldr	w0, [sp, #28]
  60104129d4:	121e0000 	and	w0, w0, #0x4
  60104129d8:	7100001f 	cmp	w0, #0x0
  60104129dc:	54000100 	b.eq	60104129fc <_ftoa+0x5e4>  // b.none
            buf[len++] = '+'; // ignore the space if the '+' exists
  60104129e0:	f9404fe0 	ldr	x0, [sp, #152]
  60104129e4:	91000401 	add	x1, x0, #0x1
  60104129e8:	f9004fe1 	str	x1, [sp, #152]
  60104129ec:	910143e1 	add	x1, sp, #0x50
  60104129f0:	52800562 	mov	w2, #0x2b                  	// #43
  60104129f4:	38206822 	strb	w2, [x1, x0]
  60104129f8:	1400000b 	b	6010412a24 <_ftoa+0x60c>
        } else if (flags & FLAGS_SPACE) {
  60104129fc:	b9401fe0 	ldr	w0, [sp, #28]
  6010412a00:	121d0000 	and	w0, w0, #0x8
  6010412a04:	7100001f 	cmp	w0, #0x0
  6010412a08:	540000e0 	b.eq	6010412a24 <_ftoa+0x60c>  // b.none
            buf[len++] = ' ';
  6010412a0c:	f9404fe0 	ldr	x0, [sp, #152]
  6010412a10:	91000401 	add	x1, x0, #0x1
  6010412a14:	f9004fe1 	str	x1, [sp, #152]
  6010412a18:	910143e1 	add	x1, sp, #0x50
  6010412a1c:	52800402 	mov	w2, #0x20                  	// #32
  6010412a20:	38206822 	strb	w2, [x1, x0]
        }
    }

    return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
  6010412a24:	910143e0 	add	x0, sp, #0x50
  6010412a28:	b9401fe7 	ldr	w7, [sp, #28]
  6010412a2c:	b94023e6 	ldr	w6, [sp, #32]
  6010412a30:	f9404fe5 	ldr	x5, [sp, #152]
  6010412a34:	aa0003e4 	mov	x4, x0
  6010412a38:	f9401be3 	ldr	x3, [sp, #48]
  6010412a3c:	f9401fe2 	ldr	x2, [sp, #56]
  6010412a40:	f94023e1 	ldr	x1, [sp, #64]
  6010412a44:	f94027e0 	ldr	x0, [sp, #72]
  6010412a48:	97fffca9 	bl	6010411cec <_out_rev>
}
  6010412a4c:	a8ca7bfd 	ldp	x29, x30, [sp], #160
  6010412a50:	d65f03c0 	ret

0000006010412a54 <_etoa>:

#if defined(PRINTF_SUPPORT_EXPONENTIAL)
// internal ftoa variant for exponential floating-point type, contributed by Martijn Jasperse <m.jasperse@gmail.com>
static size_t _etoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value, unsigned int prec, unsigned int width, unsigned int flags)
{
  6010412a54:	d10283ff 	sub	sp, sp, #0xa0
  6010412a58:	a9017bfd 	stp	x29, x30, [sp, #16]
  6010412a5c:	910043fd 	add	x29, sp, #0x10
  6010412a60:	f9002fe0 	str	x0, [sp, #88]
  6010412a64:	f9002be1 	str	x1, [sp, #80]
  6010412a68:	f90027e2 	str	x2, [sp, #72]
  6010412a6c:	f90023e3 	str	x3, [sp, #64]
  6010412a70:	fd001fe0 	str	d0, [sp, #56]
  6010412a74:	b90037e4 	str	w4, [sp, #52]
  6010412a78:	b90033e5 	str	w5, [sp, #48]
  6010412a7c:	b9002fe6 	str	w6, [sp, #44]
    // check for NaN and special values
    if ((value != value) || (value > DBL_MAX) || (value < -DBL_MAX)) {
  6010412a80:	fd401fe1 	ldr	d1, [sp, #56]
  6010412a84:	fd401fe0 	ldr	d0, [sp, #56]
  6010412a88:	1e602020 	fcmp	d1, d0
  6010412a8c:	54000181 	b.ne	6010412abc <_etoa+0x68>  // b.any
  6010412a90:	fd401fe0 	ldr	d0, [sp, #56]
  6010412a94:	92f00200 	mov	x0, #0x7fefffffffffffff    	// #9218868437227405311
  6010412a98:	9e670001 	fmov	d1, x0
  6010412a9c:	1e612010 	fcmpe	d0, d1
  6010412aa0:	540000ec 	b.gt	6010412abc <_etoa+0x68>
  6010412aa4:	fd401fe0 	ldr	d0, [sp, #56]
  6010412aa8:	92e00200 	mov	x0, #0xffefffffffffffff    	// #-4503599627370497
  6010412aac:	9e670001 	fmov	d1, x0
  6010412ab0:	1e612010 	fcmpe	d0, d1
  6010412ab4:	54000044 	b.mi	6010412abc <_etoa+0x68>  // b.first
  6010412ab8:	1400000b 	b	6010412ae4 <_etoa+0x90>
        return _ftoa(out, buffer, idx, maxlen, value, prec, width, flags);
  6010412abc:	b9402fe6 	ldr	w6, [sp, #44]
  6010412ac0:	b94033e5 	ldr	w5, [sp, #48]
  6010412ac4:	b94037e4 	ldr	w4, [sp, #52]
  6010412ac8:	fd401fe0 	ldr	d0, [sp, #56]
  6010412acc:	f94023e3 	ldr	x3, [sp, #64]
  6010412ad0:	f94027e2 	ldr	x2, [sp, #72]
  6010412ad4:	f9402be1 	ldr	x1, [sp, #80]
  6010412ad8:	f9402fe0 	ldr	x0, [sp, #88]
  6010412adc:	97fffe4f 	bl	6010412418 <_ftoa>
  6010412ae0:	14000110 	b	6010412f20 <_etoa+0x4cc>
    }

    // determine the sign
    const bool negative = value < 0;
  6010412ae4:	fd401fe0 	ldr	d0, [sp, #56]
  6010412ae8:	1e602018 	fcmpe	d0, #0.0
  6010412aec:	1a9f57e0 	cset	w0, mi  // mi = first
  6010412af0:	39024fe0 	strb	w0, [sp, #147]
    if (negative) {
  6010412af4:	39424fe0 	ldrb	w0, [sp, #147]
  6010412af8:	7100001f 	cmp	w0, #0x0
  6010412afc:	54000080 	b.eq	6010412b0c <_etoa+0xb8>  // b.none
        value = -value;
  6010412b00:	fd401fe0 	ldr	d0, [sp, #56]
  6010412b04:	1e614000 	fneg	d0, d0
  6010412b08:	fd001fe0 	str	d0, [sp, #56]
    }

    // default precision
    if (!(flags & FLAGS_PRECISION)) {
  6010412b0c:	b9402fe0 	ldr	w0, [sp, #44]
  6010412b10:	12160000 	and	w0, w0, #0x400
  6010412b14:	7100001f 	cmp	w0, #0x0
  6010412b18:	54000061 	b.ne	6010412b24 <_etoa+0xd0>  // b.any
        prec = PRINTF_DEFAULT_FLOAT_PRECISION;
  6010412b1c:	528000c0 	mov	w0, #0x6                   	// #6
  6010412b20:	b90037e0 	str	w0, [sp, #52]
    union {
        uint64_t U;
        double F;
    } conv;

    conv.F = value;
  6010412b24:	fd401fe0 	ldr	d0, [sp, #56]
  6010412b28:	fd0037e0 	str	d0, [sp, #104]
    int exp2 = (int)((conv.U >> 52U) & 0x07FFU) - 1023; // effectively log2
  6010412b2c:	f94037e0 	ldr	x0, [sp, #104]
  6010412b30:	d374fc00 	lsr	x0, x0, #52
  6010412b34:	12002800 	and	w0, w0, #0x7ff
  6010412b38:	510ffc00 	sub	w0, w0, #0x3ff
  6010412b3c:	b9008fe0 	str	w0, [sp, #140]
    conv.U = (conv.U & ((1ULL << 52U) - 1U)) | (1023ULL << 52U); // drop the exponent so conv.F is now in [1,2)
  6010412b40:	f94037e0 	ldr	x0, [sp, #104]
  6010412b44:	9240cc00 	and	x0, x0, #0xfffffffffffff
  6010412b48:	b24c2400 	orr	x0, x0, #0x3ff0000000000000
  6010412b4c:	f90037e0 	str	x0, [sp, #104]
    // now approximate log10 from the log2 integer part and an expansion of ln around 1.5
    int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
  6010412b50:	b9408fe0 	ldr	w0, [sp, #140]
  6010412b54:	1e620000 	scvtf	d0, w0
  6010412b58:	f0000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010412b5c:	fd41b001 	ldr	d1, [x0, #864]
  6010412b60:	1e610800 	fmul	d0, d0, d1
  6010412b64:	f0000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010412b68:	fd41b401 	ldr	d1, [x0, #872]
  6010412b6c:	1e612801 	fadd	d1, d0, d1
  6010412b70:	fd4037e2 	ldr	d2, [sp, #104]
  6010412b74:	1e6f1000 	fmov	d0, #1.500000000000000000e+00
  6010412b78:	1e603840 	fsub	d0, d2, d0
  6010412b7c:	f0000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010412b80:	fd41b802 	ldr	d2, [x0, #880]
  6010412b84:	1e620800 	fmul	d0, d0, d2
  6010412b88:	1e602820 	fadd	d0, d1, d0
  6010412b8c:	1e780000 	fcvtzs	w0, d0
  6010412b90:	b9009fe0 	str	w0, [sp, #156]
    // now we want to compute 10^expval but we want to be sure it won't overflow
    exp2 = (int)(expval * 3.321928094887362 + 0.5);
  6010412b94:	b9409fe0 	ldr	w0, [sp, #156]
  6010412b98:	1e620000 	scvtf	d0, w0
  6010412b9c:	f0000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010412ba0:	fd41bc01 	ldr	d1, [x0, #888]
  6010412ba4:	1e610801 	fmul	d1, d0, d1
  6010412ba8:	1e6c1000 	fmov	d0, #5.000000000000000000e-01
  6010412bac:	1e602820 	fadd	d0, d1, d0
  6010412bb0:	1e780000 	fcvtzs	w0, d0
  6010412bb4:	b9008fe0 	str	w0, [sp, #140]
    const double z = expval * 2.302585092994046 - exp2 * 0.6931471805599453;
  6010412bb8:	b9409fe0 	ldr	w0, [sp, #156]
  6010412bbc:	1e620000 	scvtf	d0, w0
  6010412bc0:	f0000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010412bc4:	fd41c001 	ldr	d1, [x0, #896]
  6010412bc8:	1e610801 	fmul	d1, d0, d1
  6010412bcc:	b9408fe0 	ldr	w0, [sp, #140]
  6010412bd0:	1e620000 	scvtf	d0, w0
  6010412bd4:	f0000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010412bd8:	fd41c402 	ldr	d2, [x0, #904]
  6010412bdc:	1e620800 	fmul	d0, d0, d2
  6010412be0:	1e603820 	fsub	d0, d1, d0
  6010412be4:	fd0043e0 	str	d0, [sp, #128]
    const double z2 = z * z;
  6010412be8:	fd4043e0 	ldr	d0, [sp, #128]
  6010412bec:	1e600800 	fmul	d0, d0, d0
  6010412bf0:	fd003fe0 	str	d0, [sp, #120]
    conv.U = (uint64_t)(exp2 + 1023) << 52U;
  6010412bf4:	b9408fe0 	ldr	w0, [sp, #140]
  6010412bf8:	110ffc00 	add	w0, w0, #0x3ff
  6010412bfc:	93407c00 	sxtw	x0, w0
  6010412c00:	d34c2c00 	lsl	x0, x0, #52
  6010412c04:	f90037e0 	str	x0, [sp, #104]
    // compute exp(z) using continued fractions, see https://en.wikipedia.org/wiki/Exponential_function#Continued_fractions_for_ex
    conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
  6010412c08:	fd4037e1 	ldr	d1, [sp, #104]
  6010412c0c:	fd4043e0 	ldr	d0, [sp, #128]
  6010412c10:	1e602802 	fadd	d2, d0, d0
  6010412c14:	1e601003 	fmov	d3, #2.000000000000000000e+00
  6010412c18:	fd4043e0 	ldr	d0, [sp, #128]
  6010412c1c:	1e603863 	fsub	d3, d3, d0
  6010412c20:	1e659000 	fmov	d0, #1.400000000000000000e+01
  6010412c24:	fd403fe4 	ldr	d4, [sp, #120]
  6010412c28:	1e601884 	fdiv	d4, d4, d0
  6010412c2c:	1e649000 	fmov	d0, #1.000000000000000000e+01
  6010412c30:	1e602880 	fadd	d0, d4, d0
  6010412c34:	fd403fe4 	ldr	d4, [sp, #120]
  6010412c38:	1e601884 	fdiv	d4, d4, d0
  6010412c3c:	1e631000 	fmov	d0, #6.000000000000000000e+00
  6010412c40:	1e602880 	fadd	d0, d4, d0
  6010412c44:	fd403fe4 	ldr	d4, [sp, #120]
  6010412c48:	1e601880 	fdiv	d0, d4, d0
  6010412c4c:	1e602860 	fadd	d0, d3, d0
  6010412c50:	1e601842 	fdiv	d2, d2, d0
  6010412c54:	1e6e1000 	fmov	d0, #1.000000000000000000e+00
  6010412c58:	1e602840 	fadd	d0, d2, d0
  6010412c5c:	1e600820 	fmul	d0, d1, d0
  6010412c60:	fd0037e0 	str	d0, [sp, #104]
    // correct for rounding errors
    if (value < conv.F) {
  6010412c64:	fd4037e0 	ldr	d0, [sp, #104]
  6010412c68:	fd401fe1 	ldr	d1, [sp, #56]
  6010412c6c:	1e602030 	fcmpe	d1, d0
  6010412c70:	54000044 	b.mi	6010412c78 <_etoa+0x224>  // b.first
  6010412c74:	14000008 	b	6010412c94 <_etoa+0x240>
        expval--;
  6010412c78:	b9409fe0 	ldr	w0, [sp, #156]
  6010412c7c:	51000400 	sub	w0, w0, #0x1
  6010412c80:	b9009fe0 	str	w0, [sp, #156]
        conv.F /= 10;
  6010412c84:	fd4037e1 	ldr	d1, [sp, #104]
  6010412c88:	1e649000 	fmov	d0, #1.000000000000000000e+01
  6010412c8c:	1e601820 	fdiv	d0, d1, d0
  6010412c90:	fd0037e0 	str	d0, [sp, #104]
    }

    // the exponent format is "%+03d" and largest value is "307", so set aside 4-5 characters
    unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;
  6010412c94:	b9409fe0 	ldr	w0, [sp, #156]
  6010412c98:	71018c1f 	cmp	w0, #0x63
  6010412c9c:	540000cc 	b.gt	6010412cb4 <_etoa+0x260>
  6010412ca0:	b9409fe0 	ldr	w0, [sp, #156]
  6010412ca4:	31018c1f 	cmn	w0, #0x63
  6010412ca8:	5400006b 	b.lt	6010412cb4 <_etoa+0x260>  // b.tstop
  6010412cac:	52800080 	mov	w0, #0x4                   	// #4
  6010412cb0:	14000002 	b	6010412cb8 <_etoa+0x264>
  6010412cb4:	528000a0 	mov	w0, #0x5                   	// #5
  6010412cb8:	b9009be0 	str	w0, [sp, #152]

    // in "%g" mode, "prec" is the number of *significant figures* not decimals
    if (flags & FLAGS_ADAPT_EXP) {
  6010412cbc:	b9402fe0 	ldr	w0, [sp, #44]
  6010412cc0:	12150000 	and	w0, w0, #0x800
  6010412cc4:	7100001f 	cmp	w0, #0x0
  6010412cc8:	54000520 	b.eq	6010412d6c <_etoa+0x318>  // b.none
        // do we want to fall-back to "%f" mode?
        if ((value >= 1e-4) && (value < 1e6)) {
  6010412ccc:	fd401fe0 	ldr	d0, [sp, #56]
  6010412cd0:	f0000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010412cd4:	fd41c801 	ldr	d1, [x0, #912]
  6010412cd8:	1e612010 	fcmpe	d0, d1
  6010412cdc:	5400004a 	b.ge	6010412ce4 <_etoa+0x290>  // b.tcont
  6010412ce0:	14000019 	b	6010412d44 <_etoa+0x2f0>
  6010412ce4:	fd401fe0 	ldr	d0, [sp, #56]
  6010412ce8:	d2d09000 	mov	x0, #0x848000000000        	// #145685290680320
  6010412cec:	f2e825c0 	movk	x0, #0x412e, lsl #48
  6010412cf0:	9e670001 	fmov	d1, x0
  6010412cf4:	1e612010 	fcmpe	d0, d1
  6010412cf8:	54000044 	b.mi	6010412d00 <_etoa+0x2ac>  // b.first
  6010412cfc:	14000012 	b	6010412d44 <_etoa+0x2f0>
            if ((int)prec > expval) {
  6010412d00:	b94037e0 	ldr	w0, [sp, #52]
  6010412d04:	b9409fe1 	ldr	w1, [sp, #156]
  6010412d08:	6b00003f 	cmp	w1, w0
  6010412d0c:	540000ea 	b.ge	6010412d28 <_etoa+0x2d4>  // b.tcont
                prec = (unsigned)((int)prec - expval - 1);
  6010412d10:	b94037e1 	ldr	w1, [sp, #52]
  6010412d14:	b9409fe0 	ldr	w0, [sp, #156]
  6010412d18:	4b000020 	sub	w0, w1, w0
  6010412d1c:	51000400 	sub	w0, w0, #0x1
  6010412d20:	b90037e0 	str	w0, [sp, #52]
  6010412d24:	14000002 	b	6010412d2c <_etoa+0x2d8>
            } else {
                prec = 0;
  6010412d28:	b90037ff 	str	wzr, [sp, #52]
            }
            flags |= FLAGS_PRECISION; // make sure _ftoa respects precision
  6010412d2c:	b9402fe0 	ldr	w0, [sp, #44]
  6010412d30:	32160000 	orr	w0, w0, #0x400
  6010412d34:	b9002fe0 	str	w0, [sp, #44]
            // no characters in exponent
            minwidth = 0U;
  6010412d38:	b9009bff 	str	wzr, [sp, #152]
            expval = 0;
  6010412d3c:	b9009fff 	str	wzr, [sp, #156]
  6010412d40:	1400000b 	b	6010412d6c <_etoa+0x318>
        } else {
            // we use one sigfig for the whole part
            if ((prec > 0) && (flags & FLAGS_PRECISION)) {
  6010412d44:	b94037e0 	ldr	w0, [sp, #52]
  6010412d48:	7100001f 	cmp	w0, #0x0
  6010412d4c:	54000100 	b.eq	6010412d6c <_etoa+0x318>  // b.none
  6010412d50:	b9402fe0 	ldr	w0, [sp, #44]
  6010412d54:	12160000 	and	w0, w0, #0x400
  6010412d58:	7100001f 	cmp	w0, #0x0
  6010412d5c:	54000080 	b.eq	6010412d6c <_etoa+0x318>  // b.none
                --prec;
  6010412d60:	b94037e0 	ldr	w0, [sp, #52]
  6010412d64:	51000400 	sub	w0, w0, #0x1
  6010412d68:	b90037e0 	str	w0, [sp, #52]
            }
        }
    }

    // will everything fit?
    unsigned int fwidth = width;
  6010412d6c:	b94033e0 	ldr	w0, [sp, #48]
  6010412d70:	b90097e0 	str	w0, [sp, #148]
    if (width > minwidth) {
  6010412d74:	b94033e1 	ldr	w1, [sp, #48]
  6010412d78:	b9409be0 	ldr	w0, [sp, #152]
  6010412d7c:	6b00003f 	cmp	w1, w0
  6010412d80:	540000c9 	b.ls	6010412d98 <_etoa+0x344>  // b.plast
        // we didn't fall-back so subtract the characters required for the exponent
        fwidth -= minwidth;
  6010412d84:	b94097e1 	ldr	w1, [sp, #148]
  6010412d88:	b9409be0 	ldr	w0, [sp, #152]
  6010412d8c:	4b000020 	sub	w0, w1, w0
  6010412d90:	b90097e0 	str	w0, [sp, #148]
  6010412d94:	14000002 	b	6010412d9c <_etoa+0x348>
    } else {
        // not enough characters, so go back to default sizing
        fwidth = 0U;
  6010412d98:	b90097ff 	str	wzr, [sp, #148]
    }
    if ((flags & FLAGS_LEFT) && minwidth) {
  6010412d9c:	b9402fe0 	ldr	w0, [sp, #44]
  6010412da0:	121f0000 	and	w0, w0, #0x2
  6010412da4:	7100001f 	cmp	w0, #0x0
  6010412da8:	540000a0 	b.eq	6010412dbc <_etoa+0x368>  // b.none
  6010412dac:	b9409be0 	ldr	w0, [sp, #152]
  6010412db0:	7100001f 	cmp	w0, #0x0
  6010412db4:	54000040 	b.eq	6010412dbc <_etoa+0x368>  // b.none
        // if we're padding on the right, DON'T pad the floating part
        fwidth = 0U;
  6010412db8:	b90097ff 	str	wzr, [sp, #148]
    }

    // rescale the float value
    if (expval) {
  6010412dbc:	b9409fe0 	ldr	w0, [sp, #156]
  6010412dc0:	7100001f 	cmp	w0, #0x0
  6010412dc4:	540000a0 	b.eq	6010412dd8 <_etoa+0x384>  // b.none
        value /= conv.F;
  6010412dc8:	fd4037e0 	ldr	d0, [sp, #104]
  6010412dcc:	fd401fe1 	ldr	d1, [sp, #56]
  6010412dd0:	1e601820 	fdiv	d0, d1, d0
  6010412dd4:	fd001fe0 	str	d0, [sp, #56]
    }

    // output the floating part
    const size_t start_idx = idx;
  6010412dd8:	f94027e0 	ldr	x0, [sp, #72]
  6010412ddc:	f9003be0 	str	x0, [sp, #112]
    idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);
  6010412de0:	39424fe0 	ldrb	w0, [sp, #147]
  6010412de4:	7100001f 	cmp	w0, #0x0
  6010412de8:	54000080 	b.eq	6010412df8 <_etoa+0x3a4>  // b.none
  6010412dec:	fd401fe0 	ldr	d0, [sp, #56]
  6010412df0:	1e614000 	fneg	d0, d0
  6010412df4:	14000002 	b	6010412dfc <_etoa+0x3a8>
  6010412df8:	fd401fe0 	ldr	d0, [sp, #56]
  6010412dfc:	b9402fe0 	ldr	w0, [sp, #44]
  6010412e00:	12147800 	and	w0, w0, #0xfffff7ff
  6010412e04:	2a0003e6 	mov	w6, w0
  6010412e08:	b94097e5 	ldr	w5, [sp, #148]
  6010412e0c:	b94037e4 	ldr	w4, [sp, #52]
  6010412e10:	f94023e3 	ldr	x3, [sp, #64]
  6010412e14:	f94027e2 	ldr	x2, [sp, #72]
  6010412e18:	f9402be1 	ldr	x1, [sp, #80]
  6010412e1c:	f9402fe0 	ldr	x0, [sp, #88]
  6010412e20:	97fffd7e 	bl	6010412418 <_ftoa>
  6010412e24:	f90027e0 	str	x0, [sp, #72]

    // output the exponent part
    if (minwidth) {
  6010412e28:	b9409be0 	ldr	w0, [sp, #152]
  6010412e2c:	7100001f 	cmp	w0, #0x0
  6010412e30:	54000760 	b.eq	6010412f1c <_etoa+0x4c8>  // b.none
        // output the exponential symbol
        out((flags & FLAGS_UPPERCASE) ? 'E' : 'e', buffer, idx++, maxlen);
  6010412e34:	b9402fe0 	ldr	w0, [sp, #44]
  6010412e38:	121b0000 	and	w0, w0, #0x20
  6010412e3c:	7100001f 	cmp	w0, #0x0
  6010412e40:	54000060 	b.eq	6010412e4c <_etoa+0x3f8>  // b.none
  6010412e44:	528008a4 	mov	w4, #0x45                  	// #69
  6010412e48:	14000002 	b	6010412e50 <_etoa+0x3fc>
  6010412e4c:	52800ca4 	mov	w4, #0x65                  	// #101
  6010412e50:	f94027e0 	ldr	x0, [sp, #72]
  6010412e54:	91000401 	add	x1, x0, #0x1
  6010412e58:	f90027e1 	str	x1, [sp, #72]
  6010412e5c:	f9402fe5 	ldr	x5, [sp, #88]
  6010412e60:	f94023e3 	ldr	x3, [sp, #64]
  6010412e64:	aa0003e2 	mov	x2, x0
  6010412e68:	f9402be1 	ldr	x1, [sp, #80]
  6010412e6c:	2a0403e0 	mov	w0, w4
  6010412e70:	d63f00a0 	blr	x5
        // output the exponent value
        idx = _ntoa_long(out, buffer, idx, maxlen, (expval < 0) ? -expval : expval, expval < 0, 10, 0, minwidth - 1, FLAGS_ZEROPAD | FLAGS_PLUS);
  6010412e74:	b9409fe0 	ldr	w0, [sp, #156]
  6010412e78:	7100001f 	cmp	w0, #0x0
  6010412e7c:	5a80a400 	cneg	w0, w0, lt  // lt = tstop
  6010412e80:	93407c02 	sxtw	x2, w0
  6010412e84:	b9409fe0 	ldr	w0, [sp, #156]
  6010412e88:	531f7c00 	lsr	w0, w0, #31
  6010412e8c:	12001c03 	and	w3, w0, #0xff
  6010412e90:	b9409be0 	ldr	w0, [sp, #152]
  6010412e94:	51000400 	sub	w0, w0, #0x1
  6010412e98:	528000a1 	mov	w1, #0x5                   	// #5
  6010412e9c:	b9000be1 	str	w1, [sp, #8]
  6010412ea0:	b90003e0 	str	w0, [sp]
  6010412ea4:	52800007 	mov	w7, #0x0                   	// #0
  6010412ea8:	d2800146 	mov	x6, #0xa                   	// #10
  6010412eac:	2a0303e5 	mov	w5, w3
  6010412eb0:	aa0203e4 	mov	x4, x2
  6010412eb4:	f94023e3 	ldr	x3, [sp, #64]
  6010412eb8:	f94027e2 	ldr	x2, [sp, #72]
  6010412ebc:	f9402be1 	ldr	x1, [sp, #80]
  6010412ec0:	f9402fe0 	ldr	x0, [sp, #88]
  6010412ec4:	97fffca7 	bl	6010412160 <_ntoa_long>
  6010412ec8:	f90027e0 	str	x0, [sp, #72]
        // might need to right-pad spaces
        if (flags & FLAGS_LEFT) {
  6010412ecc:	b9402fe0 	ldr	w0, [sp, #44]
  6010412ed0:	121f0000 	and	w0, w0, #0x2
  6010412ed4:	7100001f 	cmp	w0, #0x0
  6010412ed8:	54000220 	b.eq	6010412f1c <_etoa+0x4c8>  // b.none
            while (idx - start_idx < width)
  6010412edc:	1400000a 	b	6010412f04 <_etoa+0x4b0>
                out(' ', buffer, idx++, maxlen);
  6010412ee0:	f94027e0 	ldr	x0, [sp, #72]
  6010412ee4:	91000401 	add	x1, x0, #0x1
  6010412ee8:	f90027e1 	str	x1, [sp, #72]
  6010412eec:	f9402fe4 	ldr	x4, [sp, #88]
  6010412ef0:	f94023e3 	ldr	x3, [sp, #64]
  6010412ef4:	aa0003e2 	mov	x2, x0
  6010412ef8:	f9402be1 	ldr	x1, [sp, #80]
  6010412efc:	52800400 	mov	w0, #0x20                  	// #32
  6010412f00:	d63f0080 	blr	x4
            while (idx - start_idx < width)
  6010412f04:	f94027e1 	ldr	x1, [sp, #72]
  6010412f08:	f9403be0 	ldr	x0, [sp, #112]
  6010412f0c:	cb000021 	sub	x1, x1, x0
  6010412f10:	b94033e0 	ldr	w0, [sp, #48]
  6010412f14:	eb00003f 	cmp	x1, x0
  6010412f18:	54fffe43 	b.cc	6010412ee0 <_etoa+0x48c>  // b.lo, b.ul, b.last
        }
    }
    return idx;
  6010412f1c:	f94027e0 	ldr	x0, [sp, #72]
}
  6010412f20:	a9417bfd 	ldp	x29, x30, [sp, #16]
  6010412f24:	910283ff 	add	sp, sp, #0xa0
  6010412f28:	d65f03c0 	ret

0000006010412f2c <_vsnprintf>:
#endif // PRINTF_SUPPORT_EXPONENTIAL
#endif // PRINTF_SUPPORT_FLOAT

// internal vsnprintf
static int _vsnprintf(out_fct_type out, char* buffer, const size_t maxlen, const char* format, va_list va)
{
  6010412f2c:	d10283ff 	sub	sp, sp, #0xa0
  6010412f30:	a9017bfd 	stp	x29, x30, [sp, #16]
  6010412f34:	910043fd 	add	x29, sp, #0x10
  6010412f38:	f90013f3 	str	x19, [sp, #32]
  6010412f3c:	f90027e0 	str	x0, [sp, #72]
  6010412f40:	f90023e1 	str	x1, [sp, #64]
  6010412f44:	f9001fe2 	str	x2, [sp, #56]
  6010412f48:	f9001be3 	str	x3, [sp, #48]
  6010412f4c:	aa0403f3 	mov	x19, x4
    unsigned int flags, width, precision, n;
    size_t idx = 0U;
  6010412f50:	f90047ff 	str	xzr, [sp, #136]

    if (!buffer) {
  6010412f54:	f94023e0 	ldr	x0, [sp, #64]
  6010412f58:	f100001f 	cmp	x0, #0x0
  6010412f5c:	54008e01 	b.ne	601041411c <_vsnprintf+0x11f0>  // b.any
        // use null output function
        out = _out_null;
  6010412f60:	f0ffffe0 	adrp	x0, 6010411000 <el1sync+0x18>
  6010412f64:	912ce000 	add	x0, x0, #0xb38
  6010412f68:	f90027e0 	str	x0, [sp, #72]
    }

    while (*format) {
  6010412f6c:	1400046c 	b	601041411c <_vsnprintf+0x11f0>
        // format specifier?  %[flags][width][.precision][length]
        if (*format != '%') {
  6010412f70:	f9401be0 	ldr	x0, [sp, #48]
  6010412f74:	39400000 	ldrb	w0, [x0]
  6010412f78:	7100941f 	cmp	w0, #0x25
  6010412f7c:	54000200 	b.eq	6010412fbc <_vsnprintf+0x90>  // b.none
            // no
            out(*format, buffer, idx++, maxlen);
  6010412f80:	f9401be0 	ldr	x0, [sp, #48]
  6010412f84:	39400005 	ldrb	w5, [x0]
  6010412f88:	f94047e0 	ldr	x0, [sp, #136]
  6010412f8c:	91000401 	add	x1, x0, #0x1
  6010412f90:	f90047e1 	str	x1, [sp, #136]
  6010412f94:	f94027e4 	ldr	x4, [sp, #72]
  6010412f98:	f9401fe3 	ldr	x3, [sp, #56]
  6010412f9c:	aa0003e2 	mov	x2, x0
  6010412fa0:	f94023e1 	ldr	x1, [sp, #64]
  6010412fa4:	2a0503e0 	mov	w0, w5
  6010412fa8:	d63f0080 	blr	x4
            format++;
  6010412fac:	f9401be0 	ldr	x0, [sp, #48]
  6010412fb0:	91000400 	add	x0, x0, #0x1
  6010412fb4:	f9001be0 	str	x0, [sp, #48]
            continue;
  6010412fb8:	14000459 	b	601041411c <_vsnprintf+0x11f0>
        } else {
            // yes, evaluate it
            format++;
  6010412fbc:	f9401be0 	ldr	x0, [sp, #48]
  6010412fc0:	91000400 	add	x0, x0, #0x1
  6010412fc4:	f9001be0 	str	x0, [sp, #48]
        }

        // evaluate flags
        flags = 0U;
  6010412fc8:	b9009fff 	str	wzr, [sp, #156]
        do {
            switch (*format) {
  6010412fcc:	f9401be0 	ldr	x0, [sp, #48]
  6010412fd0:	39400000 	ldrb	w0, [x0]
  6010412fd4:	7100c01f 	cmp	w0, #0x30
  6010412fd8:	54000200 	b.eq	6010413018 <_vsnprintf+0xec>  // b.none
  6010412fdc:	7100c01f 	cmp	w0, #0x30
  6010412fe0:	5400076c 	b.gt	60104130cc <_vsnprintf+0x1a0>
  6010412fe4:	7100b41f 	cmp	w0, #0x2d
  6010412fe8:	540002a0 	b.eq	601041303c <_vsnprintf+0x110>  // b.none
  6010412fec:	7100b41f 	cmp	w0, #0x2d
  6010412ff0:	540006ec 	b.gt	60104130cc <_vsnprintf+0x1a0>
  6010412ff4:	7100ac1f 	cmp	w0, #0x2b
  6010412ff8:	54000340 	b.eq	6010413060 <_vsnprintf+0x134>  // b.none
  6010412ffc:	7100ac1f 	cmp	w0, #0x2b
  6010413000:	5400066c 	b.gt	60104130cc <_vsnprintf+0x1a0>
  6010413004:	7100801f 	cmp	w0, #0x20
  6010413008:	540003e0 	b.eq	6010413084 <_vsnprintf+0x158>  // b.none
  601041300c:	71008c1f 	cmp	w0, #0x23
  6010413010:	540004c0 	b.eq	60104130a8 <_vsnprintf+0x17c>  // b.none
  6010413014:	1400002e 	b	60104130cc <_vsnprintf+0x1a0>
            case '0':
                flags |= FLAGS_ZEROPAD;
  6010413018:	b9409fe0 	ldr	w0, [sp, #156]
  601041301c:	32000000 	orr	w0, w0, #0x1
  6010413020:	b9009fe0 	str	w0, [sp, #156]
                format++;
  6010413024:	f9401be0 	ldr	x0, [sp, #48]
  6010413028:	91000400 	add	x0, x0, #0x1
  601041302c:	f9001be0 	str	x0, [sp, #48]
                n = 1U;
  6010413030:	52800020 	mov	w0, #0x1                   	// #1
  6010413034:	b90093e0 	str	w0, [sp, #144]
                break;
  6010413038:	14000027 	b	60104130d4 <_vsnprintf+0x1a8>
            case '-':
                flags |= FLAGS_LEFT;
  601041303c:	b9409fe0 	ldr	w0, [sp, #156]
  6010413040:	321f0000 	orr	w0, w0, #0x2
  6010413044:	b9009fe0 	str	w0, [sp, #156]
                format++;
  6010413048:	f9401be0 	ldr	x0, [sp, #48]
  601041304c:	91000400 	add	x0, x0, #0x1
  6010413050:	f9001be0 	str	x0, [sp, #48]
                n = 1U;
  6010413054:	52800020 	mov	w0, #0x1                   	// #1
  6010413058:	b90093e0 	str	w0, [sp, #144]
                break;
  601041305c:	1400001e 	b	60104130d4 <_vsnprintf+0x1a8>
            case '+':
                flags |= FLAGS_PLUS;
  6010413060:	b9409fe0 	ldr	w0, [sp, #156]
  6010413064:	321e0000 	orr	w0, w0, #0x4
  6010413068:	b9009fe0 	str	w0, [sp, #156]
                format++;
  601041306c:	f9401be0 	ldr	x0, [sp, #48]
  6010413070:	91000400 	add	x0, x0, #0x1
  6010413074:	f9001be0 	str	x0, [sp, #48]
                n = 1U;
  6010413078:	52800020 	mov	w0, #0x1                   	// #1
  601041307c:	b90093e0 	str	w0, [sp, #144]
                break;
  6010413080:	14000015 	b	60104130d4 <_vsnprintf+0x1a8>
            case ' ':
                flags |= FLAGS_SPACE;
  6010413084:	b9409fe0 	ldr	w0, [sp, #156]
  6010413088:	321d0000 	orr	w0, w0, #0x8
  601041308c:	b9009fe0 	str	w0, [sp, #156]
                format++;
  6010413090:	f9401be0 	ldr	x0, [sp, #48]
  6010413094:	91000400 	add	x0, x0, #0x1
  6010413098:	f9001be0 	str	x0, [sp, #48]
                n = 1U;
  601041309c:	52800020 	mov	w0, #0x1                   	// #1
  60104130a0:	b90093e0 	str	w0, [sp, #144]
                break;
  60104130a4:	1400000c 	b	60104130d4 <_vsnprintf+0x1a8>
            case '#':
                flags |= FLAGS_HASH;
  60104130a8:	b9409fe0 	ldr	w0, [sp, #156]
  60104130ac:	321c0000 	orr	w0, w0, #0x10
  60104130b0:	b9009fe0 	str	w0, [sp, #156]
                format++;
  60104130b4:	f9401be0 	ldr	x0, [sp, #48]
  60104130b8:	91000400 	add	x0, x0, #0x1
  60104130bc:	f9001be0 	str	x0, [sp, #48]
                n = 1U;
  60104130c0:	52800020 	mov	w0, #0x1                   	// #1
  60104130c4:	b90093e0 	str	w0, [sp, #144]
                break;
  60104130c8:	14000003 	b	60104130d4 <_vsnprintf+0x1a8>
            default:
                n = 0U;
  60104130cc:	b90093ff 	str	wzr, [sp, #144]
                break;
  60104130d0:	d503201f 	nop
            }
        } while (n);
  60104130d4:	b94093e0 	ldr	w0, [sp, #144]
  60104130d8:	7100001f 	cmp	w0, #0x0
  60104130dc:	54fff781 	b.ne	6010412fcc <_vsnprintf+0xa0>  // b.any

        // evaluate width field
        width = 0U;
  60104130e0:	b9009bff 	str	wzr, [sp, #152]
        if (_is_digit(*format)) {
  60104130e4:	f9401be0 	ldr	x0, [sp, #48]
  60104130e8:	39400000 	ldrb	w0, [x0]
  60104130ec:	97fffad6 	bl	6010411c44 <_is_digit>
  60104130f0:	12001c00 	and	w0, w0, #0xff
  60104130f4:	7100001f 	cmp	w0, #0x0
  60104130f8:	540000a0 	b.eq	601041310c <_vsnprintf+0x1e0>  // b.none
            width = _atoi(&format);
  60104130fc:	9100c3e0 	add	x0, sp, #0x30
  6010413100:	97fffae0 	bl	6010411c80 <_atoi>
  6010413104:	b9009be0 	str	w0, [sp, #152]
  6010413108:	1400002a 	b	60104131b0 <_vsnprintf+0x284>
        } else if (*format == '*') {
  601041310c:	f9401be0 	ldr	x0, [sp, #48]
  6010413110:	39400000 	ldrb	w0, [x0]
  6010413114:	7100a81f 	cmp	w0, #0x2a
  6010413118:	540004c1 	b.ne	60104131b0 <_vsnprintf+0x284>  // b.any
            const int w = va_arg(va, int);
  601041311c:	b9401a61 	ldr	w1, [x19, #24]
  6010413120:	f9400260 	ldr	x0, [x19]
  6010413124:	7100003f 	cmp	w1, #0x0
  6010413128:	540000ab 	b.lt	601041313c <_vsnprintf+0x210>  // b.tstop
  601041312c:	91002c01 	add	x1, x0, #0xb
  6010413130:	927df021 	and	x1, x1, #0xfffffffffffffff8
  6010413134:	f9000261 	str	x1, [x19]
  6010413138:	1400000d 	b	601041316c <_vsnprintf+0x240>
  601041313c:	11002022 	add	w2, w1, #0x8
  6010413140:	b9001a62 	str	w2, [x19, #24]
  6010413144:	b9401a62 	ldr	w2, [x19, #24]
  6010413148:	7100005f 	cmp	w2, #0x0
  601041314c:	540000ad 	b.le	6010413160 <_vsnprintf+0x234>
  6010413150:	91002c01 	add	x1, x0, #0xb
  6010413154:	927df021 	and	x1, x1, #0xfffffffffffffff8
  6010413158:	f9000261 	str	x1, [x19]
  601041315c:	14000004 	b	601041316c <_vsnprintf+0x240>
  6010413160:	f9400662 	ldr	x2, [x19, #8]
  6010413164:	93407c20 	sxtw	x0, w1
  6010413168:	8b000040 	add	x0, x2, x0
  601041316c:	b9400000 	ldr	w0, [x0]
  6010413170:	b90073e0 	str	w0, [sp, #112]
            if (w < 0) {
  6010413174:	b94073e0 	ldr	w0, [sp, #112]
  6010413178:	7100001f 	cmp	w0, #0x0
  601041317c:	5400010a 	b.ge	601041319c <_vsnprintf+0x270>  // b.tcont
                flags |= FLAGS_LEFT; // reverse padding
  6010413180:	b9409fe0 	ldr	w0, [sp, #156]
  6010413184:	321f0000 	orr	w0, w0, #0x2
  6010413188:	b9009fe0 	str	w0, [sp, #156]
                width = (unsigned int)-w;
  601041318c:	b94073e0 	ldr	w0, [sp, #112]
  6010413190:	4b0003e0 	neg	w0, w0
  6010413194:	b9009be0 	str	w0, [sp, #152]
  6010413198:	14000003 	b	60104131a4 <_vsnprintf+0x278>
            } else {
                width = (unsigned int)w;
  601041319c:	b94073e0 	ldr	w0, [sp, #112]
  60104131a0:	b9009be0 	str	w0, [sp, #152]
            }
            format++;
  60104131a4:	f9401be0 	ldr	x0, [sp, #48]
  60104131a8:	91000400 	add	x0, x0, #0x1
  60104131ac:	f9001be0 	str	x0, [sp, #48]
        }

        // evaluate precision field
        precision = 0U;
  60104131b0:	b90097ff 	str	wzr, [sp, #148]
        if (*format == '.') {
  60104131b4:	f9401be0 	ldr	x0, [sp, #48]
  60104131b8:	39400000 	ldrb	w0, [x0]
  60104131bc:	7100b81f 	cmp	w0, #0x2e
  60104131c0:	54000681 	b.ne	6010413290 <_vsnprintf+0x364>  // b.any
            flags |= FLAGS_PRECISION;
  60104131c4:	b9409fe0 	ldr	w0, [sp, #156]
  60104131c8:	32160000 	orr	w0, w0, #0x400
  60104131cc:	b9009fe0 	str	w0, [sp, #156]
            format++;
  60104131d0:	f9401be0 	ldr	x0, [sp, #48]
  60104131d4:	91000400 	add	x0, x0, #0x1
  60104131d8:	f9001be0 	str	x0, [sp, #48]
            if (_is_digit(*format)) {
  60104131dc:	f9401be0 	ldr	x0, [sp, #48]
  60104131e0:	39400000 	ldrb	w0, [x0]
  60104131e4:	97fffa98 	bl	6010411c44 <_is_digit>
  60104131e8:	12001c00 	and	w0, w0, #0xff
  60104131ec:	7100001f 	cmp	w0, #0x0
  60104131f0:	540000a0 	b.eq	6010413204 <_vsnprintf+0x2d8>  // b.none
                precision = _atoi(&format);
  60104131f4:	9100c3e0 	add	x0, sp, #0x30
  60104131f8:	97fffaa2 	bl	6010411c80 <_atoi>
  60104131fc:	b90097e0 	str	w0, [sp, #148]
  6010413200:	14000024 	b	6010413290 <_vsnprintf+0x364>
            } else if (*format == '*') {
  6010413204:	f9401be0 	ldr	x0, [sp, #48]
  6010413208:	39400000 	ldrb	w0, [x0]
  601041320c:	7100a81f 	cmp	w0, #0x2a
  6010413210:	54000401 	b.ne	6010413290 <_vsnprintf+0x364>  // b.any
                const int prec = (int)va_arg(va, int);
  6010413214:	b9401a61 	ldr	w1, [x19, #24]
  6010413218:	f9400260 	ldr	x0, [x19]
  601041321c:	7100003f 	cmp	w1, #0x0
  6010413220:	540000ab 	b.lt	6010413234 <_vsnprintf+0x308>  // b.tstop
  6010413224:	91002c01 	add	x1, x0, #0xb
  6010413228:	927df021 	and	x1, x1, #0xfffffffffffffff8
  601041322c:	f9000261 	str	x1, [x19]
  6010413230:	1400000d 	b	6010413264 <_vsnprintf+0x338>
  6010413234:	11002022 	add	w2, w1, #0x8
  6010413238:	b9001a62 	str	w2, [x19, #24]
  601041323c:	b9401a62 	ldr	w2, [x19, #24]
  6010413240:	7100005f 	cmp	w2, #0x0
  6010413244:	540000ad 	b.le	6010413258 <_vsnprintf+0x32c>
  6010413248:	91002c01 	add	x1, x0, #0xb
  601041324c:	927df021 	and	x1, x1, #0xfffffffffffffff8
  6010413250:	f9000261 	str	x1, [x19]
  6010413254:	14000004 	b	6010413264 <_vsnprintf+0x338>
  6010413258:	f9400662 	ldr	x2, [x19, #8]
  601041325c:	93407c20 	sxtw	x0, w1
  6010413260:	8b000040 	add	x0, x2, x0
  6010413264:	b9400000 	ldr	w0, [x0]
  6010413268:	b9006fe0 	str	w0, [sp, #108]
                precision = prec > 0 ? (unsigned int)prec : 0U;
  601041326c:	b9406fe1 	ldr	w1, [sp, #108]
  6010413270:	b9406fe0 	ldr	w0, [sp, #108]
  6010413274:	52800002 	mov	w2, #0x0                   	// #0
  6010413278:	7100003f 	cmp	w1, #0x0
  601041327c:	1a82a000 	csel	w0, w0, w2, ge  // ge = tcont
  6010413280:	b90097e0 	str	w0, [sp, #148]
                format++;
  6010413284:	f9401be0 	ldr	x0, [sp, #48]
  6010413288:	91000400 	add	x0, x0, #0x1
  601041328c:	f9001be0 	str	x0, [sp, #48]
            }
        }

        // evaluate length field
        switch (*format) {
  6010413290:	f9401be0 	ldr	x0, [sp, #48]
  6010413294:	39400000 	ldrb	w0, [x0]
  6010413298:	7101e81f 	cmp	w0, #0x7a
  601041329c:	54000800 	b.eq	601041339c <_vsnprintf+0x470>  // b.none
  60104132a0:	7101e81f 	cmp	w0, #0x7a
  60104132a4:	540008ac 	b.gt	60104133b8 <_vsnprintf+0x48c>
  60104132a8:	7101d01f 	cmp	w0, #0x74
  60104132ac:	540005c0 	b.eq	6010413364 <_vsnprintf+0x438>  // b.none
  60104132b0:	7101d01f 	cmp	w0, #0x74
  60104132b4:	5400082c 	b.gt	60104133b8 <_vsnprintf+0x48c>
  60104132b8:	7101b01f 	cmp	w0, #0x6c
  60104132bc:	54000100 	b.eq	60104132dc <_vsnprintf+0x3b0>  // b.none
  60104132c0:	7101b01f 	cmp	w0, #0x6c
  60104132c4:	540007ac 	b.gt	60104133b8 <_vsnprintf+0x48c>
  60104132c8:	7101a01f 	cmp	w0, #0x68
  60104132cc:	540002a0 	b.eq	6010413320 <_vsnprintf+0x3f4>  // b.none
  60104132d0:	7101a81f 	cmp	w0, #0x6a
  60104132d4:	54000560 	b.eq	6010413380 <_vsnprintf+0x454>  // b.none
        case 'z':
            flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
            format++;
            break;
        default:
            break;
  60104132d8:	14000038 	b	60104133b8 <_vsnprintf+0x48c>
            flags |= FLAGS_LONG;
  60104132dc:	b9409fe0 	ldr	w0, [sp, #156]
  60104132e0:	32180000 	orr	w0, w0, #0x100
  60104132e4:	b9009fe0 	str	w0, [sp, #156]
            format++;
  60104132e8:	f9401be0 	ldr	x0, [sp, #48]
  60104132ec:	91000400 	add	x0, x0, #0x1
  60104132f0:	f9001be0 	str	x0, [sp, #48]
            if (*format == 'l') {
  60104132f4:	f9401be0 	ldr	x0, [sp, #48]
  60104132f8:	39400000 	ldrb	w0, [x0]
  60104132fc:	7101b01f 	cmp	w0, #0x6c
  6010413300:	54000601 	b.ne	60104133c0 <_vsnprintf+0x494>  // b.any
                flags |= FLAGS_LONG_LONG;
  6010413304:	b9409fe0 	ldr	w0, [sp, #156]
  6010413308:	32170000 	orr	w0, w0, #0x200
  601041330c:	b9009fe0 	str	w0, [sp, #156]
                format++;
  6010413310:	f9401be0 	ldr	x0, [sp, #48]
  6010413314:	91000400 	add	x0, x0, #0x1
  6010413318:	f9001be0 	str	x0, [sp, #48]
            break;
  601041331c:	14000029 	b	60104133c0 <_vsnprintf+0x494>
            flags |= FLAGS_SHORT;
  6010413320:	b9409fe0 	ldr	w0, [sp, #156]
  6010413324:	32190000 	orr	w0, w0, #0x80
  6010413328:	b9009fe0 	str	w0, [sp, #156]
            format++;
  601041332c:	f9401be0 	ldr	x0, [sp, #48]
  6010413330:	91000400 	add	x0, x0, #0x1
  6010413334:	f9001be0 	str	x0, [sp, #48]
            if (*format == 'h') {
  6010413338:	f9401be0 	ldr	x0, [sp, #48]
  601041333c:	39400000 	ldrb	w0, [x0]
  6010413340:	7101a01f 	cmp	w0, #0x68
  6010413344:	54000421 	b.ne	60104133c8 <_vsnprintf+0x49c>  // b.any
                flags |= FLAGS_CHAR;
  6010413348:	b9409fe0 	ldr	w0, [sp, #156]
  601041334c:	321a0000 	orr	w0, w0, #0x40
  6010413350:	b9009fe0 	str	w0, [sp, #156]
                format++;
  6010413354:	f9401be0 	ldr	x0, [sp, #48]
  6010413358:	91000400 	add	x0, x0, #0x1
  601041335c:	f9001be0 	str	x0, [sp, #48]
            break;
  6010413360:	1400001a 	b	60104133c8 <_vsnprintf+0x49c>
            flags |= (sizeof(ptrdiff_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
  6010413364:	b9409fe0 	ldr	w0, [sp, #156]
  6010413368:	32180000 	orr	w0, w0, #0x100
  601041336c:	b9009fe0 	str	w0, [sp, #156]
            format++;
  6010413370:	f9401be0 	ldr	x0, [sp, #48]
  6010413374:	91000400 	add	x0, x0, #0x1
  6010413378:	f9001be0 	str	x0, [sp, #48]
            break;
  601041337c:	14000014 	b	60104133cc <_vsnprintf+0x4a0>
            flags |= (sizeof(intmax_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
  6010413380:	b9409fe0 	ldr	w0, [sp, #156]
  6010413384:	32180000 	orr	w0, w0, #0x100
  6010413388:	b9009fe0 	str	w0, [sp, #156]
            format++;
  601041338c:	f9401be0 	ldr	x0, [sp, #48]
  6010413390:	91000400 	add	x0, x0, #0x1
  6010413394:	f9001be0 	str	x0, [sp, #48]
            break;
  6010413398:	1400000d 	b	60104133cc <_vsnprintf+0x4a0>
            flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
  601041339c:	b9409fe0 	ldr	w0, [sp, #156]
  60104133a0:	32180000 	orr	w0, w0, #0x100
  60104133a4:	b9009fe0 	str	w0, [sp, #156]
            format++;
  60104133a8:	f9401be0 	ldr	x0, [sp, #48]
  60104133ac:	91000400 	add	x0, x0, #0x1
  60104133b0:	f9001be0 	str	x0, [sp, #48]
            break;
  60104133b4:	14000006 	b	60104133cc <_vsnprintf+0x4a0>
            break;
  60104133b8:	d503201f 	nop
  60104133bc:	14000004 	b	60104133cc <_vsnprintf+0x4a0>
            break;
  60104133c0:	d503201f 	nop
  60104133c4:	14000002 	b	60104133cc <_vsnprintf+0x4a0>
            break;
  60104133c8:	d503201f 	nop
        }

        // evaluate specifier
        switch (*format) {
  60104133cc:	f9401be0 	ldr	x0, [sp, #48]
  60104133d0:	39400000 	ldrb	w0, [x0]
  60104133d4:	51009400 	sub	w0, w0, #0x25
  60104133d8:	71014c1f 	cmp	w0, #0x53
  60104133dc:	54006828 	b.hi	60104140e0 <_vsnprintf+0x11b4>  // b.pmore
  60104133e0:	d0000061 	adrp	x1, 6010421000 <__func__.0+0x508>
  60104133e4:	9106f021 	add	x1, x1, #0x1bc
  60104133e8:	b8605820 	ldr	w0, [x1, w0, uxtw #2]
  60104133ec:	10000061 	adr	x1, 60104133f8 <_vsnprintf+0x4cc>
  60104133f0:	8b20c820 	add	x0, x1, w0, sxtw #2
  60104133f4:	d61f0000 	br	x0
        case 'X':
        case 'o':
        case 'b': {
            // set the base
            unsigned int base;
            if (*format == 'x' || *format == 'X') {
  60104133f8:	f9401be0 	ldr	x0, [sp, #48]
  60104133fc:	39400000 	ldrb	w0, [x0]
  6010413400:	7101e01f 	cmp	w0, #0x78
  6010413404:	540000a0 	b.eq	6010413418 <_vsnprintf+0x4ec>  // b.none
  6010413408:	f9401be0 	ldr	x0, [sp, #48]
  601041340c:	39400000 	ldrb	w0, [x0]
  6010413410:	7101601f 	cmp	w0, #0x58
  6010413414:	54000081 	b.ne	6010413424 <_vsnprintf+0x4f8>  // b.any
                base = 16U;
  6010413418:	52800200 	mov	w0, #0x10                  	// #16
  601041341c:	b90087e0 	str	w0, [sp, #132]
  6010413420:	14000014 	b	6010413470 <_vsnprintf+0x544>
            } else if (*format == 'o') {
  6010413424:	f9401be0 	ldr	x0, [sp, #48]
  6010413428:	39400000 	ldrb	w0, [x0]
  601041342c:	7101bc1f 	cmp	w0, #0x6f
  6010413430:	54000081 	b.ne	6010413440 <_vsnprintf+0x514>  // b.any
                base = 8U;
  6010413434:	52800100 	mov	w0, #0x8                   	// #8
  6010413438:	b90087e0 	str	w0, [sp, #132]
  601041343c:	1400000d 	b	6010413470 <_vsnprintf+0x544>
            } else if (*format == 'b') {
  6010413440:	f9401be0 	ldr	x0, [sp, #48]
  6010413444:	39400000 	ldrb	w0, [x0]
  6010413448:	7101881f 	cmp	w0, #0x62
  601041344c:	54000081 	b.ne	601041345c <_vsnprintf+0x530>  // b.any
                base = 2U;
  6010413450:	52800040 	mov	w0, #0x2                   	// #2
  6010413454:	b90087e0 	str	w0, [sp, #132]
  6010413458:	14000006 	b	6010413470 <_vsnprintf+0x544>
            } else {
                base = 10U;
  601041345c:	52800140 	mov	w0, #0xa                   	// #10
  6010413460:	b90087e0 	str	w0, [sp, #132]
                flags &= ~FLAGS_HASH; // no hash for dec format
  6010413464:	b9409fe0 	ldr	w0, [sp, #156]
  6010413468:	121b7800 	and	w0, w0, #0xffffffef
  601041346c:	b9009fe0 	str	w0, [sp, #156]
            }
            // uppercase
            if (*format == 'X') {
  6010413470:	f9401be0 	ldr	x0, [sp, #48]
  6010413474:	39400000 	ldrb	w0, [x0]
  6010413478:	7101601f 	cmp	w0, #0x58
  601041347c:	54000081 	b.ne	601041348c <_vsnprintf+0x560>  // b.any
                flags |= FLAGS_UPPERCASE;
  6010413480:	b9409fe0 	ldr	w0, [sp, #156]
  6010413484:	321b0000 	orr	w0, w0, #0x20
  6010413488:	b9009fe0 	str	w0, [sp, #156]
            }

            // no plus or space flag for u, x, X, o, b
            if ((*format != 'i') && (*format != 'd')) {
  601041348c:	f9401be0 	ldr	x0, [sp, #48]
  6010413490:	39400000 	ldrb	w0, [x0]
  6010413494:	7101a41f 	cmp	w0, #0x69
  6010413498:	54000100 	b.eq	60104134b8 <_vsnprintf+0x58c>  // b.none
  601041349c:	f9401be0 	ldr	x0, [sp, #48]
  60104134a0:	39400000 	ldrb	w0, [x0]
  60104134a4:	7101901f 	cmp	w0, #0x64
  60104134a8:	54000080 	b.eq	60104134b8 <_vsnprintf+0x58c>  // b.none
                flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
  60104134ac:	b9409fe0 	ldr	w0, [sp, #156]
  60104134b0:	121c7400 	and	w0, w0, #0xfffffff3
  60104134b4:	b9009fe0 	str	w0, [sp, #156]
            }

            // ignore '0' flag when precision is given
            if (flags & FLAGS_PRECISION) {
  60104134b8:	b9409fe0 	ldr	w0, [sp, #156]
  60104134bc:	12160000 	and	w0, w0, #0x400
  60104134c0:	7100001f 	cmp	w0, #0x0
  60104134c4:	54000080 	b.eq	60104134d4 <_vsnprintf+0x5a8>  // b.none
                flags &= ~FLAGS_ZEROPAD;
  60104134c8:	b9409fe0 	ldr	w0, [sp, #156]
  60104134cc:	121f7800 	and	w0, w0, #0xfffffffe
  60104134d0:	b9009fe0 	str	w0, [sp, #156]
            }

            // convert the integer
            if ((*format == 'i') || (*format == 'd')) {
  60104134d4:	f9401be0 	ldr	x0, [sp, #48]
  60104134d8:	39400000 	ldrb	w0, [x0]
  60104134dc:	7101a41f 	cmp	w0, #0x69
  60104134e0:	540000a0 	b.eq	60104134f4 <_vsnprintf+0x5c8>  // b.none
  60104134e4:	f9401be0 	ldr	x0, [sp, #48]
  60104134e8:	39400000 	ldrb	w0, [x0]
  60104134ec:	7101901f 	cmp	w0, #0x64
  60104134f0:	540018c1 	b.ne	6010413808 <_vsnprintf+0x8dc>  // b.any
                // signed
                if (flags & FLAGS_LONG_LONG) {
  60104134f4:	b9409fe0 	ldr	w0, [sp, #156]
  60104134f8:	12170000 	and	w0, w0, #0x200
  60104134fc:	7100001f 	cmp	w0, #0x0
  6010413500:	540005c0 	b.eq	60104135b8 <_vsnprintf+0x68c>  // b.none
#if defined(PRINTF_SUPPORT_LONG_LONG)
                    const long long value = va_arg(va, long long);
  6010413504:	b9401a61 	ldr	w1, [x19, #24]
  6010413508:	f9400260 	ldr	x0, [x19]
  601041350c:	7100003f 	cmp	w1, #0x0
  6010413510:	540000ab 	b.lt	6010413524 <_vsnprintf+0x5f8>  // b.tstop
  6010413514:	91003c01 	add	x1, x0, #0xf
  6010413518:	927df021 	and	x1, x1, #0xfffffffffffffff8
  601041351c:	f9000261 	str	x1, [x19]
  6010413520:	1400000d 	b	6010413554 <_vsnprintf+0x628>
  6010413524:	11002022 	add	w2, w1, #0x8
  6010413528:	b9001a62 	str	w2, [x19, #24]
  601041352c:	b9401a62 	ldr	w2, [x19, #24]
  6010413530:	7100005f 	cmp	w2, #0x0
  6010413534:	540000ad 	b.le	6010413548 <_vsnprintf+0x61c>
  6010413538:	91003c01 	add	x1, x0, #0xf
  601041353c:	927df021 	and	x1, x1, #0xfffffffffffffff8
  6010413540:	f9000261 	str	x1, [x19]
  6010413544:	14000004 	b	6010413554 <_vsnprintf+0x628>
  6010413548:	f9400662 	ldr	x2, [x19, #8]
  601041354c:	93407c20 	sxtw	x0, w1
  6010413550:	8b000040 	add	x0, x2, x0
  6010413554:	f9400000 	ldr	x0, [x0]
  6010413558:	f9002be0 	str	x0, [sp, #80]
                    idx = _ntoa_long_long(out, buffer, idx, maxlen, (unsigned long long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
  601041355c:	f9402be0 	ldr	x0, [sp, #80]
  6010413560:	f100001f 	cmp	x0, #0x0
  6010413564:	da80a400 	cneg	x0, x0, lt  // lt = tstop
  6010413568:	aa0003e3 	mov	x3, x0
  601041356c:	f9402be0 	ldr	x0, [sp, #80]
  6010413570:	d37ffc00 	lsr	x0, x0, #63
  6010413574:	12001c02 	and	w2, w0, #0xff
  6010413578:	b94087e1 	ldr	w1, [sp, #132]
  601041357c:	b9409fe0 	ldr	w0, [sp, #156]
  6010413580:	b9000be0 	str	w0, [sp, #8]
  6010413584:	b9409be0 	ldr	w0, [sp, #152]
  6010413588:	b90003e0 	str	w0, [sp]
  601041358c:	b94097e7 	ldr	w7, [sp, #148]
  6010413590:	aa0103e6 	mov	x6, x1
  6010413594:	2a0203e5 	mov	w5, w2
  6010413598:	aa0303e4 	mov	x4, x3
  601041359c:	f9401fe3 	ldr	x3, [sp, #56]
  60104135a0:	f94047e2 	ldr	x2, [sp, #136]
  60104135a4:	f94023e1 	ldr	x1, [sp, #64]
  60104135a8:	f94027e0 	ldr	x0, [sp, #72]
  60104135ac:	97fffb44 	bl	60104122bc <_ntoa_long_long>
  60104135b0:	f90047e0 	str	x0, [sp, #136]
                if (flags & FLAGS_LONG_LONG) {
  60104135b4:	14000143 	b	6010413ac0 <_vsnprintf+0xb94>
#endif
                } else if (flags & FLAGS_LONG) {
  60104135b8:	b9409fe0 	ldr	w0, [sp, #156]
  60104135bc:	12180000 	and	w0, w0, #0x100
  60104135c0:	7100001f 	cmp	w0, #0x0
  60104135c4:	540005c0 	b.eq	601041367c <_vsnprintf+0x750>  // b.none
                    const long value = va_arg(va, long);
  60104135c8:	b9401a61 	ldr	w1, [x19, #24]
  60104135cc:	f9400260 	ldr	x0, [x19]
  60104135d0:	7100003f 	cmp	w1, #0x0
  60104135d4:	540000ab 	b.lt	60104135e8 <_vsnprintf+0x6bc>  // b.tstop
  60104135d8:	91003c01 	add	x1, x0, #0xf
  60104135dc:	927df021 	and	x1, x1, #0xfffffffffffffff8
  60104135e0:	f9000261 	str	x1, [x19]
  60104135e4:	1400000d 	b	6010413618 <_vsnprintf+0x6ec>
  60104135e8:	11002022 	add	w2, w1, #0x8
  60104135ec:	b9001a62 	str	w2, [x19, #24]
  60104135f0:	b9401a62 	ldr	w2, [x19, #24]
  60104135f4:	7100005f 	cmp	w2, #0x0
  60104135f8:	540000ad 	b.le	601041360c <_vsnprintf+0x6e0>
  60104135fc:	91003c01 	add	x1, x0, #0xf
  6010413600:	927df021 	and	x1, x1, #0xfffffffffffffff8
  6010413604:	f9000261 	str	x1, [x19]
  6010413608:	14000004 	b	6010413618 <_vsnprintf+0x6ec>
  601041360c:	f9400662 	ldr	x2, [x19, #8]
  6010413610:	93407c20 	sxtw	x0, w1
  6010413614:	8b000040 	add	x0, x2, x0
  6010413618:	f9400000 	ldr	x0, [x0]
  601041361c:	f9002fe0 	str	x0, [sp, #88]
                    idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
  6010413620:	f9402fe0 	ldr	x0, [sp, #88]
  6010413624:	f100001f 	cmp	x0, #0x0
  6010413628:	da80a400 	cneg	x0, x0, lt  // lt = tstop
  601041362c:	aa0003e3 	mov	x3, x0
  6010413630:	f9402fe0 	ldr	x0, [sp, #88]
  6010413634:	d37ffc00 	lsr	x0, x0, #63
  6010413638:	12001c02 	and	w2, w0, #0xff
  601041363c:	b94087e1 	ldr	w1, [sp, #132]
  6010413640:	b9409fe0 	ldr	w0, [sp, #156]
  6010413644:	b9000be0 	str	w0, [sp, #8]
  6010413648:	b9409be0 	ldr	w0, [sp, #152]
  601041364c:	b90003e0 	str	w0, [sp]
  6010413650:	b94097e7 	ldr	w7, [sp, #148]
  6010413654:	aa0103e6 	mov	x6, x1
  6010413658:	2a0203e5 	mov	w5, w2
  601041365c:	aa0303e4 	mov	x4, x3
  6010413660:	f9401fe3 	ldr	x3, [sp, #56]
  6010413664:	f94047e2 	ldr	x2, [sp, #136]
  6010413668:	f94023e1 	ldr	x1, [sp, #64]
  601041366c:	f94027e0 	ldr	x0, [sp, #72]
  6010413670:	97fffabc 	bl	6010412160 <_ntoa_long>
  6010413674:	f90047e0 	str	x0, [sp, #136]
                if (flags & FLAGS_LONG_LONG) {
  6010413678:	14000112 	b	6010413ac0 <_vsnprintf+0xb94>
                } else {
                    const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int)
  601041367c:	b9409fe0 	ldr	w0, [sp, #156]
  6010413680:	121a0000 	and	w0, w0, #0x40
  6010413684:	7100001f 	cmp	w0, #0x0
  6010413688:	54000300 	b.eq	60104136e8 <_vsnprintf+0x7bc>  // b.none
  601041368c:	b9401a61 	ldr	w1, [x19, #24]
  6010413690:	f9400260 	ldr	x0, [x19]
  6010413694:	7100003f 	cmp	w1, #0x0
  6010413698:	540000ab 	b.lt	60104136ac <_vsnprintf+0x780>  // b.tstop
  601041369c:	91002c01 	add	x1, x0, #0xb
  60104136a0:	927df021 	and	x1, x1, #0xfffffffffffffff8
  60104136a4:	f9000261 	str	x1, [x19]
  60104136a8:	1400000d 	b	60104136dc <_vsnprintf+0x7b0>
  60104136ac:	11002022 	add	w2, w1, #0x8
  60104136b0:	b9001a62 	str	w2, [x19, #24]
  60104136b4:	b9401a62 	ldr	w2, [x19, #24]
  60104136b8:	7100005f 	cmp	w2, #0x0
  60104136bc:	540000ad 	b.le	60104136d0 <_vsnprintf+0x7a4>
  60104136c0:	91002c01 	add	x1, x0, #0xb
  60104136c4:	927df021 	and	x1, x1, #0xfffffffffffffff8
  60104136c8:	f9000261 	str	x1, [x19]
  60104136cc:	14000004 	b	60104136dc <_vsnprintf+0x7b0>
  60104136d0:	f9400662 	ldr	x2, [x19, #8]
  60104136d4:	93407c20 	sxtw	x0, w1
  60104136d8:	8b000040 	add	x0, x2, x0
  60104136dc:	b9400000 	ldr	w0, [x0]
  60104136e0:	12001c00 	and	w0, w0, #0xff
  60104136e4:	14000031 	b	60104137a8 <_vsnprintf+0x87c>
  60104136e8:	b9409fe0 	ldr	w0, [sp, #156]
  60104136ec:	12190000 	and	w0, w0, #0x80
                                                                                                           : va_arg(va, int);
  60104136f0:	7100001f 	cmp	w0, #0x0
  60104136f4:	54000300 	b.eq	6010413754 <_vsnprintf+0x828>  // b.none
                    const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int)
  60104136f8:	b9401a61 	ldr	w1, [x19, #24]
  60104136fc:	f9400260 	ldr	x0, [x19]
  6010413700:	7100003f 	cmp	w1, #0x0
  6010413704:	540000ab 	b.lt	6010413718 <_vsnprintf+0x7ec>  // b.tstop
  6010413708:	91002c01 	add	x1, x0, #0xb
  601041370c:	927df021 	and	x1, x1, #0xfffffffffffffff8
  6010413710:	f9000261 	str	x1, [x19]
  6010413714:	1400000d 	b	6010413748 <_vsnprintf+0x81c>
  6010413718:	11002022 	add	w2, w1, #0x8
  601041371c:	b9001a62 	str	w2, [x19, #24]
  6010413720:	b9401a62 	ldr	w2, [x19, #24]
  6010413724:	7100005f 	cmp	w2, #0x0
  6010413728:	540000ad 	b.le	601041373c <_vsnprintf+0x810>
  601041372c:	91002c01 	add	x1, x0, #0xb
  6010413730:	927df021 	and	x1, x1, #0xfffffffffffffff8
  6010413734:	f9000261 	str	x1, [x19]
  6010413738:	14000004 	b	6010413748 <_vsnprintf+0x81c>
  601041373c:	f9400662 	ldr	x2, [x19, #8]
  6010413740:	93407c20 	sxtw	x0, w1
  6010413744:	8b000040 	add	x0, x2, x0
  6010413748:	b9400000 	ldr	w0, [x0]
  601041374c:	13003c00 	sxth	w0, w0
  6010413750:	14000016 	b	60104137a8 <_vsnprintf+0x87c>
                                                                                                           : va_arg(va, int);
  6010413754:	b9401a61 	ldr	w1, [x19, #24]
  6010413758:	f9400260 	ldr	x0, [x19]
  601041375c:	7100003f 	cmp	w1, #0x0
  6010413760:	540000ab 	b.lt	6010413774 <_vsnprintf+0x848>  // b.tstop
  6010413764:	91002c01 	add	x1, x0, #0xb
  6010413768:	927df021 	and	x1, x1, #0xfffffffffffffff8
  601041376c:	f9000261 	str	x1, [x19]
  6010413770:	1400000d 	b	60104137a4 <_vsnprintf+0x878>
  6010413774:	11002022 	add	w2, w1, #0x8
  6010413778:	b9001a62 	str	w2, [x19, #24]
  601041377c:	b9401a62 	ldr	w2, [x19, #24]
  6010413780:	7100005f 	cmp	w2, #0x0
  6010413784:	540000ad 	b.le	6010413798 <_vsnprintf+0x86c>
  6010413788:	91002c01 	add	x1, x0, #0xb
  601041378c:	927df021 	and	x1, x1, #0xfffffffffffffff8
  6010413790:	f9000261 	str	x1, [x19]
  6010413794:	14000004 	b	60104137a4 <_vsnprintf+0x878>
  6010413798:	f9400662 	ldr	x2, [x19, #8]
  601041379c:	93407c20 	sxtw	x0, w1
  60104137a0:	8b000040 	add	x0, x2, x0
  60104137a4:	b9400000 	ldr	w0, [x0]
                    const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int)
  60104137a8:	b90063e0 	str	w0, [sp, #96]
                    idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
  60104137ac:	b94063e0 	ldr	w0, [sp, #96]
  60104137b0:	7100001f 	cmp	w0, #0x0
  60104137b4:	5a80a400 	cneg	w0, w0, lt  // lt = tstop
  60104137b8:	2a0003e1 	mov	w1, w0
  60104137bc:	b94063e0 	ldr	w0, [sp, #96]
  60104137c0:	531f7c00 	lsr	w0, w0, #31
  60104137c4:	12001c03 	and	w3, w0, #0xff
  60104137c8:	b94087e2 	ldr	w2, [sp, #132]
  60104137cc:	b9409fe0 	ldr	w0, [sp, #156]
  60104137d0:	b9000be0 	str	w0, [sp, #8]
  60104137d4:	b9409be0 	ldr	w0, [sp, #152]
  60104137d8:	b90003e0 	str	w0, [sp]
  60104137dc:	b94097e7 	ldr	w7, [sp, #148]
  60104137e0:	aa0203e6 	mov	x6, x2
  60104137e4:	2a0303e5 	mov	w5, w3
  60104137e8:	aa0103e4 	mov	x4, x1
  60104137ec:	f9401fe3 	ldr	x3, [sp, #56]
  60104137f0:	f94047e2 	ldr	x2, [sp, #136]
  60104137f4:	f94023e1 	ldr	x1, [sp, #64]
  60104137f8:	f94027e0 	ldr	x0, [sp, #72]
  60104137fc:	97fffa59 	bl	6010412160 <_ntoa_long>
  6010413800:	f90047e0 	str	x0, [sp, #136]
                if (flags & FLAGS_LONG_LONG) {
  6010413804:	140000af 	b	6010413ac0 <_vsnprintf+0xb94>
                }
            } else {
                // unsigned
                if (flags & FLAGS_LONG_LONG) {
  6010413808:	b9409fe0 	ldr	w0, [sp, #156]
  601041380c:	12170000 	and	w0, w0, #0x200
  6010413810:	7100001f 	cmp	w0, #0x0
  6010413814:	540004c0 	b.eq	60104138ac <_vsnprintf+0x980>  // b.none
#if defined(PRINTF_SUPPORT_LONG_LONG)
                    idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
  6010413818:	b9401a61 	ldr	w1, [x19, #24]
  601041381c:	f9400260 	ldr	x0, [x19]
  6010413820:	7100003f 	cmp	w1, #0x0
  6010413824:	540000ab 	b.lt	6010413838 <_vsnprintf+0x90c>  // b.tstop
  6010413828:	91003c01 	add	x1, x0, #0xf
  601041382c:	927df021 	and	x1, x1, #0xfffffffffffffff8
  6010413830:	f9000261 	str	x1, [x19]
  6010413834:	1400000d 	b	6010413868 <_vsnprintf+0x93c>
  6010413838:	11002022 	add	w2, w1, #0x8
  601041383c:	b9001a62 	str	w2, [x19, #24]
  6010413840:	b9401a62 	ldr	w2, [x19, #24]
  6010413844:	7100005f 	cmp	w2, #0x0
  6010413848:	540000ad 	b.le	601041385c <_vsnprintf+0x930>
  601041384c:	91003c01 	add	x1, x0, #0xf
  6010413850:	927df021 	and	x1, x1, #0xfffffffffffffff8
  6010413854:	f9000261 	str	x1, [x19]
  6010413858:	14000004 	b	6010413868 <_vsnprintf+0x93c>
  601041385c:	f9400662 	ldr	x2, [x19, #8]
  6010413860:	93407c20 	sxtw	x0, w1
  6010413864:	8b000040 	add	x0, x2, x0
  6010413868:	f9400001 	ldr	x1, [x0]
  601041386c:	b94087e2 	ldr	w2, [sp, #132]
  6010413870:	b9409fe0 	ldr	w0, [sp, #156]
  6010413874:	b9000be0 	str	w0, [sp, #8]
  6010413878:	b9409be0 	ldr	w0, [sp, #152]
  601041387c:	b90003e0 	str	w0, [sp]
  6010413880:	b94097e7 	ldr	w7, [sp, #148]
  6010413884:	aa0203e6 	mov	x6, x2
  6010413888:	52800005 	mov	w5, #0x0                   	// #0
  601041388c:	aa0103e4 	mov	x4, x1
  6010413890:	f9401fe3 	ldr	x3, [sp, #56]
  6010413894:	f94047e2 	ldr	x2, [sp, #136]
  6010413898:	f94023e1 	ldr	x1, [sp, #64]
  601041389c:	f94027e0 	ldr	x0, [sp, #72]
  60104138a0:	97fffa87 	bl	60104122bc <_ntoa_long_long>
  60104138a4:	f90047e0 	str	x0, [sp, #136]
  60104138a8:	14000086 	b	6010413ac0 <_vsnprintf+0xb94>
#endif
                } else if (flags & FLAGS_LONG) {
  60104138ac:	b9409fe0 	ldr	w0, [sp, #156]
  60104138b0:	12180000 	and	w0, w0, #0x100
  60104138b4:	7100001f 	cmp	w0, #0x0
  60104138b8:	540004c0 	b.eq	6010413950 <_vsnprintf+0xa24>  // b.none
                    idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
  60104138bc:	b9401a61 	ldr	w1, [x19, #24]
  60104138c0:	f9400260 	ldr	x0, [x19]
  60104138c4:	7100003f 	cmp	w1, #0x0
  60104138c8:	540000ab 	b.lt	60104138dc <_vsnprintf+0x9b0>  // b.tstop
  60104138cc:	91003c01 	add	x1, x0, #0xf
  60104138d0:	927df021 	and	x1, x1, #0xfffffffffffffff8
  60104138d4:	f9000261 	str	x1, [x19]
  60104138d8:	1400000d 	b	601041390c <_vsnprintf+0x9e0>
  60104138dc:	11002022 	add	w2, w1, #0x8
  60104138e0:	b9001a62 	str	w2, [x19, #24]
  60104138e4:	b9401a62 	ldr	w2, [x19, #24]
  60104138e8:	7100005f 	cmp	w2, #0x0
  60104138ec:	540000ad 	b.le	6010413900 <_vsnprintf+0x9d4>
  60104138f0:	91003c01 	add	x1, x0, #0xf
  60104138f4:	927df021 	and	x1, x1, #0xfffffffffffffff8
  60104138f8:	f9000261 	str	x1, [x19]
  60104138fc:	14000004 	b	601041390c <_vsnprintf+0x9e0>
  6010413900:	f9400662 	ldr	x2, [x19, #8]
  6010413904:	93407c20 	sxtw	x0, w1
  6010413908:	8b000040 	add	x0, x2, x0
  601041390c:	f9400001 	ldr	x1, [x0]
  6010413910:	b94087e2 	ldr	w2, [sp, #132]
  6010413914:	b9409fe0 	ldr	w0, [sp, #156]
  6010413918:	b9000be0 	str	w0, [sp, #8]
  601041391c:	b9409be0 	ldr	w0, [sp, #152]
  6010413920:	b90003e0 	str	w0, [sp]
  6010413924:	b94097e7 	ldr	w7, [sp, #148]
  6010413928:	aa0203e6 	mov	x6, x2
  601041392c:	52800005 	mov	w5, #0x0                   	// #0
  6010413930:	aa0103e4 	mov	x4, x1
  6010413934:	f9401fe3 	ldr	x3, [sp, #56]
  6010413938:	f94047e2 	ldr	x2, [sp, #136]
  601041393c:	f94023e1 	ldr	x1, [sp, #64]
  6010413940:	f94027e0 	ldr	x0, [sp, #72]
  6010413944:	97fffa07 	bl	6010412160 <_ntoa_long>
  6010413948:	f90047e0 	str	x0, [sp, #136]
  601041394c:	1400005d 	b	6010413ac0 <_vsnprintf+0xb94>
                } else {
                    const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int)
  6010413950:	b9409fe0 	ldr	w0, [sp, #156]
  6010413954:	121a0000 	and	w0, w0, #0x40
  6010413958:	7100001f 	cmp	w0, #0x0
  601041395c:	54000300 	b.eq	60104139bc <_vsnprintf+0xa90>  // b.none
  6010413960:	b9401a61 	ldr	w1, [x19, #24]
  6010413964:	f9400260 	ldr	x0, [x19]
  6010413968:	7100003f 	cmp	w1, #0x0
  601041396c:	540000ab 	b.lt	6010413980 <_vsnprintf+0xa54>  // b.tstop
  6010413970:	91002c01 	add	x1, x0, #0xb
  6010413974:	927df021 	and	x1, x1, #0xfffffffffffffff8
  6010413978:	f9000261 	str	x1, [x19]
  601041397c:	1400000d 	b	60104139b0 <_vsnprintf+0xa84>
  6010413980:	11002022 	add	w2, w1, #0x8
  6010413984:	b9001a62 	str	w2, [x19, #24]
  6010413988:	b9401a62 	ldr	w2, [x19, #24]
  601041398c:	7100005f 	cmp	w2, #0x0
  6010413990:	540000ad 	b.le	60104139a4 <_vsnprintf+0xa78>
  6010413994:	91002c01 	add	x1, x0, #0xb
  6010413998:	927df021 	and	x1, x1, #0xfffffffffffffff8
  601041399c:	f9000261 	str	x1, [x19]
  60104139a0:	14000004 	b	60104139b0 <_vsnprintf+0xa84>
  60104139a4:	f9400662 	ldr	x2, [x19, #8]
  60104139a8:	93407c20 	sxtw	x0, w1
  60104139ac:	8b000040 	add	x0, x2, x0
  60104139b0:	b9400000 	ldr	w0, [x0]
  60104139b4:	12001c00 	and	w0, w0, #0xff
  60104139b8:	14000031 	b	6010413a7c <_vsnprintf+0xb50>
  60104139bc:	b9409fe0 	ldr	w0, [sp, #156]
  60104139c0:	12190000 	and	w0, w0, #0x80
                                                                                                                                      : va_arg(va, unsigned int);
  60104139c4:	7100001f 	cmp	w0, #0x0
  60104139c8:	54000300 	b.eq	6010413a28 <_vsnprintf+0xafc>  // b.none
                    const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int)
  60104139cc:	b9401a61 	ldr	w1, [x19, #24]
  60104139d0:	f9400260 	ldr	x0, [x19]
  60104139d4:	7100003f 	cmp	w1, #0x0
  60104139d8:	540000ab 	b.lt	60104139ec <_vsnprintf+0xac0>  // b.tstop
  60104139dc:	91002c01 	add	x1, x0, #0xb
  60104139e0:	927df021 	and	x1, x1, #0xfffffffffffffff8
  60104139e4:	f9000261 	str	x1, [x19]
  60104139e8:	1400000d 	b	6010413a1c <_vsnprintf+0xaf0>
  60104139ec:	11002022 	add	w2, w1, #0x8
  60104139f0:	b9001a62 	str	w2, [x19, #24]
  60104139f4:	b9401a62 	ldr	w2, [x19, #24]
  60104139f8:	7100005f 	cmp	w2, #0x0
  60104139fc:	540000ad 	b.le	6010413a10 <_vsnprintf+0xae4>
  6010413a00:	91002c01 	add	x1, x0, #0xb
  6010413a04:	927df021 	and	x1, x1, #0xfffffffffffffff8
  6010413a08:	f9000261 	str	x1, [x19]
  6010413a0c:	14000004 	b	6010413a1c <_vsnprintf+0xaf0>
  6010413a10:	f9400662 	ldr	x2, [x19, #8]
  6010413a14:	93407c20 	sxtw	x0, w1
  6010413a18:	8b000040 	add	x0, x2, x0
  6010413a1c:	b9400000 	ldr	w0, [x0]
  6010413a20:	12003c00 	and	w0, w0, #0xffff
  6010413a24:	14000016 	b	6010413a7c <_vsnprintf+0xb50>
                                                                                                                                      : va_arg(va, unsigned int);
  6010413a28:	b9401a61 	ldr	w1, [x19, #24]
  6010413a2c:	f9400260 	ldr	x0, [x19]
  6010413a30:	7100003f 	cmp	w1, #0x0
  6010413a34:	540000ab 	b.lt	6010413a48 <_vsnprintf+0xb1c>  // b.tstop
  6010413a38:	91002c01 	add	x1, x0, #0xb
  6010413a3c:	927df021 	and	x1, x1, #0xfffffffffffffff8
  6010413a40:	f9000261 	str	x1, [x19]
  6010413a44:	1400000d 	b	6010413a78 <_vsnprintf+0xb4c>
  6010413a48:	11002022 	add	w2, w1, #0x8
  6010413a4c:	b9001a62 	str	w2, [x19, #24]
  6010413a50:	b9401a62 	ldr	w2, [x19, #24]
  6010413a54:	7100005f 	cmp	w2, #0x0
  6010413a58:	540000ad 	b.le	6010413a6c <_vsnprintf+0xb40>
  6010413a5c:	91002c01 	add	x1, x0, #0xb
  6010413a60:	927df021 	and	x1, x1, #0xfffffffffffffff8
  6010413a64:	f9000261 	str	x1, [x19]
  6010413a68:	14000004 	b	6010413a78 <_vsnprintf+0xb4c>
  6010413a6c:	f9400662 	ldr	x2, [x19, #8]
  6010413a70:	93407c20 	sxtw	x0, w1
  6010413a74:	8b000040 	add	x0, x2, x0
  6010413a78:	b9400000 	ldr	w0, [x0]
                    const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int)
  6010413a7c:	b90067e0 	str	w0, [sp, #100]
                    idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);
  6010413a80:	b94067e1 	ldr	w1, [sp, #100]
  6010413a84:	b94087e2 	ldr	w2, [sp, #132]
  6010413a88:	b9409fe0 	ldr	w0, [sp, #156]
  6010413a8c:	b9000be0 	str	w0, [sp, #8]
  6010413a90:	b9409be0 	ldr	w0, [sp, #152]
  6010413a94:	b90003e0 	str	w0, [sp]
  6010413a98:	b94097e7 	ldr	w7, [sp, #148]
  6010413a9c:	aa0203e6 	mov	x6, x2
  6010413aa0:	52800005 	mov	w5, #0x0                   	// #0
  6010413aa4:	aa0103e4 	mov	x4, x1
  6010413aa8:	f9401fe3 	ldr	x3, [sp, #56]
  6010413aac:	f94047e2 	ldr	x2, [sp, #136]
  6010413ab0:	f94023e1 	ldr	x1, [sp, #64]
  6010413ab4:	f94027e0 	ldr	x0, [sp, #72]
  6010413ab8:	97fff9aa 	bl	6010412160 <_ntoa_long>
  6010413abc:	f90047e0 	str	x0, [sp, #136]
                }
            }
            format++;
  6010413ac0:	f9401be0 	ldr	x0, [sp, #48]
  6010413ac4:	91000400 	add	x0, x0, #0x1
  6010413ac8:	f9001be0 	str	x0, [sp, #48]
            break;
  6010413acc:	14000194 	b	601041411c <_vsnprintf+0x11f0>
        }
#if defined(PRINTF_SUPPORT_FLOAT)
        case 'f':
        case 'F':
            if (*format == 'F')
  6010413ad0:	f9401be0 	ldr	x0, [sp, #48]
  6010413ad4:	39400000 	ldrb	w0, [x0]
  6010413ad8:	7101181f 	cmp	w0, #0x46
  6010413adc:	54000081 	b.ne	6010413aec <_vsnprintf+0xbc0>  // b.any
                flags |= FLAGS_UPPERCASE;
  6010413ae0:	b9409fe0 	ldr	w0, [sp, #156]
  6010413ae4:	321b0000 	orr	w0, w0, #0x20
  6010413ae8:	b9009fe0 	str	w0, [sp, #156]
            idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
  6010413aec:	b9401e61 	ldr	w1, [x19, #28]
  6010413af0:	f9400260 	ldr	x0, [x19]
  6010413af4:	7100003f 	cmp	w1, #0x0
  6010413af8:	540000ab 	b.lt	6010413b0c <_vsnprintf+0xbe0>  // b.tstop
  6010413afc:	91003c01 	add	x1, x0, #0xf
  6010413b00:	927df021 	and	x1, x1, #0xfffffffffffffff8
  6010413b04:	f9000261 	str	x1, [x19]
  6010413b08:	1400000d 	b	6010413b3c <_vsnprintf+0xc10>
  6010413b0c:	11004022 	add	w2, w1, #0x10
  6010413b10:	b9001e62 	str	w2, [x19, #28]
  6010413b14:	b9401e62 	ldr	w2, [x19, #28]
  6010413b18:	7100005f 	cmp	w2, #0x0
  6010413b1c:	540000ad 	b.le	6010413b30 <_vsnprintf+0xc04>
  6010413b20:	91003c01 	add	x1, x0, #0xf
  6010413b24:	927df021 	and	x1, x1, #0xfffffffffffffff8
  6010413b28:	f9000261 	str	x1, [x19]
  6010413b2c:	14000004 	b	6010413b3c <_vsnprintf+0xc10>
  6010413b30:	f9400a62 	ldr	x2, [x19, #16]
  6010413b34:	93407c20 	sxtw	x0, w1
  6010413b38:	8b000040 	add	x0, x2, x0
  6010413b3c:	fd400000 	ldr	d0, [x0]
  6010413b40:	b9409fe6 	ldr	w6, [sp, #156]
  6010413b44:	b9409be5 	ldr	w5, [sp, #152]
  6010413b48:	b94097e4 	ldr	w4, [sp, #148]
  6010413b4c:	f9401fe3 	ldr	x3, [sp, #56]
  6010413b50:	f94047e2 	ldr	x2, [sp, #136]
  6010413b54:	f94023e1 	ldr	x1, [sp, #64]
  6010413b58:	f94027e0 	ldr	x0, [sp, #72]
  6010413b5c:	97fffa2f 	bl	6010412418 <_ftoa>
  6010413b60:	f90047e0 	str	x0, [sp, #136]
            format++;
  6010413b64:	f9401be0 	ldr	x0, [sp, #48]
  6010413b68:	91000400 	add	x0, x0, #0x1
  6010413b6c:	f9001be0 	str	x0, [sp, #48]
            break;
  6010413b70:	1400016b 	b	601041411c <_vsnprintf+0x11f0>
#if defined(PRINTF_SUPPORT_EXPONENTIAL)
        case 'e':
        case 'E':
        case 'g':
        case 'G':
            if ((*format == 'g') || (*format == 'G'))
  6010413b74:	f9401be0 	ldr	x0, [sp, #48]
  6010413b78:	39400000 	ldrb	w0, [x0]
  6010413b7c:	71019c1f 	cmp	w0, #0x67
  6010413b80:	540000a0 	b.eq	6010413b94 <_vsnprintf+0xc68>  // b.none
  6010413b84:	f9401be0 	ldr	x0, [sp, #48]
  6010413b88:	39400000 	ldrb	w0, [x0]
  6010413b8c:	71011c1f 	cmp	w0, #0x47
  6010413b90:	54000081 	b.ne	6010413ba0 <_vsnprintf+0xc74>  // b.any
                flags |= FLAGS_ADAPT_EXP;
  6010413b94:	b9409fe0 	ldr	w0, [sp, #156]
  6010413b98:	32150000 	orr	w0, w0, #0x800
  6010413b9c:	b9009fe0 	str	w0, [sp, #156]
            if ((*format == 'E') || (*format == 'G'))
  6010413ba0:	f9401be0 	ldr	x0, [sp, #48]
  6010413ba4:	39400000 	ldrb	w0, [x0]
  6010413ba8:	7101141f 	cmp	w0, #0x45
  6010413bac:	540000a0 	b.eq	6010413bc0 <_vsnprintf+0xc94>  // b.none
  6010413bb0:	f9401be0 	ldr	x0, [sp, #48]
  6010413bb4:	39400000 	ldrb	w0, [x0]
  6010413bb8:	71011c1f 	cmp	w0, #0x47
  6010413bbc:	54000081 	b.ne	6010413bcc <_vsnprintf+0xca0>  // b.any
                flags |= FLAGS_UPPERCASE;
  6010413bc0:	b9409fe0 	ldr	w0, [sp, #156]
  6010413bc4:	321b0000 	orr	w0, w0, #0x20
  6010413bc8:	b9009fe0 	str	w0, [sp, #156]
            idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
  6010413bcc:	b9401e61 	ldr	w1, [x19, #28]
  6010413bd0:	f9400260 	ldr	x0, [x19]
  6010413bd4:	7100003f 	cmp	w1, #0x0
  6010413bd8:	540000ab 	b.lt	6010413bec <_vsnprintf+0xcc0>  // b.tstop
  6010413bdc:	91003c01 	add	x1, x0, #0xf
  6010413be0:	927df021 	and	x1, x1, #0xfffffffffffffff8
  6010413be4:	f9000261 	str	x1, [x19]
  6010413be8:	1400000d 	b	6010413c1c <_vsnprintf+0xcf0>
  6010413bec:	11004022 	add	w2, w1, #0x10
  6010413bf0:	b9001e62 	str	w2, [x19, #28]
  6010413bf4:	b9401e62 	ldr	w2, [x19, #28]
  6010413bf8:	7100005f 	cmp	w2, #0x0
  6010413bfc:	540000ad 	b.le	6010413c10 <_vsnprintf+0xce4>
  6010413c00:	91003c01 	add	x1, x0, #0xf
  6010413c04:	927df021 	and	x1, x1, #0xfffffffffffffff8
  6010413c08:	f9000261 	str	x1, [x19]
  6010413c0c:	14000004 	b	6010413c1c <_vsnprintf+0xcf0>
  6010413c10:	f9400a62 	ldr	x2, [x19, #16]
  6010413c14:	93407c20 	sxtw	x0, w1
  6010413c18:	8b000040 	add	x0, x2, x0
  6010413c1c:	fd400000 	ldr	d0, [x0]
  6010413c20:	b9409fe6 	ldr	w6, [sp, #156]
  6010413c24:	b9409be5 	ldr	w5, [sp, #152]
  6010413c28:	b94097e4 	ldr	w4, [sp, #148]
  6010413c2c:	f9401fe3 	ldr	x3, [sp, #56]
  6010413c30:	f94047e2 	ldr	x2, [sp, #136]
  6010413c34:	f94023e1 	ldr	x1, [sp, #64]
  6010413c38:	f94027e0 	ldr	x0, [sp, #72]
  6010413c3c:	97fffb86 	bl	6010412a54 <_etoa>
  6010413c40:	f90047e0 	str	x0, [sp, #136]
            format++;
  6010413c44:	f9401be0 	ldr	x0, [sp, #48]
  6010413c48:	91000400 	add	x0, x0, #0x1
  6010413c4c:	f9001be0 	str	x0, [sp, #48]
            break;
  6010413c50:	14000133 	b	601041411c <_vsnprintf+0x11f0>
#endif // PRINTF_SUPPORT_EXPONENTIAL
#endif // PRINTF_SUPPORT_FLOAT
        case 'c': {
            unsigned int l = 1U;
  6010413c54:	52800020 	mov	w0, #0x1                   	// #1
  6010413c58:	b90083e0 	str	w0, [sp, #128]
            // pre padding
            if (!(flags & FLAGS_LEFT)) {
  6010413c5c:	b9409fe0 	ldr	w0, [sp, #156]
  6010413c60:	121f0000 	and	w0, w0, #0x2
  6010413c64:	7100001f 	cmp	w0, #0x0
  6010413c68:	54000221 	b.ne	6010413cac <_vsnprintf+0xd80>  // b.any
                while (l++ < width) {
  6010413c6c:	1400000a 	b	6010413c94 <_vsnprintf+0xd68>
                    out(' ', buffer, idx++, maxlen);
  6010413c70:	f94047e0 	ldr	x0, [sp, #136]
  6010413c74:	91000401 	add	x1, x0, #0x1
  6010413c78:	f90047e1 	str	x1, [sp, #136]
  6010413c7c:	f94027e4 	ldr	x4, [sp, #72]
  6010413c80:	f9401fe3 	ldr	x3, [sp, #56]
  6010413c84:	aa0003e2 	mov	x2, x0
  6010413c88:	f94023e1 	ldr	x1, [sp, #64]
  6010413c8c:	52800400 	mov	w0, #0x20                  	// #32
  6010413c90:	d63f0080 	blr	x4
                while (l++ < width) {
  6010413c94:	b94083e0 	ldr	w0, [sp, #128]
  6010413c98:	11000401 	add	w1, w0, #0x1
  6010413c9c:	b90083e1 	str	w1, [sp, #128]
  6010413ca0:	b9409be1 	ldr	w1, [sp, #152]
  6010413ca4:	6b00003f 	cmp	w1, w0
  6010413ca8:	54fffe48 	b.hi	6010413c70 <_vsnprintf+0xd44>  // b.pmore
                }
            }
            // char output
            out((char)va_arg(va, int), buffer, idx++, maxlen);
  6010413cac:	b9401a61 	ldr	w1, [x19, #24]
  6010413cb0:	f9400260 	ldr	x0, [x19]
  6010413cb4:	7100003f 	cmp	w1, #0x0
  6010413cb8:	540000ab 	b.lt	6010413ccc <_vsnprintf+0xda0>  // b.tstop
  6010413cbc:	91002c01 	add	x1, x0, #0xb
  6010413cc0:	927df021 	and	x1, x1, #0xfffffffffffffff8
  6010413cc4:	f9000261 	str	x1, [x19]
  6010413cc8:	1400000d 	b	6010413cfc <_vsnprintf+0xdd0>
  6010413ccc:	11002022 	add	w2, w1, #0x8
  6010413cd0:	b9001a62 	str	w2, [x19, #24]
  6010413cd4:	b9401a62 	ldr	w2, [x19, #24]
  6010413cd8:	7100005f 	cmp	w2, #0x0
  6010413cdc:	540000ad 	b.le	6010413cf0 <_vsnprintf+0xdc4>
  6010413ce0:	91002c01 	add	x1, x0, #0xb
  6010413ce4:	927df021 	and	x1, x1, #0xfffffffffffffff8
  6010413ce8:	f9000261 	str	x1, [x19]
  6010413cec:	14000004 	b	6010413cfc <_vsnprintf+0xdd0>
  6010413cf0:	f9400662 	ldr	x2, [x19, #8]
  6010413cf4:	93407c20 	sxtw	x0, w1
  6010413cf8:	8b000040 	add	x0, x2, x0
  6010413cfc:	b9400000 	ldr	w0, [x0]
  6010413d00:	12001c05 	and	w5, w0, #0xff
  6010413d04:	f94047e0 	ldr	x0, [sp, #136]
  6010413d08:	91000401 	add	x1, x0, #0x1
  6010413d0c:	f90047e1 	str	x1, [sp, #136]
  6010413d10:	f94027e4 	ldr	x4, [sp, #72]
  6010413d14:	f9401fe3 	ldr	x3, [sp, #56]
  6010413d18:	aa0003e2 	mov	x2, x0
  6010413d1c:	f94023e1 	ldr	x1, [sp, #64]
  6010413d20:	2a0503e0 	mov	w0, w5
  6010413d24:	d63f0080 	blr	x4
            // post padding
            if (flags & FLAGS_LEFT) {
  6010413d28:	b9409fe0 	ldr	w0, [sp, #156]
  6010413d2c:	121f0000 	and	w0, w0, #0x2
  6010413d30:	7100001f 	cmp	w0, #0x0
  6010413d34:	54000220 	b.eq	6010413d78 <_vsnprintf+0xe4c>  // b.none
                while (l++ < width) {
  6010413d38:	1400000a 	b	6010413d60 <_vsnprintf+0xe34>
                    out(' ', buffer, idx++, maxlen);
  6010413d3c:	f94047e0 	ldr	x0, [sp, #136]
  6010413d40:	91000401 	add	x1, x0, #0x1
  6010413d44:	f90047e1 	str	x1, [sp, #136]
  6010413d48:	f94027e4 	ldr	x4, [sp, #72]
  6010413d4c:	f9401fe3 	ldr	x3, [sp, #56]
  6010413d50:	aa0003e2 	mov	x2, x0
  6010413d54:	f94023e1 	ldr	x1, [sp, #64]
  6010413d58:	52800400 	mov	w0, #0x20                  	// #32
  6010413d5c:	d63f0080 	blr	x4
                while (l++ < width) {
  6010413d60:	b94083e0 	ldr	w0, [sp, #128]
  6010413d64:	11000401 	add	w1, w0, #0x1
  6010413d68:	b90083e1 	str	w1, [sp, #128]
  6010413d6c:	b9409be1 	ldr	w1, [sp, #152]
  6010413d70:	6b00003f 	cmp	w1, w0
  6010413d74:	54fffe48 	b.hi	6010413d3c <_vsnprintf+0xe10>  // b.pmore
                }
            }
            format++;
  6010413d78:	f9401be0 	ldr	x0, [sp, #48]
  6010413d7c:	91000400 	add	x0, x0, #0x1
  6010413d80:	f9001be0 	str	x0, [sp, #48]
            break;
  6010413d84:	140000e6 	b	601041411c <_vsnprintf+0x11f0>
        }

        case 's': {
            const char* p = va_arg(va, char*);
  6010413d88:	b9401a61 	ldr	w1, [x19, #24]
  6010413d8c:	f9400260 	ldr	x0, [x19]
  6010413d90:	7100003f 	cmp	w1, #0x0
  6010413d94:	540000ab 	b.lt	6010413da8 <_vsnprintf+0xe7c>  // b.tstop
  6010413d98:	91003c01 	add	x1, x0, #0xf
  6010413d9c:	927df021 	and	x1, x1, #0xfffffffffffffff8
  6010413da0:	f9000261 	str	x1, [x19]
  6010413da4:	1400000d 	b	6010413dd8 <_vsnprintf+0xeac>
  6010413da8:	11002022 	add	w2, w1, #0x8
  6010413dac:	b9001a62 	str	w2, [x19, #24]
  6010413db0:	b9401a62 	ldr	w2, [x19, #24]
  6010413db4:	7100005f 	cmp	w2, #0x0
  6010413db8:	540000ad 	b.le	6010413dcc <_vsnprintf+0xea0>
  6010413dbc:	91003c01 	add	x1, x0, #0xf
  6010413dc0:	927df021 	and	x1, x1, #0xfffffffffffffff8
  6010413dc4:	f9000261 	str	x1, [x19]
  6010413dc8:	14000004 	b	6010413dd8 <_vsnprintf+0xeac>
  6010413dcc:	f9400662 	ldr	x2, [x19, #8]
  6010413dd0:	93407c20 	sxtw	x0, w1
  6010413dd4:	8b000040 	add	x0, x2, x0
  6010413dd8:	f9400000 	ldr	x0, [x0]
  6010413ddc:	f9003fe0 	str	x0, [sp, #120]
            unsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);
  6010413de0:	b94097e0 	ldr	w0, [sp, #148]
  6010413de4:	7100001f 	cmp	w0, #0x0
  6010413de8:	54000060 	b.eq	6010413df4 <_vsnprintf+0xec8>  // b.none
  6010413dec:	b94097e0 	ldr	w0, [sp, #148]
  6010413df0:	14000002 	b	6010413df8 <_vsnprintf+0xecc>
  6010413df4:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
  6010413df8:	aa0003e1 	mov	x1, x0
  6010413dfc:	f9403fe0 	ldr	x0, [sp, #120]
  6010413e00:	97fff77a 	bl	6010411be8 <_strnlen_s>
  6010413e04:	b90077e0 	str	w0, [sp, #116]
            // pre padding
            if (flags & FLAGS_PRECISION) {
  6010413e08:	b9409fe0 	ldr	w0, [sp, #156]
  6010413e0c:	12160000 	and	w0, w0, #0x400
  6010413e10:	7100001f 	cmp	w0, #0x0
  6010413e14:	540000e0 	b.eq	6010413e30 <_vsnprintf+0xf04>  // b.none
                l = (l < precision ? l : precision);
  6010413e18:	b94077e0 	ldr	w0, [sp, #116]
  6010413e1c:	b94097e2 	ldr	w2, [sp, #148]
  6010413e20:	b94097e1 	ldr	w1, [sp, #148]
  6010413e24:	6b00005f 	cmp	w2, w0
  6010413e28:	1a809020 	csel	w0, w1, w0, ls  // ls = plast
  6010413e2c:	b90077e0 	str	w0, [sp, #116]
            }
            if (!(flags & FLAGS_LEFT)) {
  6010413e30:	b9409fe0 	ldr	w0, [sp, #156]
  6010413e34:	121f0000 	and	w0, w0, #0x2
  6010413e38:	7100001f 	cmp	w0, #0x0
  6010413e3c:	540003e1 	b.ne	6010413eb8 <_vsnprintf+0xf8c>  // b.any
                while (l++ < width) {
  6010413e40:	1400000a 	b	6010413e68 <_vsnprintf+0xf3c>
                    out(' ', buffer, idx++, maxlen);
  6010413e44:	f94047e0 	ldr	x0, [sp, #136]
  6010413e48:	91000401 	add	x1, x0, #0x1
  6010413e4c:	f90047e1 	str	x1, [sp, #136]
  6010413e50:	f94027e4 	ldr	x4, [sp, #72]
  6010413e54:	f9401fe3 	ldr	x3, [sp, #56]
  6010413e58:	aa0003e2 	mov	x2, x0
  6010413e5c:	f94023e1 	ldr	x1, [sp, #64]
  6010413e60:	52800400 	mov	w0, #0x20                  	// #32
  6010413e64:	d63f0080 	blr	x4
                while (l++ < width) {
  6010413e68:	b94077e0 	ldr	w0, [sp, #116]
  6010413e6c:	11000401 	add	w1, w0, #0x1
  6010413e70:	b90077e1 	str	w1, [sp, #116]
  6010413e74:	b9409be1 	ldr	w1, [sp, #152]
  6010413e78:	6b00003f 	cmp	w1, w0
  6010413e7c:	54fffe48 	b.hi	6010413e44 <_vsnprintf+0xf18>  // b.pmore
                }
            }
            // string output
            while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
  6010413e80:	1400000e 	b	6010413eb8 <_vsnprintf+0xf8c>
                out(*(p++), buffer, idx++, maxlen);
  6010413e84:	f9403fe0 	ldr	x0, [sp, #120]
  6010413e88:	91000401 	add	x1, x0, #0x1
  6010413e8c:	f9003fe1 	str	x1, [sp, #120]
  6010413e90:	39400005 	ldrb	w5, [x0]
  6010413e94:	f94047e0 	ldr	x0, [sp, #136]
  6010413e98:	91000401 	add	x1, x0, #0x1
  6010413e9c:	f90047e1 	str	x1, [sp, #136]
  6010413ea0:	f94027e4 	ldr	x4, [sp, #72]
  6010413ea4:	f9401fe3 	ldr	x3, [sp, #56]
  6010413ea8:	aa0003e2 	mov	x2, x0
  6010413eac:	f94023e1 	ldr	x1, [sp, #64]
  6010413eb0:	2a0503e0 	mov	w0, w5
  6010413eb4:	d63f0080 	blr	x4
            while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
  6010413eb8:	f9403fe0 	ldr	x0, [sp, #120]
  6010413ebc:	39400000 	ldrb	w0, [x0]
  6010413ec0:	7100001f 	cmp	w0, #0x0
  6010413ec4:	54000140 	b.eq	6010413eec <_vsnprintf+0xfc0>  // b.none
  6010413ec8:	b9409fe0 	ldr	w0, [sp, #156]
  6010413ecc:	12160000 	and	w0, w0, #0x400
  6010413ed0:	7100001f 	cmp	w0, #0x0
  6010413ed4:	54fffd80 	b.eq	6010413e84 <_vsnprintf+0xf58>  // b.none
  6010413ed8:	b94097e0 	ldr	w0, [sp, #148]
  6010413edc:	51000401 	sub	w1, w0, #0x1
  6010413ee0:	b90097e1 	str	w1, [sp, #148]
  6010413ee4:	7100001f 	cmp	w0, #0x0
  6010413ee8:	54fffce1 	b.ne	6010413e84 <_vsnprintf+0xf58>  // b.any
            }
            // post padding
            if (flags & FLAGS_LEFT) {
  6010413eec:	b9409fe0 	ldr	w0, [sp, #156]
  6010413ef0:	121f0000 	and	w0, w0, #0x2
  6010413ef4:	7100001f 	cmp	w0, #0x0
  6010413ef8:	54000220 	b.eq	6010413f3c <_vsnprintf+0x1010>  // b.none
                while (l++ < width) {
  6010413efc:	1400000a 	b	6010413f24 <_vsnprintf+0xff8>
                    out(' ', buffer, idx++, maxlen);
  6010413f00:	f94047e0 	ldr	x0, [sp, #136]
  6010413f04:	91000401 	add	x1, x0, #0x1
  6010413f08:	f90047e1 	str	x1, [sp, #136]
  6010413f0c:	f94027e4 	ldr	x4, [sp, #72]
  6010413f10:	f9401fe3 	ldr	x3, [sp, #56]
  6010413f14:	aa0003e2 	mov	x2, x0
  6010413f18:	f94023e1 	ldr	x1, [sp, #64]
  6010413f1c:	52800400 	mov	w0, #0x20                  	// #32
  6010413f20:	d63f0080 	blr	x4
                while (l++ < width) {
  6010413f24:	b94077e0 	ldr	w0, [sp, #116]
  6010413f28:	11000401 	add	w1, w0, #0x1
  6010413f2c:	b90077e1 	str	w1, [sp, #116]
  6010413f30:	b9409be1 	ldr	w1, [sp, #152]
  6010413f34:	6b00003f 	cmp	w1, w0
  6010413f38:	54fffe48 	b.hi	6010413f00 <_vsnprintf+0xfd4>  // b.pmore
                }
            }
            format++;
  6010413f3c:	f9401be0 	ldr	x0, [sp, #48]
  6010413f40:	91000400 	add	x0, x0, #0x1
  6010413f44:	f9001be0 	str	x0, [sp, #48]
            break;
  6010413f48:	14000075 	b	601041411c <_vsnprintf+0x11f0>
        }

        case 'p': {
            width = sizeof(void*) * 2U;
  6010413f4c:	52800200 	mov	w0, #0x10                  	// #16
  6010413f50:	b9009be0 	str	w0, [sp, #152]
            flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;
  6010413f54:	b9409fe1 	ldr	w1, [sp, #156]
  6010413f58:	52800420 	mov	w0, #0x21                  	// #33
  6010413f5c:	2a000020 	orr	w0, w1, w0
  6010413f60:	b9009fe0 	str	w0, [sp, #156]
#if defined(PRINTF_SUPPORT_LONG_LONG)
            const bool is_ll = sizeof(uintptr_t) == sizeof(long long);
  6010413f64:	52800020 	mov	w0, #0x1                   	// #1
  6010413f68:	3901afe0 	strb	w0, [sp, #107]
            if (is_ll) {
  6010413f6c:	3941afe0 	ldrb	w0, [sp, #107]
  6010413f70:	7100001f 	cmp	w0, #0x0
  6010413f74:	540004c0 	b.eq	601041400c <_vsnprintf+0x10e0>  // b.none
                idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);
  6010413f78:	b9401a61 	ldr	w1, [x19, #24]
  6010413f7c:	f9400260 	ldr	x0, [x19]
  6010413f80:	7100003f 	cmp	w1, #0x0
  6010413f84:	540000ab 	b.lt	6010413f98 <_vsnprintf+0x106c>  // b.tstop
  6010413f88:	91003c01 	add	x1, x0, #0xf
  6010413f8c:	927df021 	and	x1, x1, #0xfffffffffffffff8
  6010413f90:	f9000261 	str	x1, [x19]
  6010413f94:	1400000d 	b	6010413fc8 <_vsnprintf+0x109c>
  6010413f98:	11002022 	add	w2, w1, #0x8
  6010413f9c:	b9001a62 	str	w2, [x19, #24]
  6010413fa0:	b9401a62 	ldr	w2, [x19, #24]
  6010413fa4:	7100005f 	cmp	w2, #0x0
  6010413fa8:	540000ad 	b.le	6010413fbc <_vsnprintf+0x1090>
  6010413fac:	91003c01 	add	x1, x0, #0xf
  6010413fb0:	927df021 	and	x1, x1, #0xfffffffffffffff8
  6010413fb4:	f9000261 	str	x1, [x19]
  6010413fb8:	14000004 	b	6010413fc8 <_vsnprintf+0x109c>
  6010413fbc:	f9400662 	ldr	x2, [x19, #8]
  6010413fc0:	93407c20 	sxtw	x0, w1
  6010413fc4:	8b000040 	add	x0, x2, x0
  6010413fc8:	f9400000 	ldr	x0, [x0]
  6010413fcc:	aa0003e1 	mov	x1, x0
  6010413fd0:	b9409fe0 	ldr	w0, [sp, #156]
  6010413fd4:	b9000be0 	str	w0, [sp, #8]
  6010413fd8:	b9409be0 	ldr	w0, [sp, #152]
  6010413fdc:	b90003e0 	str	w0, [sp]
  6010413fe0:	b94097e7 	ldr	w7, [sp, #148]
  6010413fe4:	d2800206 	mov	x6, #0x10                  	// #16
  6010413fe8:	52800005 	mov	w5, #0x0                   	// #0
  6010413fec:	aa0103e4 	mov	x4, x1
  6010413ff0:	f9401fe3 	ldr	x3, [sp, #56]
  6010413ff4:	f94047e2 	ldr	x2, [sp, #136]
  6010413ff8:	f94023e1 	ldr	x1, [sp, #64]
  6010413ffc:	f94027e0 	ldr	x0, [sp, #72]
  6010414000:	97fff8af 	bl	60104122bc <_ntoa_long_long>
  6010414004:	f90047e0 	str	x0, [sp, #136]
  6010414008:	14000025 	b	601041409c <_vsnprintf+0x1170>
            } else {
#endif
                idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)((uintptr_t)va_arg(va, void*)), false, 16U, precision, width, flags);
  601041400c:	b9401a61 	ldr	w1, [x19, #24]
  6010414010:	f9400260 	ldr	x0, [x19]
  6010414014:	7100003f 	cmp	w1, #0x0
  6010414018:	540000ab 	b.lt	601041402c <_vsnprintf+0x1100>  // b.tstop
  601041401c:	91003c01 	add	x1, x0, #0xf
  6010414020:	927df021 	and	x1, x1, #0xfffffffffffffff8
  6010414024:	f9000261 	str	x1, [x19]
  6010414028:	1400000d 	b	601041405c <_vsnprintf+0x1130>
  601041402c:	11002022 	add	w2, w1, #0x8
  6010414030:	b9001a62 	str	w2, [x19, #24]
  6010414034:	b9401a62 	ldr	w2, [x19, #24]
  6010414038:	7100005f 	cmp	w2, #0x0
  601041403c:	540000ad 	b.le	6010414050 <_vsnprintf+0x1124>
  6010414040:	91003c01 	add	x1, x0, #0xf
  6010414044:	927df021 	and	x1, x1, #0xfffffffffffffff8
  6010414048:	f9000261 	str	x1, [x19]
  601041404c:	14000004 	b	601041405c <_vsnprintf+0x1130>
  6010414050:	f9400662 	ldr	x2, [x19, #8]
  6010414054:	93407c20 	sxtw	x0, w1
  6010414058:	8b000040 	add	x0, x2, x0
  601041405c:	f9400000 	ldr	x0, [x0]
  6010414060:	aa0003e1 	mov	x1, x0
  6010414064:	b9409fe0 	ldr	w0, [sp, #156]
  6010414068:	b9000be0 	str	w0, [sp, #8]
  601041406c:	b9409be0 	ldr	w0, [sp, #152]
  6010414070:	b90003e0 	str	w0, [sp]
  6010414074:	b94097e7 	ldr	w7, [sp, #148]
  6010414078:	d2800206 	mov	x6, #0x10                  	// #16
  601041407c:	52800005 	mov	w5, #0x0                   	// #0
  6010414080:	aa0103e4 	mov	x4, x1
  6010414084:	f9401fe3 	ldr	x3, [sp, #56]
  6010414088:	f94047e2 	ldr	x2, [sp, #136]
  601041408c:	f94023e1 	ldr	x1, [sp, #64]
  6010414090:	f94027e0 	ldr	x0, [sp, #72]
  6010414094:	97fff833 	bl	6010412160 <_ntoa_long>
  6010414098:	f90047e0 	str	x0, [sp, #136]
#if defined(PRINTF_SUPPORT_LONG_LONG)
            }
#endif
            format++;
  601041409c:	f9401be0 	ldr	x0, [sp, #48]
  60104140a0:	91000400 	add	x0, x0, #0x1
  60104140a4:	f9001be0 	str	x0, [sp, #48]
            break;
  60104140a8:	1400001d 	b	601041411c <_vsnprintf+0x11f0>
        }

        case '%':
            out('%', buffer, idx++, maxlen);
  60104140ac:	f94047e0 	ldr	x0, [sp, #136]
  60104140b0:	91000401 	add	x1, x0, #0x1
  60104140b4:	f90047e1 	str	x1, [sp, #136]
  60104140b8:	f94027e4 	ldr	x4, [sp, #72]
  60104140bc:	f9401fe3 	ldr	x3, [sp, #56]
  60104140c0:	aa0003e2 	mov	x2, x0
  60104140c4:	f94023e1 	ldr	x1, [sp, #64]
  60104140c8:	528004a0 	mov	w0, #0x25                  	// #37
  60104140cc:	d63f0080 	blr	x4
            format++;
  60104140d0:	f9401be0 	ldr	x0, [sp, #48]
  60104140d4:	91000400 	add	x0, x0, #0x1
  60104140d8:	f9001be0 	str	x0, [sp, #48]
            break;
  60104140dc:	14000010 	b	601041411c <_vsnprintf+0x11f0>

        default:
            out(*format, buffer, idx++, maxlen);
  60104140e0:	f9401be0 	ldr	x0, [sp, #48]
  60104140e4:	39400005 	ldrb	w5, [x0]
  60104140e8:	f94047e0 	ldr	x0, [sp, #136]
  60104140ec:	91000401 	add	x1, x0, #0x1
  60104140f0:	f90047e1 	str	x1, [sp, #136]
  60104140f4:	f94027e4 	ldr	x4, [sp, #72]
  60104140f8:	f9401fe3 	ldr	x3, [sp, #56]
  60104140fc:	aa0003e2 	mov	x2, x0
  6010414100:	f94023e1 	ldr	x1, [sp, #64]
  6010414104:	2a0503e0 	mov	w0, w5
  6010414108:	d63f0080 	blr	x4
            format++;
  601041410c:	f9401be0 	ldr	x0, [sp, #48]
  6010414110:	91000400 	add	x0, x0, #0x1
  6010414114:	f9001be0 	str	x0, [sp, #48]
            break;
  6010414118:	d503201f 	nop
    while (*format) {
  601041411c:	f9401be0 	ldr	x0, [sp, #48]
  6010414120:	39400000 	ldrb	w0, [x0]
  6010414124:	7100001f 	cmp	w0, #0x0
  6010414128:	54ff7241 	b.ne	6010412f70 <_vsnprintf+0x44>  // b.any
        }
    }

    // termination
    out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);
  601041412c:	f94047e1 	ldr	x1, [sp, #136]
  6010414130:	f9401fe0 	ldr	x0, [sp, #56]
  6010414134:	eb00003f 	cmp	x1, x0
  6010414138:	54000083 	b.cc	6010414148 <_vsnprintf+0x121c>  // b.lo, b.ul, b.last
  601041413c:	f9401fe0 	ldr	x0, [sp, #56]
  6010414140:	d1000400 	sub	x0, x0, #0x1
  6010414144:	14000002 	b	601041414c <_vsnprintf+0x1220>
  6010414148:	f94047e0 	ldr	x0, [sp, #136]
  601041414c:	f94027e4 	ldr	x4, [sp, #72]
  6010414150:	f9401fe3 	ldr	x3, [sp, #56]
  6010414154:	aa0003e2 	mov	x2, x0
  6010414158:	f94023e1 	ldr	x1, [sp, #64]
  601041415c:	52800000 	mov	w0, #0x0                   	// #0
  6010414160:	d63f0080 	blr	x4

    // return written chars without terminating \0
    return (int)idx;
  6010414164:	f94047e0 	ldr	x0, [sp, #136]
}
  6010414168:	f94013f3 	ldr	x19, [sp, #32]
  601041416c:	a9417bfd 	ldp	x29, x30, [sp, #16]
  6010414170:	910283ff 	add	sp, sp, #0xa0
  6010414174:	d65f03c0 	ret

0000006010414178 <printf_>:

///////////////////////////////////////////////////////////////////////////////

int printf_(const char* format, ...)
{
  6010414178:	a9ad7bfd 	stp	x29, x30, [sp, #-304]!
  601041417c:	910003fd 	mov	x29, sp
  6010414180:	f9001fe0 	str	x0, [sp, #56]
  6010414184:	f9007fe1 	str	x1, [sp, #248]
  6010414188:	f90083e2 	str	x2, [sp, #256]
  601041418c:	f90087e3 	str	x3, [sp, #264]
  6010414190:	f9008be4 	str	x4, [sp, #272]
  6010414194:	f9008fe5 	str	x5, [sp, #280]
  6010414198:	f90093e6 	str	x6, [sp, #288]
  601041419c:	f90097e7 	str	x7, [sp, #296]
  60104141a0:	3d801fe0 	str	q0, [sp, #112]
  60104141a4:	3d8023e1 	str	q1, [sp, #128]
  60104141a8:	3d8027e2 	str	q2, [sp, #144]
  60104141ac:	3d802be3 	str	q3, [sp, #160]
  60104141b0:	3d802fe4 	str	q4, [sp, #176]
  60104141b4:	3d8033e5 	str	q5, [sp, #192]
  60104141b8:	3d8037e6 	str	q6, [sp, #208]
  60104141bc:	3d803be7 	str	q7, [sp, #224]
    va_list va;
    va_start(va, format);
  60104141c0:	9104c3e0 	add	x0, sp, #0x130
  60104141c4:	f90027e0 	str	x0, [sp, #72]
  60104141c8:	9104c3e0 	add	x0, sp, #0x130
  60104141cc:	f9002be0 	str	x0, [sp, #80]
  60104141d0:	9103c3e0 	add	x0, sp, #0xf0
  60104141d4:	f9002fe0 	str	x0, [sp, #88]
  60104141d8:	128006e0 	mov	w0, #0xffffffc8            	// #-56
  60104141dc:	b90063e0 	str	w0, [sp, #96]
  60104141e0:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  60104141e4:	b90067e0 	str	w0, [sp, #100]
    char buffer[1];
    const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
  60104141e8:	910043e2 	add	x2, sp, #0x10
  60104141ec:	910123e3 	add	x3, sp, #0x48
  60104141f0:	a9400460 	ldp	x0, x1, [x3]
  60104141f4:	a9000440 	stp	x0, x1, [x2]
  60104141f8:	a9410460 	ldp	x0, x1, [x3, #16]
  60104141fc:	a9010440 	stp	x0, x1, [x2, #16]
  6010414200:	910043e1 	add	x1, sp, #0x10
  6010414204:	910103e0 	add	x0, sp, #0x40
  6010414208:	aa0103e4 	mov	x4, x1
  601041420c:	f9401fe3 	ldr	x3, [sp, #56]
  6010414210:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
  6010414214:	aa0003e1 	mov	x1, x0
  6010414218:	b0ffffe0 	adrp	x0, 6010411000 <el1sync+0x18>
  601041421c:	912d6000 	add	x0, x0, #0xb58
  6010414220:	97fffb43 	bl	6010412f2c <_vsnprintf>
  6010414224:	b9006fe0 	str	w0, [sp, #108]
    va_end(va);
    return ret;
  6010414228:	b9406fe0 	ldr	w0, [sp, #108]
}
  601041422c:	a8d37bfd 	ldp	x29, x30, [sp], #304
  6010414230:	d65f03c0 	ret

0000006010414234 <sprintf_>:

int sprintf_(char* buffer, const char* format, ...)
{
  6010414234:	a9ae7bfd 	stp	x29, x30, [sp, #-288]!
  6010414238:	910003fd 	mov	x29, sp
  601041423c:	f9001fe0 	str	x0, [sp, #56]
  6010414240:	f9001be1 	str	x1, [sp, #48]
  6010414244:	f9007be2 	str	x2, [sp, #240]
  6010414248:	f9007fe3 	str	x3, [sp, #248]
  601041424c:	f90083e4 	str	x4, [sp, #256]
  6010414250:	f90087e5 	str	x5, [sp, #264]
  6010414254:	f9008be6 	str	x6, [sp, #272]
  6010414258:	f9008fe7 	str	x7, [sp, #280]
  601041425c:	3d801fe0 	str	q0, [sp, #112]
  6010414260:	3d8023e1 	str	q1, [sp, #128]
  6010414264:	3d8027e2 	str	q2, [sp, #144]
  6010414268:	3d802be3 	str	q3, [sp, #160]
  601041426c:	3d802fe4 	str	q4, [sp, #176]
  6010414270:	3d8033e5 	str	q5, [sp, #192]
  6010414274:	3d8037e6 	str	q6, [sp, #208]
  6010414278:	3d803be7 	str	q7, [sp, #224]
    va_list va;
    va_start(va, format);
  601041427c:	910483e0 	add	x0, sp, #0x120
  6010414280:	f90027e0 	str	x0, [sp, #72]
  6010414284:	910483e0 	add	x0, sp, #0x120
  6010414288:	f9002be0 	str	x0, [sp, #80]
  601041428c:	9103c3e0 	add	x0, sp, #0xf0
  6010414290:	f9002fe0 	str	x0, [sp, #88]
  6010414294:	128005e0 	mov	w0, #0xffffffd0            	// #-48
  6010414298:	b90063e0 	str	w0, [sp, #96]
  601041429c:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  60104142a0:	b90067e0 	str	w0, [sp, #100]
    const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
  60104142a4:	910043e2 	add	x2, sp, #0x10
  60104142a8:	910123e3 	add	x3, sp, #0x48
  60104142ac:	a9400460 	ldp	x0, x1, [x3]
  60104142b0:	a9000440 	stp	x0, x1, [x2]
  60104142b4:	a9410460 	ldp	x0, x1, [x3, #16]
  60104142b8:	a9010440 	stp	x0, x1, [x2, #16]
  60104142bc:	910043e0 	add	x0, sp, #0x10
  60104142c0:	aa0003e4 	mov	x4, x0
  60104142c4:	f9401be3 	ldr	x3, [sp, #48]
  60104142c8:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
  60104142cc:	f9401fe1 	ldr	x1, [sp, #56]
  60104142d0:	b0ffffe0 	adrp	x0, 6010411000 <el1sync+0x18>
  60104142d4:	912bd000 	add	x0, x0, #0xaf4
  60104142d8:	97fffb15 	bl	6010412f2c <_vsnprintf>
  60104142dc:	b9006fe0 	str	w0, [sp, #108]
    va_end(va);
    return ret;
  60104142e0:	b9406fe0 	ldr	w0, [sp, #108]
}
  60104142e4:	a8d27bfd 	ldp	x29, x30, [sp], #288
  60104142e8:	d65f03c0 	ret

00000060104142ec <snprintf_>:

int snprintf_(char* buffer, size_t count, const char* format, ...)
{
  60104142ec:	a9ad7bfd 	stp	x29, x30, [sp, #-304]!
  60104142f0:	910003fd 	mov	x29, sp
  60104142f4:	f90027e0 	str	x0, [sp, #72]
  60104142f8:	f90023e1 	str	x1, [sp, #64]
  60104142fc:	f9001fe2 	str	x2, [sp, #56]
  6010414300:	f90087e3 	str	x3, [sp, #264]
  6010414304:	f9008be4 	str	x4, [sp, #272]
  6010414308:	f9008fe5 	str	x5, [sp, #280]
  601041430c:	f90093e6 	str	x6, [sp, #288]
  6010414310:	f90097e7 	str	x7, [sp, #296]
  6010414314:	3d8023e0 	str	q0, [sp, #128]
  6010414318:	3d8027e1 	str	q1, [sp, #144]
  601041431c:	3d802be2 	str	q2, [sp, #160]
  6010414320:	3d802fe3 	str	q3, [sp, #176]
  6010414324:	3d8033e4 	str	q4, [sp, #192]
  6010414328:	3d8037e5 	str	q5, [sp, #208]
  601041432c:	3d803be6 	str	q6, [sp, #224]
  6010414330:	3d803fe7 	str	q7, [sp, #240]
    va_list va;
    va_start(va, format);
  6010414334:	9104c3e0 	add	x0, sp, #0x130
  6010414338:	f9002fe0 	str	x0, [sp, #88]
  601041433c:	9104c3e0 	add	x0, sp, #0x130
  6010414340:	f90033e0 	str	x0, [sp, #96]
  6010414344:	910403e0 	add	x0, sp, #0x100
  6010414348:	f90037e0 	str	x0, [sp, #104]
  601041434c:	128004e0 	mov	w0, #0xffffffd8            	// #-40
  6010414350:	b90073e0 	str	w0, [sp, #112]
  6010414354:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  6010414358:	b90077e0 	str	w0, [sp, #116]
    const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
  601041435c:	910043e2 	add	x2, sp, #0x10
  6010414360:	910163e3 	add	x3, sp, #0x58
  6010414364:	a9400460 	ldp	x0, x1, [x3]
  6010414368:	a9000440 	stp	x0, x1, [x2]
  601041436c:	a9410460 	ldp	x0, x1, [x3, #16]
  6010414370:	a9010440 	stp	x0, x1, [x2, #16]
  6010414374:	910043e0 	add	x0, sp, #0x10
  6010414378:	aa0003e4 	mov	x4, x0
  601041437c:	f9401fe3 	ldr	x3, [sp, #56]
  6010414380:	f94023e2 	ldr	x2, [sp, #64]
  6010414384:	f94027e1 	ldr	x1, [sp, #72]
  6010414388:	b0ffffe0 	adrp	x0, 6010411000 <el1sync+0x18>
  601041438c:	912bd000 	add	x0, x0, #0xaf4
  6010414390:	97fffae7 	bl	6010412f2c <_vsnprintf>
  6010414394:	b9007fe0 	str	w0, [sp, #124]
    va_end(va);
    return ret;
  6010414398:	b9407fe0 	ldr	w0, [sp, #124]
}
  601041439c:	a8d37bfd 	ldp	x29, x30, [sp], #304
  60104143a0:	d65f03c0 	ret

00000060104143a4 <vprintf_>:

int vprintf_(const char* format, va_list va)
{
  60104143a4:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  60104143a8:	910003fd 	mov	x29, sp
  60104143ac:	f9000bf3 	str	x19, [sp, #16]
  60104143b0:	f90027e0 	str	x0, [sp, #72]
  60104143b4:	aa0103f3 	mov	x19, x1
    char buffer[1];
    return _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
  60104143b8:	910083e2 	add	x2, sp, #0x20
  60104143bc:	aa1303e3 	mov	x3, x19
  60104143c0:	a9400460 	ldp	x0, x1, [x3]
  60104143c4:	a9000440 	stp	x0, x1, [x2]
  60104143c8:	a9410460 	ldp	x0, x1, [x3, #16]
  60104143cc:	a9010440 	stp	x0, x1, [x2, #16]
  60104143d0:	910083e1 	add	x1, sp, #0x20
  60104143d4:	910163e0 	add	x0, sp, #0x58
  60104143d8:	aa0103e4 	mov	x4, x1
  60104143dc:	f94027e3 	ldr	x3, [sp, #72]
  60104143e0:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
  60104143e4:	aa0003e1 	mov	x1, x0
  60104143e8:	b0ffffe0 	adrp	x0, 6010411000 <el1sync+0x18>
  60104143ec:	912d6000 	add	x0, x0, #0xb58
  60104143f0:	97fffacf 	bl	6010412f2c <_vsnprintf>
}
  60104143f4:	f9400bf3 	ldr	x19, [sp, #16]
  60104143f8:	a8c67bfd 	ldp	x29, x30, [sp], #96
  60104143fc:	d65f03c0 	ret

0000006010414400 <vsnprintf_>:

int vsnprintf_(char* buffer, size_t count, const char* format, va_list va)
{
  6010414400:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  6010414404:	910003fd 	mov	x29, sp
  6010414408:	f9000bf3 	str	x19, [sp, #16]
  601041440c:	f9002fe0 	str	x0, [sp, #88]
  6010414410:	f9002be1 	str	x1, [sp, #80]
  6010414414:	f90027e2 	str	x2, [sp, #72]
  6010414418:	aa0303f3 	mov	x19, x3
    return _vsnprintf(_out_buffer, buffer, count, format, va);
  601041441c:	910083e2 	add	x2, sp, #0x20
  6010414420:	aa1303e3 	mov	x3, x19
  6010414424:	a9400460 	ldp	x0, x1, [x3]
  6010414428:	a9000440 	stp	x0, x1, [x2]
  601041442c:	a9410460 	ldp	x0, x1, [x3, #16]
  6010414430:	a9010440 	stp	x0, x1, [x2, #16]
  6010414434:	910083e0 	add	x0, sp, #0x20
  6010414438:	aa0003e4 	mov	x4, x0
  601041443c:	f94027e3 	ldr	x3, [sp, #72]
  6010414440:	f9402be2 	ldr	x2, [sp, #80]
  6010414444:	f9402fe1 	ldr	x1, [sp, #88]
  6010414448:	b0ffffe0 	adrp	x0, 6010411000 <el1sync+0x18>
  601041444c:	912bd000 	add	x0, x0, #0xaf4
  6010414450:	97fffab7 	bl	6010412f2c <_vsnprintf>
}
  6010414454:	f9400bf3 	ldr	x19, [sp, #16]
  6010414458:	a8c67bfd 	ldp	x29, x30, [sp], #96
  601041445c:	d65f03c0 	ret

0000006010414460 <fctprintf>:

int fctprintf(void (*out)(char character, void* arg), void* arg, const char* format, ...)
{
  6010414460:	a9ac7bfd 	stp	x29, x30, [sp, #-320]!
  6010414464:	910003fd 	mov	x29, sp
  6010414468:	f90027e0 	str	x0, [sp, #72]
  601041446c:	f90023e1 	str	x1, [sp, #64]
  6010414470:	f9001fe2 	str	x2, [sp, #56]
  6010414474:	f9008fe3 	str	x3, [sp, #280]
  6010414478:	f90093e4 	str	x4, [sp, #288]
  601041447c:	f90097e5 	str	x5, [sp, #296]
  6010414480:	f9009be6 	str	x6, [sp, #304]
  6010414484:	f9009fe7 	str	x7, [sp, #312]
  6010414488:	3d8027e0 	str	q0, [sp, #144]
  601041448c:	3d802be1 	str	q1, [sp, #160]
  6010414490:	3d802fe2 	str	q2, [sp, #176]
  6010414494:	3d8033e3 	str	q3, [sp, #192]
  6010414498:	3d8037e4 	str	q4, [sp, #208]
  601041449c:	3d803be5 	str	q5, [sp, #224]
  60104144a0:	3d803fe6 	str	q6, [sp, #240]
  60104144a4:	3d8043e7 	str	q7, [sp, #256]
    va_list va;
    va_start(va, format);
  60104144a8:	910503e0 	add	x0, sp, #0x140
  60104144ac:	f90037e0 	str	x0, [sp, #104]
  60104144b0:	910503e0 	add	x0, sp, #0x140
  60104144b4:	f9003be0 	str	x0, [sp, #112]
  60104144b8:	910443e0 	add	x0, sp, #0x110
  60104144bc:	f9003fe0 	str	x0, [sp, #120]
  60104144c0:	128004e0 	mov	w0, #0xffffffd8            	// #-40
  60104144c4:	b90083e0 	str	w0, [sp, #128]
  60104144c8:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  60104144cc:	b90087e0 	str	w0, [sp, #132]
    const out_fct_wrap_type out_fct_wrap = { out, arg };
  60104144d0:	f94027e0 	ldr	x0, [sp, #72]
  60104144d4:	f9002fe0 	str	x0, [sp, #88]
  60104144d8:	f94023e0 	ldr	x0, [sp, #64]
  60104144dc:	f90033e0 	str	x0, [sp, #96]
    const int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);
  60104144e0:	910043e2 	add	x2, sp, #0x10
  60104144e4:	9101a3e3 	add	x3, sp, #0x68
  60104144e8:	a9400460 	ldp	x0, x1, [x3]
  60104144ec:	a9000440 	stp	x0, x1, [x2]
  60104144f0:	a9410460 	ldp	x0, x1, [x3, #16]
  60104144f4:	a9010440 	stp	x0, x1, [x2, #16]
  60104144f8:	910043e1 	add	x1, sp, #0x10
  60104144fc:	910163e0 	add	x0, sp, #0x58
  6010414500:	aa0103e4 	mov	x4, x1
  6010414504:	f9401fe3 	ldr	x3, [sp, #56]
  6010414508:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
  601041450c:	aa0003e1 	mov	x1, x0
  6010414510:	b0ffffe0 	adrp	x0, 6010411000 <el1sync+0x18>
  6010414514:	912e7000 	add	x0, x0, #0xb9c
  6010414518:	97fffa85 	bl	6010412f2c <_vsnprintf>
  601041451c:	b9008fe0 	str	w0, [sp, #140]
    va_end(va);
    return ret;
  6010414520:	b9408fe0 	ldr	w0, [sp, #140]
  6010414524:	a8d47bfd 	ldp	x29, x30, [sp], #320
  6010414528:	d65f03c0 	ret

000000601041452c <InvalidateL1Dcache>:
*************************************************/

#include "l1_cache.h"

void InvalidateL1Dcache(uintptr_t start, uintptr_t end)
{
  601041452c:	d10103ff 	sub	sp, sp, #0x40
  6010414530:	f90007e0 	str	x0, [sp, #8]
  6010414534:	f90003e1 	str	x1, [sp]
    uint64_t length = end - start;
  6010414538:	f94003e1 	ldr	x1, [sp]
  601041453c:	f94007e0 	ldr	x0, [sp, #8]
  6010414540:	cb000020 	sub	x0, x1, x0
  6010414544:	f9001be0 	str	x0, [sp, #48]
    uint64_t addr = start;
  6010414548:	f94007e0 	ldr	x0, [sp, #8]
  601041454c:	f9001fe0 	str	x0, [sp, #56]
    uint64_t ccsidr_el1;
    uint64_t line_size;
    uint64_t va;
    // get the cache line size

    __asm__ __volatile__("mrs %0, ccsidr_el1" : "=r"(ccsidr_el1));
  6010414550:	d5390000 	mrs	x0, ccsidr_el1
  6010414554:	f90017e0 	str	x0, [sp, #40]
    line_size = 1 << ((ccsidr_el1 & 0x7) + 4);
  6010414558:	f94017e0 	ldr	x0, [sp, #40]
  601041455c:	12000800 	and	w0, w0, #0x7
  6010414560:	11001000 	add	w0, w0, #0x4
  6010414564:	52800021 	mov	w1, #0x1                   	// #1
  6010414568:	1ac02020 	lsl	w0, w1, w0
  601041456c:	93407c00 	sxtw	x0, w0
  6010414570:	f90013e0 	str	x0, [sp, #32]

    // align the address with line
    const uintptr_t end_addr = (const uintptr_t)((uint64_t)addr + length);
  6010414574:	f9401fe1 	ldr	x1, [sp, #56]
  6010414578:	f9401be0 	ldr	x0, [sp, #48]
  601041457c:	8b000020 	add	x0, x1, x0
  6010414580:	f9000fe0 	str	x0, [sp, #24]

    do {
        va = (uint64_t)((uint64_t)addr & (~(line_size - 1)));
  6010414584:	f94013e0 	ldr	x0, [sp, #32]
  6010414588:	cb0003e0 	neg	x0, x0
  601041458c:	f9401fe1 	ldr	x1, [sp, #56]
  6010414590:	8a000020 	and	x0, x1, x0
  6010414594:	f9000be0 	str	x0, [sp, #16]

        // Invalidate data cache line to PoC (Point of Coherence) by va.
        __asm__ __volatile__("dc ivac, %0 " : : "r"(va));
  6010414598:	f9400be0 	ldr	x0, [sp, #16]
  601041459c:	d5087620 	dc	ivac, x0

        // increment addres to next line and decrement lenght
        addr = (uintptr_t)((uint64_t)addr + line_size);
  60104145a0:	f9401fe1 	ldr	x1, [sp, #56]
  60104145a4:	f94013e0 	ldr	x0, [sp, #32]
  60104145a8:	8b000020 	add	x0, x1, x0
  60104145ac:	f9001fe0 	str	x0, [sp, #56]
    } while (addr < end_addr);
  60104145b0:	f9401fe1 	ldr	x1, [sp, #56]
  60104145b4:	f9400fe0 	ldr	x0, [sp, #24]
  60104145b8:	eb00003f 	cmp	x1, x0
  60104145bc:	54fffe43 	b.cc	6010414584 <InvalidateL1Dcache+0x58>  // b.lo, b.ul, b.last

    // All Cache, Branch predictor and TLB maintenance operations before followed instruction complete
    DSB();
  60104145c0:	d5033b9f 	dsb	ish
}
  60104145c4:	d503201f 	nop
  60104145c8:	910103ff 	add	sp, sp, #0x40
  60104145cc:	d65f03c0 	ret

00000060104145d0 <InvalidateL1DcacheAll>:

void InvalidateL1DcacheAll(void)
{
  60104145d0:	d10083ff 	sub	sp, sp, #0x20
    uint64_t ccsidr_el1; // Cache Size ID
    int num_sets; // number of sets
    int num_ways; // number of ways
    uint32_t wayset; // wayset parameter

    __asm__ __volatile__("mrs %0, ccsidr_el1" : "=r"(ccsidr_el1)); // Read Cache Size ID
  60104145d4:	d5390000 	mrs	x0, ccsidr_el1
  60104145d8:	f9000be0 	str	x0, [sp, #16]

    // Fill number of sets  and number of ways from ccsidr_el1 register
    num_sets = ((ccsidr_el1 >> 32) & 0x7FFF) + 1;
  60104145dc:	f9400be0 	ldr	x0, [sp, #16]
  60104145e0:	d360fc00 	lsr	x0, x0, #32
  60104145e4:	12003800 	and	w0, w0, #0x7fff
  60104145e8:	11000400 	add	w0, w0, #0x1
  60104145ec:	b9000fe0 	str	w0, [sp, #12]
    num_ways = ((ccsidr_el1 >> 0) & 0x7FFF) + 1;
  60104145f0:	f9400be0 	ldr	x0, [sp, #16]
  60104145f4:	12003800 	and	w0, w0, #0x7fff
  60104145f8:	11000400 	add	w0, w0, #0x1
  60104145fc:	b9000be0 	str	w0, [sp, #8]

    // Invalidation all lines (all Sets in all ways)
    for (int way = 0; way < num_ways; way++) {
  6010414600:	b9001fff 	str	wzr, [sp, #28]
  6010414604:	14000015 	b	6010414658 <InvalidateL1DcacheAll+0x88>
        for (int set = 0; set < num_sets; set++) {
  6010414608:	b9001bff 	str	wzr, [sp, #24]
  601041460c:	1400000c 	b	601041463c <InvalidateL1DcacheAll+0x6c>
            wayset = (way << 30) | (set << 5);
  6010414610:	b9401fe0 	ldr	w0, [sp, #28]
  6010414614:	53020401 	lsl	w1, w0, #30
  6010414618:	b9401be0 	ldr	w0, [sp, #24]
  601041461c:	531b6800 	lsl	w0, w0, #5
  6010414620:	2a000020 	orr	w0, w1, w0
  6010414624:	b90007e0 	str	w0, [sp, #4]
            __asm__ __volatile__("dc isw, %0" : : "r"(wayset));
  6010414628:	b94007e0 	ldr	w0, [sp, #4]
  601041462c:	d5087640 	dc	isw, x0
        for (int set = 0; set < num_sets; set++) {
  6010414630:	b9401be0 	ldr	w0, [sp, #24]
  6010414634:	11000400 	add	w0, w0, #0x1
  6010414638:	b9001be0 	str	w0, [sp, #24]
  601041463c:	b9401be1 	ldr	w1, [sp, #24]
  6010414640:	b9400fe0 	ldr	w0, [sp, #12]
  6010414644:	6b00003f 	cmp	w1, w0
  6010414648:	54fffe4b 	b.lt	6010414610 <InvalidateL1DcacheAll+0x40>  // b.tstop
    for (int way = 0; way < num_ways; way++) {
  601041464c:	b9401fe0 	ldr	w0, [sp, #28]
  6010414650:	11000400 	add	w0, w0, #0x1
  6010414654:	b9001fe0 	str	w0, [sp, #28]
  6010414658:	b9401fe1 	ldr	w1, [sp, #28]
  601041465c:	b9400be0 	ldr	w0, [sp, #8]
  6010414660:	6b00003f 	cmp	w1, w0
  6010414664:	54fffd2b 	b.lt	6010414608 <InvalidateL1DcacheAll+0x38>  // b.tstop
        }
    }

    // All Cache, Branch predictor and TLB maintenance operations before followed instruction complete
    DSB();
  6010414668:	d5033b9f 	dsb	ish
}
  601041466c:	d503201f 	nop
  6010414670:	910083ff 	add	sp, sp, #0x20
  6010414674:	d65f03c0 	ret

0000006010414678 <CleanL1Dcache>:

void CleanL1Dcache(uintptr_t start, uintptr_t end)
{
  6010414678:	d10103ff 	sub	sp, sp, #0x40
  601041467c:	f90007e0 	str	x0, [sp, #8]
  6010414680:	f90003e1 	str	x1, [sp]
    void* addr = (void*)start;
  6010414684:	f94007e0 	ldr	x0, [sp, #8]
  6010414688:	f9001fe0 	str	x0, [sp, #56]
    uintptr_t length = end - start;
  601041468c:	f94003e1 	ldr	x1, [sp]
  6010414690:	f94007e0 	ldr	x0, [sp, #8]
  6010414694:	cb000020 	sub	x0, x1, x0
  6010414698:	f9001be0 	str	x0, [sp, #48]
    const void* end_addr = (const void*)((uint64_t)addr + length);
  601041469c:	f9401fe1 	ldr	x1, [sp, #56]
  60104146a0:	f9401be0 	ldr	x0, [sp, #48]
  60104146a4:	8b000020 	add	x0, x1, x0
  60104146a8:	f90017e0 	str	x0, [sp, #40]
    uint64_t ccsidr_el1;
    uint64_t line_size;
    uint64_t va;

    // get the cache line size
    __asm__ __volatile__("mrs %0, ccsidr_el1" : "=r"(ccsidr_el1));
  60104146ac:	d5390000 	mrs	x0, ccsidr_el1
  60104146b0:	f90013e0 	str	x0, [sp, #32]
    line_size = 1 << ((ccsidr_el1 & 0x7) + 4);
  60104146b4:	f94013e0 	ldr	x0, [sp, #32]
  60104146b8:	12000800 	and	w0, w0, #0x7
  60104146bc:	11001000 	add	w0, w0, #0x4
  60104146c0:	52800021 	mov	w1, #0x1                   	// #1
  60104146c4:	1ac02020 	lsl	w0, w1, w0
  60104146c8:	93407c00 	sxtw	x0, w0
  60104146cc:	f9000fe0 	str	x0, [sp, #24]

    do {
        va = (uint64_t)addr & (~(line_size - 1));
  60104146d0:	f9400fe0 	ldr	x0, [sp, #24]
  60104146d4:	cb0003e1 	neg	x1, x0
  60104146d8:	f9401fe0 	ldr	x0, [sp, #56]
  60104146dc:	8a000020 	and	x0, x1, x0
  60104146e0:	f9000be0 	str	x0, [sp, #16]
        // Clean data cache line to PoC (Point of Coherence) by va.
        __asm__ __volatile__("dc cvac, %0" : : "r"(va));
  60104146e4:	f9400be0 	ldr	x0, [sp, #16]
  60104146e8:	d50b7a20 	dc	cvac, x0

        // increment addres to next line and decrement lenght
        addr = (void*)((uint64_t)addr + line_size);
  60104146ec:	f9401fe1 	ldr	x1, [sp, #56]
  60104146f0:	f9400fe0 	ldr	x0, [sp, #24]
  60104146f4:	8b000020 	add	x0, x1, x0
  60104146f8:	f9001fe0 	str	x0, [sp, #56]
    } while (addr < end_addr);
  60104146fc:	f9401fe1 	ldr	x1, [sp, #56]
  6010414700:	f94017e0 	ldr	x0, [sp, #40]
  6010414704:	eb00003f 	cmp	x1, x0
  6010414708:	54fffe43 	b.cc	60104146d0 <CleanL1Dcache+0x58>  // b.lo, b.ul, b.last

    // All Cache, Branch predictor and TLB maintenance operations before followed instruction complete
    DSB();
  601041470c:	d5033b9f 	dsb	ish
}
  6010414710:	d503201f 	nop
  6010414714:	910103ff 	add	sp, sp, #0x40
  6010414718:	d65f03c0 	ret

000000601041471c <CleanL1DcacheAll>:

void CleanL1DcacheAll(void)
{
  601041471c:	d10083ff 	sub	sp, sp, #0x20
    uint64_t ccsidr_el1; // Cache Size ID
    int num_sets; // number of sets
    int num_ways; // number of ways
    uint32_t wayset; // wayset parameter

    __asm__ __volatile__("mrs %0, ccsidr_el1" : "=r"(ccsidr_el1)); // Read Cache Size ID
  6010414720:	d5390000 	mrs	x0, ccsidr_el1
  6010414724:	f9000be0 	str	x0, [sp, #16]

    // Fill number of sets  and number of ways from ccsidr_el1 register  This walues are decremented by 1
    num_sets = ((ccsidr_el1 >> 32) & 0x7FFF) + 1;
  6010414728:	f9400be0 	ldr	x0, [sp, #16]
  601041472c:	d360fc00 	lsr	x0, x0, #32
  6010414730:	12003800 	and	w0, w0, #0x7fff
  6010414734:	11000400 	add	w0, w0, #0x1
  6010414738:	b9000fe0 	str	w0, [sp, #12]
    num_ways = ((ccsidr_el1 >> 0) & 0x7FFF) + 1;
  601041473c:	f9400be0 	ldr	x0, [sp, #16]
  6010414740:	12003800 	and	w0, w0, #0x7fff
  6010414744:	11000400 	add	w0, w0, #0x1
  6010414748:	b9000be0 	str	w0, [sp, #8]

    // clean all lines (all Sets in all ways)
    for (int way = 0; way < num_ways; way++) {
  601041474c:	b9001fff 	str	wzr, [sp, #28]
  6010414750:	14000015 	b	60104147a4 <CleanL1DcacheAll+0x88>
        for (int set = 0; set < num_sets; set++) {
  6010414754:	b9001bff 	str	wzr, [sp, #24]
  6010414758:	1400000c 	b	6010414788 <CleanL1DcacheAll+0x6c>
            wayset = (way << 30) | (set << 5);
  601041475c:	b9401fe0 	ldr	w0, [sp, #28]
  6010414760:	53020401 	lsl	w1, w0, #30
  6010414764:	b9401be0 	ldr	w0, [sp, #24]
  6010414768:	531b6800 	lsl	w0, w0, #5
  601041476c:	2a000020 	orr	w0, w1, w0
  6010414770:	b90007e0 	str	w0, [sp, #4]
            __asm__ __volatile__("dc csw, %0" : : "r"(wayset));
  6010414774:	b94007e0 	ldr	w0, [sp, #4]
  6010414778:	d5087a40 	dc	csw, x0
        for (int set = 0; set < num_sets; set++) {
  601041477c:	b9401be0 	ldr	w0, [sp, #24]
  6010414780:	11000400 	add	w0, w0, #0x1
  6010414784:	b9001be0 	str	w0, [sp, #24]
  6010414788:	b9401be1 	ldr	w1, [sp, #24]
  601041478c:	b9400fe0 	ldr	w0, [sp, #12]
  6010414790:	6b00003f 	cmp	w1, w0
  6010414794:	54fffe4b 	b.lt	601041475c <CleanL1DcacheAll+0x40>  // b.tstop
    for (int way = 0; way < num_ways; way++) {
  6010414798:	b9401fe0 	ldr	w0, [sp, #28]
  601041479c:	11000400 	add	w0, w0, #0x1
  60104147a0:	b9001fe0 	str	w0, [sp, #28]
  60104147a4:	b9401fe1 	ldr	w1, [sp, #28]
  60104147a8:	b9400be0 	ldr	w0, [sp, #8]
  60104147ac:	6b00003f 	cmp	w1, w0
  60104147b0:	54fffd2b 	b.lt	6010414754 <CleanL1DcacheAll+0x38>  // b.tstop
        }
    }

    // All Cache, Branch predictor and TLB maintenance operations before followed instruction complete
    DSB();
  60104147b4:	d5033b9f 	dsb	ish
}
  60104147b8:	d503201f 	nop
  60104147bc:	910083ff 	add	sp, sp, #0x20
  60104147c0:	d65f03c0 	ret

00000060104147c4 <FlushL1Dcache>:

void FlushL1Dcache(uintptr_t start, uintptr_t end)
{
  60104147c4:	d10103ff 	sub	sp, sp, #0x40
  60104147c8:	f90007e0 	str	x0, [sp, #8]
  60104147cc:	f90003e1 	str	x1, [sp]
    void* addr = (void*)start;
  60104147d0:	f94007e0 	ldr	x0, [sp, #8]
  60104147d4:	f9001fe0 	str	x0, [sp, #56]
    // size_t length=end-start;
    uint64_t va;
    uint64_t ccsidr_el1 = 0, line_size = 0;
  60104147d8:	f9001bff 	str	xzr, [sp, #48]
  60104147dc:	f90017ff 	str	xzr, [sp, #40]
    const void* end_addr = (const void*)((uint64_t)end);
  60104147e0:	f94003e0 	ldr	x0, [sp]
  60104147e4:	f90013e0 	str	x0, [sp, #32]

    // get the cache line size
    __asm__ __volatile__("mrs %0, ccsidr_el1" : "=r"(ccsidr_el1));
  60104147e8:	d5390000 	mrs	x0, ccsidr_el1
  60104147ec:	f9001be0 	str	x0, [sp, #48]
    line_size = 1 << ((ccsidr_el1 & 0x7) + 4);
  60104147f0:	f9401be0 	ldr	x0, [sp, #48]
  60104147f4:	12000800 	and	w0, w0, #0x7
  60104147f8:	11001000 	add	w0, w0, #0x4
  60104147fc:	52800021 	mov	w1, #0x1                   	// #1
  6010414800:	1ac02020 	lsl	w0, w1, w0
  6010414804:	93407c00 	sxtw	x0, w0
  6010414808:	f90017e0 	str	x0, [sp, #40]

    do {
        // Clean data cache line to PoC (Point of Coherence) by va.
        va = (uint64_t)((uint64_t)addr & (~(line_size - 1))); // addr & va_VIRTUAL_ADDRESS_MASK
  601041480c:	f94017e0 	ldr	x0, [sp, #40]
  6010414810:	cb0003e1 	neg	x1, x0
  6010414814:	f9401fe0 	ldr	x0, [sp, #56]
  6010414818:	8a000020 	and	x0, x1, x0
  601041481c:	f9000fe0 	str	x0, [sp, #24]
        __asm__ __volatile__("dc civac, %0" : : "r"(va));
  6010414820:	f9400fe0 	ldr	x0, [sp, #24]
  6010414824:	d50b7e20 	dc	civac, x0

        // increment addres to next line and decrement lenght
        addr = (void*)((uint64_t)addr + line_size);
  6010414828:	f9401fe1 	ldr	x1, [sp, #56]
  601041482c:	f94017e0 	ldr	x0, [sp, #40]
  6010414830:	8b000020 	add	x0, x1, x0
  6010414834:	f9001fe0 	str	x0, [sp, #56]
    } while (addr < end_addr);
  6010414838:	f9401fe1 	ldr	x1, [sp, #56]
  601041483c:	f94013e0 	ldr	x0, [sp, #32]
  6010414840:	eb00003f 	cmp	x1, x0
  6010414844:	54fffe43 	b.cc	601041480c <FlushL1Dcache+0x48>  // b.lo, b.ul, b.last

    // All Cache, Branch predictor and TLB maintenance operations before followed instruction complete
    DSB();
  6010414848:	d5033b9f 	dsb	ish
}
  601041484c:	d503201f 	nop
  6010414850:	910103ff 	add	sp, sp, #0x40
  6010414854:	d65f03c0 	ret

0000006010414858 <FlushL1DcacheAll>:

void FlushL1DcacheAll(void)
{
  6010414858:	d10083ff 	sub	sp, sp, #0x20
    uint64_t ccsidr_el1; // Cache Size ID
    int num_sets; // number of sets
    int num_ways; // number of ways
    uint32_t wayset; // wayset parameter

    __asm__ __volatile__("mrs %0, ccsidr_el1" : "=r"(ccsidr_el1)); // Read Cache Size ID
  601041485c:	d5390000 	mrs	x0, ccsidr_el1
  6010414860:	f9000be0 	str	x0, [sp, #16]

    // Fill number of sets  and number of ways from ccsidr_el1 register  This walues are decremented by 1
    num_sets = ((ccsidr_el1 >> 32) & 0x7FFF) + 1;
  6010414864:	f9400be0 	ldr	x0, [sp, #16]
  6010414868:	d360fc00 	lsr	x0, x0, #32
  601041486c:	12003800 	and	w0, w0, #0x7fff
  6010414870:	11000400 	add	w0, w0, #0x1
  6010414874:	b9000fe0 	str	w0, [sp, #12]
    num_ways = ((ccsidr_el1 >> 0) & 0x7FFF) + 1;
  6010414878:	f9400be0 	ldr	x0, [sp, #16]
  601041487c:	12003800 	and	w0, w0, #0x7fff
  6010414880:	11000400 	add	w0, w0, #0x1
  6010414884:	b9000be0 	str	w0, [sp, #8]

    // clean and invalidate all lines (all Sets in all ways)
    for (int way = 0; way < num_ways; way++) {
  6010414888:	b9001fff 	str	wzr, [sp, #28]
  601041488c:	14000015 	b	60104148e0 <FlushL1DcacheAll+0x88>
        for (int set = 0; set < num_sets; set++) {
  6010414890:	b9001bff 	str	wzr, [sp, #24]
  6010414894:	1400000c 	b	60104148c4 <FlushL1DcacheAll+0x6c>
            wayset = (way << 30) | (set << 5);
  6010414898:	b9401fe0 	ldr	w0, [sp, #28]
  601041489c:	53020401 	lsl	w1, w0, #30
  60104148a0:	b9401be0 	ldr	w0, [sp, #24]
  60104148a4:	531b6800 	lsl	w0, w0, #5
  60104148a8:	2a000020 	orr	w0, w1, w0
  60104148ac:	b90007e0 	str	w0, [sp, #4]
            __asm__ __volatile__("dc cisw, %0" : : "r"(wayset));
  60104148b0:	b94007e0 	ldr	w0, [sp, #4]
  60104148b4:	d5087e40 	dc	cisw, x0
        for (int set = 0; set < num_sets; set++) {
  60104148b8:	b9401be0 	ldr	w0, [sp, #24]
  60104148bc:	11000400 	add	w0, w0, #0x1
  60104148c0:	b9001be0 	str	w0, [sp, #24]
  60104148c4:	b9401be1 	ldr	w1, [sp, #24]
  60104148c8:	b9400fe0 	ldr	w0, [sp, #12]
  60104148cc:	6b00003f 	cmp	w1, w0
  60104148d0:	54fffe4b 	b.lt	6010414898 <FlushL1DcacheAll+0x40>  // b.tstop
    for (int way = 0; way < num_ways; way++) {
  60104148d4:	b9401fe0 	ldr	w0, [sp, #28]
  60104148d8:	11000400 	add	w0, w0, #0x1
  60104148dc:	b9001fe0 	str	w0, [sp, #28]
  60104148e0:	b9401fe1 	ldr	w1, [sp, #28]
  60104148e4:	b9400be0 	ldr	w0, [sp, #8]
  60104148e8:	6b00003f 	cmp	w1, w0
  60104148ec:	54fffd2b 	b.lt	6010414890 <FlushL1DcacheAll+0x38>  // b.tstop
        }
    }

    // All Cache, Branch predictor and TLB maintenance operations before followed instruction complete
    DSB();
  60104148f0:	d5033b9f 	dsb	ish
}
  60104148f4:	d503201f 	nop
  60104148f8:	910083ff 	add	sp, sp, #0x20
  60104148fc:	d65f03c0 	ret

0000006010414900 <InvalidateL1IcacheAll>:

void InvalidateL1IcacheAll()
{
    __asm__ __volatile__("ic iallu\n\t");
  6010414900:	d508751f 	ic	iallu
    // synchronize context on this processor
    ISB();
  6010414904:	d5033fdf 	isb
}
  6010414908:	d503201f 	nop
  601041490c:	d65f03c0 	ret

0000006010414910 <InvalidateL1Icache>:

void InvalidateL1Icache(uintptr_t start, uintptr_t end)
{
  6010414910:	d10103ff 	sub	sp, sp, #0x40
  6010414914:	f90007e0 	str	x0, [sp, #8]
  6010414918:	f90003e1 	str	x1, [sp]
    // uintptr_t length = end - start;
    uintptr_t addr = start;
  601041491c:	f94007e0 	ldr	x0, [sp, #8]
  6010414920:	f9001fe0 	str	x0, [sp, #56]
    uint64_t ccsidr_el1;
    uint64_t line_size;
    uint64_t va;
    const uintptr_t end_addr = (const uintptr_t)((uint64_t)end);
  6010414924:	f94003e0 	ldr	x0, [sp]
  6010414928:	f9001be0 	str	x0, [sp, #48]
    // get the cache line size
    __asm__ __volatile__("mrs %0, ccsidr_el1" : "=r"(ccsidr_el1));
  601041492c:	d5390000 	mrs	x0, ccsidr_el1
  6010414930:	f90017e0 	str	x0, [sp, #40]
    line_size = 1 << ((ccsidr_el1 & 0x7) + 4);
  6010414934:	f94017e0 	ldr	x0, [sp, #40]
  6010414938:	12000800 	and	w0, w0, #0x7
  601041493c:	11001000 	add	w0, w0, #0x4
  6010414940:	52800021 	mov	w1, #0x1                   	// #1
  6010414944:	1ac02020 	lsl	w0, w1, w0
  6010414948:	93407c00 	sxtw	x0, w0
  601041494c:	f90013e0 	str	x0, [sp, #32]

    do {
        va = (uint64_t)((uint64_t)addr & (~(line_size - 1)));
  6010414950:	f94013e0 	ldr	x0, [sp, #32]
  6010414954:	cb0003e0 	neg	x0, x0
  6010414958:	f9401fe1 	ldr	x1, [sp, #56]
  601041495c:	8a000020 	and	x0, x1, x0
  6010414960:	f9000fe0 	str	x0, [sp, #24]

        // Invalidate data cache line to PoC (Point of Coherence) by va.
        __asm__ __volatile__("ic ivau, %0 " : : "r"(va));
  6010414964:	f9400fe0 	ldr	x0, [sp, #24]
  6010414968:	d50b7520 	ic	ivau, x0
        // increment addres to next line and decrement lenght
        addr = (uintptr_t)((uint64_t)addr + line_size);
  601041496c:	f9401fe1 	ldr	x1, [sp, #56]
  6010414970:	f94013e0 	ldr	x0, [sp, #32]
  6010414974:	8b000020 	add	x0, x1, x0
  6010414978:	f9001fe0 	str	x0, [sp, #56]
    } while (addr < end_addr);
  601041497c:	f9401fe1 	ldr	x1, [sp, #56]
  6010414980:	f9401be0 	ldr	x0, [sp, #48]
  6010414984:	eb00003f 	cmp	x1, x0
  6010414988:	54fffe43 	b.cc	6010414950 <InvalidateL1Icache+0x40>  // b.lo, b.ul, b.last

    // synchronize context on this processor
    ISB();
  601041498c:	d5033fdf 	isb
}
  6010414990:	d503201f 	nop
  6010414994:	910103ff 	add	sp, sp, #0x40
  6010414998:	d65f03c0 	ret

000000601041499c <EnableL1Dcache>:

void EnableL1Dcache()
{
  601041499c:	d10043ff 	sub	sp, sp, #0x10
    uint64_t sctlr_el1; // System Control Register

    // read sctlr_el1
    __asm__ __volatile__("mrs %0, sctlr_el1" : "=r"(sctlr_el1));
  60104149a0:	d5381000 	mrs	x0, sctlr_el1
  60104149a4:	f90007e0 	str	x0, [sp, #8]

    if (!(sctlr_el1 & SCTLR_EL1_DCACHE_ENABLE)) {
  60104149a8:	f94007e0 	ldr	x0, [sp, #8]
  60104149ac:	927e0000 	and	x0, x0, #0x4
  60104149b0:	f100001f 	cmp	x0, #0x0
  60104149b4:	540000e1 	b.ne	60104149d0 <EnableL1Dcache+0x34>  // b.any
        // set  C bit (data caching enable)
        sctlr_el1 |= SCTLR_EL1_DCACHE_ENABLE;
  60104149b8:	f94007e0 	ldr	x0, [sp, #8]
  60104149bc:	b27e0000 	orr	x0, x0, #0x4
  60104149c0:	f90007e0 	str	x0, [sp, #8]

        // write modified sctlr_el1
        __asm__ __volatile__("msr sctlr_el1, %0" : : "r"(sctlr_el1));
  60104149c4:	f94007e0 	ldr	x0, [sp, #8]
  60104149c8:	d5181000 	msr	sctlr_el1, x0

        // data synchronization barrier
        DSB();
  60104149cc:	d5033b9f 	dsb	ish
    }
}
  60104149d0:	d503201f 	nop
  60104149d4:	910043ff 	add	sp, sp, #0x10
  60104149d8:	d65f03c0 	ret

00000060104149dc <DisableL1Dcache>:

void DisableL1Dcache()
{
  60104149dc:	d10043ff 	sub	sp, sp, #0x10
    uint64_t sctlr_el1; // System Control Register

    // read sctlr_el1
    __asm__ __volatile__("mrs %0, sctlr_el1" : "=r"(sctlr_el1));
  60104149e0:	d5381000 	mrs	x0, sctlr_el1
  60104149e4:	f90007e0 	str	x0, [sp, #8]

    // set  C bit (data caching enable)
    sctlr_el1 &= ~SCTLR_EL1_DCACHE_ENABLE;
  60104149e8:	f94007e0 	ldr	x0, [sp, #8]
  60104149ec:	927df800 	and	x0, x0, #0xfffffffffffffffb
  60104149f0:	f90007e0 	str	x0, [sp, #8]

    // write modified sctlr_el1
    __asm__ __volatile__("msr sctlr_el1, %0" : "=r"(sctlr_el1));
  60104149f4:	d5181000 	msr	sctlr_el1, x0
  60104149f8:	f90007e0 	str	x0, [sp, #8]

    // data synchronization barrier
    DSB();
  60104149fc:	d5033b9f 	dsb	ish
}
  6010414a00:	d503201f 	nop
  6010414a04:	910043ff 	add	sp, sp, #0x10
  6010414a08:	d65f03c0 	ret

0000006010414a0c <EnableL1Icache>:

void EnableL1Icache()
{
  6010414a0c:	d10043ff 	sub	sp, sp, #0x10
    uint64_t sctlr_el1; // System Control Register

    // read sctlr_el1
    __asm__ __volatile__("mrs %0, sctlr_el1" : "=r"(sctlr_el1));
  6010414a10:	d5381000 	mrs	x0, sctlr_el1
  6010414a14:	f90007e0 	str	x0, [sp, #8]

    if (!(sctlr_el1 & SCTLR_EL1_ICACHE_ENABLE)) {
  6010414a18:	f94007e0 	ldr	x0, [sp, #8]
  6010414a1c:	92740000 	and	x0, x0, #0x1000
  6010414a20:	f100001f 	cmp	x0, #0x0
  6010414a24:	540000e1 	b.ne	6010414a40 <EnableL1Icache+0x34>  // b.any
        // set  I bit (data caching enable)
        sctlr_el1 |= SCTLR_EL1_ICACHE_ENABLE;
  6010414a28:	f94007e0 	ldr	x0, [sp, #8]
  6010414a2c:	b2740000 	orr	x0, x0, #0x1000
  6010414a30:	f90007e0 	str	x0, [sp, #8]

        // write modified sctlr_el1
        __asm__ __volatile__("msr sctlr_el1, %0" : "=r"(sctlr_el1));
  6010414a34:	d5181000 	msr	sctlr_el1, x0
  6010414a38:	f90007e0 	str	x0, [sp, #8]

        // Instruction synchronization barrier
        ISB();
  6010414a3c:	d5033fdf 	isb
    }
}
  6010414a40:	d503201f 	nop
  6010414a44:	910043ff 	add	sp, sp, #0x10
  6010414a48:	d65f03c0 	ret

0000006010414a4c <DisableL1Icache>:

void DisableL1Icache()
{
  6010414a4c:	d10043ff 	sub	sp, sp, #0x10
    uint64_t sctlr_el1; // System Control Register

    // read sctlr_el1
    __asm__ __volatile__("mrs %0, sctlr_el1" : "=r"(sctlr_el1));
  6010414a50:	d5381000 	mrs	x0, sctlr_el1
  6010414a54:	f90007e0 	str	x0, [sp, #8]

    // set  I bit (data caching enable)
    sctlr_el1 &= ~SCTLR_EL1_ICACHE_ENABLE;
  6010414a58:	f94007e0 	ldr	x0, [sp, #8]
  6010414a5c:	9273f800 	and	x0, x0, #0xffffffffffffefff
  6010414a60:	f90007e0 	str	x0, [sp, #8]

    // write modified sctlr_el1
    __asm__ __volatile__("msr sctlr_el1, %0" : : "r"(sctlr_el1));
  6010414a64:	f94007e0 	ldr	x0, [sp, #8]
  6010414a68:	d5181000 	msr	sctlr_el1, x0

    // Instruction synchronization barrier
    ISB();
  6010414a6c:	d5033fdf 	isb
  6010414a70:	d503201f 	nop
  6010414a74:	910043ff 	add	sp, sp, #0x10
  6010414a78:	d65f03c0 	ret

0000006010414a7c <pl310_flush_all>:
 *   Flush all ways using the Clean Invalidate Way Register (CIWR).
 *
 ****************************************************************************/

void pl310_flush_all(void)
{
  6010414a7c:	d10083ff 	sub	sp, sp, #0x20
    DSB();
  6010414a80:	d5033b9f 	dsb	ish
  6010414a84:	d2840000 	mov	x0, #0x2000                	// #8192
  6010414a88:	f2a01400 	movk	x0, #0xa0, lsl #16
  6010414a8c:	f9000fe0 	str	x0, [sp, #24]
#ifndef __ASSEMBLER__
typedef uintptr_t mmio_reg_t;
__attribute__((unused, always_inline)) static inline uintptr_t MMIO_P2V(uintptr_t paddr)
{
    /// @todo use dtb rather than just mapping.
    return (DEV_VRTMEM_BASE - DEV_PHYMEM_BASE) + paddr;
  6010414a90:	f9400fe1 	ldr	x1, [sp, #24]
  6010414a94:	d2c00800 	mov	x0, #0x4000000000          	// #274877906944
  6010414a98:	8b000020 	add	x0, x1, x0
    /* Flush all ways by writing the set of ways to be cleaned to the Clean
    * Invalidate Way Register (CIWR).
    */
    write32(PL310_WAY_MASK, L2CC_CIWR);
  6010414a9c:	911ff000 	add	x0, x0, #0x7fc
  6010414aa0:	aa0003e1 	mov	x1, x0
  6010414aa4:	529fffe0 	mov	w0, #0xffff                	// #65535
  6010414aa8:	b9000020 	str	w0, [x1]

    /* Wait for cache operation by way to complete */
    while ((read32(L2CC_CIWR) & PL310_WAY_MASK) != 0)
  6010414aac:	d503201f 	nop
  6010414ab0:	d2840000 	mov	x0, #0x2000                	// #8192
  6010414ab4:	f2a01400 	movk	x0, #0xa0, lsl #16
  6010414ab8:	f9000be0 	str	x0, [sp, #16]
  6010414abc:	f9400be1 	ldr	x1, [sp, #16]
  6010414ac0:	d2c00800 	mov	x0, #0x4000000000          	// #274877906944
  6010414ac4:	8b000020 	add	x0, x1, x0
  6010414ac8:	911ff000 	add	x0, x0, #0x7fc
  6010414acc:	b9400000 	ldr	w0, [x0]
  6010414ad0:	12003c00 	and	w0, w0, #0xffff
  6010414ad4:	7100001f 	cmp	w0, #0x0
  6010414ad8:	54fffec1 	b.ne	6010414ab0 <pl310_flush_all+0x34>  // b.any
  6010414adc:	d2840000 	mov	x0, #0x2000                	// #8192
  6010414ae0:	f2a01400 	movk	x0, #0xa0, lsl #16
  6010414ae4:	f90007e0 	str	x0, [sp, #8]
  6010414ae8:	f94007e1 	ldr	x1, [sp, #8]
  6010414aec:	d2c00800 	mov	x0, #0x4000000000          	// #274877906944
  6010414af0:	8b000020 	add	x0, x1, x0

    /* Drain the STB. Operation complete when all buffers, LRB, LFB, STB, and
    * EB, are empty.
    */

    write32(0, L2CC_CSR);
  6010414af4:	911cc000 	add	x0, x0, #0x730
  6010414af8:	b900001f 	str	wzr, [x0]
    DSB();
  6010414afc:	d5033b9f 	dsb	ish
}
  6010414b00:	d503201f 	nop
  6010414b04:	910083ff 	add	sp, sp, #0x20
  6010414b08:	d65f03c0 	ret

0000006010414b0c <arm_l2ccinitialize>:
 *   upon return.
 *
 ****************************************************************************/

void arm_l2ccinitialize(void)
{
  6010414b0c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  6010414b10:	910003fd 	mov	x29, sp
  6010414b14:	d2840000 	mov	x0, #0x2000                	// #8192
  6010414b18:	f2a01400 	movk	x0, #0xa0, lsl #16
  6010414b1c:	f90023e0 	str	x0, [sp, #64]
  6010414b20:	f94023e1 	ldr	x1, [sp, #64]
  6010414b24:	d2c00800 	mov	x0, #0x4000000000          	// #274877906944
  6010414b28:	8b000020 	add	x0, x1, x0
    DEBUGASSERT((read32(L2CC_ACR) & L2CC_ACR_WAYSIZE_MASK) == L2CC_ACR_WAYSIZE_512KB);
#else
#  error No way size selected
#endif

    if ((read32(L2CC_CR) & L2CC_CR_L2CEN) == 0) {
  6010414b2c:	91040000 	add	x0, x0, #0x100
  6010414b30:	b9400000 	ldr	w0, [x0]
  6010414b34:	12000000 	and	w0, w0, #0x1
  6010414b38:	7100001f 	cmp	w0, #0x0
  6010414b3c:	540008e1 	b.ne	6010414c58 <arm_l2ccinitialize+0x14c>  // b.any
        write32(regval | L2X0_ADDR_FILTER_EN, L2CC_FLSTRT);
#endif
#endif
        /* Make sure that the memory is not locked down */

        for (i = 0; i < PL310_NLOCKREGS; i++) {
  6010414b40:	b9004fff 	str	wzr, [sp, #76]
  6010414b44:	1400001c 	b	6010414bb4 <arm_l2ccinitialize+0xa8>
  6010414b48:	d2840000 	mov	x0, #0x2000                	// #8192
  6010414b4c:	f2a01400 	movk	x0, #0xa0, lsl #16
  6010414b50:	f9001be0 	str	x0, [sp, #48]
  6010414b54:	f9401be1 	ldr	x1, [sp, #48]
  6010414b58:	d2c00800 	mov	x0, #0x4000000000          	// #274877906944
  6010414b5c:	8b000021 	add	x1, x1, x0
            write32(0, L2CC_DLKR(i));
  6010414b60:	b9404fe0 	ldr	w0, [sp, #76]
  6010414b64:	531d7000 	lsl	w0, w0, #3
  6010414b68:	11240000 	add	w0, w0, #0x900
  6010414b6c:	93407c00 	sxtw	x0, w0
  6010414b70:	8b000020 	add	x0, x1, x0
  6010414b74:	b900001f 	str	wzr, [x0]
  6010414b78:	d2840000 	mov	x0, #0x2000                	// #8192
  6010414b7c:	f2a01400 	movk	x0, #0xa0, lsl #16
  6010414b80:	f9001fe0 	str	x0, [sp, #56]
  6010414b84:	f9401fe1 	ldr	x1, [sp, #56]
  6010414b88:	d2c00800 	mov	x0, #0x4000000000          	// #274877906944
  6010414b8c:	8b000021 	add	x1, x1, x0
            write32(0, L2CC_ILKR(i));
  6010414b90:	b9404fe0 	ldr	w0, [sp, #76]
  6010414b94:	531d7000 	lsl	w0, w0, #3
  6010414b98:	11241000 	add	w0, w0, #0x904
  6010414b9c:	93407c00 	sxtw	x0, w0
  6010414ba0:	8b000020 	add	x0, x1, x0
  6010414ba4:	b900001f 	str	wzr, [x0]
        for (i = 0; i < PL310_NLOCKREGS; i++) {
  6010414ba8:	b9404fe0 	ldr	w0, [sp, #76]
  6010414bac:	11000400 	add	w0, w0, #0x1
  6010414bb0:	b9004fe0 	str	w0, [sp, #76]
  6010414bb4:	b9404fe0 	ldr	w0, [sp, #76]
  6010414bb8:	7100001f 	cmp	w0, #0x0
  6010414bbc:	54fffc6d 	b.le	6010414b48 <arm_l2ccinitialize+0x3c>
  6010414bc0:	d2840000 	mov	x0, #0x2000                	// #8192
  6010414bc4:	f2a01400 	movk	x0, #0xa0, lsl #16
  6010414bc8:	f9000fe0 	str	x0, [sp, #24]
  6010414bcc:	f9400fe1 	ldr	x1, [sp, #24]
  6010414bd0:	d2c00800 	mov	x0, #0x4000000000          	// #274877906944
  6010414bd4:	8b000020 	add	x0, x1, x0
        }

        /* Configure the cache properties */

        regval = read32(L2CC_ACR);
  6010414bd8:	91041000 	add	x0, x0, #0x104
  6010414bdc:	b9400000 	ldr	w0, [x0]
  6010414be0:	b9004be0 	str	w0, [sp, #72]
        regval &= ~L2CC_ACR_CONFIGMASK;
  6010414be4:	b9404be1 	ldr	w1, [sp, #72]
  6010414be8:	52804000 	mov	w0, #0x200                 	// #512
  6010414bec:	72a019e0 	movk	w0, #0xcf, lsl #16
  6010414bf0:	0a000020 	and	w0, w1, w0
  6010414bf4:	b9004be0 	str	w0, [sp, #72]
        regval |= L2CC_ACR_CONFIG;
  6010414bf8:	b9404be0 	ldr	w0, [sp, #72]
  6010414bfc:	32070000 	orr	w0, w0, #0x2000000
  6010414c00:	b9004be0 	str	w0, [sp, #72]
  6010414c04:	d2840000 	mov	x0, #0x2000                	// #8192
  6010414c08:	f2a01400 	movk	x0, #0xa0, lsl #16
  6010414c0c:	f90013e0 	str	x0, [sp, #32]
  6010414c10:	f94013e1 	ldr	x1, [sp, #32]
  6010414c14:	d2c00800 	mov	x0, #0x4000000000          	// #274877906944
  6010414c18:	8b000020 	add	x0, x1, x0
        write32(regval, L2CC_ACR);
  6010414c1c:	91041000 	add	x0, x0, #0x104
  6010414c20:	aa0003e1 	mov	x1, x0
  6010414c24:	b9404be0 	ldr	w0, [sp, #72]
  6010414c28:	b9000020 	str	w0, [x1]

        /* Invalidate and enable the cache */

        InvalidateL2CacheAll();
  6010414c2c:	94000037 	bl	6010414d08 <InvalidateL2CacheAll>
  6010414c30:	d2840000 	mov	x0, #0x2000                	// #8192
  6010414c34:	f2a01400 	movk	x0, #0xa0, lsl #16
  6010414c38:	f90017e0 	str	x0, [sp, #40]
  6010414c3c:	f94017e1 	ldr	x1, [sp, #40]
  6010414c40:	d2c00800 	mov	x0, #0x4000000000          	// #274877906944
  6010414c44:	8b000020 	add	x0, x1, x0
        write32(L2CC_CR_L2CEN, L2CC_CR);
  6010414c48:	91040000 	add	x0, x0, #0x100
  6010414c4c:	aa0003e1 	mov	x1, x0
  6010414c50:	52800020 	mov	w0, #0x1                   	// #1
  6010414c54:	b9000020 	str	w0, [x1]
    }
}
  6010414c58:	d503201f 	nop
  6010414c5c:	a8c57bfd 	ldp	x29, x30, [sp], #80
  6010414c60:	d65f03c0 	ret

0000006010414c64 <EnableL2Cache>:
 *    Control Register (CR)
 *
 ****************************************************************************/

void EnableL2Cache(void)
{
  6010414c64:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  6010414c68:	910003fd 	mov	x29, sp

    InvalidateL2CacheAll();
  6010414c6c:	94000027 	bl	6010414d08 <InvalidateL2CacheAll>
  6010414c70:	d2840000 	mov	x0, #0x2000                	// #8192
  6010414c74:	f2a01400 	movk	x0, #0xa0, lsl #16
  6010414c78:	f9000fe0 	str	x0, [sp, #24]
  6010414c7c:	f9400fe1 	ldr	x1, [sp, #24]
  6010414c80:	d2c00800 	mov	x0, #0x4000000000          	// #274877906944
  6010414c84:	8b000020 	add	x0, x1, x0
    write32(L2CC_CR_L2CEN, L2CC_CR);
  6010414c88:	91040000 	add	x0, x0, #0x100
  6010414c8c:	aa0003e1 	mov	x1, x0
  6010414c90:	52800020 	mov	w0, #0x1                   	// #1
  6010414c94:	b9000020 	str	w0, [x1]
}
  6010414c98:	d503201f 	nop
  6010414c9c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  6010414ca0:	d65f03c0 	ret

0000006010414ca4 <DisableL2Cache>:
 *
 * 
 ****************************************************************************/

void DisableL2Cache(void)
{
  6010414ca4:	d10043ff 	sub	sp, sp, #0x10
  6010414ca8:	d2840000 	mov	x0, #0x2000                	// #8192
  6010414cac:	f2a01400 	movk	x0, #0xa0, lsl #16
  6010414cb0:	f90007e0 	str	x0, [sp, #8]
  6010414cb4:	f94007e1 	ldr	x1, [sp, #8]
  6010414cb8:	d2c00800 	mov	x0, #0x4000000000          	// #274877906944
  6010414cbc:	8b000020 	add	x0, x1, x0
    write32(0, L2CC_CR);
  6010414cc0:	91040000 	add	x0, x0, #0x100
  6010414cc4:	b900001f 	str	wzr, [x0]
    DSB();
  6010414cc8:	d5033b9f 	dsb	ish
}
  6010414ccc:	d503201f 	nop
  6010414cd0:	910043ff 	add	sp, sp, #0x10
  6010414cd4:	d65f03c0 	ret

0000006010414cd8 <SyncL2Cache>:
 *   EB, are empty.
 *
 ****************************************************************************/

void SyncL2Cache(void)
{
  6010414cd8:	d10043ff 	sub	sp, sp, #0x10
  6010414cdc:	d2840000 	mov	x0, #0x2000                	// #8192
  6010414ce0:	f2a01400 	movk	x0, #0xa0, lsl #16
  6010414ce4:	f90007e0 	str	x0, [sp, #8]
  6010414ce8:	f94007e1 	ldr	x1, [sp, #8]
  6010414cec:	d2c00800 	mov	x0, #0x4000000000          	// #274877906944
  6010414cf0:	8b000020 	add	x0, x1, x0
    write32(0, L2CC_CSR);
  6010414cf4:	911cc000 	add	x0, x0, #0x730
  6010414cf8:	b900001f 	str	wzr, [x0]
}
  6010414cfc:	d503201f 	nop
  6010414d00:	910043ff 	add	sp, sp, #0x10
  6010414d04:	d65f03c0 	ret

0000006010414d08 <InvalidateL2CacheAll>:
 *   Invalidate all ways using the Invalidate Way Register (IWR).
 *
 ****************************************************************************/

void InvalidateL2CacheAll(void)
{
  6010414d08:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  6010414d0c:	910003fd 	mov	x29, sp
  6010414d10:	d2840000 	mov	x0, #0x2000                	// #8192
  6010414d14:	f2a01400 	movk	x0, #0xa0, lsl #16
  6010414d18:	f90017e0 	str	x0, [sp, #40]
  6010414d1c:	f94017e1 	ldr	x1, [sp, #40]
  6010414d20:	d2c00800 	mov	x0, #0x4000000000          	// #274877906944
  6010414d24:	8b000020 	add	x0, x1, x0
    uint32_t regval;

    /* Invalidate all ways */
    /* Disable the L2 cache while we invalidate it */

    regval = read32(L2CC_CR);
  6010414d28:	91040000 	add	x0, x0, #0x100
  6010414d2c:	b9400000 	ldr	w0, [x0]
  6010414d30:	b9003fe0 	str	w0, [sp, #60]
    DisableL2Cache();
  6010414d34:	97ffffdc 	bl	6010414ca4 <DisableL2Cache>
  6010414d38:	d2840000 	mov	x0, #0x2000                	// #8192
  6010414d3c:	f2a01400 	movk	x0, #0xa0, lsl #16
  6010414d40:	f9001be0 	str	x0, [sp, #48]
  6010414d44:	f9401be1 	ldr	x1, [sp, #48]
  6010414d48:	d2c00800 	mov	x0, #0x4000000000          	// #274877906944
  6010414d4c:	8b000020 	add	x0, x1, x0

    /* Invalidate all ways by writing the bit mask of ways to be invalidated
    * the Invalidate Way Register (IWR).
    */

    write32(PL310_WAY_MASK, L2CC_IWR);
  6010414d50:	911df000 	add	x0, x0, #0x77c
  6010414d54:	aa0003e1 	mov	x1, x0
  6010414d58:	529fffe0 	mov	w0, #0xffff                	// #65535
  6010414d5c:	b9000020 	str	w0, [x1]

    while ((read32(L2CC_IWR) & PL310_WAY_MASK) != 0)
  6010414d60:	d503201f 	nop
  6010414d64:	d2840000 	mov	x0, #0x2000                	// #8192
  6010414d68:	f2a01400 	movk	x0, #0xa0, lsl #16
  6010414d6c:	f90013e0 	str	x0, [sp, #32]
  6010414d70:	f94013e1 	ldr	x1, [sp, #32]
  6010414d74:	d2c00800 	mov	x0, #0x4000000000          	// #274877906944
  6010414d78:	8b000020 	add	x0, x1, x0
  6010414d7c:	911df000 	add	x0, x0, #0x77c
  6010414d80:	b9400000 	ldr	w0, [x0]
  6010414d84:	12003c00 	and	w0, w0, #0xffff
  6010414d88:	7100001f 	cmp	w0, #0x0
  6010414d8c:	54fffec1 	b.ne	6010414d64 <InvalidateL2CacheAll+0x5c>  // b.any
  6010414d90:	d2840000 	mov	x0, #0x2000                	// #8192
  6010414d94:	f2a01400 	movk	x0, #0xa0, lsl #16
  6010414d98:	f9000be0 	str	x0, [sp, #16]
  6010414d9c:	f9400be1 	ldr	x1, [sp, #16]
  6010414da0:	d2c00800 	mov	x0, #0x4000000000          	// #274877906944
  6010414da4:	8b000020 	add	x0, x1, x0

    /* Drain the STB. Operation complete when all buffers, LRB, LFB, STB, and
    * EB, are empty.
    */

    write32(0, L2CC_CSR);
  6010414da8:	911cc000 	add	x0, x0, #0x730
  6010414dac:	b900001f 	str	wzr, [x0]
  6010414db0:	d2840000 	mov	x0, #0x2000                	// #8192
  6010414db4:	f2a01400 	movk	x0, #0xa0, lsl #16
  6010414db8:	f9000fe0 	str	x0, [sp, #24]
  6010414dbc:	f9400fe1 	ldr	x1, [sp, #24]
  6010414dc0:	d2c00800 	mov	x0, #0x4000000000          	// #274877906944
  6010414dc4:	8b000020 	add	x0, x1, x0

    /* Then re-enable the L2 cache if it was enabled before */

    write32(regval, L2CC_CR);
  6010414dc8:	91040000 	add	x0, x0, #0x100
  6010414dcc:	aa0003e1 	mov	x1, x0
  6010414dd0:	b9403fe0 	ldr	w0, [sp, #60]
  6010414dd4:	b9000020 	str	w0, [x1]
}
  6010414dd8:	d503201f 	nop
  6010414ddc:	a8c47bfd 	ldp	x29, x30, [sp], #64
  6010414de0:	d65f03c0 	ret

0000006010414de4 <InvalidateL2Cache>:
 *   Address Line Register (IPALR) repeatedly.
 *
 ****************************************************************************/

void InvalidateL2Cache(uintptr_t startaddr, uintptr_t endaddr)
{
  6010414de4:	d10103ff 	sub	sp, sp, #0x40
  6010414de8:	f90007e0 	str	x0, [sp, #8]
  6010414dec:	f90003e1 	str	x1, [sp]
    uintptr_t invalsize;
    uintptr_t gulpend;

    /* Check if the start address is aligned with a cacheline */
    if ((startaddr & PL310_CACHE_LINE_MASK) != 0) {
  6010414df0:	f94007e0 	ldr	x0, [sp, #8]
  6010414df4:	92401000 	and	x0, x0, #0x1f
  6010414df8:	f100001f 	cmp	x0, #0x0
  6010414dfc:	54000200 	b.eq	6010414e3c <InvalidateL2Cache+0x58>  // b.none
        /* No.. align down and flush the cache line by writing the address to
        * the Clean Invalidate Physical Address Line Register (CIPALR).
        */

        startaddr &= ~PL310_CACHE_LINE_MASK;
  6010414e00:	f94007e0 	ldr	x0, [sp, #8]
  6010414e04:	927be800 	and	x0, x0, #0xffffffffffffffe0
  6010414e08:	f90007e0 	str	x0, [sp, #8]
  6010414e0c:	d2840000 	mov	x0, #0x2000                	// #8192
  6010414e10:	f2a01400 	movk	x0, #0xa0, lsl #16
  6010414e14:	f90017e0 	str	x0, [sp, #40]
  6010414e18:	f94017e1 	ldr	x1, [sp, #40]
  6010414e1c:	d2c00800 	mov	x0, #0x4000000000          	// #274877906944
  6010414e20:	8b000020 	add	x0, x1, x0
        write32(startaddr, L2CC_CIPALR);
  6010414e24:	911fc000 	add	x0, x0, #0x7f0
  6010414e28:	f94007e1 	ldr	x1, [sp, #8]
  6010414e2c:	b9000001 	str	w1, [x0]

        /* Then start invalidating at the next cache line */

        startaddr += PL310_CACHE_LINE_SIZE;
  6010414e30:	f94007e0 	ldr	x0, [sp, #8]
  6010414e34:	91008000 	add	x0, x0, #0x20
  6010414e38:	f90007e0 	str	x0, [sp, #8]
    }

    /* Check if the end address is aligned with a cache line */

    if ((endaddr & PL310_CACHE_LINE_MASK) != 0) {
  6010414e3c:	f94003e0 	ldr	x0, [sp]
  6010414e40:	92401000 	and	x0, x0, #0x1f
  6010414e44:	f100001f 	cmp	x0, #0x0
  6010414e48:	54000560 	b.eq	6010414ef4 <InvalidateL2Cache+0x110>  // b.none
        /* No.. align down and flush cache line by writing the address to
        * the Clean Invalidate Physical Address Line Register (CIPALR).
        */

        endaddr &= ~PL310_CACHE_LINE_MASK;
  6010414e4c:	f94003e0 	ldr	x0, [sp]
  6010414e50:	927be800 	and	x0, x0, #0xffffffffffffffe0
  6010414e54:	f90003e0 	str	x0, [sp]
  6010414e58:	d2840000 	mov	x0, #0x2000                	// #8192
  6010414e5c:	f2a01400 	movk	x0, #0xa0, lsl #16
  6010414e60:	f90013e0 	str	x0, [sp, #32]
  6010414e64:	f94013e1 	ldr	x1, [sp, #32]
  6010414e68:	d2c00800 	mov	x0, #0x4000000000          	// #274877906944
  6010414e6c:	8b000020 	add	x0, x1, x0
        write32(endaddr, L2CC_CIPALR);
  6010414e70:	911fc000 	add	x0, x0, #0x7f0
  6010414e74:	f94003e1 	ldr	x1, [sp]
  6010414e78:	b9000001 	str	w1, [x0]

    /* Loop, invalidated the address range by cache line.  Interrupts are re-
    * enabled momentarily every PL310_GULP_SIZE bytes.
    */

    while (startaddr < endaddr) {
  6010414e7c:	1400001e 	b	6010414ef4 <InvalidateL2Cache+0x110>
        /* Get the size of the next gulp of cache lines to invalidate.  We do
        * this in small chunks so that we do not have to keep interrupts
        * disabled throughout the whole flush.
        */

        invalsize = endaddr - startaddr;
  6010414e80:	f94003e1 	ldr	x1, [sp]
  6010414e84:	f94007e0 	ldr	x0, [sp, #8]
  6010414e88:	cb000020 	sub	x0, x1, x0
  6010414e8c:	f9001fe0 	str	x0, [sp, #56]
        gulpend = startaddr + MIN(invalsize, PL310_GULP_SIZE);
  6010414e90:	f9401fe2 	ldr	x2, [sp, #56]
  6010414e94:	f9401fe1 	ldr	x1, [sp, #56]
  6010414e98:	d2820000 	mov	x0, #0x1000                	// #4096
  6010414e9c:	f140045f 	cmp	x2, #0x1, lsl #12
  6010414ea0:	9a809020 	csel	x0, x1, x0, ls  // ls = plast
  6010414ea4:	f94007e1 	ldr	x1, [sp, #8]
  6010414ea8:	8b000020 	add	x0, x1, x0
  6010414eac:	f9001be0 	str	x0, [sp, #48]

        /* Disable interrupts and invalidate the gulp */
        while (startaddr < gulpend) {
  6010414eb0:	1400000d 	b	6010414ee4 <InvalidateL2Cache+0x100>
  6010414eb4:	d2840000 	mov	x0, #0x2000                	// #8192
  6010414eb8:	f2a01400 	movk	x0, #0xa0, lsl #16
  6010414ebc:	f9000fe0 	str	x0, [sp, #24]
  6010414ec0:	f9400fe1 	ldr	x1, [sp, #24]
  6010414ec4:	d2c00800 	mov	x0, #0x4000000000          	// #274877906944
  6010414ec8:	8b000020 	add	x0, x1, x0
            /* Invalidate the cache line by writing the address to the
            * Invalidate Physical Address Line Register (IPALR).
            */
            write32(startaddr, L2CC_IPALR);
  6010414ecc:	911dc000 	add	x0, x0, #0x770
  6010414ed0:	f94007e1 	ldr	x1, [sp, #8]
  6010414ed4:	b9000001 	str	w1, [x0]

            /* Start of the next cache line */

            startaddr += PL310_CACHE_LINE_SIZE;
  6010414ed8:	f94007e0 	ldr	x0, [sp, #8]
  6010414edc:	91008000 	add	x0, x0, #0x20
  6010414ee0:	f90007e0 	str	x0, [sp, #8]
        while (startaddr < gulpend) {
  6010414ee4:	f94007e1 	ldr	x1, [sp, #8]
  6010414ee8:	f9401be0 	ldr	x0, [sp, #48]
  6010414eec:	eb00003f 	cmp	x1, x0
  6010414ef0:	54fffe23 	b.cc	6010414eb4 <InvalidateL2Cache+0xd0>  // b.lo, b.ul, b.last
    while (startaddr < endaddr) {
  6010414ef4:	f94007e1 	ldr	x1, [sp, #8]
  6010414ef8:	f94003e0 	ldr	x0, [sp]
  6010414efc:	eb00003f 	cmp	x1, x0
  6010414f00:	54fffc03 	b.cc	6010414e80 <InvalidateL2Cache+0x9c>  // b.lo, b.ul, b.last
  6010414f04:	d2840000 	mov	x0, #0x2000                	// #8192
  6010414f08:	f2a01400 	movk	x0, #0xa0, lsl #16
  6010414f0c:	f9000be0 	str	x0, [sp, #16]
  6010414f10:	f9400be1 	ldr	x1, [sp, #16]
  6010414f14:	d2c00800 	mov	x0, #0x4000000000          	// #274877906944
  6010414f18:	8b000020 	add	x0, x1, x0
    }

    /* Drain the STB. Operation complete when all buffers, LRB, LFB, STB, and
    * EB, are empty.
    */
    write32(0, L2CC_CSR);
  6010414f1c:	911cc000 	add	x0, x0, #0x730
  6010414f20:	b900001f 	str	wzr, [x0]
}
  6010414f24:	d503201f 	nop
  6010414f28:	910103ff 	add	sp, sp, #0x40
  6010414f2c:	d65f03c0 	ret

0000006010414f30 <CleanL2CacheAll>:
 *   Clean all ways by using the Clean Ways Register (CWR).
 *
 ****************************************************************************/

void CleanL2CacheAll(void)
{
  6010414f30:	d10083ff 	sub	sp, sp, #0x20
  6010414f34:	d2840000 	mov	x0, #0x2000                	// #8192
  6010414f38:	f2a01400 	movk	x0, #0xa0, lsl #16
  6010414f3c:	f9000fe0 	str	x0, [sp, #24]
  6010414f40:	f9400fe1 	ldr	x1, [sp, #24]
  6010414f44:	d2c00800 	mov	x0, #0x4000000000          	// #274877906944
  6010414f48:	8b000020 	add	x0, x1, x0
    write32(PL310_WAY_MASK, L2CC_CWR);
  6010414f4c:	911ef000 	add	x0, x0, #0x7bc
  6010414f50:	aa0003e1 	mov	x1, x0
  6010414f54:	529fffe0 	mov	w0, #0xffff                	// #65535
  6010414f58:	b9000020 	str	w0, [x1]

    /* Wait for cache operation by way to complete */

    while ((read32(L2CC_CWR) & PL310_WAY_MASK) != 0)
  6010414f5c:	d503201f 	nop
  6010414f60:	d2840000 	mov	x0, #0x2000                	// #8192
  6010414f64:	f2a01400 	movk	x0, #0xa0, lsl #16
  6010414f68:	f9000be0 	str	x0, [sp, #16]
  6010414f6c:	f9400be1 	ldr	x1, [sp, #16]
  6010414f70:	d2c00800 	mov	x0, #0x4000000000          	// #274877906944
  6010414f74:	8b000020 	add	x0, x1, x0
  6010414f78:	911ef000 	add	x0, x0, #0x7bc
  6010414f7c:	b9400000 	ldr	w0, [x0]
  6010414f80:	12003c00 	and	w0, w0, #0xffff
  6010414f84:	7100001f 	cmp	w0, #0x0
  6010414f88:	54fffec1 	b.ne	6010414f60 <CleanL2CacheAll+0x30>  // b.any
  6010414f8c:	d2840000 	mov	x0, #0x2000                	// #8192
  6010414f90:	f2a01400 	movk	x0, #0xa0, lsl #16
  6010414f94:	f90007e0 	str	x0, [sp, #8]
  6010414f98:	f94007e1 	ldr	x1, [sp, #8]
  6010414f9c:	d2c00800 	mov	x0, #0x4000000000          	// #274877906944
  6010414fa0:	8b000020 	add	x0, x1, x0

    /* Drain the STB. Operation complete when all buffers, LRB, LFB, STB, and
    * EB, are empty.
    */

    write32(0, L2CC_CSR);
  6010414fa4:	911cc000 	add	x0, x0, #0x730
  6010414fa8:	b900001f 	str	wzr, [x0]
}
  6010414fac:	d503201f 	nop
  6010414fb0:	910083ff 	add	sp, sp, #0x20
  6010414fb4:	d65f03c0 	ret

0000006010414fb8 <CleanL2Cache>:
 *   Address Line Register (CPALR) repeatedly.
 *
 ****************************************************************************/

void CleanL2Cache(uintptr_t startaddr, uintptr_t endaddr)
{
  6010414fb8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  6010414fbc:	910003fd 	mov	x29, sp
  6010414fc0:	f9000fe0 	str	x0, [sp, #24]
  6010414fc4:	f9000be1 	str	x1, [sp, #16]

    /* If the range of addresses to clean is as large or larger the L2 cache,
    * then just clean the whole thing.
    */

    cleansize = endaddr - startaddr;
  6010414fc8:	f9400be1 	ldr	x1, [sp, #16]
  6010414fcc:	f9400fe0 	ldr	x0, [sp, #24]
  6010414fd0:	cb000020 	sub	x0, x1, x0
  6010414fd4:	f9001fe0 	str	x0, [sp, #56]
    if (cleansize >= PL310_CACHE_SIZE) {
  6010414fd8:	f9401fe1 	ldr	x1, [sp, #56]
  6010414fdc:	b24047e0 	mov	x0, #0x3ffff               	// #262143
  6010414fe0:	eb00003f 	cmp	x1, x0
  6010414fe4:	54000069 	b.ls	6010414ff0 <CleanL2Cache+0x38>  // b.plast
        CleanL2CacheAll();
  6010414fe8:	97ffffd2 	bl	6010414f30 <CleanL2CacheAll>
        return;
  6010414fec:	1400002e 	b	60104150a4 <CleanL2Cache+0xec>
    }

    /* Align the starting address to a cache line boundary */

    startaddr &= ~PL310_CACHE_LINE_MASK;
  6010414ff0:	f9400fe0 	ldr	x0, [sp, #24]
  6010414ff4:	927be800 	and	x0, x0, #0xffffffffffffffe0
  6010414ff8:	f9000fe0 	str	x0, [sp, #24]

    /* Clean the L2 cache by cache line, enabling interrupts momentarily
    * every PL310_GULP_SIZE bytes.
    */

    while (startaddr < endaddr) {
  6010414ffc:	1400001e 	b	6010415074 <CleanL2Cache+0xbc>
        /* Get the size of the next gulp of cache lines to flush.  We do
        * this in small chunks so that we do not have to keep interrupts
        * disabled throughout the whole flush.
        */

        cleansize = endaddr - startaddr;
  6010415000:	f9400be1 	ldr	x1, [sp, #16]
  6010415004:	f9400fe0 	ldr	x0, [sp, #24]
  6010415008:	cb000020 	sub	x0, x1, x0
  601041500c:	f9001fe0 	str	x0, [sp, #56]
        gulpend = startaddr + MIN(cleansize, PL310_GULP_SIZE);
  6010415010:	f9401fe2 	ldr	x2, [sp, #56]
  6010415014:	f9401fe1 	ldr	x1, [sp, #56]
  6010415018:	d2820000 	mov	x0, #0x1000                	// #4096
  601041501c:	f140045f 	cmp	x2, #0x1, lsl #12
  6010415020:	9a809020 	csel	x0, x1, x0, ls  // ls = plast
  6010415024:	f9400fe1 	ldr	x1, [sp, #24]
  6010415028:	8b000020 	add	x0, x1, x0
  601041502c:	f9001be0 	str	x0, [sp, #48]

        /* Disable interrupts and clean the gulp */
        while (startaddr < gulpend) {
  6010415030:	1400000d 	b	6010415064 <CleanL2Cache+0xac>
  6010415034:	d2840000 	mov	x0, #0x2000                	// #8192
  6010415038:	f2a01400 	movk	x0, #0xa0, lsl #16
  601041503c:	f90017e0 	str	x0, [sp, #40]
  6010415040:	f94017e1 	ldr	x1, [sp, #40]
  6010415044:	d2c00800 	mov	x0, #0x4000000000          	// #274877906944
  6010415048:	8b000020 	add	x0, x1, x0
            /* Clean the cache line by writing the address to the Clean
            * Physical Address Line Register (CPALR).
            */

            write32(startaddr, L2CC_CPALR);
  601041504c:	911ec000 	add	x0, x0, #0x7b0
  6010415050:	f9400fe1 	ldr	x1, [sp, #24]
  6010415054:	b9000001 	str	w1, [x0]

            /* Start of the next cache line */

            startaddr += PL310_CACHE_LINE_SIZE;
  6010415058:	f9400fe0 	ldr	x0, [sp, #24]
  601041505c:	91008000 	add	x0, x0, #0x20
  6010415060:	f9000fe0 	str	x0, [sp, #24]
        while (startaddr < gulpend) {
  6010415064:	f9400fe1 	ldr	x1, [sp, #24]
  6010415068:	f9401be0 	ldr	x0, [sp, #48]
  601041506c:	eb00003f 	cmp	x1, x0
  6010415070:	54fffe23 	b.cc	6010415034 <CleanL2Cache+0x7c>  // b.lo, b.ul, b.last
    while (startaddr < endaddr) {
  6010415074:	f9400fe1 	ldr	x1, [sp, #24]
  6010415078:	f9400be0 	ldr	x0, [sp, #16]
  601041507c:	eb00003f 	cmp	x1, x0
  6010415080:	54fffc03 	b.cc	6010415000 <CleanL2Cache+0x48>  // b.lo, b.ul, b.last
  6010415084:	d2840000 	mov	x0, #0x2000                	// #8192
  6010415088:	f2a01400 	movk	x0, #0xa0, lsl #16
  601041508c:	f90013e0 	str	x0, [sp, #32]
  6010415090:	f94013e1 	ldr	x1, [sp, #32]
  6010415094:	d2c00800 	mov	x0, #0x4000000000          	// #274877906944
  6010415098:	8b000020 	add	x0, x1, x0
    }

    /* Drain the STB. Operation complete when all buffers, LRB, LFB, STB, and
    * EB, are empty.
    */
    write32(0, L2CC_CSR);
  601041509c:	911cc000 	add	x0, x0, #0x730
  60104150a0:	b900001f 	str	wzr, [x0]
}
  60104150a4:	a8c47bfd 	ldp	x29, x30, [sp], #64
  60104150a8:	d65f03c0 	ret

00000060104150ac <FlushL2CacheAll>:
 *   Flush all ways using the Clean Invalidate Way Register (CIWR).
 *
 ****************************************************************************/

void FlushL2CacheAll(void)
{
  60104150ac:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  60104150b0:	910003fd 	mov	x29, sp
    /* Flush all ways using the Clean Invalidate Way Register (CIWR). */
    pl310_flush_all();
  60104150b4:	97fffe72 	bl	6010414a7c <pl310_flush_all>
}
  60104150b8:	d503201f 	nop
  60104150bc:	a8c17bfd 	ldp	x29, x30, [sp], #16
  60104150c0:	d65f03c0 	ret

00000060104150c4 <FlushL2Cache>:
 *   Line Register (CIPALR) repeatedly.
 *
 ****************************************************************************/

void FlushL2Cache(uint32_t startaddr, uint32_t endaddr)
{
  60104150c4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  60104150c8:	910003fd 	mov	x29, sp
  60104150cc:	b9001fe0 	str	w0, [sp, #28]
  60104150d0:	b9001be1 	str	w1, [sp, #24]
    uintptr_t  gulpend;
    /* If the range of addresses to flush is as large or larger the L2 cache,
    * then just flush the whole thing.
    */

    flushsize = endaddr - startaddr;
  60104150d4:	b9401be1 	ldr	w1, [sp, #24]
  60104150d8:	b9401fe0 	ldr	w0, [sp, #28]
  60104150dc:	4b000020 	sub	w0, w1, w0
  60104150e0:	2a0003e0 	mov	w0, w0
  60104150e4:	f9001fe0 	str	x0, [sp, #56]
    if (flushsize >= PL310_CACHE_SIZE)
  60104150e8:	f9401fe1 	ldr	x1, [sp, #56]
  60104150ec:	b24047e0 	mov	x0, #0x3ffff               	// #262143
  60104150f0:	eb00003f 	cmp	x1, x0
  60104150f4:	54000069 	b.ls	6010415100 <FlushL2Cache+0x3c>  // b.plast
    {
        pl310_flush_all();
  60104150f8:	97fffe61 	bl	6010414a7c <pl310_flush_all>
        return;
  60104150fc:	14000030 	b	60104151bc <FlushL2Cache+0xf8>
    }

    /* Align the starting address to a cache line boundary */

    startaddr &= ~PL310_CACHE_LINE_MASK;
  6010415100:	b9401fe0 	ldr	w0, [sp, #28]
  6010415104:	121b6800 	and	w0, w0, #0xffffffe0
  6010415108:	b9001fe0 	str	w0, [sp, #28]

    /* Flush the L2 cache by cache line, enabling interrupts momentarily
    * every PL310_GULP_SIZE bytes.
    */

    while (startaddr < endaddr)
  601041510c:	14000020 	b	601041518c <FlushL2Cache+0xc8>
        /* Get the size of the next gulp of cache lines to flush.  We do
        * this in small chunks so that we do not have to keep interrupts
        * disabled throughout the whole flush.
        */

        flushsize = endaddr - startaddr;
  6010415110:	b9401be1 	ldr	w1, [sp, #24]
  6010415114:	b9401fe0 	ldr	w0, [sp, #28]
  6010415118:	4b000020 	sub	w0, w1, w0
  601041511c:	2a0003e0 	mov	w0, w0
  6010415120:	f9001fe0 	str	x0, [sp, #56]
        gulpend   = startaddr + MIN(flushsize, PL310_GULP_SIZE);
  6010415124:	b9401fe1 	ldr	w1, [sp, #28]
  6010415128:	f9401fe3 	ldr	x3, [sp, #56]
  601041512c:	f9401fe2 	ldr	x2, [sp, #56]
  6010415130:	d2820000 	mov	x0, #0x1000                	// #4096
  6010415134:	f140047f 	cmp	x3, #0x1, lsl #12
  6010415138:	9a809040 	csel	x0, x2, x0, ls  // ls = plast
  601041513c:	8b000020 	add	x0, x1, x0
  6010415140:	f9001be0 	str	x0, [sp, #48]

        /* Disable interrupts and flush the gulp */
        while (startaddr < gulpend)
  6010415144:	1400000e 	b	601041517c <FlushL2Cache+0xb8>
  6010415148:	d2840000 	mov	x0, #0x2000                	// #8192
  601041514c:	f2a01400 	movk	x0, #0xa0, lsl #16
  6010415150:	f90017e0 	str	x0, [sp, #40]
  6010415154:	f94017e1 	ldr	x1, [sp, #40]
  6010415158:	d2c00800 	mov	x0, #0x4000000000          	// #274877906944
  601041515c:	8b000020 	add	x0, x1, x0
        {
            /* Flush the cache line by writing the address to the Clean
            * Invalidate Physical Address Line Register (CIPALR).
            */
            write32(startaddr, L2CC_CIPALR);
  6010415160:	911fc000 	add	x0, x0, #0x7f0
  6010415164:	aa0003e1 	mov	x1, x0
  6010415168:	b9401fe0 	ldr	w0, [sp, #28]
  601041516c:	b9000020 	str	w0, [x1]

            /* Start of the next cache line */
            startaddr += PL310_CACHE_LINE_SIZE;
  6010415170:	b9401fe0 	ldr	w0, [sp, #28]
  6010415174:	11008000 	add	w0, w0, #0x20
  6010415178:	b9001fe0 	str	w0, [sp, #28]
        while (startaddr < gulpend)
  601041517c:	b9401fe0 	ldr	w0, [sp, #28]
  6010415180:	f9401be1 	ldr	x1, [sp, #48]
  6010415184:	eb00003f 	cmp	x1, x0
  6010415188:	54fffe08 	b.hi	6010415148 <FlushL2Cache+0x84>  // b.pmore
    while (startaddr < endaddr)
  601041518c:	b9401fe1 	ldr	w1, [sp, #28]
  6010415190:	b9401be0 	ldr	w0, [sp, #24]
  6010415194:	6b00003f 	cmp	w1, w0
  6010415198:	54fffbc3 	b.cc	6010415110 <FlushL2Cache+0x4c>  // b.lo, b.ul, b.last
  601041519c:	d2840000 	mov	x0, #0x2000                	// #8192
  60104151a0:	f2a01400 	movk	x0, #0xa0, lsl #16
  60104151a4:	f90013e0 	str	x0, [sp, #32]
  60104151a8:	f94013e1 	ldr	x1, [sp, #32]
  60104151ac:	d2c00800 	mov	x0, #0x4000000000          	// #274877906944
  60104151b0:	8b000020 	add	x0, x1, x0
    }

    /* Drain the STB. Operation complete when all buffers, LRB, LFB, STB, and
    * EB, are empty.
    */
    write32(0, L2CC_CSR);
  60104151b4:	911cc000 	add	x0, x0, #0x730
  60104151b8:	b900001f 	str	wzr, [x0]
}
  60104151bc:	a8c47bfd 	ldp	x29, x30, [sp], #64
  60104151c0:	d65f03c0 	ret

00000060104151c4 <invalidate_dcache>:
 *   in the cache.
 *
 ****************************************************************************/

static inline void invalidate_dcache(uintptr_t start, uintptr_t end)
{
  60104151c4:	d10043ff 	sub	sp, sp, #0x10
  60104151c8:	f90007e0 	str	x0, [sp, #8]
  60104151cc:	f90003e1 	str	x1, [sp]
    // InvalidateL1Dcache(start, end);
    // InvalidateL2Cache(start, end);
}
  60104151d0:	d503201f 	nop
  60104151d4:	910043ff 	add	sp, sp, #0x10
  60104151d8:	d65f03c0 	ret

00000060104151dc <invalidate_dcache_all>:

static inline void invalidate_dcache_all(void)
{
    // InvalidateL1DcacheAll();
    // InvalidateL2CacheAll();
}
  60104151dc:	d503201f 	nop
  60104151e0:	d65f03c0 	ret

00000060104151e4 <invalidate_icache>:
 * Description:
 *   Invalidate the instruction cache within the specified region.
 *
 ****************************************************************************/
static inline void invalidate_icache(uintptr_t start, uintptr_t end)
{
  60104151e4:	d10043ff 	sub	sp, sp, #0x10
  60104151e8:	f90007e0 	str	x0, [sp, #8]
  60104151ec:	f90003e1 	str	x1, [sp]
    // InvalidateL1Icache(start, end);
}
  60104151f0:	d503201f 	nop
  60104151f4:	910043ff 	add	sp, sp, #0x10
  60104151f8:	d65f03c0 	ret

00000060104151fc <invalidate_icache_all>:
 ****************************************************************************/

static inline void invalidate_icache_all(void)
{
    // InvalidateL1IcacheAll();
}
  60104151fc:	d503201f 	nop
  6010415200:	d65f03c0 	ret

0000006010415204 <clean_dcache>:
 *   contents of the data cache to memory.
 *
 ****************************************************************************/

static inline void clean_dcache(uintptr_t start, uintptr_t end)
{
  6010415204:	d10043ff 	sub	sp, sp, #0x10
  6010415208:	f90007e0 	str	x0, [sp, #8]
  601041520c:	f90003e1 	str	x1, [sp]
    // CleanL1Dcache(start, end);
    // CleanL2Cache(start, end);
}
  6010415210:	d503201f 	nop
  6010415214:	910043ff 	add	sp, sp, #0x10
  6010415218:	d65f03c0 	ret

000000601041521c <clean_dcache_all>:

static inline void clean_dcache_all(void)
{
    // CleanL1DcacheAll();
    // CleanL2CacheAll();
}
  601041521c:	d503201f 	nop
  6010415220:	d65f03c0 	ret

0000006010415224 <flush_dcache>:
 *   invalidating the D cache.
 *
 ****************************************************************************/

static inline void flush_dcache(uintptr_t start, uintptr_t end)
{
  6010415224:	d10043ff 	sub	sp, sp, #0x10
  6010415228:	f90007e0 	str	x0, [sp, #8]
  601041522c:	f90003e1 	str	x1, [sp]

    // FlushL1Dcache(start, end);
    // FlushL2Cache(start, end);
}
  6010415230:	d503201f 	nop
  6010415234:	910043ff 	add	sp, sp, #0x10
  6010415238:	d65f03c0 	ret

000000601041523c <flush_dcache_all>:

static inline void flush_dcache_all(void)
{
    // FlushL1DcacheAll();
    // FlushL2CacheAll();
}
  601041523c:	d503201f 	nop
  6010415240:	d65f03c0 	ret

0000006010415244 <enable_icache>:
 ****************************************************************************/

static inline void enable_icache(void)
{
    // EnableL1Icache();
}
  6010415244:	d503201f 	nop
  6010415248:	d65f03c0 	ret

000000601041524c <disable_icache>:
 ****************************************************************************/

static inline void disable_icache(void)
{
    // DisableL1Icache();
}
  601041524c:	d503201f 	nop
  6010415250:	d65f03c0 	ret

0000006010415254 <enable_dcache>:

static inline void enable_dcache(void)
{
    // EnableL1Dcache();
    // EnableL2Cache();
}
  6010415254:	d503201f 	nop
  6010415258:	d65f03c0 	ret

000000601041525c <disable_dcache>:
{
    // FlushL1DcacheAll();
    // pl310_flush_all();
    // DisableL1Dcache();
    // DisableL2Cache();
}
  601041525c:	d503201f 	nop
  6010415260:	d65f03c0 	ret

0000006010415264 <hardkernel_icache_init>:
    .flushall = flush_dcache_all,
    .invalidateall = invalidate_dcache_all,
};

struct ICacheDone* hardkernel_icache_init(struct TraceTag* hardkernel_tag)
{
  6010415264:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  6010415268:	910003fd 	mov	x29, sp
  601041526c:	f9000fe0 	str	x0, [sp, #24]
    /* init icache */
    icache_done.enable();
  6010415270:	f0000060 	adrp	x0, 6010424000 <impure_data+0x210>
  6010415274:	913aa000 	add	x0, x0, #0xea8
  6010415278:	f9400000 	ldr	x0, [x0]
  601041527c:	d63f0000 	blr	x0
    return &icache_done;
  6010415280:	f0000060 	adrp	x0, 6010424000 <impure_data+0x210>
  6010415284:	913aa000 	add	x0, x0, #0xea8
}
  6010415288:	a8c27bfd 	ldp	x29, x30, [sp], #32
  601041528c:	d65f03c0 	ret

0000006010415290 <hardkernel_dcache_init>:

struct DCacheDone* hardkernel_dcache_init(struct TraceTag* hardkernel_tag)
{
  6010415290:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  6010415294:	910003fd 	mov	x29, sp
  6010415298:	f9000fe0 	str	x0, [sp, #24]
    /* init dcache */
    dcache_done.enable();
  601041529c:	f0000060 	adrp	x0, 6010424000 <impure_data+0x210>
  60104152a0:	913b2000 	add	x0, x0, #0xec8
  60104152a4:	f9400000 	ldr	x0, [x0]
  60104152a8:	d63f0000 	blr	x0
    return &dcache_done;
  60104152ac:	f0000060 	adrp	x0, 6010424000 <impure_data+0x210>
  60104152b0:	913b2000 	add	x0, x0, #0xec8
  60104152b4:	a8c27bfd 	ldp	x29, x30, [sp], #32
  60104152b8:	d65f03c0 	ret

00000060104152bc <xizi_uart_init>:
    }

static struct TraceTag hardkernel_tag;

static bool xizi_uart_init()
{
  60104152bc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  60104152c0:	910003fd 	mov	x29, sp
    struct XiziSerialDriver* p_uart_driver = hardkernel_uart_init(&hardkernel_tag);
  60104152c4:	d0008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  60104152c8:	911c0000 	add	x0, x0, #0x700
  60104152cc:	97fff15e 	bl	6010411844 <hardkernel_uart_init>
  60104152d0:	f9000fe0 	str	x0, [sp, #24]
    if (p_uart_driver == NULL) {
  60104152d4:	f9400fe0 	ldr	x0, [sp, #24]
  60104152d8:	f100001f 	cmp	x0, #0x0
  60104152dc:	54000181 	b.ne	601041530c <xizi_uart_init+0x50>  // b.any
        ERROR("uart driver init failed\n");
  60104152e0:	528006a2 	mov	w2, #0x35                  	// #53
  60104152e4:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104152e8:	911d6001 	add	x1, x0, #0x758
  60104152ec:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104152f0:	910e6000 	add	x0, x0, #0x398
  60104152f4:	97fffba1 	bl	6010414178 <printf_>
  60104152f8:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104152fc:	910ea000 	add	x0, x0, #0x3a8
  6010415300:	97fffb9e 	bl	6010414178 <printf_>
        return false;
  6010415304:	52800000 	mov	w0, #0x0                   	// #0
  6010415308:	1400001d 	b	601041537c <xizi_uart_init+0xc0>
    }

    struct TraceTag uart_driver_tag;
    if (!CreateResourceTag(&uart_driver_tag, &hardkernel_tag, "uart-ac-resource", TRACER_HARDKERNEL_AC_RESOURCE, p_uart_driver)) {
  601041530c:	910043e5 	add	x5, sp, #0x10
  6010415310:	f9400fe4 	ldr	x4, [sp, #24]
  6010415314:	52800043 	mov	w3, #0x2                   	// #2
  6010415318:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  601041531c:	910f2002 	add	x2, x0, #0x3c8
  6010415320:	d0008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010415324:	911c0001 	add	x1, x0, #0x700
  6010415328:	aa0503e0 	mov	x0, x5
  601041532c:	9400033d 	bl	6010416020 <CreateResourceTag>
  6010415330:	12001c00 	and	w0, w0, #0xff
  6010415334:	52000000 	eor	w0, w0, #0x1
  6010415338:	12001c00 	and	w0, w0, #0xff
  601041533c:	7100001f 	cmp	w0, #0x0
  6010415340:	54000180 	b.eq	6010415370 <xizi_uart_init+0xb4>  // b.none
        ERROR("Create uart resource failed.\n");
  6010415344:	52800762 	mov	w2, #0x3b                  	// #59
  6010415348:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  601041534c:	911d6001 	add	x1, x0, #0x758
  6010415350:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415354:	910e6000 	add	x0, x0, #0x398
  6010415358:	97fffb88 	bl	6010414178 <printf_>
  601041535c:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415360:	910f8000 	add	x0, x0, #0x3e0
  6010415364:	97fffb85 	bl	6010414178 <printf_>
        return false;
  6010415368:	52800000 	mov	w0, #0x0                   	// #0
  601041536c:	14000004 	b	601041537c <xizi_uart_init+0xc0>
    }

    serial_init(&uart_driver_tag);
  6010415370:	910043e0 	add	x0, sp, #0x10
  6010415374:	97fff1cc 	bl	6010411aa4 <serial_init>
    return true;
  6010415378:	52800020 	mov	w0, #0x1                   	// #1
}
  601041537c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  6010415380:	d65f03c0 	ret

0000006010415384 <xizi_intr_init>:

static bool xizi_intr_init()
{
  6010415384:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  6010415388:	910003fd 	mov	x29, sp
    /* init intr driver */
    struct XiziTrapDriver* p_intr_driver = hardkernel_intr_init(&hardkernel_tag);
  601041538c:	d0008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010415390:	911c0000 	add	x0, x0, #0x700
  6010415394:	97ffe829 	bl	601040f438 <hardkernel_intr_init>
  6010415398:	f90017e0 	str	x0, [sp, #40]
    if (UNLIKELY(p_intr_driver == NULL)) {
  601041539c:	f94017e0 	ldr	x0, [sp, #40]
  60104153a0:	f100001f 	cmp	x0, #0x0
  60104153a4:	1a9f17e0 	cset	w0, eq  // eq = none
  60104153a8:	12001c00 	and	w0, w0, #0xff
  60104153ac:	92401c00 	and	x0, x0, #0xff
  60104153b0:	f100001f 	cmp	x0, #0x0
  60104153b4:	54000180 	b.eq	60104153e4 <xizi_intr_init+0x60>  // b.none
        ERROR("intr driver init failed\n");
  60104153b8:	52800902 	mov	w2, #0x48                  	// #72
  60104153bc:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104153c0:	911da001 	add	x1, x0, #0x768
  60104153c4:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104153c8:	910e6000 	add	x0, x0, #0x398
  60104153cc:	97fffb6b 	bl	6010414178 <printf_>
  60104153d0:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104153d4:	91100000 	add	x0, x0, #0x400
  60104153d8:	97fffb68 	bl	6010414178 <printf_>
        return false;
  60104153dc:	52800000 	mov	w0, #0x0                   	// #0
  60104153e0:	14000055 	b	6010415534 <xizi_intr_init+0x1b0>
    }

    struct TraceTag intr_driver_tag = {};
  60104153e4:	f90013ff 	str	xzr, [sp, #32]
    if (!CreateResourceTag(&intr_driver_tag, &hardkernel_tag, "intr-ac-resource", TRACER_HARDKERNEL_AC_RESOURCE, p_intr_driver)) {
  60104153e8:	910083e5 	add	x5, sp, #0x20
  60104153ec:	f94017e4 	ldr	x4, [sp, #40]
  60104153f0:	52800043 	mov	w3, #0x2                   	// #2
  60104153f4:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104153f8:	91108002 	add	x2, x0, #0x420
  60104153fc:	d0008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010415400:	911c0001 	add	x1, x0, #0x700
  6010415404:	aa0503e0 	mov	x0, x5
  6010415408:	94000306 	bl	6010416020 <CreateResourceTag>
  601041540c:	12001c00 	and	w0, w0, #0xff
  6010415410:	52000000 	eor	w0, w0, #0x1
  6010415414:	12001c00 	and	w0, w0, #0xff
  6010415418:	7100001f 	cmp	w0, #0x0
  601041541c:	54000180 	b.eq	601041544c <xizi_intr_init+0xc8>  // b.none
        ERROR("Create intr resource failed.\n");
  6010415420:	528009c2 	mov	w2, #0x4e                  	// #78
  6010415424:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415428:	911da001 	add	x1, x0, #0x768
  601041542c:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415430:	910e6000 	add	x0, x0, #0x398
  6010415434:	97fffb51 	bl	6010414178 <printf_>
  6010415438:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  601041543c:	9110e000 	add	x0, x0, #0x438
  6010415440:	97fffb4e 	bl	6010414178 <printf_>
        return false;
  6010415444:	52800000 	mov	w0, #0x0                   	// #0
  6010415448:	1400003b 	b	6010415534 <xizi_intr_init+0x1b0>
    }

    /* grant rights to intr dispatcher */
    struct IrqDispatcherRightGroup irq_dispatcher_rights = { .intr_driver_tag = intr_driver_tag };
  601041544c:	f94013e0 	ldr	x0, [sp, #32]
  6010415450:	f9000fe0 	str	x0, [sp, #24]
    if (!intr_distributer_init(&irq_dispatcher_rights)) {
  6010415454:	910063e0 	add	x0, sp, #0x18
  6010415458:	940011d7 	bl	6010419bb4 <intr_distributer_init>
  601041545c:	12001c00 	and	w0, w0, #0xff
  6010415460:	52000000 	eor	w0, w0, #0x1
  6010415464:	12001c00 	and	w0, w0, #0xff
  6010415468:	7100001f 	cmp	w0, #0x0
  601041546c:	54000180 	b.eq	601041549c <xizi_intr_init+0x118>  // b.none
        ERROR("init intr distributer failed.\n");
  6010415470:	52800aa2 	mov	w2, #0x55                  	// #85
  6010415474:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415478:	911da001 	add	x1, x0, #0x768
  601041547c:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415480:	910e6000 	add	x0, x0, #0x398
  6010415484:	97fffb3d 	bl	6010414178 <printf_>
  6010415488:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  601041548c:	91116000 	add	x0, x0, #0x458
  6010415490:	97fffb3a 	bl	6010414178 <printf_>
        return false;
  6010415494:	52800000 	mov	w0, #0x0                   	// #0
  6010415498:	14000027 	b	6010415534 <xizi_intr_init+0x1b0>
    }

    /* grant rights to syscall dispatcher */
    struct SwiDispatcherRightGroup swi_dispatcher_rights = { .intr_driver_tag = intr_driver_tag };
  601041549c:	f94013e0 	ldr	x0, [sp, #32]
  60104154a0:	f9000be0 	str	x0, [sp, #16]
    if (!swi_distributer_init(&swi_dispatcher_rights)) {
  60104154a4:	910043e0 	add	x0, sp, #0x10
  60104154a8:	94001313 	bl	601041a0f4 <swi_distributer_init>
  60104154ac:	12001c00 	and	w0, w0, #0xff
  60104154b0:	52000000 	eor	w0, w0, #0x1
  60104154b4:	12001c00 	and	w0, w0, #0xff
  60104154b8:	7100001f 	cmp	w0, #0x0
  60104154bc:	54000180 	b.eq	60104154ec <xizi_intr_init+0x168>  // b.none
        ERROR("init syscall distributer failed.\n");
  60104154c0:	52800b82 	mov	w2, #0x5c                  	// #92
  60104154c4:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104154c8:	911da001 	add	x1, x0, #0x768
  60104154cc:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104154d0:	910e6000 	add	x0, x0, #0x398
  60104154d4:	97fffb29 	bl	6010414178 <printf_>
  60104154d8:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104154dc:	9111e000 	add	x0, x0, #0x478
  60104154e0:	97fffb26 	bl	6010414178 <printf_>
        return false;
  60104154e4:	52800000 	mov	w0, #0x0                   	// #0
  60104154e8:	14000013 	b	6010415534 <xizi_intr_init+0x1b0>
    }

    /* grant rights to spinlock module*/
    if (!module_spinlock_use_intr_init()) {
  60104154ec:	97ffef83 	bl	60104112f8 <module_spinlock_use_intr_init>
  60104154f0:	12001c00 	and	w0, w0, #0xff
  60104154f4:	52000000 	eor	w0, w0, #0x1
  60104154f8:	12001c00 	and	w0, w0, #0xff
  60104154fc:	7100001f 	cmp	w0, #0x0
  6010415500:	54000180 	b.eq	6010415530 <xizi_intr_init+0x1ac>  // b.none
        ERROR("spinlock init using interrupt failed\n");
  6010415504:	52800c42 	mov	w2, #0x62                  	// #98
  6010415508:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  601041550c:	911da001 	add	x1, x0, #0x768
  6010415510:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415514:	910e6000 	add	x0, x0, #0x398
  6010415518:	97fffb18 	bl	6010414178 <printf_>
  601041551c:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415520:	91128000 	add	x0, x0, #0x4a0
  6010415524:	97fffb15 	bl	6010414178 <printf_>
        return false;
  6010415528:	52800000 	mov	w0, #0x0                   	// #0
  601041552c:	14000002 	b	6010415534 <xizi_intr_init+0x1b0>
    }

    return true;
  6010415530:	52800020 	mov	w0, #0x1                   	// #1
}
  6010415534:	a8c37bfd 	ldp	x29, x30, [sp], #48
  6010415538:	d65f03c0 	ret

000000601041553c <xizi_gpt_init>:

static bool xizi_gpt_init()
{
  601041553c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  6010415540:	910003fd 	mov	x29, sp
  6010415544:	f9000bf3 	str	x19, [sp, #16]
    /* init clock driver and create clock driver tag */
    struct XiziClockDriver* p_clock_driver = hardkernel_clock_init(&hardkernel_tag);
  6010415548:	d0008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041554c:	911c0000 	add	x0, x0, #0x700
  6010415550:	97ffe4dd 	bl	601040e8c4 <hardkernel_clock_init>
  6010415554:	f9001fe0 	str	x0, [sp, #56]
    if (UNLIKELY(p_clock_driver == NULL)) {
  6010415558:	f9401fe0 	ldr	x0, [sp, #56]
  601041555c:	f100001f 	cmp	x0, #0x0
  6010415560:	1a9f17e0 	cset	w0, eq  // eq = none
  6010415564:	12001c00 	and	w0, w0, #0xff
  6010415568:	92401c00 	and	x0, x0, #0xff
  601041556c:	f100001f 	cmp	x0, #0x0
  6010415570:	54000180 	b.eq	60104155a0 <xizi_gpt_init+0x64>  // b.none
        ERROR("clock driver init failed\n");
  6010415574:	52800dc2 	mov	w2, #0x6e                  	// #110
  6010415578:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  601041557c:	911de001 	add	x1, x0, #0x778
  6010415580:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415584:	910e6000 	add	x0, x0, #0x398
  6010415588:	97fffafc 	bl	6010414178 <printf_>
  601041558c:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415590:	91132000 	add	x0, x0, #0x4c8
  6010415594:	97fffaf9 	bl	6010414178 <printf_>
        return false;
  6010415598:	52800000 	mov	w0, #0x0                   	// #0
  601041559c:	14000059 	b	6010415700 <xizi_gpt_init+0x1c4>
    }

    struct TraceTag clock_driver_tag;
    if (!CreateResourceTag(&clock_driver_tag, &hardkernel_tag, "clock-ac-resource", TRACER_HARDKERNEL_AC_RESOURCE, p_clock_driver)) {
  60104155a0:	9100a3e5 	add	x5, sp, #0x28
  60104155a4:	f9401fe4 	ldr	x4, [sp, #56]
  60104155a8:	52800043 	mov	w3, #0x2                   	// #2
  60104155ac:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104155b0:	9113a002 	add	x2, x0, #0x4e8
  60104155b4:	d0008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  60104155b8:	911c0001 	add	x1, x0, #0x700
  60104155bc:	aa0503e0 	mov	x0, x5
  60104155c0:	94000298 	bl	6010416020 <CreateResourceTag>
  60104155c4:	12001c00 	and	w0, w0, #0xff
  60104155c8:	52000000 	eor	w0, w0, #0x1
  60104155cc:	12001c00 	and	w0, w0, #0xff
  60104155d0:	7100001f 	cmp	w0, #0x0
  60104155d4:	54000180 	b.eq	6010415604 <xizi_gpt_init+0xc8>  // b.none
        ERROR("Create clock resource failed.\n");
  60104155d8:	52800e82 	mov	w2, #0x74                  	// #116
  60104155dc:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104155e0:	911de001 	add	x1, x0, #0x778
  60104155e4:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104155e8:	910e6000 	add	x0, x0, #0x398
  60104155ec:	97fffae3 	bl	6010414178 <printf_>
  60104155f0:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104155f4:	91140000 	add	x0, x0, #0x500
  60104155f8:	97fffae0 	bl	6010414178 <printf_>
        return false;
  60104155fc:	52800000 	mov	w0, #0x0                   	// #0
  6010415600:	14000040 	b	6010415700 <xizi_gpt_init+0x1c4>
    }

    /* enable clock interrupt */
    if (!clock_intr_handler_init(&clock_driver_tag)) {
  6010415604:	9100a3e0 	add	x0, sp, #0x28
  6010415608:	9400125f 	bl	6010419f84 <clock_intr_handler_init>
  601041560c:	12001c00 	and	w0, w0, #0xff
  6010415610:	52000000 	eor	w0, w0, #0x1
  6010415614:	12001c00 	and	w0, w0, #0xff
  6010415618:	7100001f 	cmp	w0, #0x0
  601041561c:	54000180 	b.eq	601041564c <xizi_gpt_init+0x110>  // b.none
        ERROR("clock interrupt init failed.\n");
  6010415620:	52800f42 	mov	w2, #0x7a                  	// #122
  6010415624:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415628:	911de001 	add	x1, x0, #0x778
  601041562c:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415630:	910e6000 	add	x0, x0, #0x398
  6010415634:	97fffad1 	bl	6010414178 <printf_>
  6010415638:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  601041563c:	91148000 	add	x0, x0, #0x520
  6010415640:	97ffface 	bl	6010414178 <printf_>
        return false;
  6010415644:	52800000 	mov	w0, #0x0                   	// #0
  6010415648:	1400002e 	b	6010415700 <xizi_gpt_init+0x1c4>
    }
    // get intr driver tag
    struct TraceTag intr_driver_tag;
    if (!AchieveResourceTag(&intr_driver_tag, &hardkernel_tag, "intr-ac-resource")) {
  601041564c:	910083e3 	add	x3, sp, #0x20
  6010415650:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415654:	91108002 	add	x2, x0, #0x420
  6010415658:	d0008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041565c:	911c0001 	add	x1, x0, #0x700
  6010415660:	aa0303e0 	mov	x0, x3
  6010415664:	940001f8 	bl	6010415e44 <AchieveResourceTag>
  6010415668:	12001c00 	and	w0, w0, #0xff
  601041566c:	52000000 	eor	w0, w0, #0x1
  6010415670:	12001c00 	and	w0, w0, #0xff
  6010415674:	7100001f 	cmp	w0, #0x0
  6010415678:	54000180 	b.eq	60104156a8 <xizi_gpt_init+0x16c>  // b.none
        ERROR("Achieve intr resource failed.\n");
  601041567c:	52801002 	mov	w2, #0x80                  	// #128
  6010415680:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415684:	911de001 	add	x1, x0, #0x778
  6010415688:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  601041568c:	910e6000 	add	x0, x0, #0x398
  6010415690:	97fffaba 	bl	6010414178 <printf_>
  6010415694:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415698:	91150000 	add	x0, x0, #0x540
  601041569c:	97fffab7 	bl	6010414178 <printf_>
        return false;
  60104156a0:	52800000 	mov	w0, #0x0                   	// #0
  60104156a4:	14000017 	b	6010415700 <xizi_gpt_init+0x1c4>
    }
    // register clock handler to intr
    struct XiziTrapDriver* p_intr_driver = (struct XiziTrapDriver*)AchieveResource(&intr_driver_tag);
  60104156a8:	910083e0 	add	x0, sp, #0x20
  60104156ac:	94000239 	bl	6010415f90 <AchieveResource>
  60104156b0:	f9001be0 	str	x0, [sp, #48]
    p_intr_driver->bind_irq_handler(p_clock_driver->get_clock_int(), xizi_clock_handler);
  60104156b4:	f9401be0 	ldr	x0, [sp, #48]
  60104156b8:	f9445413 	ldr	x19, [x0, #2216]
  60104156bc:	f9401fe0 	ldr	x0, [sp, #56]
  60104156c0:	f9400400 	ldr	x0, [x0, #8]
  60104156c4:	d63f0000 	blr	x0
  60104156c8:	2a0003e2 	mov	w2, w0
  60104156cc:	d0008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  60104156d0:	f942ac01 	ldr	x1, [x0, #1368]
  60104156d4:	2a0203e0 	mov	w0, w2
  60104156d8:	d63f0260 	blr	x19
    p_intr_driver->single_irq_enable(p_clock_driver->get_clock_int(), 0, 0);
  60104156dc:	f9401be0 	ldr	x0, [sp, #48]
  60104156e0:	f9444813 	ldr	x19, [x0, #2192]
  60104156e4:	f9401fe0 	ldr	x0, [sp, #56]
  60104156e8:	f9400400 	ldr	x0, [x0, #8]
  60104156ec:	d63f0000 	blr	x0
  60104156f0:	52800002 	mov	w2, #0x0                   	// #0
  60104156f4:	52800001 	mov	w1, #0x0                   	// #0
  60104156f8:	d63f0260 	blr	x19
    return true;
  60104156fc:	52800020 	mov	w0, #0x1                   	// #1
}
  6010415700:	f9400bf3 	ldr	x19, [sp, #16]
  6010415704:	a8c47bfd 	ldp	x29, x30, [sp], #64
  6010415708:	d65f03c0 	ret

000000601041570c <xizi_cache_init>:

static bool xizi_cache_init()
{
  601041570c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  6010415710:	910003fd 	mov	x29, sp
    struct TraceTag icache_driver_tag, dcache_driver_tag;

    struct ICacheDone* p_icache_done = hardkernel_icache_init(&hardkernel_tag);
  6010415714:	d0008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010415718:	911c0000 	add	x0, x0, #0x700
  601041571c:	97fffed2 	bl	6010415264 <hardkernel_icache_init>
  6010415720:	f90017e0 	str	x0, [sp, #40]
    if (UNLIKELY(p_icache_done == NULL)) {
  6010415724:	f94017e0 	ldr	x0, [sp, #40]
  6010415728:	f100001f 	cmp	x0, #0x0
  601041572c:	1a9f17e0 	cset	w0, eq  // eq = none
  6010415730:	12001c00 	and	w0, w0, #0xff
  6010415734:	92401c00 	and	x0, x0, #0xff
  6010415738:	f100001f 	cmp	x0, #0x0
  601041573c:	54000180 	b.eq	601041576c <xizi_cache_init+0x60>  // b.none
        ERROR("icache driver init failed.\n");
  6010415740:	52801202 	mov	w2, #0x90                  	// #144
  6010415744:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415748:	911e2001 	add	x1, x0, #0x788
  601041574c:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415750:	910e6000 	add	x0, x0, #0x398
  6010415754:	97fffa89 	bl	6010414178 <printf_>
  6010415758:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  601041575c:	91158000 	add	x0, x0, #0x560
  6010415760:	97fffa86 	bl	6010414178 <printf_>
        return false;
  6010415764:	52800000 	mov	w0, #0x0                   	// #0
  6010415768:	1400004a 	b	6010415890 <xizi_cache_init+0x184>
    }
    if (!CreateResourceTag(&icache_driver_tag, &hardkernel_tag, "icache-ac-resource", TRACER_HARDKERNEL_AC_RESOURCE, p_icache_done)) {
  601041576c:	910063e5 	add	x5, sp, #0x18
  6010415770:	f94017e4 	ldr	x4, [sp, #40]
  6010415774:	52800043 	mov	w3, #0x2                   	// #2
  6010415778:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  601041577c:	91160002 	add	x2, x0, #0x580
  6010415780:	d0008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010415784:	911c0001 	add	x1, x0, #0x700
  6010415788:	aa0503e0 	mov	x0, x5
  601041578c:	94000225 	bl	6010416020 <CreateResourceTag>
  6010415790:	12001c00 	and	w0, w0, #0xff
  6010415794:	52000000 	eor	w0, w0, #0x1
  6010415798:	12001c00 	and	w0, w0, #0xff
  601041579c:	7100001f 	cmp	w0, #0x0
  60104157a0:	54000180 	b.eq	60104157d0 <xizi_cache_init+0xc4>  // b.none
        ERROR("Create icache resource failed.\n");
  60104157a4:	52801282 	mov	w2, #0x94                  	// #148
  60104157a8:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104157ac:	911e2001 	add	x1, x0, #0x788
  60104157b0:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104157b4:	910e6000 	add	x0, x0, #0x398
  60104157b8:	97fffa70 	bl	6010414178 <printf_>
  60104157bc:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104157c0:	91166000 	add	x0, x0, #0x598
  60104157c4:	97fffa6d 	bl	6010414178 <printf_>
        return false;
  60104157c8:	52800000 	mov	w0, #0x0                   	// #0
  60104157cc:	14000031 	b	6010415890 <xizi_cache_init+0x184>
    }

    struct DCacheDone* p_dcache_done = hardkernel_dcache_init(&hardkernel_tag);
  60104157d0:	d0008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  60104157d4:	911c0000 	add	x0, x0, #0x700
  60104157d8:	97fffeae 	bl	6010415290 <hardkernel_dcache_init>
  60104157dc:	f90013e0 	str	x0, [sp, #32]
    if (UNLIKELY(p_dcache_done == NULL)) {
  60104157e0:	f94013e0 	ldr	x0, [sp, #32]
  60104157e4:	f100001f 	cmp	x0, #0x0
  60104157e8:	1a9f17e0 	cset	w0, eq  // eq = none
  60104157ec:	12001c00 	and	w0, w0, #0xff
  60104157f0:	92401c00 	and	x0, x0, #0xff
  60104157f4:	f100001f 	cmp	x0, #0x0
  60104157f8:	54000180 	b.eq	6010415828 <xizi_cache_init+0x11c>  // b.none
        ERROR("dcache driver init failed.\n");
  60104157fc:	52801342 	mov	w2, #0x9a                  	// #154
  6010415800:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415804:	911e2001 	add	x1, x0, #0x788
  6010415808:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  601041580c:	910e6000 	add	x0, x0, #0x398
  6010415810:	97fffa5a 	bl	6010414178 <printf_>
  6010415814:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415818:	9116e000 	add	x0, x0, #0x5b8
  601041581c:	97fffa57 	bl	6010414178 <printf_>
        return false;
  6010415820:	52800000 	mov	w0, #0x0                   	// #0
  6010415824:	1400001b 	b	6010415890 <xizi_cache_init+0x184>
    }
    if (!CreateResourceTag(&dcache_driver_tag, &hardkernel_tag, "dcache-ac-resource", TRACER_HARDKERNEL_AC_RESOURCE, p_dcache_done)) {
  6010415828:	910043e5 	add	x5, sp, #0x10
  601041582c:	f94013e4 	ldr	x4, [sp, #32]
  6010415830:	52800043 	mov	w3, #0x2                   	// #2
  6010415834:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415838:	91176002 	add	x2, x0, #0x5d8
  601041583c:	d0008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010415840:	911c0001 	add	x1, x0, #0x700
  6010415844:	aa0503e0 	mov	x0, x5
  6010415848:	940001f6 	bl	6010416020 <CreateResourceTag>
  601041584c:	12001c00 	and	w0, w0, #0xff
  6010415850:	52000000 	eor	w0, w0, #0x1
  6010415854:	12001c00 	and	w0, w0, #0xff
  6010415858:	7100001f 	cmp	w0, #0x0
  601041585c:	54000180 	b.eq	601041588c <xizi_cache_init+0x180>  // b.none
        ERROR("Create dcache resource failed.\n");
  6010415860:	528013c2 	mov	w2, #0x9e                  	// #158
  6010415864:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415868:	911e2001 	add	x1, x0, #0x788
  601041586c:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415870:	910e6000 	add	x0, x0, #0x398
  6010415874:	97fffa41 	bl	6010414178 <printf_>
  6010415878:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  601041587c:	9117c000 	add	x0, x0, #0x5f0
  6010415880:	97fffa3e 	bl	6010414178 <printf_>
        return false;
  6010415884:	52800000 	mov	w0, #0x0                   	// #0
  6010415888:	14000002 	b	6010415890 <xizi_cache_init+0x184>
    }

    return true;
  601041588c:	52800020 	mov	w0, #0x1                   	// #1
}
  6010415890:	a8c37bfd 	ldp	x29, x30, [sp], #48
  6010415894:	d65f03c0 	ret

0000006010415898 <xizi_mmu_init>:

static bool xizi_mmu_init()
{
  6010415898:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  601041589c:	910003fd 	mov	x29, sp
    struct MmuCommonDone* p_mmu_done = hardkernel_mmu_init(&hardkernel_tag, "icache-ac-resource", "dcache-ac-resource");
  60104158a0:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104158a4:	91176002 	add	x2, x0, #0x5d8
  60104158a8:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104158ac:	91160001 	add	x1, x0, #0x580
  60104158b0:	d0008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  60104158b4:	911c0000 	add	x0, x0, #0x700
  60104158b8:	97ffe444 	bl	601040e9c8 <hardkernel_mmu_init>
  60104158bc:	f9000fe0 	str	x0, [sp, #24]
    if (UNLIKELY(p_mmu_done == NULL)) {
  60104158c0:	f9400fe0 	ldr	x0, [sp, #24]
  60104158c4:	f100001f 	cmp	x0, #0x0
  60104158c8:	1a9f17e0 	cset	w0, eq  // eq = none
  60104158cc:	12001c00 	and	w0, w0, #0xff
  60104158d0:	92401c00 	and	x0, x0, #0xff
  60104158d4:	f100001f 	cmp	x0, #0x0
  60104158d8:	54000180 	b.eq	6010415908 <xizi_mmu_init+0x70>  // b.none
        ERROR("mmu driver init failed\n");
  60104158dc:	52801522 	mov	w2, #0xa9                  	// #169
  60104158e0:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104158e4:	911e6001 	add	x1, x0, #0x798
  60104158e8:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104158ec:	910e6000 	add	x0, x0, #0x398
  60104158f0:	97fffa22 	bl	6010414178 <printf_>
  60104158f4:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104158f8:	91184000 	add	x0, x0, #0x610
  60104158fc:	97fffa1f 	bl	6010414178 <printf_>
        return false;
  6010415900:	52800000 	mov	w0, #0x0                   	// #0
  6010415904:	1400000b 	b	6010415930 <xizi_mmu_init+0x98>
    }

    /* create trace for mmu driver */
    struct TraceTag mmu_driver_tag;
    CreateResourceTag(&mmu_driver_tag, &hardkernel_tag, "mmu-ac-resource", TRACER_HARDKERNEL_AC_RESOURCE, p_mmu_done);
  6010415908:	910043e5 	add	x5, sp, #0x10
  601041590c:	f9400fe4 	ldr	x4, [sp, #24]
  6010415910:	52800043 	mov	w3, #0x2                   	// #2
  6010415914:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415918:	9118a002 	add	x2, x0, #0x628
  601041591c:	d0008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010415920:	911c0001 	add	x1, x0, #0x700
  6010415924:	aa0503e0 	mov	x0, x5
  6010415928:	940001be 	bl	6010416020 <CreateResourceTag>

    return true;
  601041592c:	52800020 	mov	w0, #0x1                   	// #1
}
  6010415930:	a8c27bfd 	ldp	x29, x30, [sp], #32
  6010415934:	d65f03c0 	ret

0000006010415938 <hardkernel_init>:
    KERN_BOOT_DRIVER("mmu", "Xizi mmu driver initialized successfully.", xizi_mmu_init),
    KERN_BOOT_DRIVER("clock", "Xizi clock driver initialized successfully.", xizi_gpt_init),
};

bool hardkernel_init(struct TraceTag* _hardkernel_tag)
{
  6010415938:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  601041593c:	910003fd 	mov	x29, sp
  6010415940:	f9000fe0 	str	x0, [sp, #24]
    hardkernel_tag = *_hardkernel_tag;
  6010415944:	d0008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010415948:	911c0000 	add	x0, x0, #0x700
  601041594c:	f9400fe1 	ldr	x1, [sp, #24]
  6010415950:	f9400021 	ldr	x1, [x1]
  6010415954:	f9000001 	str	x1, [x0]

    for (uint32_t i = 0; i < sizeof(hardkernel_init_array) / sizeof(struct XiziBootNode); i++) {
  6010415958:	b9002fff 	str	wzr, [sp, #44]
  601041595c:	1400001e 	b	60104159d4 <hardkernel_init+0x9c>
        if (!hardkernel_init_array[i].init()) {
  6010415960:	d0008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010415964:	f942c801 	ldr	x1, [x0, #1424]
  6010415968:	b9402fe2 	ldr	w2, [sp, #44]
  601041596c:	d2800300 	mov	x0, #0x18                  	// #24
  6010415970:	9b007c40 	mul	x0, x2, x0
  6010415974:	8b000020 	add	x0, x1, x0
  6010415978:	f9400800 	ldr	x0, [x0, #16]
  601041597c:	d63f0000 	blr	x0
  6010415980:	12001c00 	and	w0, w0, #0xff
  6010415984:	52000000 	eor	w0, w0, #0x1
  6010415988:	12001c00 	and	w0, w0, #0xff
  601041598c:	7100001f 	cmp	w0, #0x0
  6010415990:	54000060 	b.eq	601041599c <hardkernel_init+0x64>  // b.none
            return false;
  6010415994:	52800000 	mov	w0, #0x0                   	// #0
  6010415998:	14000013 	b	60104159e4 <hardkernel_init+0xac>
        }
        LOG_PRINTF(hardkernel_init_array[i].bootinfo);
  601041599c:	d0008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  60104159a0:	f942c801 	ldr	x1, [x0, #1424]
  60104159a4:	b9402fe2 	ldr	w2, [sp, #44]
  60104159a8:	d2800300 	mov	x0, #0x18                  	// #24
  60104159ac:	9b007c40 	mul	x0, x2, x0
  60104159b0:	8b000020 	add	x0, x1, x0
  60104159b4:	f9400400 	ldr	x0, [x0, #8]
  60104159b8:	97fff9f0 	bl	6010414178 <printf_>
        LOG_PRINTF("\n");
  60104159bc:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104159c0:	911d4000 	add	x0, x0, #0x750
  60104159c4:	97fff9ed 	bl	6010414178 <printf_>
    for (uint32_t i = 0; i < sizeof(hardkernel_init_array) / sizeof(struct XiziBootNode); i++) {
  60104159c8:	b9402fe0 	ldr	w0, [sp, #44]
  60104159cc:	11000400 	add	w0, w0, #0x1
  60104159d0:	b9002fe0 	str	w0, [sp, #44]
  60104159d4:	b9402fe0 	ldr	w0, [sp, #44]
  60104159d8:	7100101f 	cmp	w0, #0x4
  60104159dc:	54fffc29 	b.ls	6010415960 <hardkernel_init+0x28>  // b.plast
    }
    return true;
  60104159e0:	52800020 	mov	w0, #0x1                   	// #1
}
  60104159e4:	a8c37bfd 	ldp	x29, x30, [sp], #48
  60104159e8:	d65f03c0 	ret

00000060104159ec <secondary_cpu_hardkernel_init>:

bool secondary_cpu_hardkernel_init(int cpu_id, struct TraceTag* _hardkernel_tag)
{
  60104159ec:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
  60104159f0:	910003fd 	mov	x29, sp
  60104159f4:	f9000bf3 	str	x19, [sp, #16]
  60104159f8:	b9002fe0 	str	w0, [sp, #44]
  60104159fc:	f90013e1 	str	x1, [sp, #32]
    struct TraceTag init_intr_tag, init_icache_tag, init_dcache_tag, init_clock_tag, init_mmu_tag;
    AchieveResourceTag(&init_intr_tag, _hardkernel_tag, "intr-ac-resource");
  6010415a00:	910163e3 	add	x3, sp, #0x58
  6010415a04:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415a08:	91108002 	add	x2, x0, #0x420
  6010415a0c:	f94013e1 	ldr	x1, [sp, #32]
  6010415a10:	aa0303e0 	mov	x0, x3
  6010415a14:	9400010c 	bl	6010415e44 <AchieveResourceTag>
    AchieveResourceTag(&init_icache_tag, _hardkernel_tag, "icache-ac-resource");
  6010415a18:	910143e3 	add	x3, sp, #0x50
  6010415a1c:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415a20:	91160002 	add	x2, x0, #0x580
  6010415a24:	f94013e1 	ldr	x1, [sp, #32]
  6010415a28:	aa0303e0 	mov	x0, x3
  6010415a2c:	94000106 	bl	6010415e44 <AchieveResourceTag>
    AchieveResourceTag(&init_dcache_tag, _hardkernel_tag, "dcache-ac-resource");
  6010415a30:	910123e3 	add	x3, sp, #0x48
  6010415a34:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415a38:	91176002 	add	x2, x0, #0x5d8
  6010415a3c:	f94013e1 	ldr	x1, [sp, #32]
  6010415a40:	aa0303e0 	mov	x0, x3
  6010415a44:	94000100 	bl	6010415e44 <AchieveResourceTag>
    AchieveResourceTag(&init_clock_tag, _hardkernel_tag, "clock-ac-resource");
  6010415a48:	910103e3 	add	x3, sp, #0x40
  6010415a4c:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415a50:	9113a002 	add	x2, x0, #0x4e8
  6010415a54:	f94013e1 	ldr	x1, [sp, #32]
  6010415a58:	aa0303e0 	mov	x0, x3
  6010415a5c:	940000fa 	bl	6010415e44 <AchieveResourceTag>
    AchieveResourceTag(&init_mmu_tag, _hardkernel_tag, "mmu-ac-resource");
  6010415a60:	9100e3e3 	add	x3, sp, #0x38
  6010415a64:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415a68:	9118a002 	add	x2, x0, #0x628
  6010415a6c:	f94013e1 	ldr	x1, [sp, #32]
  6010415a70:	aa0303e0 	mov	x0, x3
  6010415a74:	940000f4 	bl	6010415e44 <AchieveResourceTag>
    struct XiziTrapDriver* p_intr_driver = (struct XiziTrapDriver*)AchieveResource(&init_intr_tag);
  6010415a78:	910163e0 	add	x0, sp, #0x58
  6010415a7c:	94000145 	bl	6010415f90 <AchieveResource>
  6010415a80:	f9003fe0 	str	x0, [sp, #120]
    struct ICacheDone* p_icache_driver = (struct ICacheDone*)AchieveResource(&init_icache_tag);
  6010415a84:	910143e0 	add	x0, sp, #0x50
  6010415a88:	94000142 	bl	6010415f90 <AchieveResource>
  6010415a8c:	f9003be0 	str	x0, [sp, #112]
    struct DCacheDone* p_dcache_driver = (struct DCacheDone*)AchieveResource(&init_dcache_tag);
  6010415a90:	910123e0 	add	x0, sp, #0x48
  6010415a94:	9400013f 	bl	6010415f90 <AchieveResource>
  6010415a98:	f90037e0 	str	x0, [sp, #104]
    struct XiziClockDriver* p_clock_driver = (struct XiziClockDriver*)AchieveResource(&init_clock_tag);
  6010415a9c:	910103e0 	add	x0, sp, #0x40
  6010415aa0:	9400013c 	bl	6010415f90 <AchieveResource>
  6010415aa4:	f90033e0 	str	x0, [sp, #96]

    // secondary cpu init hardwares
    // intr
    p_intr_driver->sys_irq_init(cpu_id);
  6010415aa8:	f9403fe0 	ldr	x0, [sp, #120]
  6010415aac:	f9443801 	ldr	x1, [x0, #2160]
  6010415ab0:	b9402fe0 	ldr	w0, [sp, #44]
  6010415ab4:	d63f0020 	blr	x1
    p_intr_driver->cpu_irq_disable();
  6010415ab8:	f9403fe0 	ldr	x0, [sp, #120]
  6010415abc:	f9444400 	ldr	x0, [x0, #2184]
  6010415ac0:	d63f0000 	blr	x0
    // cache
    p_icache_driver->enable();
  6010415ac4:	f9403be0 	ldr	x0, [sp, #112]
  6010415ac8:	f9400000 	ldr	x0, [x0]
  6010415acc:	d63f0000 	blr	x0
    p_dcache_driver->enable();
  6010415ad0:	f94037e0 	ldr	x0, [sp, #104]
  6010415ad4:	f9400000 	ldr	x0, [x0]
  6010415ad8:	d63f0000 	blr	x0
    // clock
    p_intr_driver->single_irq_enable(p_clock_driver->get_clock_int(), cpu_id, 0);
  6010415adc:	f9403fe0 	ldr	x0, [sp, #120]
  6010415ae0:	f9444813 	ldr	x19, [x0, #2192]
  6010415ae4:	f94033e0 	ldr	x0, [sp, #96]
  6010415ae8:	f9400400 	ldr	x0, [x0, #8]
  6010415aec:	d63f0000 	blr	x0
  6010415af0:	52800002 	mov	w2, #0x0                   	// #0
  6010415af4:	b9402fe1 	ldr	w1, [sp, #44]
  6010415af8:	d63f0260 	blr	x19
    // mmu
    secondary_cpu_load_kern_pgdir(&init_mmu_tag, &init_intr_tag);
  6010415afc:	910163e1 	add	x1, sp, #0x58
  6010415b00:	9100e3e0 	add	x0, sp, #0x38
  6010415b04:	940005de 	bl	601041727c <secondary_cpu_load_kern_pgdir>
    return true;
  6010415b08:	52800020 	mov	w0, #0x1                   	// #1
  6010415b0c:	f9400bf3 	ldr	x19, [sp, #16]
  6010415b10:	a8c87bfd 	ldp	x29, x30, [sp], #128
  6010415b14:	d65f03c0 	ret

0000006010415b18 <tracer_init_node>:

static struct SysTracer sys_tracer;
static char root_name[TRACER_NODE_NAME_LEN] = "ROOT\0";

static void tracer_init_node(TracerNode* node, char* name, tracemeta_ac_type type, void* p_resource)
{
  6010415b18:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  6010415b1c:	910003fd 	mov	x29, sp
  6010415b20:	f90017e0 	str	x0, [sp, #40]
  6010415b24:	f90013e1 	str	x1, [sp, #32]
  6010415b28:	b9001fe2 	str	w2, [sp, #28]
  6010415b2c:	f9000be3 	str	x3, [sp, #16]
    node->type = type;
  6010415b30:	f94017e0 	ldr	x0, [sp, #40]
  6010415b34:	b9401fe1 	ldr	w1, [sp, #28]
  6010415b38:	b9000001 	str	w1, [x0]
    node->parent = NULL;
  6010415b3c:	f94017e0 	ldr	x0, [sp, #40]
  6010415b40:	f900101f 	str	xzr, [x0, #32]
    if (name != NULL) {
  6010415b44:	f94013e0 	ldr	x0, [sp, #32]
  6010415b48:	f100001f 	cmp	x0, #0x0
  6010415b4c:	540001c0 	b.eq	6010415b84 <tracer_init_node+0x6c>  // b.none
        char* p_name = (char*)slab_alloc(&sys_tracer.node_name_allocator);
  6010415b50:	d0008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010415b54:	911e0000 	add	x0, x0, #0x780
  6010415b58:	940009e3 	bl	60104182e4 <slab_alloc>
  6010415b5c:	f90027e0 	str	x0, [sp, #72]
        strcpy(p_name, name);
  6010415b60:	f94013e1 	ldr	x1, [sp, #32]
  6010415b64:	f94027e0 	ldr	x0, [sp, #72]
  6010415b68:	94002a46 	bl	6010420480 <strcpy>
        p_name[TRACER_NODE_NAME_LEN - 1] = '\0';
  6010415b6c:	f94027e0 	ldr	x0, [sp, #72]
  6010415b70:	91007c00 	add	x0, x0, #0x1f
  6010415b74:	3900001f 	strb	wzr, [x0]
        node->name = p_name;
  6010415b78:	f94017e0 	ldr	x0, [sp, #40]
  6010415b7c:	f94027e1 	ldr	x1, [sp, #72]
  6010415b80:	f9000401 	str	x1, [x0, #8]
    }
    if (node->type == TRACER_OWNER) {
  6010415b84:	f94017e0 	ldr	x0, [sp, #40]
  6010415b88:	b9400000 	ldr	w0, [x0]
  6010415b8c:	7100041f 	cmp	w0, #0x1
  6010415b90:	54000161 	b.ne	6010415bbc <tracer_init_node+0xa4>  // b.any
        doubleListNodeInit(&node->children_guard);
  6010415b94:	f94017e0 	ldr	x0, [sp, #40]
  6010415b98:	91004000 	add	x0, x0, #0x10
  6010415b9c:	f90023e0 	str	x0, [sp, #64]
    list->next = list;
  6010415ba0:	f94023e0 	ldr	x0, [sp, #64]
  6010415ba4:	f94023e1 	ldr	x1, [sp, #64]
  6010415ba8:	f9000001 	str	x1, [x0]
    list->prev = list;
  6010415bac:	f94023e0 	ldr	x0, [sp, #64]
  6010415bb0:	f94023e1 	ldr	x1, [sp, #64]
  6010415bb4:	f9000401 	str	x1, [x0, #8]
}
  6010415bb8:	14000004 	b	6010415bc8 <tracer_init_node+0xb0>
    } else {
        node->p_resource = p_resource;
  6010415bbc:	f94017e0 	ldr	x0, [sp, #40]
  6010415bc0:	f9400be1 	ldr	x1, [sp, #16]
  6010415bc4:	f9000801 	str	x1, [x0, #16]
    }
    doubleListNodeInit(&node->list_node);
  6010415bc8:	f94017e0 	ldr	x0, [sp, #40]
  6010415bcc:	9100a000 	add	x0, x0, #0x28
  6010415bd0:	f9001fe0 	str	x0, [sp, #56]
    list->next = list;
  6010415bd4:	f9401fe0 	ldr	x0, [sp, #56]
  6010415bd8:	f9401fe1 	ldr	x1, [sp, #56]
  6010415bdc:	f9000001 	str	x1, [x0]
    list->prev = list;
  6010415be0:	f9401fe0 	ldr	x0, [sp, #56]
  6010415be4:	f9401fe1 	ldr	x1, [sp, #56]
  6010415be8:	f9000401 	str	x1, [x0, #8]
}
  6010415bec:	d503201f 	nop
}
  6010415bf0:	d503201f 	nop
  6010415bf4:	a8c57bfd 	ldp	x29, x30, [sp], #80
  6010415bf8:	d65f03c0 	ret

0000006010415bfc <sys_tracer_init>:

void sys_tracer_init()
{
  6010415bfc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  6010415c00:	910003fd 	mov	x29, sp
    // set sys_tracer resource identity
    tracer_init_node(&sys_tracer.root_node, NULL, TRACER_OWNER, NULL);
  6010415c04:	d2800003 	mov	x3, #0x0                   	// #0
  6010415c08:	52800022 	mov	w2, #0x1                   	// #1
  6010415c0c:	d2800001 	mov	x1, #0x0                   	// #0
  6010415c10:	d0008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010415c14:	911c2000 	add	x0, x0, #0x708
  6010415c18:	97ffffc0 	bl	6010415b18 <tracer_init_node>
    sys_tracer.root_node.name = root_name;
  6010415c1c:	d0008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010415c20:	911c2000 	add	x0, x0, #0x708
  6010415c24:	f0000061 	adrp	x1, 6010424000 <impure_data+0x210>
  6010415c28:	913e0021 	add	x1, x1, #0xf80
  6010415c2c:	f9000401 	str	x1, [x0, #8]
    sys_tracer.sys_tracer_tag.meta = &sys_tracer.root_node;
  6010415c30:	d0008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010415c34:	911c2000 	add	x0, x0, #0x708
  6010415c38:	d0008961 	adrp	x1, 6011543000 <_binary_default_fs_start+0x96000>
  6010415c3c:	911c2021 	add	x1, x1, #0x708
  6010415c40:	f9001c01 	str	x1, [x0, #56]

    // init memory allocator
    slab_init(&sys_tracer.node_allocator, sizeof(TracerNode));
  6010415c44:	d2800701 	mov	x1, #0x38                  	// #56
  6010415c48:	d0008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010415c4c:	911d2000 	add	x0, x0, #0x748
  6010415c50:	9400096b 	bl	60104181fc <slab_init>
    slab_init(&sys_tracer.node_name_allocator, sizeof(char[TRACER_NODE_NAME_LEN]));
  6010415c54:	d2800401 	mov	x1, #0x20                  	// #32
  6010415c58:	d0008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010415c5c:	911e0000 	add	x0, x0, #0x780
  6010415c60:	94000967 	bl	60104181fc <slab_init>
}
  6010415c64:	d503201f 	nop
  6010415c68:	a8c17bfd 	ldp	x29, x30, [sp], #16
  6010415c6c:	d65f03c0 	ret

0000006010415c70 <parse_path>:

static char* parse_path(char* path, char* const name)
{
  6010415c70:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  6010415c74:	910003fd 	mov	x29, sp
  6010415c78:	f9000fe0 	str	x0, [sp, #24]
  6010415c7c:	f9000be1 	str	x1, [sp, #16]
    // skip extra '/'
    while (*path == '/') {
  6010415c80:	14000004 	b	6010415c90 <parse_path+0x20>
        path++;
  6010415c84:	f9400fe0 	ldr	x0, [sp, #24]
  6010415c88:	91000400 	add	x0, x0, #0x1
  6010415c8c:	f9000fe0 	str	x0, [sp, #24]
    while (*path == '/') {
  6010415c90:	f9400fe0 	ldr	x0, [sp, #24]
  6010415c94:	39400000 	ldrb	w0, [x0]
  6010415c98:	7100bc1f 	cmp	w0, #0x2f
  6010415c9c:	54ffff40 	b.eq	6010415c84 <parse_path+0x14>  // b.none
    }
    if (*path == '\0') {
  6010415ca0:	f9400fe0 	ldr	x0, [sp, #24]
  6010415ca4:	39400000 	ldrb	w0, [x0]
  6010415ca8:	7100001f 	cmp	w0, #0x0
  6010415cac:	54000061 	b.ne	6010415cb8 <parse_path+0x48>  // b.any
        return NULL;
  6010415cb0:	d2800000 	mov	x0, #0x0                   	// #0
  6010415cb4:	14000028 	b	6010415d54 <parse_path+0xe4>
    }

    // start of current name
    char* cur_start = path;
  6010415cb8:	f9400fe0 	ldr	x0, [sp, #24]
  6010415cbc:	f90017e0 	str	x0, [sp, #40]
    while (*path != '/' && *path != '\0') {
  6010415cc0:	14000004 	b	6010415cd0 <parse_path+0x60>
        path++;
  6010415cc4:	f9400fe0 	ldr	x0, [sp, #24]
  6010415cc8:	91000400 	add	x0, x0, #0x1
  6010415ccc:	f9000fe0 	str	x0, [sp, #24]
    while (*path != '/' && *path != '\0') {
  6010415cd0:	f9400fe0 	ldr	x0, [sp, #24]
  6010415cd4:	39400000 	ldrb	w0, [x0]
  6010415cd8:	7100bc1f 	cmp	w0, #0x2f
  6010415cdc:	540000a0 	b.eq	6010415cf0 <parse_path+0x80>  // b.none
  6010415ce0:	f9400fe0 	ldr	x0, [sp, #24]
  6010415ce4:	39400000 	ldrb	w0, [x0]
  6010415ce8:	7100001f 	cmp	w0, #0x0
  6010415cec:	54fffec1 	b.ne	6010415cc4 <parse_path+0x54>  // b.any
    }

    // handle current name
    int len = path - cur_start;
  6010415cf0:	f9400fe1 	ldr	x1, [sp, #24]
  6010415cf4:	f94017e0 	ldr	x0, [sp, #40]
  6010415cf8:	cb000020 	sub	x0, x1, x0
  6010415cfc:	b90027e0 	str	w0, [sp, #36]
    if (len >= TRACER_NODE_NAME_LEN) {
  6010415d00:	b94027e0 	ldr	w0, [sp, #36]
  6010415d04:	71007c1f 	cmp	w0, #0x1f
  6010415d08:	5400012d 	b.le	6010415d2c <parse_path+0xbc>
        strncpy(name, cur_start, TRACER_NODE_NAME_LEN);
  6010415d0c:	d2800402 	mov	x2, #0x20                  	// #32
  6010415d10:	f94017e1 	ldr	x1, [sp, #40]
  6010415d14:	f9400be0 	ldr	x0, [sp, #16]
  6010415d18:	94002a9a 	bl	6010420780 <strncpy>
        name[TRACER_NODE_NAME_LEN - 1] = '\0';
  6010415d1c:	f9400be0 	ldr	x0, [sp, #16]
  6010415d20:	91007c00 	add	x0, x0, #0x1f
  6010415d24:	3900001f 	strb	wzr, [x0]
  6010415d28:	1400000a 	b	6010415d50 <parse_path+0xe0>
    } else {
        strncpy(name, cur_start, len);
  6010415d2c:	b98027e0 	ldrsw	x0, [sp, #36]
  6010415d30:	aa0003e2 	mov	x2, x0
  6010415d34:	f94017e1 	ldr	x1, [sp, #40]
  6010415d38:	f9400be0 	ldr	x0, [sp, #16]
  6010415d3c:	94002a91 	bl	6010420780 <strncpy>
        name[len] = '\0';
  6010415d40:	b98027e0 	ldrsw	x0, [sp, #36]
  6010415d44:	f9400be1 	ldr	x1, [sp, #16]
  6010415d48:	8b000020 	add	x0, x1, x0
  6010415d4c:	3900001f 	strb	wzr, [x0]
    }

    return path;
  6010415d50:	f9400fe0 	ldr	x0, [sp, #24]
}
  6010415d54:	a8c37bfd 	ldp	x29, x30, [sp], #48
  6010415d58:	d65f03c0 	ret

0000006010415d5c <tracer_find_node_onestep>:

static TracerNode* tracer_find_node_onestep(TracerNode* const owner, const char* const name)
{
  6010415d5c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  6010415d60:	910003fd 	mov	x29, sp
  6010415d64:	f9000fe0 	str	x0, [sp, #24]
  6010415d68:	f9000be1 	str	x1, [sp, #16]
    TracerNode* iter = NULL;
  6010415d6c:	f90017ff 	str	xzr, [sp, #40]
    assert(owner->type == TRACER_OWNER);
  6010415d70:	f9400fe0 	ldr	x0, [sp, #24]
  6010415d74:	b9400000 	ldr	w0, [x0]
  6010415d78:	7100041f 	cmp	w0, #0x1
  6010415d7c:	540001e0 	b.eq	6010415db8 <tracer_find_node_onestep+0x5c>  // b.none
  6010415d80:	52800c82 	mov	w2, #0x64                  	// #100
  6010415d84:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415d88:	9127c001 	add	x1, x0, #0x9f0
  6010415d8c:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415d90:	911ea000 	add	x0, x0, #0x7a8
  6010415d94:	97fff8f9 	bl	6010414178 <printf_>
  6010415d98:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415d9c:	911ee001 	add	x1, x0, #0x7b8
  6010415da0:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415da4:	911f6000 	add	x0, x0, #0x7d8
  6010415da8:	97fff8f4 	bl	6010414178 <printf_>
  6010415dac:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415db0:	911fa000 	add	x0, x0, #0x7e8
  6010415db4:	97ffe53d 	bl	601040f2a8 <panic>
    DOUBLE_LIST_FOR_EACH_ENTRY(iter, &owner->children_guard, list_node)
  6010415db8:	f9400fe0 	ldr	x0, [sp, #24]
  6010415dbc:	f9400800 	ldr	x0, [x0, #16]
  6010415dc0:	d100a000 	sub	x0, x0, #0x28
  6010415dc4:	f90017e0 	str	x0, [sp, #40]
  6010415dc8:	14000013 	b	6010415e14 <tracer_find_node_onestep+0xb8>
    {
        if (iter->name == NULL) {
  6010415dcc:	f94017e0 	ldr	x0, [sp, #40]
  6010415dd0:	f9400400 	ldr	x0, [x0, #8]
  6010415dd4:	f100001f 	cmp	x0, #0x0
  6010415dd8:	54000140 	b.eq	6010415e00 <tracer_find_node_onestep+0xa4>  // b.none
            continue;
        }

        if (strcmp(name, iter->name) == 0) {
  6010415ddc:	f94017e0 	ldr	x0, [sp, #40]
  6010415de0:	f9400400 	ldr	x0, [x0, #8]
  6010415de4:	aa0003e1 	mov	x1, x0
  6010415de8:	f9400be0 	ldr	x0, [sp, #16]
  6010415dec:	94002965 	bl	6010420380 <strcmp>
  6010415df0:	7100001f 	cmp	w0, #0x0
  6010415df4:	54000081 	b.ne	6010415e04 <tracer_find_node_onestep+0xa8>  // b.any
            return iter;
  6010415df8:	f94017e0 	ldr	x0, [sp, #40]
  6010415dfc:	1400000d 	b	6010415e30 <tracer_find_node_onestep+0xd4>
            continue;
  6010415e00:	d503201f 	nop
    DOUBLE_LIST_FOR_EACH_ENTRY(iter, &owner->children_guard, list_node)
  6010415e04:	f94017e0 	ldr	x0, [sp, #40]
  6010415e08:	f9401400 	ldr	x0, [x0, #40]
  6010415e0c:	d100a000 	sub	x0, x0, #0x28
  6010415e10:	f90017e0 	str	x0, [sp, #40]
  6010415e14:	f94017e0 	ldr	x0, [sp, #40]
  6010415e18:	9100a001 	add	x1, x0, #0x28
  6010415e1c:	f9400fe0 	ldr	x0, [sp, #24]
  6010415e20:	91004000 	add	x0, x0, #0x10
  6010415e24:	eb00003f 	cmp	x1, x0
  6010415e28:	54fffd21 	b.ne	6010415dcc <tracer_find_node_onestep+0x70>  // b.any
        }
    }

    return NULL;
  6010415e2c:	d2800000 	mov	x0, #0x0                   	// #0
}
  6010415e30:	a8c37bfd 	ldp	x29, x30, [sp], #48
  6010415e34:	d65f03c0 	ret

0000006010415e38 <RequireRootTag>:

TraceTag* const RequireRootTag()
{
    return &sys_tracer.sys_tracer_tag;
  6010415e38:	d0008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010415e3c:	911d0000 	add	x0, x0, #0x740
}
  6010415e40:	d65f03c0 	ret

0000006010415e44 <AchieveResourceTag>:

bool AchieveResourceTag(TraceTag* target, TraceTag* owner, char* name)
{
  6010415e44:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  6010415e48:	910003fd 	mov	x29, sp
  6010415e4c:	f90017e0 	str	x0, [sp, #40]
  6010415e50:	f90013e1 	str	x1, [sp, #32]
  6010415e54:	f9000fe2 	str	x2, [sp, #24]
    static char name_buffer[TRACER_NODE_NAME_LEN];

    TracerNode* inner_node = owner->meta;
  6010415e58:	f94013e0 	ldr	x0, [sp, #32]
  6010415e5c:	f9400000 	ldr	x0, [x0]
  6010415e60:	f9001fe0 	str	x0, [sp, #56]
    assert(inner_node != NULL && inner_node->type == TRACER_OWNER);
  6010415e64:	f9401fe0 	ldr	x0, [sp, #56]
  6010415e68:	f100001f 	cmp	x0, #0x0
  6010415e6c:	540000a0 	b.eq	6010415e80 <AchieveResourceTag+0x3c>  // b.none
  6010415e70:	f9401fe0 	ldr	x0, [sp, #56]
  6010415e74:	b9400000 	ldr	w0, [x0]
  6010415e78:	7100041f 	cmp	w0, #0x1
  6010415e7c:	540006e0 	b.eq	6010415f58 <AchieveResourceTag+0x114>  // b.none
  6010415e80:	52800fa2 	mov	w2, #0x7d                  	// #125
  6010415e84:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415e88:	91284001 	add	x1, x0, #0xa10
  6010415e8c:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415e90:	911ea000 	add	x0, x0, #0x7a8
  6010415e94:	97fff8b9 	bl	6010414178 <printf_>
  6010415e98:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415e9c:	911fc001 	add	x1, x0, #0x7f0
  6010415ea0:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415ea4:	911f6000 	add	x0, x0, #0x7d8
  6010415ea8:	97fff8b4 	bl	6010414178 <printf_>
  6010415eac:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415eb0:	911fa000 	add	x0, x0, #0x7e8
  6010415eb4:	97ffe4fd 	bl	601040f2a8 <panic>
    while ((name = parse_path(name, name_buffer)) != NULL) {
  6010415eb8:	14000028 	b	6010415f58 <AchieveResourceTag+0x114>
        if ((inner_node = tracer_find_node_onestep(inner_node, name_buffer)) == NULL) {
  6010415ebc:	d0008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010415ec0:	911ee001 	add	x1, x0, #0x7b8
  6010415ec4:	f9401fe0 	ldr	x0, [sp, #56]
  6010415ec8:	97ffffa5 	bl	6010415d5c <tracer_find_node_onestep>
  6010415ecc:	f9001fe0 	str	x0, [sp, #56]
  6010415ed0:	f9401fe0 	ldr	x0, [sp, #56]
  6010415ed4:	f100001f 	cmp	x0, #0x0
  6010415ed8:	54000401 	b.ne	6010415f58 <AchieveResourceTag+0x114>  // b.any
            DEBUG("Tracer: No such object, owner: %s, child: %s\n", //
  6010415edc:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415ee0:	91284001 	add	x1, x0, #0xa10
  6010415ee4:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415ee8:	9120a000 	add	x0, x0, #0x828
  6010415eec:	97fff8a3 	bl	6010414178 <printf_>
  6010415ef0:	f94013e0 	ldr	x0, [sp, #32]
  6010415ef4:	f9400000 	ldr	x0, [x0]
  6010415ef8:	f9400400 	ldr	x0, [x0, #8]
  6010415efc:	f100001f 	cmp	x0, #0x0
  6010415f00:	540000a0 	b.eq	6010415f14 <AchieveResourceTag+0xd0>  // b.none
  6010415f04:	f94013e0 	ldr	x0, [sp, #32]
  6010415f08:	f9400000 	ldr	x0, [x0]
  6010415f0c:	f9400400 	ldr	x0, [x0, #8]
  6010415f10:	14000003 	b	6010415f1c <AchieveResourceTag+0xd8>
  6010415f14:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415f18:	9120e000 	add	x0, x0, #0x838
  6010415f1c:	f9400fe1 	ldr	x1, [sp, #24]
  6010415f20:	f100003f 	cmp	x1, #0x0
  6010415f24:	54000081 	b.ne	6010415f34 <AchieveResourceTag+0xf0>  // b.any
  6010415f28:	90000061 	adrp	x1, 6010421000 <__func__.0+0x508>
  6010415f2c:	9120e021 	add	x1, x1, #0x838
  6010415f30:	14000003 	b	6010415f3c <AchieveResourceTag+0xf8>
  6010415f34:	d0008961 	adrp	x1, 6011543000 <_binary_default_fs_start+0x96000>
  6010415f38:	911ee021 	add	x1, x1, #0x7b8
  6010415f3c:	aa0103e2 	mov	x2, x1
  6010415f40:	aa0003e1 	mov	x1, x0
  6010415f44:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415f48:	91210000 	add	x0, x0, #0x840
  6010415f4c:	97fff88b 	bl	6010414178 <printf_>
                owner->meta->name == NULL ? "NULL" : owner->meta->name, name == NULL ? "NULL" : name_buffer);
            return false;
  6010415f50:	52800000 	mov	w0, #0x0                   	// #0
  6010415f54:	1400000d 	b	6010415f88 <AchieveResourceTag+0x144>
    while ((name = parse_path(name, name_buffer)) != NULL) {
  6010415f58:	d0008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010415f5c:	911ee001 	add	x1, x0, #0x7b8
  6010415f60:	f9400fe0 	ldr	x0, [sp, #24]
  6010415f64:	97ffff43 	bl	6010415c70 <parse_path>
  6010415f68:	f9000fe0 	str	x0, [sp, #24]
  6010415f6c:	f9400fe0 	ldr	x0, [sp, #24]
  6010415f70:	f100001f 	cmp	x0, #0x0
  6010415f74:	54fffa41 	b.ne	6010415ebc <AchieveResourceTag+0x78>  // b.any
        }
    }

    target->meta = inner_node;
  6010415f78:	f94017e0 	ldr	x0, [sp, #40]
  6010415f7c:	f9401fe1 	ldr	x1, [sp, #56]
  6010415f80:	f9000001 	str	x1, [x0]
    return true;
  6010415f84:	52800020 	mov	w0, #0x1                   	// #1
}
  6010415f88:	a8c47bfd 	ldp	x29, x30, [sp], #64
  6010415f8c:	d65f03c0 	ret

0000006010415f90 <AchieveResource>:

void* AchieveResource(TraceTag* tag)
{
  6010415f90:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  6010415f94:	910003fd 	mov	x29, sp
  6010415f98:	f9000fe0 	str	x0, [sp, #24]
    assert(tag != NULL);
  6010415f9c:	f9400fe0 	ldr	x0, [sp, #24]
  6010415fa0:	f100001f 	cmp	x0, #0x0
  6010415fa4:	540001e1 	b.ne	6010415fe0 <AchieveResource+0x50>  // b.any
  6010415fa8:	52801182 	mov	w2, #0x8c                  	// #140
  6010415fac:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415fb0:	9128a001 	add	x1, x0, #0xa28
  6010415fb4:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415fb8:	911ea000 	add	x0, x0, #0x7a8
  6010415fbc:	97fff86f 	bl	6010414178 <printf_>
  6010415fc0:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415fc4:	9121c001 	add	x1, x0, #0x870
  6010415fc8:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415fcc:	911f6000 	add	x0, x0, #0x7d8
  6010415fd0:	97fff86a 	bl	6010414178 <printf_>
  6010415fd4:	90000060 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010415fd8:	911fa000 	add	x0, x0, #0x7e8
  6010415fdc:	97ffe4b3 	bl	601040f2a8 <panic>
    if (tag->meta == NULL || tag->meta->type == TRACER_OWNER) {
  6010415fe0:	f9400fe0 	ldr	x0, [sp, #24]
  6010415fe4:	f9400000 	ldr	x0, [x0]
  6010415fe8:	f100001f 	cmp	x0, #0x0
  6010415fec:	540000c0 	b.eq	6010416004 <AchieveResource+0x74>  // b.none
  6010415ff0:	f9400fe0 	ldr	x0, [sp, #24]
  6010415ff4:	f9400000 	ldr	x0, [x0]
  6010415ff8:	b9400000 	ldr	w0, [x0]
  6010415ffc:	7100041f 	cmp	w0, #0x1
  6010416000:	54000061 	b.ne	601041600c <AchieveResource+0x7c>  // b.any
        return NULL;
  6010416004:	d2800000 	mov	x0, #0x0                   	// #0
  6010416008:	14000004 	b	6010416018 <AchieveResource+0x88>
    }

    return tag->meta->p_resource;
  601041600c:	f9400fe0 	ldr	x0, [sp, #24]
  6010416010:	f9400000 	ldr	x0, [x0]
  6010416014:	f9400800 	ldr	x0, [x0, #16]
}
  6010416018:	a8c27bfd 	ldp	x29, x30, [sp], #32
  601041601c:	d65f03c0 	ret

0000006010416020 <CreateResourceTag>:

bool CreateResourceTag(TraceTag* new_tag, TraceTag* owner, char* name, tracemeta_ac_type type, void* p_resource)
{
  6010416020:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
  6010416024:	910003fd 	mov	x29, sp
  6010416028:	f9001fe0 	str	x0, [sp, #56]
  601041602c:	f9001be1 	str	x1, [sp, #48]
  6010416030:	f90017e2 	str	x2, [sp, #40]
  6010416034:	b90027e3 	str	w3, [sp, #36]
  6010416038:	f9000fe4 	str	x4, [sp, #24]
    assert(new_tag != NULL && owner != NULL);
  601041603c:	f9401fe0 	ldr	x0, [sp, #56]
  6010416040:	f100001f 	cmp	x0, #0x0
  6010416044:	54000080 	b.eq	6010416054 <CreateResourceTag+0x34>  // b.none
  6010416048:	f9401be0 	ldr	x0, [sp, #48]
  601041604c:	f100001f 	cmp	x0, #0x0
  6010416050:	540001e1 	b.ne	601041608c <CreateResourceTag+0x6c>  // b.any
  6010416054:	528012c2 	mov	w2, #0x96                  	// #150
  6010416058:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  601041605c:	9128e001 	add	x1, x0, #0xa38
  6010416060:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416064:	911ea000 	add	x0, x0, #0x7a8
  6010416068:	97fff844 	bl	6010414178 <printf_>
  601041606c:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416070:	91220001 	add	x1, x0, #0x880
  6010416074:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416078:	911f6000 	add	x0, x0, #0x7d8
  601041607c:	97fff83f 	bl	6010414178 <printf_>
  6010416080:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416084:	911fa000 	add	x0, x0, #0x7e8
  6010416088:	97ffe488 	bl	601040f2a8 <panic>
    if (owner->meta == NULL) {
  601041608c:	f9401be0 	ldr	x0, [sp, #48]
  6010416090:	f9400000 	ldr	x0, [x0]
  6010416094:	f100001f 	cmp	x0, #0x0
  6010416098:	54000181 	b.ne	60104160c8 <CreateResourceTag+0xa8>  // b.any
        ERROR("Tracer: Empty owner\n");
  601041609c:	52801302 	mov	w2, #0x98                  	// #152
  60104160a0:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104160a4:	9128e001 	add	x1, x0, #0xa38
  60104160a8:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104160ac:	911ea000 	add	x0, x0, #0x7a8
  60104160b0:	97fff832 	bl	6010414178 <printf_>
  60104160b4:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104160b8:	9122a000 	add	x0, x0, #0x8a8
  60104160bc:	97fff82f 	bl	6010414178 <printf_>
        return false;
  60104160c0:	52800000 	mov	w0, #0x0                   	// #0
  60104160c4:	14000057 	b	6010416220 <CreateResourceTag+0x200>
    }
    assert(owner->meta->type == TRACER_OWNER);
  60104160c8:	f9401be0 	ldr	x0, [sp, #48]
  60104160cc:	f9400000 	ldr	x0, [x0]
  60104160d0:	b9400000 	ldr	w0, [x0]
  60104160d4:	7100041f 	cmp	w0, #0x1
  60104160d8:	540001e0 	b.eq	6010416114 <CreateResourceTag+0xf4>  // b.none
  60104160dc:	52801362 	mov	w2, #0x9b                  	// #155
  60104160e0:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104160e4:	9128e001 	add	x1, x0, #0xa38
  60104160e8:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104160ec:	911ea000 	add	x0, x0, #0x7a8
  60104160f0:	97fff822 	bl	6010414178 <printf_>
  60104160f4:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104160f8:	91230001 	add	x1, x0, #0x8c0
  60104160fc:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416100:	911f6000 	add	x0, x0, #0x7d8
  6010416104:	97fff81d 	bl	6010414178 <printf_>
  6010416108:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  601041610c:	911fa000 	add	x0, x0, #0x7e8
  6010416110:	97ffe466 	bl	601040f2a8 <panic>
    if (tracer_find_node_onestep(owner->meta, name) != NULL) {
  6010416114:	f9401be0 	ldr	x0, [sp, #48]
  6010416118:	f9400000 	ldr	x0, [x0]
  601041611c:	f94017e1 	ldr	x1, [sp, #40]
  6010416120:	97ffff0f 	bl	6010415d5c <tracer_find_node_onestep>
  6010416124:	f100001f 	cmp	x0, #0x0
  6010416128:	54000060 	b.eq	6010416134 <CreateResourceTag+0x114>  // b.none
        return false;
  601041612c:	52800000 	mov	w0, #0x0                   	// #0
  6010416130:	1400003c 	b	6010416220 <CreateResourceTag+0x200>
    }

    TracerNode* new_node = (TracerNode*)slab_alloc(&sys_tracer.node_allocator);
  6010416134:	b0008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010416138:	911d2000 	add	x0, x0, #0x748
  601041613c:	9400086a 	bl	60104182e4 <slab_alloc>
  6010416140:	f90037e0 	str	x0, [sp, #104]
    if (new_node == NULL) {
  6010416144:	f94037e0 	ldr	x0, [sp, #104]
  6010416148:	f100001f 	cmp	x0, #0x0
  601041614c:	54000181 	b.ne	601041617c <CreateResourceTag+0x15c>  // b.any
        ERROR("Tracer: No memory for new node\n");
  6010416150:	52801442 	mov	w2, #0xa2                  	// #162
  6010416154:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416158:	9128e001 	add	x1, x0, #0xa38
  601041615c:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416160:	911ea000 	add	x0, x0, #0x7a8
  6010416164:	97fff805 	bl	6010414178 <printf_>
  6010416168:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  601041616c:	9123a000 	add	x0, x0, #0x8e8
  6010416170:	97fff802 	bl	6010414178 <printf_>
        return false;
  6010416174:	52800000 	mov	w0, #0x0                   	// #0
  6010416178:	1400002a 	b	6010416220 <CreateResourceTag+0x200>
    }
    tracer_init_node(new_node, name, type, p_resource);
  601041617c:	f9400fe3 	ldr	x3, [sp, #24]
  6010416180:	b94027e2 	ldr	w2, [sp, #36]
  6010416184:	f94017e1 	ldr	x1, [sp, #40]
  6010416188:	f94037e0 	ldr	x0, [sp, #104]
  601041618c:	97fffe63 	bl	6010415b18 <tracer_init_node>

    // new node add to owner's children list
    doubleListAddOnHead(&new_node->list_node, &owner->meta->children_guard);
  6010416190:	f94037e0 	ldr	x0, [sp, #104]
  6010416194:	9100a001 	add	x1, x0, #0x28
  6010416198:	f9401be0 	ldr	x0, [sp, #48]
  601041619c:	f9400000 	ldr	x0, [x0]
  60104161a0:	91004000 	add	x0, x0, #0x10
  60104161a4:	f90033e1 	str	x1, [sp, #96]
  60104161a8:	f9002fe0 	str	x0, [sp, #88]
    _double_list_add(new_node, head, head->next);
  60104161ac:	f9402fe0 	ldr	x0, [sp, #88]
  60104161b0:	f9400000 	ldr	x0, [x0]
  60104161b4:	f94033e1 	ldr	x1, [sp, #96]
  60104161b8:	f9002be1 	str	x1, [sp, #80]
  60104161bc:	f9402fe1 	ldr	x1, [sp, #88]
  60104161c0:	f90027e1 	str	x1, [sp, #72]
  60104161c4:	f90023e0 	str	x0, [sp, #64]
    next->prev = new_node;
  60104161c8:	f94023e0 	ldr	x0, [sp, #64]
  60104161cc:	f9402be1 	ldr	x1, [sp, #80]
  60104161d0:	f9000401 	str	x1, [x0, #8]
    new_node->next = next;
  60104161d4:	f9402be0 	ldr	x0, [sp, #80]
  60104161d8:	f94023e1 	ldr	x1, [sp, #64]
  60104161dc:	f9000001 	str	x1, [x0]
    new_node->prev = prev;
  60104161e0:	f9402be0 	ldr	x0, [sp, #80]
  60104161e4:	f94027e1 	ldr	x1, [sp, #72]
  60104161e8:	f9000401 	str	x1, [x0, #8]
    prev->next = new_node;
  60104161ec:	f94027e0 	ldr	x0, [sp, #72]
  60104161f0:	f9402be1 	ldr	x1, [sp, #80]
  60104161f4:	f9000001 	str	x1, [x0]
}
  60104161f8:	d503201f 	nop
}
  60104161fc:	d503201f 	nop
    new_node->parent = owner->meta;
  6010416200:	f9401be0 	ldr	x0, [sp, #48]
  6010416204:	f9400001 	ldr	x1, [x0]
  6010416208:	f94037e0 	ldr	x0, [sp, #104]
  601041620c:	f9001001 	str	x1, [x0, #32]

    new_tag->meta = new_node;
  6010416210:	f9401fe0 	ldr	x0, [sp, #56]
  6010416214:	f94037e1 	ldr	x1, [sp, #104]
  6010416218:	f9000001 	str	x1, [x0]
    return true;
  601041621c:	52800020 	mov	w0, #0x1                   	// #1
}
  6010416220:	a8c77bfd 	ldp	x29, x30, [sp], #112
  6010416224:	d65f03c0 	ret

0000006010416228 <DeleteResource>:

bool DeleteResource(TraceTag* target, TraceTag* owner)
{
  6010416228:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  601041622c:	910003fd 	mov	x29, sp
  6010416230:	f9000fe0 	str	x0, [sp, #24]
  6010416234:	f9000be1 	str	x1, [sp, #16]
    assert(target != NULL && owner != NULL);
  6010416238:	f9400fe0 	ldr	x0, [sp, #24]
  601041623c:	f100001f 	cmp	x0, #0x0
  6010416240:	54000080 	b.eq	6010416250 <DeleteResource+0x28>  // b.none
  6010416244:	f9400be0 	ldr	x0, [sp, #16]
  6010416248:	f100001f 	cmp	x0, #0x0
  601041624c:	540001e1 	b.ne	6010416288 <DeleteResource+0x60>  // b.any
  6010416250:	52801622 	mov	w2, #0xb1                  	// #177
  6010416254:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416258:	91294001 	add	x1, x0, #0xa50
  601041625c:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416260:	911ea000 	add	x0, x0, #0x7a8
  6010416264:	97fff7c5 	bl	6010414178 <printf_>
  6010416268:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  601041626c:	91242001 	add	x1, x0, #0x908
  6010416270:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416274:	911f6000 	add	x0, x0, #0x7d8
  6010416278:	97fff7c0 	bl	6010414178 <printf_>
  601041627c:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416280:	911fa000 	add	x0, x0, #0x7e8
  6010416284:	97ffe409 	bl	601040f2a8 <panic>
    assert(owner->meta != NULL && owner->meta->type == TRACER_OWNER);
  6010416288:	f9400be0 	ldr	x0, [sp, #16]
  601041628c:	f9400000 	ldr	x0, [x0]
  6010416290:	f100001f 	cmp	x0, #0x0
  6010416294:	540000c0 	b.eq	60104162ac <DeleteResource+0x84>  // b.none
  6010416298:	f9400be0 	ldr	x0, [sp, #16]
  601041629c:	f9400000 	ldr	x0, [x0]
  60104162a0:	b9400000 	ldr	w0, [x0]
  60104162a4:	7100041f 	cmp	w0, #0x1
  60104162a8:	540001e0 	b.eq	60104162e4 <DeleteResource+0xbc>  // b.none
  60104162ac:	52801642 	mov	w2, #0xb2                  	// #178
  60104162b0:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104162b4:	91294001 	add	x1, x0, #0xa50
  60104162b8:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104162bc:	911ea000 	add	x0, x0, #0x7a8
  60104162c0:	97fff7ae 	bl	6010414178 <printf_>
  60104162c4:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104162c8:	9124a001 	add	x1, x0, #0x928
  60104162cc:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104162d0:	911f6000 	add	x0, x0, #0x7d8
  60104162d4:	97fff7a9 	bl	6010414178 <printf_>
  60104162d8:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104162dc:	911fa000 	add	x0, x0, #0x7e8
  60104162e0:	97ffe3f2 	bl	601040f2a8 <panic>
    if (target->meta == NULL) {
  60104162e4:	f9400fe0 	ldr	x0, [sp, #24]
  60104162e8:	f9400000 	ldr	x0, [x0]
  60104162ec:	f100001f 	cmp	x0, #0x0
  60104162f0:	54000181 	b.ne	6010416320 <DeleteResource+0xf8>  // b.any
        ERROR("Tracer: Delete a empty resource\n");
  60104162f4:	52801682 	mov	w2, #0xb4                  	// #180
  60104162f8:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104162fc:	91294001 	add	x1, x0, #0xa50
  6010416300:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416304:	911ea000 	add	x0, x0, #0x7a8
  6010416308:	97fff79c 	bl	6010414178 <printf_>
  601041630c:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416310:	9125a000 	add	x0, x0, #0x968
  6010416314:	97fff799 	bl	6010414178 <printf_>
        return false;
  6010416318:	52800000 	mov	w0, #0x0                   	// #0
  601041631c:	1400005e 	b	6010416494 <DeleteResource+0x26c>
    }

    assert(target->meta->parent == owner->meta);
  6010416320:	f9400fe0 	ldr	x0, [sp, #24]
  6010416324:	f9400000 	ldr	x0, [x0]
  6010416328:	f9401001 	ldr	x1, [x0, #32]
  601041632c:	f9400be0 	ldr	x0, [sp, #16]
  6010416330:	f9400000 	ldr	x0, [x0]
  6010416334:	eb00003f 	cmp	x1, x0
  6010416338:	540001e0 	b.eq	6010416374 <DeleteResource+0x14c>  // b.none
  601041633c:	52801702 	mov	w2, #0xb8                  	// #184
  6010416340:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416344:	91294001 	add	x1, x0, #0xa50
  6010416348:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  601041634c:	911ea000 	add	x0, x0, #0x7a8
  6010416350:	97fff78a 	bl	6010414178 <printf_>
  6010416354:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416358:	91264001 	add	x1, x0, #0x990
  601041635c:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416360:	911f6000 	add	x0, x0, #0x7d8
  6010416364:	97fff785 	bl	6010414178 <printf_>
  6010416368:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  601041636c:	911fa000 	add	x0, x0, #0x7e8
  6010416370:	97ffe3ce 	bl	601040f2a8 <panic>
    doubleListDel(&target->meta->list_node);
  6010416374:	f9400fe0 	ldr	x0, [sp, #24]
  6010416378:	f9400000 	ldr	x0, [x0]
  601041637c:	9100a000 	add	x0, x0, #0x28
  6010416380:	f9001fe0 	str	x0, [sp, #56]

__attribute__((always_inline))
static void inline doubleListDel(struct double_list_node *entry)
{
    _double_list_del(entry->prev, entry->next);
  6010416384:	f9401fe0 	ldr	x0, [sp, #56]
  6010416388:	f9400401 	ldr	x1, [x0, #8]
  601041638c:	f9401fe0 	ldr	x0, [sp, #56]
  6010416390:	f9400000 	ldr	x0, [x0]
  6010416394:	f9001be1 	str	x1, [sp, #48]
  6010416398:	f90017e0 	str	x0, [sp, #40]
    next->prev = prev;
  601041639c:	f94017e0 	ldr	x0, [sp, #40]
  60104163a0:	f9401be1 	ldr	x1, [sp, #48]
  60104163a4:	f9000401 	str	x1, [x0, #8]
    prev->next = next;
  60104163a8:	f9401be0 	ldr	x0, [sp, #48]
  60104163ac:	f94017e1 	ldr	x1, [sp, #40]
  60104163b0:	f9000001 	str	x1, [x0]
}
  60104163b4:	d503201f 	nop
    entry->next = entry;
  60104163b8:	f9401fe0 	ldr	x0, [sp, #56]
  60104163bc:	f9401fe1 	ldr	x1, [sp, #56]
  60104163c0:	f9000001 	str	x1, [x0]
    entry->prev = entry;
  60104163c4:	f9401fe0 	ldr	x0, [sp, #56]
  60104163c8:	f9401fe1 	ldr	x1, [sp, #56]
  60104163cc:	f9000401 	str	x1, [x0, #8]
}
  60104163d0:	d503201f 	nop
    // delete name
    if (target->meta->name != NULL) {
  60104163d4:	f9400fe0 	ldr	x0, [sp, #24]
  60104163d8:	f9400000 	ldr	x0, [x0]
  60104163dc:	f9400400 	ldr	x0, [x0, #8]
  60104163e0:	f100001f 	cmp	x0, #0x0
  60104163e4:	54000100 	b.eq	6010416404 <DeleteResource+0x1dc>  // b.none
        slab_free(&sys_tracer.node_name_allocator, target->meta->name);
  60104163e8:	f9400fe0 	ldr	x0, [sp, #24]
  60104163ec:	f9400000 	ldr	x0, [x0]
  60104163f0:	f9400400 	ldr	x0, [x0, #8]
  60104163f4:	aa0003e1 	mov	x1, x0
  60104163f8:	b0008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  60104163fc:	911e0000 	add	x0, x0, #0x780
  6010416400:	940008a0 	bl	6010418680 <slab_free>
    }
    // delete all children
    /// @attention currently donot allow multilevel resource deletion
    if (target->meta->type == TRACER_OWNER) {
  6010416404:	f9400fe0 	ldr	x0, [sp, #24]
  6010416408:	f9400000 	ldr	x0, [x0]
  601041640c:	b9400000 	ldr	w0, [x0]
  6010416410:	7100041f 	cmp	w0, #0x1
  6010416414:	540002e1 	b.ne	6010416470 <DeleteResource+0x248>  // b.any
        assert(IS_DOUBLE_LIST_EMPTY(&target->meta->children_guard));
  6010416418:	f9400fe0 	ldr	x0, [sp, #24]
  601041641c:	f9400000 	ldr	x0, [x0]
  6010416420:	f9400801 	ldr	x1, [x0, #16]
  6010416424:	f9400fe0 	ldr	x0, [sp, #24]
  6010416428:	f9400000 	ldr	x0, [x0]
  601041642c:	91004000 	add	x0, x0, #0x10
  6010416430:	eb00003f 	cmp	x1, x0
  6010416434:	540001e0 	b.eq	6010416470 <DeleteResource+0x248>  // b.none
  6010416438:	52801822 	mov	w2, #0xc1                  	// #193
  601041643c:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416440:	91294001 	add	x1, x0, #0xa50
  6010416444:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416448:	911ea000 	add	x0, x0, #0x7a8
  601041644c:	97fff74b 	bl	6010414178 <printf_>
  6010416450:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416454:	9126e001 	add	x1, x0, #0x9b8
  6010416458:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  601041645c:	911f6000 	add	x0, x0, #0x7d8
  6010416460:	97fff746 	bl	6010414178 <printf_>
  6010416464:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416468:	911fa000 	add	x0, x0, #0x7e8
  601041646c:	97ffe38f 	bl	601040f2a8 <panic>
    }
    slab_free(&sys_tracer.node_allocator, target->meta);
  6010416470:	f9400fe0 	ldr	x0, [sp, #24]
  6010416474:	f9400000 	ldr	x0, [x0]
  6010416478:	aa0003e1 	mov	x1, x0
  601041647c:	b0008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010416480:	911d2000 	add	x0, x0, #0x748
  6010416484:	9400087f 	bl	6010418680 <slab_free>
    target->meta = NULL;
  6010416488:	f9400fe0 	ldr	x0, [sp, #24]
  601041648c:	f900001f 	str	xzr, [x0]
    return true;
  6010416490:	52800020 	mov	w0, #0x1                   	// #1
  6010416494:	a8c47bfd 	ldp	x29, x30, [sp], #64
  6010416498:	d65f03c0 	ret

000000601041649c <softkernel_init>:
#include "assert.h"
#include "log.h"
#include "task.h"

bool softkernel_init(struct TraceTag* _hardkernel_tag, struct TraceTag* _softkernel_tag)
{
  601041649c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  60104164a0:	910003fd 	mov	x29, sp
  60104164a4:	f9000fe0 	str	x0, [sp, #24]
  60104164a8:	f9000be1 	str	x1, [sp, #16]
    struct TraceTag server_identifier_owner;
    CreateResourceTag(&server_identifier_owner, _softkernel_tag, "server-identifier", TRACER_OWNER, NULL);
  60104164ac:	910123e5 	add	x5, sp, #0x48
  60104164b0:	d2800004 	mov	x4, #0x0                   	// #0
  60104164b4:	52800023 	mov	w3, #0x1                   	// #1
  60104164b8:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104164bc:	91298002 	add	x2, x0, #0xa60
  60104164c0:	f9400be1 	ldr	x1, [sp, #16]
  60104164c4:	aa0503e0 	mov	x0, x5
  60104164c8:	97fffed6 	bl	6010416020 <CreateResourceTag>

    /* init soft kernel */
    struct PagerRightGroup pager_rights;
    AchieveResourceTag(&pager_rights.mmu_driver_tag, _hardkernel_tag, "mmu-ac-resource");
  60104164cc:	910103e3 	add	x3, sp, #0x40
  60104164d0:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104164d4:	9129e002 	add	x2, x0, #0xa78
  60104164d8:	f9400fe1 	ldr	x1, [sp, #24]
  60104164dc:	aa0303e0 	mov	x0, x3
  60104164e0:	97fffe59 	bl	6010415e44 <AchieveResourceTag>
    module_pager_init(&pager_rights);
  60104164e4:	910103e0 	add	x0, sp, #0x40
  60104164e8:	94000301 	bl	60104170ec <module_pager_init>

    struct TraceTag mmu_driver_tag, intr_driver_tag;
    AchieveResourceTag(&mmu_driver_tag, _hardkernel_tag, "mmu-ac-resource");
  60104164ec:	9100e3e3 	add	x3, sp, #0x38
  60104164f0:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104164f4:	9129e002 	add	x2, x0, #0xa78
  60104164f8:	f9400fe1 	ldr	x1, [sp, #24]
  60104164fc:	aa0303e0 	mov	x0, x3
  6010416500:	97fffe51 	bl	6010415e44 <AchieveResourceTag>
    AchieveResourceTag(&intr_driver_tag, _hardkernel_tag, "intr-ac-resource");
  6010416504:	9100c3e3 	add	x3, sp, #0x30
  6010416508:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  601041650c:	912a2002 	add	x2, x0, #0xa88
  6010416510:	f9400fe1 	ldr	x1, [sp, #24]
  6010416514:	aa0303e0 	mov	x0, x3
  6010416518:	97fffe4b 	bl	6010415e44 <AchieveResourceTag>
    load_kern_pgdir(&mmu_driver_tag, &intr_driver_tag); // enter kernel virtmem space
  601041651c:	9100c3e1 	add	x1, sp, #0x30
  6010416520:	9100e3e0 	add	x0, sp, #0x38
  6010416524:	94000309 	bl	6010417148 <load_kern_pgdir>

    module_task_manager_init(); // init task
  6010416528:	94001582 	bl	601041bb30 <module_task_manager_init>

    struct SharePageRightGroup sp_rights;
    AchieveResourceTag(&sp_rights.dcache_driver_tag, _hardkernel_tag, "dcache-ac-resource");
  601041652c:	910083e3 	add	x3, sp, #0x20
  6010416530:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416534:	912a8002 	add	x2, x0, #0xaa0
  6010416538:	f9400fe1 	ldr	x1, [sp, #24]
  601041653c:	aa0303e0 	mov	x0, x3
  6010416540:	97fffe41 	bl	6010415e44 <AchieveResourceTag>
    AchieveResourceTag(&sp_rights.mmu_driver_tag, _hardkernel_tag, "mmu-ac-resource");
  6010416544:	910083e0 	add	x0, sp, #0x20
  6010416548:	91002003 	add	x3, x0, #0x8
  601041654c:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416550:	9129e002 	add	x2, x0, #0xa78
  6010416554:	f9400fe1 	ldr	x1, [sp, #24]
  6010416558:	aa0303e0 	mov	x0, x3
  601041655c:	97fffe3a 	bl	6010415e44 <AchieveResourceTag>
    module_share_page_init(&sp_rights);
  6010416560:	910083e0 	add	x0, sp, #0x20
  6010416564:	94000d7a 	bl	6010419b4c <module_share_page_init>

    return true;
  6010416568:	52800020 	mov	w0, #0x1                   	// #1
}
  601041656c:	a8c57bfd 	ldp	x29, x30, [sp], #80
  6010416570:	d65f03c0 	ret

0000006010416574 <show_xizi_bar>:

void show_xizi_bar(void)
{
  6010416574:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  6010416578:	910003fd 	mov	x29, sp
    LOG_PRINTF("__  _____ ________     __  __ ___ ____ ____   ___\n");
  601041657c:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416580:	912ae000 	add	x0, x0, #0xab8
  6010416584:	97fff6fd 	bl	6010414178 <printf_>
    LOG_PRINTF("\\ \\/ /_ _|__  /_ _|   |  \\/  |_ _/ ___|  _ \\ / _ \\\n");
  6010416588:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  601041658c:	912bc000 	add	x0, x0, #0xaf0
  6010416590:	97fff6fa 	bl	6010414178 <printf_>
    LOG_PRINTF(" \\  / | |  / / | |    | |\\/| || | |   | |_) | | | |\n");
  6010416594:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416598:	912ca000 	add	x0, x0, #0xb28
  601041659c:	97fff6f7 	bl	6010414178 <printf_>
    LOG_PRINTF(" /  \\ | | / /_ | |    | |  | || | |___|  _ <| |_| |\n");
  60104165a0:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104165a4:	912d8000 	add	x0, x0, #0xb60
  60104165a8:	97fff6f4 	bl	6010414178 <printf_>
    LOG_PRINTF("/_/\\_\\___/____|___|   |_|  |_|___\\____|_| \\_\\\\___/ \n");
  60104165ac:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104165b0:	912e6000 	add	x0, x0, #0xb98
  60104165b4:	97fff6f1 	bl	6010414178 <printf_>
  60104165b8:	d503201f 	nop
  60104165bc:	a8c17bfd 	ldp	x29, x30, [sp], #16
  60104165c0:	d65f03c0 	ret

00000060104165c4 <module_phymem_init>:
struct KBuddy kern_virtmem_buddy;
struct KBuddy user_phy_freemem_buddy;

extern uintptr_t kernel_data_end[];
bool module_phymem_init()
{
  60104165c4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  60104165c8:	910003fd 	mov	x29, sp
    uintptr_t kern_freemem_start = V2P(kernel_data_end);
  60104165cc:	b0008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  60104165d0:	f942c001 	ldr	x1, [x0, #1408]
  60104165d4:	d2dff400 	mov	x0, #0xffa000000000        	// #281062659850240
  60104165d8:	f2ffffe0 	movk	x0, #0xffff, lsl #48
  60104165dc:	8b000020 	add	x0, x1, x0
  60104165e0:	f90017e0 	str	x0, [sp, #40]
    uintptr_t kern_freemem_end = PHY_USER_FREEMEM_BASE;
  60104165e4:	d2a60000 	mov	x0, #0x30000000            	// #805306368
  60104165e8:	f90013e0 	str	x0, [sp, #32]
    uintptr_t user_freemem_start = PHY_USER_FREEMEM_BASE;
  60104165ec:	d2a60000 	mov	x0, #0x30000000            	// #805306368
  60104165f0:	f9000fe0 	str	x0, [sp, #24]
    uintptr_t user_freemem_end = PHY_MEM_STOP;
  60104165f4:	d2a80000 	mov	x0, #0x40000000            	// #1073741824
  60104165f8:	f9000be0 	str	x0, [sp, #16]
    user_phy_freemem_buddy.pages = NULL;
  60104165fc:	b0008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010416600:	f9429800 	ldr	x0, [x0, #1328]
  6010416604:	f900a41f 	str	xzr, [x0, #328]
    KBuddySysInit(&kern_virtmem_buddy, kern_freemem_start, kern_freemem_end);
  6010416608:	f94013e2 	ldr	x2, [sp, #32]
  601041660c:	f94017e1 	ldr	x1, [sp, #40]
  6010416610:	b0008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010416614:	f942d400 	ldr	x0, [x0, #1448]
  6010416618:	9400063d 	bl	6010417f0c <KBuddySysInit>
    KBuddyInit(&user_phy_freemem_buddy, user_freemem_start, user_freemem_end);
  601041661c:	f9400be2 	ldr	x2, [sp, #16]
  6010416620:	f9400fe1 	ldr	x1, [sp, #24]
  6010416624:	b0008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010416628:	f9429800 	ldr	x0, [x0, #1328]
  601041662c:	940005ab 	bl	6010417cd8 <KBuddyInit>
    return true;
  6010416630:	52800020 	mov	w0, #0x1                   	// #1
}
  6010416634:	a8c37bfd 	ldp	x29, x30, [sp], #48
  6010416638:	d65f03c0 	ret

000000601041663c <kalloc>:

char* kalloc(size_t size)
{
  601041663c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  6010416640:	910003fd 	mov	x29, sp
  6010416644:	f9000fe0 	str	x0, [sp, #24]
    char* mem_alloc = KBuddyAlloc(&kern_virtmem_buddy, size);
  6010416648:	f9400fe1 	ldr	x1, [sp, #24]
  601041664c:	b0008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010416650:	f942d400 	ldr	x0, [x0, #1448]
  6010416654:	9400063e 	bl	6010417f4c <KBuddyAlloc>
  6010416658:	f90017e0 	str	x0, [sp, #40]
    if (mem_alloc == NULL) {
  601041665c:	f94017e0 	ldr	x0, [sp, #40]
  6010416660:	f100001f 	cmp	x0, #0x0
  6010416664:	54000061 	b.ne	6010416670 <kalloc+0x34>  // b.any
        return NULL;
  6010416668:	d2800000 	mov	x0, #0x0                   	// #0
  601041666c:	14000033 	b	6010416738 <kalloc+0xfc>
    }
    assert((uintptr_t)mem_alloc >= V2P(&kernel_data_end) && (uintptr_t)mem_alloc < PHY_USER_FREEMEM_BASE);
  6010416670:	f94017e1 	ldr	x1, [sp, #40]
  6010416674:	b0008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010416678:	f942c002 	ldr	x2, [x0, #1408]
  601041667c:	d2dff400 	mov	x0, #0xffa000000000        	// #281062659850240
  6010416680:	f2ffffe0 	movk	x0, #0xffff, lsl #48
  6010416684:	8b000040 	add	x0, x2, x0
  6010416688:	eb00003f 	cmp	x1, x0
  601041668c:	540000a3 	b.cc	60104166a0 <kalloc+0x64>  // b.lo, b.ul, b.last
  6010416690:	f94017e1 	ldr	x1, [sp, #40]
  6010416694:	12ba0000 	mov	w0, #0x2fffffff            	// #805306367
  6010416698:	eb00003f 	cmp	x1, x0
  601041669c:	540001e9 	b.ls	60104166d8 <kalloc+0x9c>  // b.plast
  60104166a0:	52800742 	mov	w2, #0x3a                  	// #58
  60104166a4:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104166a8:	91328001 	add	x1, x0, #0xca0
  60104166ac:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104166b0:	912f4000 	add	x0, x0, #0xbd0
  60104166b4:	97fff6b1 	bl	6010414178 <printf_>
  60104166b8:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104166bc:	912f8001 	add	x1, x0, #0xbe0
  60104166c0:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104166c4:	91310000 	add	x0, x0, #0xc40
  60104166c8:	97fff6ac 	bl	6010414178 <printf_>
  60104166cc:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104166d0:	91314000 	add	x0, x0, #0xc50
  60104166d4:	97ffe2f5 	bl	601040f2a8 <panic>
    mem_alloc = P2V(mem_alloc);
  60104166d8:	f94017e1 	ldr	x1, [sp, #40]
  60104166dc:	d2c00c00 	mov	x0, #0x6000000000          	// #412316860416
  60104166e0:	8b000020 	add	x0, x1, x0
  60104166e4:	f90017e0 	str	x0, [sp, #40]
    if ((uintptr_t)mem_alloc < KERN_MEM_BASE) {
  60104166e8:	f94017e1 	ldr	x1, [sp, #40]
  60104166ec:	b2406fe0 	mov	x0, #0xfffffff             	// #268435455
  60104166f0:	f2c00c00 	movk	x0, #0x60, lsl #32
  60104166f4:	eb00003f 	cmp	x1, x0
  60104166f8:	54000168 	b.hi	6010416724 <kalloc+0xe8>  // b.pmore
        DEBUG("Error Alloc: %x by size: %d (Caused by double free)\n", mem_alloc, size);
  60104166fc:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416700:	91328001 	add	x1, x0, #0xca0
  6010416704:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416708:	91316000 	add	x0, x0, #0xc58
  601041670c:	97fff69b 	bl	6010414178 <printf_>
  6010416710:	f9400fe2 	ldr	x2, [sp, #24]
  6010416714:	f94017e1 	ldr	x1, [sp, #40]
  6010416718:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  601041671c:	9131a000 	add	x0, x0, #0xc68
  6010416720:	97fff696 	bl	6010414178 <printf_>
    }
    memset(mem_alloc, 0, size);
  6010416724:	f9400fe2 	ldr	x2, [sp, #24]
  6010416728:	52800001 	mov	w1, #0x0                   	// #0
  601041672c:	f94017e0 	ldr	x0, [sp, #40]
  6010416730:	97ffdee4 	bl	601040e2c0 <memset>
    return mem_alloc;
  6010416734:	f94017e0 	ldr	x0, [sp, #40]
}
  6010416738:	a8c37bfd 	ldp	x29, x30, [sp], #48
  601041673c:	d65f03c0 	ret

0000006010416740 <kfree>:

bool kfree(char* vaddr)
{
  6010416740:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  6010416744:	910003fd 	mov	x29, sp
  6010416748:	f9000fe0 	str	x0, [sp, #24]
    return KBuddyFree(&kern_virtmem_buddy, V2P_WO(vaddr));
  601041674c:	f9400fe1 	ldr	x1, [sp, #24]
  6010416750:	d2dff400 	mov	x0, #0xffa000000000        	// #281062659850240
  6010416754:	f2ffffe0 	movk	x0, #0xffff, lsl #48
  6010416758:	8b000020 	add	x0, x1, x0
  601041675c:	aa0003e1 	mov	x1, x0
  6010416760:	b0008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010416764:	f942d400 	ldr	x0, [x0, #1448]
  6010416768:	94000623 	bl	6010417ff4 <KBuddyFree>
  601041676c:	12001c00 	and	w0, w0, #0xff
}
  6010416770:	a8c27bfd 	ldp	x29, x30, [sp], #32
  6010416774:	d65f03c0 	ret

0000006010416778 <raw_alloc>:

char* raw_alloc(size_t size)
{
  6010416778:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  601041677c:	910003fd 	mov	x29, sp
  6010416780:	f9000fe0 	str	x0, [sp, #24]
    char* mem_alloc = KBuddyAlloc(&user_phy_freemem_buddy, size);
  6010416784:	f9400fe1 	ldr	x1, [sp, #24]
  6010416788:	b0008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041678c:	f9429800 	ldr	x0, [x0, #1328]
  6010416790:	940005ef 	bl	6010417f4c <KBuddyAlloc>
  6010416794:	f90017e0 	str	x0, [sp, #40]
    if (mem_alloc == NULL) {
  6010416798:	f94017e0 	ldr	x0, [sp, #40]
  601041679c:	f100001f 	cmp	x0, #0x0
  60104167a0:	54000061 	b.ne	60104167ac <raw_alloc+0x34>  // b.any
        return NULL;
  60104167a4:	d2800000 	mov	x0, #0x0                   	// #0
  60104167a8:	14000002 	b	60104167b0 <raw_alloc+0x38>
    }
    return mem_alloc;
  60104167ac:	f94017e0 	ldr	x0, [sp, #40]
}
  60104167b0:	a8c37bfd 	ldp	x29, x30, [sp], #48
  60104167b4:	d65f03c0 	ret

00000060104167b8 <raw_free>:

bool raw_free(char* paddr)
{
  60104167b8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  60104167bc:	910003fd 	mov	x29, sp
  60104167c0:	f9000fe0 	str	x0, [sp, #24]
    return KBuddyFree(&user_phy_freemem_buddy, paddr);
  60104167c4:	f9400fe1 	ldr	x1, [sp, #24]
  60104167c8:	b0008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  60104167cc:	f9429800 	ldr	x0, [x0, #1328]
  60104167d0:	94000609 	bl	6010417ff4 <KBuddyFree>
  60104167d4:	12001c00 	and	w0, w0, #0xff
}
  60104167d8:	a8c27bfd 	ldp	x29, x30, [sp], #32
  60104167dc:	d65f03c0 	ret

00000060104167e0 <show_phymem_info>:

void show_phymem_info()
{
  60104167e0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  60104167e4:	910003fd 	mov	x29, sp
    KFreePagesInfo(&user_phy_freemem_buddy);
  60104167e8:	b0008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  60104167ec:	f9429800 	ldr	x0, [x0, #1328]
  60104167f0:	94000660 	bl	6010418170 <KFreePagesInfo>
  60104167f4:	d503201f 	nop
  60104167f8:	a8c17bfd 	ldp	x29, x30, [sp], #16
  60104167fc:	d65f03c0 	ret

0000006010416800 <_new_pgdir>:
#include "pagetable.h"

static struct PagerRightGroup right_group;
struct MmuCommonDone* _p_pgtbl_mmu_access = NULL;
static bool _new_pgdir(struct TopLevelPageDirectory* pgdir)
{
  6010416800:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  6010416804:	910003fd 	mov	x29, sp
  6010416808:	f9000fe0 	str	x0, [sp, #24]
    void* new_pgdir_addr = 0;
  601041680c:	f90017ff 	str	xzr, [sp, #40]
    if (UNLIKELY((new_pgdir_addr = kalloc(TOPLEVLE_PAGEDIR_SIZE)) == NULL)) {
  6010416810:	d2820000 	mov	x0, #0x1000                	// #4096
  6010416814:	97ffff8a 	bl	601041663c <kalloc>
  6010416818:	f90017e0 	str	x0, [sp, #40]
  601041681c:	f94017e0 	ldr	x0, [sp, #40]
  6010416820:	f100001f 	cmp	x0, #0x0
  6010416824:	1a9f17e0 	cset	w0, eq  // eq = none
  6010416828:	12001c00 	and	w0, w0, #0xff
  601041682c:	92401c00 	and	x0, x0, #0xff
  6010416830:	f100001f 	cmp	x0, #0x0
  6010416834:	54000060 	b.eq	6010416840 <_new_pgdir+0x40>  // b.none
        return false;
  6010416838:	52800000 	mov	w0, #0x0                   	// #0
  601041683c:	14000009 	b	6010416860 <_new_pgdir+0x60>
    }

    pgdir->pd_addr = new_pgdir_addr;
  6010416840:	f9400fe0 	ldr	x0, [sp, #24]
  6010416844:	f94017e1 	ldr	x1, [sp, #40]
  6010416848:	f9000001 	str	x1, [x0]

    memset(new_pgdir_addr, 0, TOPLEVLE_PAGEDIR_SIZE);
  601041684c:	d2820002 	mov	x2, #0x1000                	// #4096
  6010416850:	52800001 	mov	w1, #0x0                   	// #0
  6010416854:	f94017e0 	ldr	x0, [sp, #40]
  6010416858:	97ffde9a 	bl	601040e2c0 <memset>
    return true;
  601041685c:	52800020 	mov	w0, #0x1                   	// #1
}
  6010416860:	a8c37bfd 	ldp	x29, x30, [sp], #48
  6010416864:	d65f03c0 	ret

0000006010416868 <_map_pages>:

static bool _map_pages(uintptr_t* pgdir, uintptr_t vaddr, uintptr_t paddr, int len, uintptr_t attr)
{
  6010416868:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  601041686c:	910003fd 	mov	x29, sp
  6010416870:	f9001fe0 	str	x0, [sp, #56]
  6010416874:	f9001be1 	str	x1, [sp, #48]
  6010416878:	f90017e2 	str	x2, [sp, #40]
  601041687c:	b90027e3 	str	w3, [sp, #36]
  6010416880:	f9000fe4 	str	x4, [sp, #24]
    assert(len >= 0);
  6010416884:	b94027e0 	ldr	w0, [sp, #36]
  6010416888:	7100001f 	cmp	w0, #0x0
  601041688c:	540001ea 	b.ge	60104168c8 <_map_pages+0x60>  // b.tcont
  6010416890:	52800702 	mov	w2, #0x38                  	// #56
  6010416894:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416898:	913a0001 	add	x1, x0, #0xe80
  601041689c:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104168a0:	9132a000 	add	x0, x0, #0xca8
  60104168a4:	97fff635 	bl	6010414178 <printf_>
  60104168a8:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104168ac:	9132e001 	add	x1, x0, #0xcb8
  60104168b0:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104168b4:	91332000 	add	x0, x0, #0xcc8
  60104168b8:	97fff630 	bl	6010414178 <printf_>
  60104168bc:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104168c0:	91336000 	add	x0, x0, #0xcd8
  60104168c4:	97ffe279 	bl	601040f2a8 <panic>
    vaddr = ALIGNDOWN(vaddr, LEVEL4_PTE_SIZE);
  60104168c8:	f9401be0 	ldr	x0, [sp, #48]
  60104168cc:	9274cc00 	and	x0, x0, #0xfffffffffffff000
  60104168d0:	f9001be0 	str	x0, [sp, #48]
    paddr = ALIGNDOWN(paddr, LEVEL4_PTE_SIZE);
  60104168d4:	f94017e0 	ldr	x0, [sp, #40]
  60104168d8:	9274cc00 	and	x0, x0, #0xfffffffffffff000
  60104168dc:	f90017e0 	str	x0, [sp, #40]
    uintptr_t vaddr_last = ALIGNDOWN(vaddr + len - 1, LEVEL4_PTE_SIZE);
  60104168e0:	b98027e1 	ldrsw	x1, [sp, #36]
  60104168e4:	f9401be0 	ldr	x0, [sp, #48]
  60104168e8:	8b000020 	add	x0, x1, x0
  60104168ec:	d1000400 	sub	x0, x0, #0x1
  60104168f0:	9274cc00 	and	x0, x0, #0xfffffffffffff000
  60104168f4:	f90027e0 	str	x0, [sp, #72]

    while (true) {
        uintptr_t* pte = NULL;
  60104168f8:	f90023ff 	str	xzr, [sp, #64]
        if ((pte = _page_walk(pgdir, vaddr, true)) == NULL) {
  60104168fc:	52800022 	mov	w2, #0x1                   	// #1
  6010416900:	f9401be1 	ldr	x1, [sp, #48]
  6010416904:	f9401fe0 	ldr	x0, [sp, #56]
  6010416908:	94000270 	bl	60104172c8 <_page_walk>
  601041690c:	f90023e0 	str	x0, [sp, #64]
  6010416910:	f94023e0 	ldr	x0, [sp, #64]
  6010416914:	f100001f 	cmp	x0, #0x0
  6010416918:	540001a1 	b.ne	601041694c <_map_pages+0xe4>  // b.any
            ERROR("pte not found for vaddr %p.\n", vaddr);
  601041691c:	52800802 	mov	w2, #0x40                  	// #64
  6010416920:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416924:	913a0001 	add	x1, x0, #0xe80
  6010416928:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  601041692c:	9132a000 	add	x0, x0, #0xca8
  6010416930:	97fff612 	bl	6010414178 <printf_>
  6010416934:	f9401be1 	ldr	x1, [sp, #48]
  6010416938:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  601041693c:	91338000 	add	x0, x0, #0xce0
  6010416940:	97fff60e 	bl	6010414178 <printf_>
            return false;
  6010416944:	52800000 	mov	w0, #0x0                   	// #0
  6010416948:	1400003d 	b	6010416a3c <_map_pages+0x1d4>
        }

        if (UNLIKELY(*pte != 0)) {
  601041694c:	f94023e0 	ldr	x0, [sp, #64]
  6010416950:	f9400000 	ldr	x0, [x0]
  6010416954:	f100001f 	cmp	x0, #0x0
  6010416958:	1a9f07e0 	cset	w0, ne  // ne = any
  601041695c:	12001c00 	and	w0, w0, #0xff
  6010416960:	92401c00 	and	x0, x0, #0xff
  6010416964:	f100001f 	cmp	x0, #0x0
  6010416968:	54000220 	b.eq	60104169ac <_map_pages+0x144>  // b.none
            ERROR("remapping: vaddr: %p | paddr: %p | pte: %p |\n", vaddr, paddr, *pte);
  601041696c:	528008a2 	mov	w2, #0x45                  	// #69
  6010416970:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416974:	913a0001 	add	x1, x0, #0xe80
  6010416978:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  601041697c:	9132a000 	add	x0, x0, #0xca8
  6010416980:	97fff5fe 	bl	6010414178 <printf_>
  6010416984:	f94023e0 	ldr	x0, [sp, #64]
  6010416988:	f9400000 	ldr	x0, [x0]
  601041698c:	aa0003e3 	mov	x3, x0
  6010416990:	f94017e2 	ldr	x2, [sp, #40]
  6010416994:	f9401be1 	ldr	x1, [sp, #48]
  6010416998:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  601041699c:	91340000 	add	x0, x0, #0xd00
  60104169a0:	97fff5f6 	bl	6010414178 <printf_>
            return false;
  60104169a4:	52800000 	mov	w0, #0x0                   	// #0
  60104169a8:	14000025 	b	6010416a3c <_map_pages+0x1d4>
        }

        *pte = paddr | attr;
  60104169ac:	f94017e1 	ldr	x1, [sp, #40]
  60104169b0:	f9400fe0 	ldr	x0, [sp, #24]
  60104169b4:	aa000021 	orr	x1, x1, x0
  60104169b8:	f94023e0 	ldr	x0, [sp, #64]
  60104169bc:	f9000001 	str	x1, [x0]

        if (vaddr == vaddr_last) {
  60104169c0:	f9401be1 	ldr	x1, [sp, #48]
  60104169c4:	f94027e0 	ldr	x0, [sp, #72]
  60104169c8:	eb00003f 	cmp	x1, x0
  60104169cc:	54000100 	b.eq	60104169ec <_map_pages+0x184>  // b.none
            break;
        }

        vaddr += PAGE_SIZE;
  60104169d0:	f9401be0 	ldr	x0, [sp, #48]
  60104169d4:	91400400 	add	x0, x0, #0x1, lsl #12
  60104169d8:	f9001be0 	str	x0, [sp, #48]
        paddr += PAGE_SIZE;
  60104169dc:	f94017e0 	ldr	x0, [sp, #40]
  60104169e0:	91400400 	add	x0, x0, #0x1, lsl #12
  60104169e4:	f90017e0 	str	x0, [sp, #40]
    while (true) {
  60104169e8:	17ffffc4 	b	60104168f8 <_map_pages+0x90>
            break;
  60104169ec:	d503201f 	nop
    }

    assert(vaddr == vaddr_last);
  60104169f0:	f9401be1 	ldr	x1, [sp, #48]
  60104169f4:	f94027e0 	ldr	x0, [sp, #72]
  60104169f8:	eb00003f 	cmp	x1, x0
  60104169fc:	540001e0 	b.eq	6010416a38 <_map_pages+0x1d0>  // b.none
  6010416a00:	52800a62 	mov	w2, #0x53                  	// #83
  6010416a04:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416a08:	913a0001 	add	x1, x0, #0xe80
  6010416a0c:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416a10:	9132a000 	add	x0, x0, #0xca8
  6010416a14:	97fff5d9 	bl	6010414178 <printf_>
  6010416a18:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416a1c:	9134c001 	add	x1, x0, #0xd30
  6010416a20:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416a24:	91332000 	add	x0, x0, #0xcc8
  6010416a28:	97fff5d4 	bl	6010414178 <printf_>
  6010416a2c:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416a30:	91336000 	add	x0, x0, #0xcd8
  6010416a34:	97ffe21d 	bl	601040f2a8 <panic>
    return true;
  6010416a38:	52800020 	mov	w0, #0x1                   	// #1
}
  6010416a3c:	a8c57bfd 	ldp	x29, x30, [sp], #80
  6010416a40:	d65f03c0 	ret

0000006010416a44 <_unmap_pages>:

static bool _unmap_pages(uintptr_t* pgdir, uintptr_t vaddr, int len)
{
  6010416a44:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  6010416a48:	910003fd 	mov	x29, sp
  6010416a4c:	f90017e0 	str	x0, [sp, #40]
  6010416a50:	f90013e1 	str	x1, [sp, #32]
  6010416a54:	b9001fe2 	str	w2, [sp, #28]
    assert(len >= 0);
  6010416a58:	b9401fe0 	ldr	w0, [sp, #28]
  6010416a5c:	7100001f 	cmp	w0, #0x0
  6010416a60:	540001ea 	b.ge	6010416a9c <_unmap_pages+0x58>  // b.tcont
  6010416a64:	52800b22 	mov	w2, #0x59                  	// #89
  6010416a68:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416a6c:	913a4001 	add	x1, x0, #0xe90
  6010416a70:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416a74:	9132a000 	add	x0, x0, #0xca8
  6010416a78:	97fff5c0 	bl	6010414178 <printf_>
  6010416a7c:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416a80:	9132e001 	add	x1, x0, #0xcb8
  6010416a84:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416a88:	91332000 	add	x0, x0, #0xcc8
  6010416a8c:	97fff5bb 	bl	6010414178 <printf_>
  6010416a90:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416a94:	91336000 	add	x0, x0, #0xcd8
  6010416a98:	97ffe204 	bl	601040f2a8 <panic>
    vaddr = ALIGNDOWN(vaddr, LEVEL4_PTE_SIZE);
  6010416a9c:	f94013e0 	ldr	x0, [sp, #32]
  6010416aa0:	9274cc00 	and	x0, x0, #0xfffffffffffff000
  6010416aa4:	f90013e0 	str	x0, [sp, #32]
    uintptr_t vaddr_last = ALIGNDOWN(vaddr + len - 1, LEVEL4_PTE_SIZE);
  6010416aa8:	b9801fe1 	ldrsw	x1, [sp, #28]
  6010416aac:	f94013e0 	ldr	x0, [sp, #32]
  6010416ab0:	8b000020 	add	x0, x1, x0
  6010416ab4:	d1000400 	sub	x0, x0, #0x1
  6010416ab8:	9274cc00 	and	x0, x0, #0xfffffffffffff000
  6010416abc:	f9001fe0 	str	x0, [sp, #56]

    while (true) {
        uintptr_t* pte = NULL;
  6010416ac0:	f9001bff 	str	xzr, [sp, #48]
        if ((pte = _page_walk(pgdir, vaddr, false)) == NULL) {
  6010416ac4:	52800002 	mov	w2, #0x0                   	// #0
  6010416ac8:	f94013e1 	ldr	x1, [sp, #32]
  6010416acc:	f94017e0 	ldr	x0, [sp, #40]
  6010416ad0:	940001fe 	bl	60104172c8 <_page_walk>
  6010416ad4:	f9001be0 	str	x0, [sp, #48]
  6010416ad8:	f9401be0 	ldr	x0, [sp, #48]
  6010416adc:	f100001f 	cmp	x0, #0x0
  6010416ae0:	540001a1 	b.ne	6010416b14 <_unmap_pages+0xd0>  // b.any
            ERROR("pte not found for vaddr %p.\n", vaddr);
  6010416ae4:	52800c02 	mov	w2, #0x60                  	// #96
  6010416ae8:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416aec:	913a4001 	add	x1, x0, #0xe90
  6010416af0:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416af4:	9132a000 	add	x0, x0, #0xca8
  6010416af8:	97fff5a0 	bl	6010414178 <printf_>
  6010416afc:	f94013e1 	ldr	x1, [sp, #32]
  6010416b00:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416b04:	91338000 	add	x0, x0, #0xce0
  6010416b08:	97fff59c 	bl	6010414178 <printf_>
            return false;
  6010416b0c:	52800000 	mov	w0, #0x0                   	// #0
  6010416b10:	14000032 	b	6010416bd8 <_unmap_pages+0x194>
        }

        if (*pte == 0) {
  6010416b14:	f9401be0 	ldr	x0, [sp, #48]
  6010416b18:	f9400000 	ldr	x0, [x0]
  6010416b1c:	f100001f 	cmp	x0, #0x0
  6010416b20:	54000201 	b.ne	6010416b60 <_unmap_pages+0x11c>  // b.any
            ERROR("unmap a unmapped page, vaddr: %p, pte: %p\n", vaddr, *pte);
  6010416b24:	52800ca2 	mov	w2, #0x65                  	// #101
  6010416b28:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416b2c:	913a4001 	add	x1, x0, #0xe90
  6010416b30:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416b34:	9132a000 	add	x0, x0, #0xca8
  6010416b38:	97fff590 	bl	6010414178 <printf_>
  6010416b3c:	f9401be0 	ldr	x0, [sp, #48]
  6010416b40:	f9400000 	ldr	x0, [x0]
  6010416b44:	aa0003e2 	mov	x2, x0
  6010416b48:	f94013e1 	ldr	x1, [sp, #32]
  6010416b4c:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416b50:	91352000 	add	x0, x0, #0xd48
  6010416b54:	97fff589 	bl	6010414178 <printf_>
            return false;
  6010416b58:	52800000 	mov	w0, #0x0                   	// #0
  6010416b5c:	1400001f 	b	6010416bd8 <_unmap_pages+0x194>
        }

        *pte = 0;
  6010416b60:	f9401be0 	ldr	x0, [sp, #48]
  6010416b64:	f900001f 	str	xzr, [x0]

        if (vaddr == vaddr_last) {
  6010416b68:	f94013e1 	ldr	x1, [sp, #32]
  6010416b6c:	f9401fe0 	ldr	x0, [sp, #56]
  6010416b70:	eb00003f 	cmp	x1, x0
  6010416b74:	540000a0 	b.eq	6010416b88 <_unmap_pages+0x144>  // b.none
            break;
        }

        vaddr += PAGE_SIZE;
  6010416b78:	f94013e0 	ldr	x0, [sp, #32]
  6010416b7c:	91400400 	add	x0, x0, #0x1, lsl #12
  6010416b80:	f90013e0 	str	x0, [sp, #32]
    while (true) {
  6010416b84:	17ffffcf 	b	6010416ac0 <_unmap_pages+0x7c>
            break;
  6010416b88:	d503201f 	nop
    }

    assert(vaddr == vaddr_last);
  6010416b8c:	f94013e1 	ldr	x1, [sp, #32]
  6010416b90:	f9401fe0 	ldr	x0, [sp, #56]
  6010416b94:	eb00003f 	cmp	x1, x0
  6010416b98:	540001e0 	b.eq	6010416bd4 <_unmap_pages+0x190>  // b.none
  6010416b9c:	52800e42 	mov	w2, #0x72                  	// #114
  6010416ba0:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416ba4:	913a4001 	add	x1, x0, #0xe90
  6010416ba8:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416bac:	9132a000 	add	x0, x0, #0xca8
  6010416bb0:	97fff572 	bl	6010414178 <printf_>
  6010416bb4:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416bb8:	9134c001 	add	x1, x0, #0xd30
  6010416bbc:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416bc0:	91332000 	add	x0, x0, #0xcc8
  6010416bc4:	97fff56d 	bl	6010414178 <printf_>
  6010416bc8:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416bcc:	91336000 	add	x0, x0, #0xcd8
  6010416bd0:	97ffe1b6 	bl	601040f2a8 <panic>
    return true;
  6010416bd4:	52800020 	mov	w0, #0x1                   	// #1
}
  6010416bd8:	a8c47bfd 	ldp	x29, x30, [sp], #64
  6010416bdc:	d65f03c0 	ret

0000006010416be0 <_map_user_pages>:
/// @param paddr
/// @param len
/// @param is_dev
/// @return
static bool _map_user_pages(uintptr_t* pgdir, uintptr_t vaddr, uintptr_t paddr, int len, bool is_dev)
{
  6010416be0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  6010416be4:	910003fd 	mov	x29, sp
  6010416be8:	f90017e0 	str	x0, [sp, #40]
  6010416bec:	f90013e1 	str	x1, [sp, #32]
  6010416bf0:	f9000fe2 	str	x2, [sp, #24]
  6010416bf4:	b90017e3 	str	w3, [sp, #20]
  6010416bf8:	39004fe4 	strb	w4, [sp, #19]
    if (len < 0) {
  6010416bfc:	b94017e0 	ldr	w0, [sp, #20]
  6010416c00:	7100001f 	cmp	w0, #0x0
  6010416c04:	5400006a 	b.ge	6010416c10 <_map_user_pages+0x30>  // b.tcont
        return false;
  6010416c08:	52800000 	mov	w0, #0x0                   	// #0
  6010416c0c:	14000030 	b	6010416ccc <_map_user_pages+0xec>
    }

    if (UNLIKELY(vaddr >= USER_MEM_TOP)) {
  6010416c10:	f94013e1 	ldr	x1, [sp, #32]
  6010416c14:	b24097e0 	mov	x0, #0x3fffffffff          	// #274877906943
  6010416c18:	eb00003f 	cmp	x1, x0
  6010416c1c:	1a9f97e0 	cset	w0, hi  // hi = pmore
  6010416c20:	12001c00 	and	w0, w0, #0xff
  6010416c24:	92401c00 	and	x0, x0, #0xff
  6010416c28:	f100001f 	cmp	x0, #0x0
  6010416c2c:	54000180 	b.eq	6010416c5c <_map_user_pages+0x7c>  // b.none
        ERROR("mapping kernel space.\n");
  6010416c30:	52801082 	mov	w2, #0x84                  	// #132
  6010416c34:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416c38:	913a8001 	add	x1, x0, #0xea0
  6010416c3c:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416c40:	9132a000 	add	x0, x0, #0xca8
  6010416c44:	97fff54d 	bl	6010414178 <printf_>
  6010416c48:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416c4c:	9135e000 	add	x0, x0, #0xd78
  6010416c50:	97fff54a 	bl	6010414178 <printf_>
        return false;
  6010416c54:	52800000 	mov	w0, #0x0                   	// #0
  6010416c58:	1400001d 	b	6010416ccc <_map_user_pages+0xec>
    }

    uintptr_t mem_attr = 0;
  6010416c5c:	f9001fff 	str	xzr, [sp, #56]
    if (LIKELY(!is_dev)) {
  6010416c60:	39404fe0 	ldrb	w0, [sp, #19]
  6010416c64:	52000000 	eor	w0, w0, #0x1
  6010416c68:	12001c00 	and	w0, w0, #0xff
  6010416c6c:	92401c00 	and	x0, x0, #0xff
  6010416c70:	f100001f 	cmp	x0, #0x0
  6010416c74:	54000100 	b.eq	6010416c94 <_map_user_pages+0xb4>  // b.none
        _p_pgtbl_mmu_access->MmuUsrPteAttr(&mem_attr);
  6010416c78:	b0008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010416c7c:	f942bc00 	ldr	x0, [x0, #1400]
  6010416c80:	f9400000 	ldr	x0, [x0]
  6010416c84:	f9400801 	ldr	x1, [x0, #16]
  6010416c88:	9100e3e0 	add	x0, sp, #0x38
  6010416c8c:	d63f0020 	blr	x1
  6010416c90:	14000007 	b	6010416cac <_map_user_pages+0xcc>
    } else {
        _p_pgtbl_mmu_access->MmuUsrDevPteAttr(&mem_attr);
  6010416c94:	b0008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010416c98:	f942bc00 	ldr	x0, [x0, #1400]
  6010416c9c:	f9400000 	ldr	x0, [x0]
  6010416ca0:	f9400c01 	ldr	x1, [x0, #24]
  6010416ca4:	9100e3e0 	add	x0, sp, #0x38
  6010416ca8:	d63f0020 	blr	x1
    }

    return _map_pages(pgdir, vaddr, paddr, len, mem_attr);
  6010416cac:	f9401fe0 	ldr	x0, [sp, #56]
  6010416cb0:	aa0003e4 	mov	x4, x0
  6010416cb4:	b94017e3 	ldr	w3, [sp, #20]
  6010416cb8:	f9400fe2 	ldr	x2, [sp, #24]
  6010416cbc:	f94013e1 	ldr	x1, [sp, #32]
  6010416cc0:	f94017e0 	ldr	x0, [sp, #40]
  6010416cc4:	97fffee9 	bl	6010416868 <_map_pages>
  6010416cc8:	12001c00 	and	w0, w0, #0xff
}
  6010416ccc:	a8c47bfd 	ldp	x29, x30, [sp], #64
  6010416cd0:	d65f03c0 	ret

0000006010416cd4 <_resize_user_pgdir>:

/// assume that a user pagedir is allocated from [0, size)
/// if new_size > old_size, allocate more space,
/// if old_size > new_size, free extra space, to avoid unnecessary alloc/free.
static uintptr_t _resize_user_pgdir(struct TopLevelPageDirectory* pgdir, uintptr_t old_size, uintptr_t new_size)
{
  6010416cd4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  6010416cd8:	910003fd 	mov	x29, sp
  6010416cdc:	f90017e0 	str	x0, [sp, #40]
  6010416ce0:	f90013e1 	str	x1, [sp, #32]
  6010416ce4:	f9000fe2 	str	x2, [sp, #24]
    if (UNLIKELY(new_size > USER_MEM_TOP)) {
  6010416ce8:	f9400fe1 	ldr	x1, [sp, #24]
  6010416cec:	d2c00800 	mov	x0, #0x4000000000          	// #274877906944
  6010416cf0:	eb00003f 	cmp	x1, x0
  6010416cf4:	1a9f97e0 	cset	w0, hi  // hi = pmore
  6010416cf8:	12001c00 	and	w0, w0, #0xff
  6010416cfc:	92401c00 	and	x0, x0, #0xff
  6010416d00:	f100001f 	cmp	x0, #0x0
  6010416d04:	54000180 	b.eq	6010416d34 <_resize_user_pgdir+0x60>  // b.none
        ERROR("user size out of range.\n");
  6010416d08:	52801302 	mov	w2, #0x98                  	// #152
  6010416d0c:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416d10:	913ac001 	add	x1, x0, #0xeb0
  6010416d14:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416d18:	9132a000 	add	x0, x0, #0xca8
  6010416d1c:	97fff517 	bl	6010414178 <printf_>
  6010416d20:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416d24:	91364000 	add	x0, x0, #0xd90
  6010416d28:	97fff514 	bl	6010414178 <printf_>
        return old_size;
  6010416d2c:	f94013e0 	ldr	x0, [sp, #32]
  6010416d30:	14000043 	b	6010416e3c <_resize_user_pgdir+0x168>
    }
    if (UNLIKELY(new_size < old_size)) {
  6010416d34:	f9400fe1 	ldr	x1, [sp, #24]
  6010416d38:	f94013e0 	ldr	x0, [sp, #32]
  6010416d3c:	eb00003f 	cmp	x1, x0
  6010416d40:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
  6010416d44:	12001c00 	and	w0, w0, #0xff
  6010416d48:	92401c00 	and	x0, x0, #0xff
  6010416d4c:	f100001f 	cmp	x0, #0x0
  6010416d50:	54000060 	b.eq	6010416d5c <_resize_user_pgdir+0x88>  // b.none
        /// @todo: free extra space.
        return old_size;
  6010416d54:	f94013e0 	ldr	x0, [sp, #32]
  6010416d58:	14000039 	b	6010416e3c <_resize_user_pgdir+0x168>
    }

    uintptr_t cur_size = ALIGNUP(old_size, PAGE_SIZE);
  6010416d5c:	f94013e0 	ldr	x0, [sp, #32]
  6010416d60:	913ffc00 	add	x0, x0, #0xfff
  6010416d64:	9274cc00 	and	x0, x0, #0xfffffffffffff000
  6010416d68:	f9001fe0 	str	x0, [sp, #56]

    while (cur_size < new_size) {
  6010416d6c:	1400002f 	b	6010416e28 <_resize_user_pgdir+0x154>
        char* new_page = kalloc(PAGE_SIZE);
  6010416d70:	d2820000 	mov	x0, #0x1000                	// #4096
  6010416d74:	97fffe32 	bl	601041663c <kalloc>
  6010416d78:	f9001be0 	str	x0, [sp, #48]
        if (new_page == NULL) {
  6010416d7c:	f9401be0 	ldr	x0, [sp, #48]
  6010416d80:	f100001f 	cmp	x0, #0x0
  6010416d84:	54000181 	b.ne	6010416db4 <_resize_user_pgdir+0xe0>  // b.any
            ERROR("No memory\n");
  6010416d88:	528014a2 	mov	w2, #0xa5                  	// #165
  6010416d8c:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416d90:	913ac001 	add	x1, x0, #0xeb0
  6010416d94:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416d98:	9132a000 	add	x0, x0, #0xca8
  6010416d9c:	97fff4f7 	bl	6010414178 <printf_>
  6010416da0:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416da4:	9136c000 	add	x0, x0, #0xdb0
  6010416da8:	97fff4f4 	bl	6010414178 <printf_>
            return cur_size;
  6010416dac:	f9401fe0 	ldr	x0, [sp, #56]
  6010416db0:	14000023 	b	6010416e3c <_resize_user_pgdir+0x168>
        }
        memset(new_page, 0, PAGE_SIZE);
  6010416db4:	d2820002 	mov	x2, #0x1000                	// #4096
  6010416db8:	52800001 	mov	w1, #0x0                   	// #0
  6010416dbc:	f9401be0 	ldr	x0, [sp, #48]
  6010416dc0:	97ffdd40 	bl	601040e2c0 <memset>

        if (!xizi_pager.map_pages(pgdir->pd_addr, cur_size, V2P(new_page), PAGE_SIZE, false)) {
  6010416dc4:	b0008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010416dc8:	f942b000 	ldr	x0, [x0, #1376]
  6010416dcc:	f9400805 	ldr	x5, [x0, #16]
  6010416dd0:	f94017e0 	ldr	x0, [sp, #40]
  6010416dd4:	f9400006 	ldr	x6, [x0]
  6010416dd8:	f9401be1 	ldr	x1, [sp, #48]
  6010416ddc:	d2dff400 	mov	x0, #0xffa000000000        	// #281062659850240
  6010416de0:	f2ffffe0 	movk	x0, #0xffff, lsl #48
  6010416de4:	8b000020 	add	x0, x1, x0
  6010416de8:	52800004 	mov	w4, #0x0                   	// #0
  6010416dec:	52820003 	mov	w3, #0x1000                	// #4096
  6010416df0:	aa0003e2 	mov	x2, x0
  6010416df4:	f9401fe1 	ldr	x1, [sp, #56]
  6010416df8:	aa0603e0 	mov	x0, x6
  6010416dfc:	d63f00a0 	blr	x5
  6010416e00:	12001c00 	and	w0, w0, #0xff
  6010416e04:	52000000 	eor	w0, w0, #0x1
  6010416e08:	12001c00 	and	w0, w0, #0xff
  6010416e0c:	7100001f 	cmp	w0, #0x0
  6010416e10:	54000060 	b.eq	6010416e1c <_resize_user_pgdir+0x148>  // b.none
            return cur_size;
  6010416e14:	f9401fe0 	ldr	x0, [sp, #56]
  6010416e18:	14000009 	b	6010416e3c <_resize_user_pgdir+0x168>
        }
        cur_size += PAGE_SIZE;
  6010416e1c:	f9401fe0 	ldr	x0, [sp, #56]
  6010416e20:	91400400 	add	x0, x0, #0x1, lsl #12
  6010416e24:	f9001fe0 	str	x0, [sp, #56]
    while (cur_size < new_size) {
  6010416e28:	f9401fe1 	ldr	x1, [sp, #56]
  6010416e2c:	f9400fe0 	ldr	x0, [sp, #24]
  6010416e30:	eb00003f 	cmp	x1, x0
  6010416e34:	54fff9e3 	b.cc	6010416d70 <_resize_user_pgdir+0x9c>  // b.lo, b.ul, b.last
    }

    return new_size;
  6010416e38:	f9400fe0 	ldr	x0, [sp, #24]
}
  6010416e3c:	a8c47bfd 	ldp	x29, x30, [sp], #64
  6010416e40:	d65f03c0 	ret

0000006010416e44 <_address_translate>:
/// @brief translate virt address to phy address with pgdir
/// @param pgdir
/// @param vaddr accept only page aligned address
/// @return paddr of pgdir(vaddr); zero for unmapped addr
static uintptr_t _address_translate(struct TopLevelPageDirectory* pgdir, uintptr_t vaddr)
{
  6010416e44:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  6010416e48:	910003fd 	mov	x29, sp
  6010416e4c:	f9000fe0 	str	x0, [sp, #24]
  6010416e50:	f9000be1 	str	x1, [sp, #16]
    assert(vaddr % PAGE_SIZE == 0);
  6010416e54:	f9400be0 	ldr	x0, [sp, #16]
  6010416e58:	92402c00 	and	x0, x0, #0xfff
  6010416e5c:	f100001f 	cmp	x0, #0x0
  6010416e60:	540001e0 	b.eq	6010416e9c <_address_translate+0x58>  // b.none
  6010416e64:	52801722 	mov	w2, #0xb9                  	// #185
  6010416e68:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416e6c:	913b2001 	add	x1, x0, #0xec8
  6010416e70:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416e74:	9132a000 	add	x0, x0, #0xca8
  6010416e78:	97fff4c0 	bl	6010414178 <printf_>
  6010416e7c:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416e80:	91370001 	add	x1, x0, #0xdc0
  6010416e84:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416e88:	91332000 	add	x0, x0, #0xcc8
  6010416e8c:	97fff4bb 	bl	6010414178 <printf_>
  6010416e90:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416e94:	91336000 	add	x0, x0, #0xcd8
  6010416e98:	97ffe104 	bl	601040f2a8 <panic>
    const uintptr_t* const pte = _page_walk(pgdir->pd_addr, vaddr, false);
  6010416e9c:	f9400fe0 	ldr	x0, [sp, #24]
  6010416ea0:	f9400000 	ldr	x0, [x0]
  6010416ea4:	52800002 	mov	w2, #0x0                   	// #0
  6010416ea8:	f9400be1 	ldr	x1, [sp, #16]
  6010416eac:	94000107 	bl	60104172c8 <_page_walk>
  6010416eb0:	f90017e0 	str	x0, [sp, #40]
    if (pte == NULL || *pte == 0) {
  6010416eb4:	f94017e0 	ldr	x0, [sp, #40]
  6010416eb8:	f100001f 	cmp	x0, #0x0
  6010416ebc:	540000a0 	b.eq	6010416ed0 <_address_translate+0x8c>  // b.none
  6010416ec0:	f94017e0 	ldr	x0, [sp, #40]
  6010416ec4:	f9400000 	ldr	x0, [x0]
  6010416ec8:	f100001f 	cmp	x0, #0x0
  6010416ecc:	54000061 	b.ne	6010416ed8 <_address_translate+0x94>  // b.any
        return 0;
  6010416ed0:	d2800000 	mov	x0, #0x0                   	// #0
  6010416ed4:	14000004 	b	6010416ee4 <_address_translate+0xa0>
    }
    return (uintptr_t)ALIGNDOWN(*pte, PAGE_SIZE);
  6010416ed8:	f94017e0 	ldr	x0, [sp, #40]
  6010416edc:	f9400000 	ldr	x0, [x0]
  6010416ee0:	9274cc00 	and	x0, x0, #0xfffffffffffff000
}
  6010416ee4:	a8c37bfd 	ldp	x29, x30, [sp], #48
  6010416ee8:	d65f03c0 	ret

0000006010416eec <_cross_vspace_data_copy_in_page>:

static uintptr_t _cross_vspace_data_copy_in_page(struct TopLevelPageDirectory* pgdir, uintptr_t cross_dest, uintptr_t src, uintptr_t len)
{
  6010416eec:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  6010416ef0:	910003fd 	mov	x29, sp
  6010416ef4:	f90017e0 	str	x0, [sp, #40]
  6010416ef8:	f90013e1 	str	x1, [sp, #32]
  6010416efc:	f9000fe2 	str	x2, [sp, #24]
  6010416f00:	f9000be3 	str	x3, [sp, #16]
    uintptr_t cross_dest_end = cross_dest + len;
  6010416f04:	f94013e1 	ldr	x1, [sp, #32]
  6010416f08:	f9400be0 	ldr	x0, [sp, #16]
  6010416f0c:	8b000020 	add	x0, x1, x0
  6010416f10:	f9002fe0 	str	x0, [sp, #88]
    assert(ALIGNUP(cross_dest, PAGE_SIZE) == ALIGNUP(cross_dest_end, PAGE_SIZE));
  6010416f14:	f94013e0 	ldr	x0, [sp, #32]
  6010416f18:	913ffc01 	add	x1, x0, #0xfff
  6010416f1c:	f9402fe0 	ldr	x0, [sp, #88]
  6010416f20:	913ffc00 	add	x0, x0, #0xfff
  6010416f24:	ca000020 	eor	x0, x1, x0
  6010416f28:	9274cc00 	and	x0, x0, #0xfffffffffffff000
  6010416f2c:	f100001f 	cmp	x0, #0x0
  6010416f30:	540001e0 	b.eq	6010416f6c <_cross_vspace_data_copy_in_page+0x80>  // b.none
  6010416f34:	52801882 	mov	w2, #0xc4                  	// #196
  6010416f38:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416f3c:	913b8001 	add	x1, x0, #0xee0
  6010416f40:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416f44:	9132a000 	add	x0, x0, #0xca8
  6010416f48:	97fff48c 	bl	6010414178 <printf_>
  6010416f4c:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416f50:	91376001 	add	x1, x0, #0xdd8
  6010416f54:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416f58:	91332000 	add	x0, x0, #0xcc8
  6010416f5c:	97fff487 	bl	6010414178 <printf_>
  6010416f60:	f0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010416f64:	91336000 	add	x0, x0, #0xcd8
  6010416f68:	97ffe0d0 	bl	601040f2a8 <panic>

    uintptr_t paddr = xizi_pager.address_translate(pgdir, ALIGNDOWN(cross_dest, PAGE_SIZE));
  6010416f6c:	b0008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010416f70:	f942b000 	ldr	x0, [x0, #1376]
  6010416f74:	f9401402 	ldr	x2, [x0, #40]
  6010416f78:	f94013e0 	ldr	x0, [sp, #32]
  6010416f7c:	9274cc00 	and	x0, x0, #0xfffffffffffff000
  6010416f80:	aa0003e1 	mov	x1, x0
  6010416f84:	f94017e0 	ldr	x0, [sp, #40]
  6010416f88:	d63f0040 	blr	x2
  6010416f8c:	f9002be0 	str	x0, [sp, #80]
    uintptr_t offset = cross_dest - ALIGNDOWN(cross_dest, PAGE_SIZE);
  6010416f90:	f94013e0 	ldr	x0, [sp, #32]
  6010416f94:	92402c00 	and	x0, x0, #0xfff
  6010416f98:	f90027e0 	str	x0, [sp, #72]
    uintptr_t* vdest = (uintptr_t*)((uintptr_t)P2V(paddr) + offset);
  6010416f9c:	f9402be1 	ldr	x1, [sp, #80]
  6010416fa0:	f94027e0 	ldr	x0, [sp, #72]
  6010416fa4:	8b000021 	add	x1, x1, x0
  6010416fa8:	d2c00c00 	mov	x0, #0x6000000000          	// #412316860416
  6010416fac:	8b000020 	add	x0, x1, x0
  6010416fb0:	f90023e0 	str	x0, [sp, #64]
    uintptr_t* vsrc = (uintptr_t*)src;
  6010416fb4:	f9400fe0 	ldr	x0, [sp, #24]
  6010416fb8:	f9001fe0 	str	x0, [sp, #56]
    memcpy(vdest, vsrc, len);
  6010416fbc:	f9400be2 	ldr	x2, [sp, #16]
  6010416fc0:	f9401fe1 	ldr	x1, [sp, #56]
  6010416fc4:	f94023e0 	ldr	x0, [sp, #64]
  6010416fc8:	9400248e 	bl	6010420200 <memcpy>
    return len;
  6010416fcc:	f9400be0 	ldr	x0, [sp, #16]
}
  6010416fd0:	a8c67bfd 	ldp	x29, x30, [sp], #96
  6010416fd4:	d65f03c0 	ret

0000006010416fd8 <_cross_vspace_data_copy>:
/// @param cross_dest vaddress in pgdir
/// @param src
/// @param len
/// @return
static uintptr_t _cross_vspace_data_copy(struct TopLevelPageDirectory* pgdir, uintptr_t cross_dest, uintptr_t src, uintptr_t len)
{
  6010416fd8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  6010416fdc:	910003fd 	mov	x29, sp
  6010416fe0:	f90017e0 	str	x0, [sp, #40]
  6010416fe4:	f90013e1 	str	x1, [sp, #32]
  6010416fe8:	f9000fe2 	str	x2, [sp, #24]
  6010416fec:	f9000be3 	str	x3, [sp, #16]
    uintptr_t len_to_top = ALIGNUP(cross_dest, PAGE_SIZE) - cross_dest;
  6010416ff0:	f94013e0 	ldr	x0, [sp, #32]
  6010416ff4:	913ffc00 	add	x0, x0, #0xfff
  6010416ff8:	9274cc01 	and	x1, x0, #0xfffffffffffff000
  6010416ffc:	f94013e0 	ldr	x0, [sp, #32]
  6010417000:	cb000020 	sub	x0, x1, x0
  6010417004:	f90027e0 	str	x0, [sp, #72]

    uintptr_t copied_len = 0;
  6010417008:	f90023ff 	str	xzr, [sp, #64]
    while (copied_len < len) {
  601041700c:	14000031 	b	60104170d0 <_cross_vspace_data_copy+0xf8>
        uintptr_t current_copy_len = len_to_top >= len ? len : len_to_top;
  6010417010:	f94027e0 	ldr	x0, [sp, #72]
  6010417014:	f9400be2 	ldr	x2, [sp, #16]
  6010417018:	f9400be1 	ldr	x1, [sp, #16]
  601041701c:	eb00005f 	cmp	x2, x0
  6010417020:	9a809020 	csel	x0, x1, x0, ls  // ls = plast
  6010417024:	f9001fe0 	str	x0, [sp, #56]

        current_copy_len = _cross_vspace_data_copy_in_page(pgdir, cross_dest, src, current_copy_len);
  6010417028:	f9401fe3 	ldr	x3, [sp, #56]
  601041702c:	f9400fe2 	ldr	x2, [sp, #24]
  6010417030:	f94013e1 	ldr	x1, [sp, #32]
  6010417034:	f94017e0 	ldr	x0, [sp, #40]
  6010417038:	97ffffad 	bl	6010416eec <_cross_vspace_data_copy_in_page>
  601041703c:	f9001fe0 	str	x0, [sp, #56]

        // update variables
        copied_len += current_copy_len;
  6010417040:	f94023e1 	ldr	x1, [sp, #64]
  6010417044:	f9401fe0 	ldr	x0, [sp, #56]
  6010417048:	8b000020 	add	x0, x1, x0
  601041704c:	f90023e0 	str	x0, [sp, #64]
        cross_dest += current_copy_len;
  6010417050:	f94013e1 	ldr	x1, [sp, #32]
  6010417054:	f9401fe0 	ldr	x0, [sp, #56]
  6010417058:	8b000020 	add	x0, x1, x0
  601041705c:	f90013e0 	str	x0, [sp, #32]
        src += current_copy_len;
  6010417060:	f9400fe1 	ldr	x1, [sp, #24]
  6010417064:	f9401fe0 	ldr	x0, [sp, #56]
  6010417068:	8b000020 	add	x0, x1, x0
  601041706c:	f9000fe0 	str	x0, [sp, #24]
        len_to_top = ALIGNDOWN(cross_dest + PAGE_SIZE, PAGE_SIZE) - ALIGNDOWN(cross_dest, PAGE_SIZE); // actually PAGE_SIZE
  6010417070:	f94013e0 	ldr	x0, [sp, #32]
  6010417074:	91400400 	add	x0, x0, #0x1, lsl #12
  6010417078:	9274cc01 	and	x1, x0, #0xfffffffffffff000
  601041707c:	f94013e0 	ldr	x0, [sp, #32]
  6010417080:	9274cc00 	and	x0, x0, #0xfffffffffffff000
  6010417084:	cb000020 	sub	x0, x1, x0
  6010417088:	f90027e0 	str	x0, [sp, #72]
        assert(len_to_top == PAGE_SIZE);
  601041708c:	f94027e0 	ldr	x0, [sp, #72]
  6010417090:	f140041f 	cmp	x0, #0x1, lsl #12
  6010417094:	540001e0 	b.eq	60104170d0 <_cross_vspace_data_copy+0xf8>  // b.none
  6010417098:	52801c62 	mov	w2, #0xe3                  	// #227
  601041709c:	d0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104170a0:	913c0001 	add	x1, x0, #0xf00
  60104170a4:	d0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104170a8:	9132a000 	add	x0, x0, #0xca8
  60104170ac:	97fff433 	bl	6010414178 <printf_>
  60104170b0:	d0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104170b4:	91388001 	add	x1, x0, #0xe20
  60104170b8:	d0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104170bc:	91332000 	add	x0, x0, #0xcc8
  60104170c0:	97fff42e 	bl	6010414178 <printf_>
  60104170c4:	d0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104170c8:	91336000 	add	x0, x0, #0xcd8
  60104170cc:	97ffe077 	bl	601040f2a8 <panic>
    while (copied_len < len) {
  60104170d0:	f94023e1 	ldr	x1, [sp, #64]
  60104170d4:	f9400be0 	ldr	x0, [sp, #16]
  60104170d8:	eb00003f 	cmp	x1, x0
  60104170dc:	54fff9a3 	b.cc	6010417010 <_cross_vspace_data_copy+0x38>  // b.lo, b.ul, b.last
    }

    return len;
  60104170e0:	f9400be0 	ldr	x0, [sp, #16]
}
  60104170e4:	a8c57bfd 	ldp	x29, x30, [sp], #80
  60104170e8:	d65f03c0 	ret

00000060104170ec <module_pager_init>:
    .address_translate = _address_translate,
    .cross_vspace_data_copy = _cross_vspace_data_copy,
};

bool module_pager_init(struct PagerRightGroup* _right_group)
{
  60104170ec:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  60104170f0:	910003fd 	mov	x29, sp
  60104170f4:	f9000fe0 	str	x0, [sp, #24]
    right_group = *_right_group;
  60104170f8:	90008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  60104170fc:	912ac000 	add	x0, x0, #0xab0
  6010417100:	f9400fe1 	ldr	x1, [sp, #24]
  6010417104:	f9400021 	ldr	x1, [x1]
  6010417108:	f9000001 	str	x1, [x0]
    _p_pgtbl_mmu_access = AchieveResource(&right_group.mmu_driver_tag);
  601041710c:	90008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010417110:	912ac000 	add	x0, x0, #0xab0
  6010417114:	97fffb9f 	bl	6010415f90 <AchieveResource>
  6010417118:	aa0003e1 	mov	x1, x0
  601041711c:	90008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010417120:	f942bc00 	ldr	x0, [x0, #1400]
  6010417124:	f9000001 	str	x1, [x0]
    return _p_pgtbl_mmu_access != NULL;
  6010417128:	90008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041712c:	f942bc00 	ldr	x0, [x0, #1400]
  6010417130:	f9400000 	ldr	x0, [x0]
  6010417134:	f100001f 	cmp	x0, #0x0
  6010417138:	1a9f07e0 	cset	w0, ne  // ne = any
  601041713c:	12001c00 	and	w0, w0, #0xff
}
  6010417140:	a8c27bfd 	ldp	x29, x30, [sp], #32
  6010417144:	d65f03c0 	ret

0000006010417148 <load_kern_pgdir>:

/// @brief kernel pagedir
struct TopLevelPageDirectory kern_pgdir;

void load_kern_pgdir(struct TraceTag* mmu_driver_tag, struct TraceTag* intr_driver_tag)
{
  6010417148:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  601041714c:	910003fd 	mov	x29, sp
  6010417150:	f9000fe0 	str	x0, [sp, #24]
  6010417154:	f9000be1 	str	x1, [sp, #16]
    if (mmu_driver_tag->meta == NULL) {
  6010417158:	f9400fe0 	ldr	x0, [sp, #24]
  601041715c:	f9400000 	ldr	x0, [x0]
  6010417160:	f100001f 	cmp	x0, #0x0
  6010417164:	54000161 	b.ne	6010417190 <load_kern_pgdir+0x48>  // b.any
        ERROR("Invalid mmu driver tag.\n");
  6010417168:	52802022 	mov	w2, #0x101                 	// #257
  601041716c:	d0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010417170:	913c6001 	add	x1, x0, #0xf18
  6010417174:	d0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010417178:	9132a000 	add	x0, x0, #0xca8
  601041717c:	97fff3ff 	bl	6010414178 <printf_>
  6010417180:	d0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010417184:	9138e000 	add	x0, x0, #0xe38
  6010417188:	97fff3fc 	bl	6010414178 <printf_>
  601041718c:	1400003a 	b	6010417274 <load_kern_pgdir+0x12c>
        return;
    }

    if (!_new_pgdir(&kern_pgdir)) {
  6010417190:	90008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010417194:	f942fc00 	ldr	x0, [x0, #1528]
  6010417198:	97fffd9a 	bl	6010416800 <_new_pgdir>
  601041719c:	12001c00 	and	w0, w0, #0xff
  60104171a0:	52000000 	eor	w0, w0, #0x1
  60104171a4:	12001c00 	and	w0, w0, #0xff
  60104171a8:	7100001f 	cmp	w0, #0x0
  60104171ac:	54000080 	b.eq	60104171bc <load_kern_pgdir+0x74>  // b.none
        panic("cannot alloc kernel page directory");
  60104171b0:	d0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104171b4:	91396000 	add	x0, x0, #0xe58
  60104171b8:	97ffe03c 	bl	601040f2a8 <panic>
    }
    uintptr_t kern_attr = 0;
  60104171bc:	f90017ff 	str	xzr, [sp, #40]
    _p_pgtbl_mmu_access->MmuKernPteAttr(&kern_attr);
  60104171c0:	90008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  60104171c4:	f942bc00 	ldr	x0, [x0, #1400]
  60104171c8:	f9400000 	ldr	x0, [x0]
  60104171cc:	f9401001 	ldr	x1, [x0, #32]
  60104171d0:	9100a3e0 	add	x0, sp, #0x28
  60104171d4:	d63f0020 	blr	x1
    uintptr_t dev_attr = 0;
  60104171d8:	f90013ff 	str	xzr, [sp, #32]
    _p_pgtbl_mmu_access->MmuDevPteAttr(&dev_attr);
  60104171dc:	90008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  60104171e0:	f942bc00 	ldr	x0, [x0, #1400]
  60104171e4:	f9400000 	ldr	x0, [x0]
  60104171e8:	f9400001 	ldr	x1, [x0]
  60104171ec:	910083e0 	add	x0, sp, #0x20
  60104171f0:	d63f0020 	blr	x1

    // kern mem
    _map_pages((uintptr_t*)kern_pgdir.pd_addr, KERN_MEM_BASE, PHY_MEM_BASE, (PHY_MEM_STOP - PHY_MEM_BASE), kern_attr);
  60104171f4:	90008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  60104171f8:	f942fc00 	ldr	x0, [x0, #1528]
  60104171fc:	f9400000 	ldr	x0, [x0]
  6010417200:	f94017e1 	ldr	x1, [sp, #40]
  6010417204:	aa0103e4 	mov	x4, x1
  6010417208:	52a60003 	mov	w3, #0x30000000            	// #805306368
  601041720c:	d2a20002 	mov	x2, #0x10000000            	// #268435456
  6010417210:	d2a20001 	mov	x1, #0x10000000            	// #268435456
  6010417214:	f2c00c01 	movk	x1, #0x60, lsl #32
  6010417218:	97fffd94 	bl	6010416868 <_map_pages>
    // dev mem
    _map_pages((uintptr_t*)kern_pgdir.pd_addr, DEV_VRTMEM_BASE, DEV_PHYMEM_BASE, DEV_MEM_SIZE, dev_attr);
  601041721c:	90008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010417220:	f942fc00 	ldr	x0, [x0, #1528]
  6010417224:	f9400000 	ldr	x0, [x0]
  6010417228:	f94013e1 	ldr	x1, [sp, #32]
  601041722c:	aa0103e4 	mov	x4, x1
  6010417230:	52a20003 	mov	w3, #0x10000000            	// #268435456
  6010417234:	d2be0002 	mov	x2, #0xf0000000            	// #4026531840
  6010417238:	d2be0001 	mov	x1, #0xf0000000            	// #4026531840
  601041723c:	f2c00801 	movk	x1, #0x40, lsl #32
  6010417240:	97fffd8a 	bl	6010416868 <_map_pages>

    _p_pgtbl_mmu_access->LoadPgdir((uintptr_t)V2P(kern_pgdir.pd_addr));
  6010417244:	90008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010417248:	f942bc00 	ldr	x0, [x0, #1400]
  601041724c:	f9400000 	ldr	x0, [x0]
  6010417250:	f9401401 	ldr	x1, [x0, #40]
  6010417254:	90008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010417258:	f942fc00 	ldr	x0, [x0, #1528]
  601041725c:	f9400000 	ldr	x0, [x0]
  6010417260:	aa0003e2 	mov	x2, x0
  6010417264:	d2dff400 	mov	x0, #0xffa000000000        	// #281062659850240
  6010417268:	f2ffffe0 	movk	x0, #0xffff, lsl #48
  601041726c:	8b000040 	add	x0, x2, x0
  6010417270:	d63f0020 	blr	x1
}
  6010417274:	a8c37bfd 	ldp	x29, x30, [sp], #48
  6010417278:	d65f03c0 	ret

000000601041727c <secondary_cpu_load_kern_pgdir>:

void secondary_cpu_load_kern_pgdir(struct TraceTag* mmu_driver_tag, struct TraceTag* intr_driver_tag)
{
  601041727c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  6010417280:	910003fd 	mov	x29, sp
  6010417284:	f9000fe0 	str	x0, [sp, #24]
  6010417288:	f9000be1 	str	x1, [sp, #16]
    _p_pgtbl_mmu_access->LoadPgdir((uintptr_t)V2P(kern_pgdir.pd_addr));
  601041728c:	90008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010417290:	f942bc00 	ldr	x0, [x0, #1400]
  6010417294:	f9400000 	ldr	x0, [x0]
  6010417298:	f9401401 	ldr	x1, [x0, #40]
  601041729c:	90008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  60104172a0:	f942fc00 	ldr	x0, [x0, #1528]
  60104172a4:	f9400000 	ldr	x0, [x0]
  60104172a8:	aa0003e2 	mov	x2, x0
  60104172ac:	d2dff400 	mov	x0, #0xffa000000000        	// #281062659850240
  60104172b0:	f2ffffe0 	movk	x0, #0xffff, lsl #48
  60104172b4:	8b000040 	add	x0, x2, x0
  60104172b8:	d63f0020 	blr	x1
  60104172bc:	d503201f 	nop
  60104172c0:	a8c27bfd 	ldp	x29, x30, [sp], #32
  60104172c4:	d65f03c0 	ret

00000060104172c8 <_page_walk>:
#include "buddy.h"
#include "kalloc.h"
#include "pagetable.h"

uintptr_t* _page_walk(uintptr_t* pgdir, uintptr_t vaddr, bool alloc)
{
  60104172c8:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
  60104172cc:	910003fd 	mov	x29, sp
  60104172d0:	f90017e0 	str	x0, [sp, #40]
  60104172d4:	f90013e1 	str	x1, [sp, #32]
  60104172d8:	39007fe2 	strb	w2, [sp, #31]

    // get page table addr
    assert(pgdir != NULL);
  60104172dc:	f94017e0 	ldr	x0, [sp, #40]
  60104172e0:	f100001f 	cmp	x0, #0x0
  60104172e4:	540001e1 	b.ne	6010417320 <_page_walk+0x58>  // b.any
  60104172e8:	52800562 	mov	w2, #0x2b                  	// #43
  60104172ec:	d0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104172f0:	913e8001 	add	x1, x0, #0xfa0
  60104172f4:	d0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104172f8:	913ca000 	add	x0, x0, #0xf28
  60104172fc:	97fff39f 	bl	6010414178 <printf_>
  6010417300:	d0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010417304:	913ce001 	add	x1, x0, #0xf38
  6010417308:	d0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  601041730c:	913d2000 	add	x0, x0, #0xf48
  6010417310:	97fff39a 	bl	6010414178 <printf_>
  6010417314:	d0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010417318:	913d6000 	add	x0, x0, #0xf58
  601041731c:	97ffdfe3 	bl	601040f2a8 <panic>
    uintptr_t pde_attr = 0;
  6010417320:	f9001fff 	str	xzr, [sp, #56]
    _p_pgtbl_mmu_access->MmuPdeAttr(&pde_attr);
  6010417324:	90008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010417328:	f942bc00 	ldr	x0, [x0, #1400]
  601041732c:	f9400000 	ldr	x0, [x0]
  6010417330:	f9400401 	ldr	x1, [x0, #8]
  6010417334:	9100e3e0 	add	x0, sp, #0x38
  6010417338:	d63f0020 	blr	x1

    uintptr_t* l2_pde_ptr = (uintptr_t*)&pgdir[(vaddr >> LEVEL2_PDE_SHIFT) & (NUM_LEVEL2_PDE - 1)];
  601041733c:	f94013e0 	ldr	x0, [sp, #32]
  6010417340:	d35efc00 	lsr	x0, x0, #30
  6010417344:	92402000 	and	x0, x0, #0x1ff
  6010417348:	d37df000 	lsl	x0, x0, #3
  601041734c:	f94017e1 	ldr	x1, [sp, #40]
  6010417350:	8b000020 	add	x0, x1, x0
  6010417354:	f9002fe0 	str	x0, [sp, #88]

    uintptr_t* l3_pde_vaddr;
    if (*l2_pde_ptr != 0) {
  6010417358:	f9402fe0 	ldr	x0, [sp, #88]
  601041735c:	f9400000 	ldr	x0, [x0]
  6010417360:	f100001f 	cmp	x0, #0x0
  6010417364:	54000140 	b.eq	601041738c <_page_walk+0xc4>  // b.none
        uintptr_t l3_table_paddr = ALIGNDOWN(*l2_pde_ptr, PAGE_SIZE);
  6010417368:	f9402fe0 	ldr	x0, [sp, #88]
  601041736c:	f9400000 	ldr	x0, [x0]
  6010417370:	9274cc00 	and	x0, x0, #0xfffffffffffff000
  6010417374:	f9002be0 	str	x0, [sp, #80]
        l3_pde_vaddr = (uintptr_t*)P2V(l3_table_paddr);
  6010417378:	f9402be1 	ldr	x1, [sp, #80]
  601041737c:	d2c00c00 	mov	x0, #0x6000000000          	// #412316860416
  6010417380:	8b000020 	add	x0, x1, x0
  6010417384:	f90037e0 	str	x0, [sp, #104]
  6010417388:	1400001a 	b	60104173f0 <_page_walk+0x128>
    } else {
        if (!alloc || !(l3_pde_vaddr = (uintptr_t*)kalloc(sizeof(uintptr_t) * NUM_LEVEL3_PDE))) {
  601041738c:	39407fe0 	ldrb	w0, [sp, #31]
  6010417390:	52000000 	eor	w0, w0, #0x1
  6010417394:	12001c00 	and	w0, w0, #0xff
  6010417398:	7100001f 	cmp	w0, #0x0
  601041739c:	540000e1 	b.ne	60104173b8 <_page_walk+0xf0>  // b.any
  60104173a0:	d2820000 	mov	x0, #0x1000                	// #4096
  60104173a4:	97fffca6 	bl	601041663c <kalloc>
  60104173a8:	f90037e0 	str	x0, [sp, #104]
  60104173ac:	f94037e0 	ldr	x0, [sp, #104]
  60104173b0:	f100001f 	cmp	x0, #0x0
  60104173b4:	54000061 	b.ne	60104173c0 <_page_walk+0xf8>  // b.any
            return NULL;
  60104173b8:	d2800000 	mov	x0, #0x0                   	// #0
  60104173bc:	14000040 	b	60104174bc <_page_walk+0x1f4>
        }

        memset(l3_pde_vaddr, 0, sizeof(uintptr_t) * NUM_LEVEL3_PDE);
  60104173c0:	d2820002 	mov	x2, #0x1000                	// #4096
  60104173c4:	52800001 	mov	w1, #0x0                   	// #0
  60104173c8:	f94037e0 	ldr	x0, [sp, #104]
  60104173cc:	97ffdbbd 	bl	601040e2c0 <memset>
        *l2_pde_ptr = V2P(l3_pde_vaddr) | pde_attr;
  60104173d0:	f94037e1 	ldr	x1, [sp, #104]
  60104173d4:	d2dff400 	mov	x0, #0xffa000000000        	// #281062659850240
  60104173d8:	f2ffffe0 	movk	x0, #0xffff, lsl #48
  60104173dc:	8b000021 	add	x1, x1, x0
  60104173e0:	f9401fe0 	ldr	x0, [sp, #56]
  60104173e4:	aa000021 	orr	x1, x1, x0
  60104173e8:	f9402fe0 	ldr	x0, [sp, #88]
  60104173ec:	f9000001 	str	x1, [x0]
    }

    uintptr_t* l3_pde_ptr = (uintptr_t*)&l3_pde_vaddr[(vaddr >> LEVEL3_PDE_SHIFT) & (NUM_LEVEL3_PDE - 1)];
  60104173f0:	f94013e0 	ldr	x0, [sp, #32]
  60104173f4:	d355fc00 	lsr	x0, x0, #21
  60104173f8:	92402000 	and	x0, x0, #0x1ff
  60104173fc:	d37df000 	lsl	x0, x0, #3
  6010417400:	f94037e1 	ldr	x1, [sp, #104]
  6010417404:	8b000020 	add	x0, x1, x0
  6010417408:	f90027e0 	str	x0, [sp, #72]

    uintptr_t* l4_pte_vaddr;
    if (*l3_pde_ptr != 0) {
  601041740c:	f94027e0 	ldr	x0, [sp, #72]
  6010417410:	f9400000 	ldr	x0, [x0]
  6010417414:	f100001f 	cmp	x0, #0x0
  6010417418:	54000140 	b.eq	6010417440 <_page_walk+0x178>  // b.none
        uintptr_t l4_table_paddr = ALIGNDOWN(*l3_pde_ptr, PAGE_SIZE);
  601041741c:	f94027e0 	ldr	x0, [sp, #72]
  6010417420:	f9400000 	ldr	x0, [x0]
  6010417424:	9274cc00 	and	x0, x0, #0xfffffffffffff000
  6010417428:	f90023e0 	str	x0, [sp, #64]
        l4_pte_vaddr = (uintptr_t*)P2V(l4_table_paddr);
  601041742c:	f94023e1 	ldr	x1, [sp, #64]
  6010417430:	d2c00c00 	mov	x0, #0x6000000000          	// #412316860416
  6010417434:	8b000020 	add	x0, x1, x0
  6010417438:	f90033e0 	str	x0, [sp, #96]
  601041743c:	1400001a 	b	60104174a4 <_page_walk+0x1dc>
    } else {
        if (!alloc || !(l4_pte_vaddr = (uintptr_t*)kalloc(sizeof(uintptr_t) * NUM_LEVEL4_PTE))) {
  6010417440:	39407fe0 	ldrb	w0, [sp, #31]
  6010417444:	52000000 	eor	w0, w0, #0x1
  6010417448:	12001c00 	and	w0, w0, #0xff
  601041744c:	7100001f 	cmp	w0, #0x0
  6010417450:	540000e1 	b.ne	601041746c <_page_walk+0x1a4>  // b.any
  6010417454:	d2820000 	mov	x0, #0x1000                	// #4096
  6010417458:	97fffc79 	bl	601041663c <kalloc>
  601041745c:	f90033e0 	str	x0, [sp, #96]
  6010417460:	f94033e0 	ldr	x0, [sp, #96]
  6010417464:	f100001f 	cmp	x0, #0x0
  6010417468:	54000061 	b.ne	6010417474 <_page_walk+0x1ac>  // b.any
            return NULL;
  601041746c:	d2800000 	mov	x0, #0x0                   	// #0
  6010417470:	14000013 	b	60104174bc <_page_walk+0x1f4>
        }

        memset(l4_pte_vaddr, 0, sizeof(uintptr_t) * NUM_LEVEL4_PTE);
  6010417474:	d2820002 	mov	x2, #0x1000                	// #4096
  6010417478:	52800001 	mov	w1, #0x0                   	// #0
  601041747c:	f94033e0 	ldr	x0, [sp, #96]
  6010417480:	97ffdb90 	bl	601040e2c0 <memset>
        *l3_pde_ptr = V2P(l4_pte_vaddr) | pde_attr;
  6010417484:	f94033e1 	ldr	x1, [sp, #96]
  6010417488:	d2dff400 	mov	x0, #0xffa000000000        	// #281062659850240
  601041748c:	f2ffffe0 	movk	x0, #0xffff, lsl #48
  6010417490:	8b000021 	add	x1, x1, x0
  6010417494:	f9401fe0 	ldr	x0, [sp, #56]
  6010417498:	aa000021 	orr	x1, x1, x0
  601041749c:	f94027e0 	ldr	x0, [sp, #72]
  60104174a0:	f9000001 	str	x1, [x0]
    }

    return &l4_pte_vaddr[LEVEL4_PTE_IDX(vaddr)];
  60104174a4:	f94013e0 	ldr	x0, [sp, #32]
  60104174a8:	d34cfc00 	lsr	x0, x0, #12
  60104174ac:	92402000 	and	x0, x0, #0x1ff
  60104174b0:	d37df000 	lsl	x0, x0, #3
  60104174b4:	f94033e1 	ldr	x1, [sp, #96]
  60104174b8:	8b000020 	add	x0, x1, x0
}
  60104174bc:	a8c77bfd 	ldp	x29, x30, [sp], #112
  60104174c0:	d65f03c0 	ret

00000060104174c4 <_free_user_pgdir>:

void _free_user_pgdir(struct TopLevelPageDirectory* pgdir)
{
  60104174c4:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
  60104174c8:	910003fd 	mov	x29, sp
  60104174cc:	f9000fe0 	str	x0, [sp, #24]
    if (pgdir->pd_addr == NULL) {
  60104174d0:	f9400fe0 	ldr	x0, [sp, #24]
  60104174d4:	f9400000 	ldr	x0, [x0]
  60104174d8:	f100001f 	cmp	x0, #0x0
  60104174dc:	540014c0 	b.eq	6010417774 <_free_user_pgdir+0x2b0>  // b.none
        return;
    }

    uintptr_t low_bound = kern_virtmem_buddy.mem_start, high_bound = kern_virtmem_buddy.mem_end;
  60104174e0:	90008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  60104174e4:	f942d400 	ldr	x0, [x0, #1448]
  60104174e8:	f9409c00 	ldr	x0, [x0, #312]
  60104174ec:	f9003be0 	str	x0, [sp, #112]
  60104174f0:	90008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  60104174f4:	f942d400 	ldr	x0, [x0, #1448]
  60104174f8:	f940a000 	ldr	x0, [x0, #320]
  60104174fc:	f90037e0 	str	x0, [sp, #104]
    uintptr_t user_low_bound = user_phy_freemem_buddy.mem_start, user_high_bound = user_phy_freemem_buddy.mem_end;
  6010417500:	90008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010417504:	f9429800 	ldr	x0, [x0, #1328]
  6010417508:	f9409c00 	ldr	x0, [x0, #312]
  601041750c:	f90033e0 	str	x0, [sp, #96]
  6010417510:	90008960 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010417514:	f9429800 	ldr	x0, [x0, #1328]
  6010417518:	f940a000 	ldr	x0, [x0, #320]
  601041751c:	f9002fe0 	str	x0, [sp, #88]
    uintptr_t end_idx = (USER_MEM_TOP >> LEVEL2_PDE_SHIFT) & (NUM_LEVEL2_PDE - 1);
  6010417520:	d2802000 	mov	x0, #0x100                 	// #256
  6010417524:	f9002be0 	str	x0, [sp, #80]

    for (uintptr_t l2_entry_idx = 0; l2_entry_idx < end_idx; l2_entry_idx++) {
  6010417528:	f90047ff 	str	xzr, [sp, #136]
  601041752c:	1400008a 	b	6010417754 <_free_user_pgdir+0x290>
        // free each level3 page table
        uintptr_t* l3_table_paddr = (uintptr_t*)ALIGNDOWN(pgdir->pd_addr[l2_entry_idx], PAGE_SIZE);
  6010417530:	f9400fe0 	ldr	x0, [sp, #24]
  6010417534:	f9400001 	ldr	x1, [x0]
  6010417538:	f94047e0 	ldr	x0, [sp, #136]
  601041753c:	d37df000 	lsl	x0, x0, #3
  6010417540:	8b000020 	add	x0, x1, x0
  6010417544:	f9400000 	ldr	x0, [x0]
  6010417548:	9274cc00 	and	x0, x0, #0xfffffffffffff000
  601041754c:	f90027e0 	str	x0, [sp, #72]
        if (l3_table_paddr != NULL) {
  6010417550:	f94027e0 	ldr	x0, [sp, #72]
  6010417554:	f100001f 	cmp	x0, #0x0
  6010417558:	54000f80 	b.eq	6010417748 <_free_user_pgdir+0x284>  // b.none
            uintptr_t* l3_table_vaddr = P2V(l3_table_paddr);
  601041755c:	f94027e1 	ldr	x1, [sp, #72]
  6010417560:	d2c00c00 	mov	x0, #0x6000000000          	// #412316860416
  6010417564:	8b000020 	add	x0, x1, x0
  6010417568:	f90023e0 	str	x0, [sp, #64]
            for (uintptr_t l3_entry_idx = 0; l3_entry_idx < NUM_LEVEL3_PDE; l3_entry_idx++) {
  601041756c:	f90043ff 	str	xzr, [sp, #128]
  6010417570:	1400006f 	b	601041772c <_free_user_pgdir+0x268>
                uintptr_t* l4_table_paddr = (uintptr_t*)LEVEL4_PTE_ADDR(l3_table_vaddr[l3_entry_idx]);
  6010417574:	f94043e0 	ldr	x0, [sp, #128]
  6010417578:	d37df000 	lsl	x0, x0, #3
  601041757c:	f94023e1 	ldr	x1, [sp, #64]
  6010417580:	8b000020 	add	x0, x1, x0
  6010417584:	f9400000 	ldr	x0, [x0]
  6010417588:	9274cc00 	and	x0, x0, #0xfffffffffffff000
  601041758c:	f9001fe0 	str	x0, [sp, #56]
                if (l4_table_paddr != NULL) {
  6010417590:	f9401fe0 	ldr	x0, [sp, #56]
  6010417594:	f100001f 	cmp	x0, #0x0
  6010417598:	54000c40 	b.eq	6010417720 <_free_user_pgdir+0x25c>  // b.none
                    uintptr_t* l4_table_vaddr = P2V(l4_table_paddr);
  601041759c:	f9401fe1 	ldr	x1, [sp, #56]
  60104175a0:	d2c00c00 	mov	x0, #0x6000000000          	// #412316860416
  60104175a4:	8b000020 	add	x0, x1, x0
  60104175a8:	f9001be0 	str	x0, [sp, #48]
                    for (uintptr_t page_entry_idx = 0; page_entry_idx < NUM_LEVEL4_PTE; page_entry_idx++) {
  60104175ac:	f9003fff 	str	xzr, [sp, #120]
  60104175b0:	14000055 	b	6010417704 <_free_user_pgdir+0x240>
                        uintptr_t vaddr = (l2_entry_idx << LEVEL2_PDE_SHIFT) | (l3_entry_idx << LEVEL3_PDE_SHIFT) | (page_entry_idx << LEVEL4_PTE_SHIFT);
  60104175b4:	f94047e0 	ldr	x0, [sp, #136]
  60104175b8:	d3628401 	lsl	x1, x0, #30
  60104175bc:	f94043e0 	ldr	x0, [sp, #128]
  60104175c0:	d36ba800 	lsl	x0, x0, #21
  60104175c4:	aa000021 	orr	x1, x1, x0
  60104175c8:	f9403fe0 	ldr	x0, [sp, #120]
  60104175cc:	d374cc00 	lsl	x0, x0, #12
  60104175d0:	aa000020 	orr	x0, x1, x0
  60104175d4:	f90017e0 	str	x0, [sp, #40]

                        // get page paddr
                        uintptr_t* page_paddr = (uintptr_t*)ALIGNDOWN((l4_table_vaddr)[page_entry_idx], PAGE_SIZE);
  60104175d8:	f9403fe0 	ldr	x0, [sp, #120]
  60104175dc:	d37df000 	lsl	x0, x0, #3
  60104175e0:	f9401be1 	ldr	x1, [sp, #48]
  60104175e4:	8b000020 	add	x0, x1, x0
  60104175e8:	f9400000 	ldr	x0, [x0]
  60104175ec:	9274cc00 	and	x0, x0, #0xfffffffffffff000
  60104175f0:	f90013e0 	str	x0, [sp, #32]
                        if (page_paddr != NULL) {
  60104175f4:	f94013e0 	ldr	x0, [sp, #32]
  60104175f8:	f100001f 	cmp	x0, #0x0
  60104175fc:	540007e0 	b.eq	60104176f8 <_free_user_pgdir+0x234>  // b.none
                            // Ensure the virtual address is not in the IPC address space
                            assert(vaddr < USER_IPC_SPACE_BASE || vaddr >= USER_IPC_SPACE_TOP);
  6010417600:	f94017e1 	ldr	x1, [sp, #40]
  6010417604:	d2c00600 	mov	x0, #0x3000000000          	// #206158430208
  6010417608:	eb00003f 	cmp	x1, x0
  601041760c:	54000283 	b.cc	601041765c <_free_user_pgdir+0x198>  // b.lo, b.ul, b.last
  6010417610:	f94017e1 	ldr	x1, [sp, #40]
  6010417614:	b2406fe0 	mov	x0, #0xfffffff             	// #268435455
  6010417618:	f2c00600 	movk	x0, #0x30, lsl #32
  601041761c:	eb00003f 	cmp	x1, x0
  6010417620:	540001e8 	b.hi	601041765c <_free_user_pgdir+0x198>  // b.pmore
  6010417624:	52800d42 	mov	w2, #0x6a                  	// #106
  6010417628:	d0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  601041762c:	913ec001 	add	x1, x0, #0xfb0
  6010417630:	d0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010417634:	913ca000 	add	x0, x0, #0xf28
  6010417638:	97fff2d0 	bl	6010414178 <printf_>
  601041763c:	d0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010417640:	913d8001 	add	x1, x0, #0xf60
  6010417644:	d0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010417648:	913d2000 	add	x0, x0, #0xf48
  601041764c:	97fff2cb 	bl	6010414178 <printf_>
  6010417650:	d0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010417654:	913d6000 	add	x0, x0, #0xf58
  6010417658:	97ffdf14 	bl	601040f2a8 <panic>

                            if (LIKELY((uintptr_t)page_paddr >= low_bound && (uintptr_t)page_paddr < high_bound)) {
  601041765c:	f94013e0 	ldr	x0, [sp, #32]
  6010417660:	f9403be1 	ldr	x1, [sp, #112]
  6010417664:	eb00003f 	cmp	x1, x0
  6010417668:	1a9f87e0 	cset	w0, ls  // ls = plast
  601041766c:	12001c00 	and	w0, w0, #0xff
  6010417670:	92401c00 	and	x0, x0, #0xff
  6010417674:	f100001f 	cmp	x0, #0x0
  6010417678:	540001c0 	b.eq	60104176b0 <_free_user_pgdir+0x1ec>  // b.none
  601041767c:	f94013e0 	ldr	x0, [sp, #32]
  6010417680:	f94037e1 	ldr	x1, [sp, #104]
  6010417684:	eb00003f 	cmp	x1, x0
  6010417688:	1a9f97e0 	cset	w0, hi  // hi = pmore
  601041768c:	12001c00 	and	w0, w0, #0xff
  6010417690:	92401c00 	and	x0, x0, #0xff
  6010417694:	f100001f 	cmp	x0, #0x0
  6010417698:	540000c0 	b.eq	60104176b0 <_free_user_pgdir+0x1ec>  // b.none
                                kfree(P2V(page_paddr));
  601041769c:	f94013e1 	ldr	x1, [sp, #32]
  60104176a0:	d2c00c00 	mov	x0, #0x6000000000          	// #412316860416
  60104176a4:	8b000020 	add	x0, x1, x0
  60104176a8:	97fffc26 	bl	6010416740 <kfree>
  60104176ac:	14000013 	b	60104176f8 <_free_user_pgdir+0x234>
                            } else if (LIKELY((uintptr_t)page_paddr >= user_low_bound && (uintptr_t)page_paddr < user_high_bound)) {
  60104176b0:	f94013e0 	ldr	x0, [sp, #32]
  60104176b4:	f94033e1 	ldr	x1, [sp, #96]
  60104176b8:	eb00003f 	cmp	x1, x0
  60104176bc:	1a9f87e0 	cset	w0, ls  // ls = plast
  60104176c0:	12001c00 	and	w0, w0, #0xff
  60104176c4:	92401c00 	and	x0, x0, #0xff
  60104176c8:	f100001f 	cmp	x0, #0x0
  60104176cc:	54000160 	b.eq	60104176f8 <_free_user_pgdir+0x234>  // b.none
  60104176d0:	f94013e0 	ldr	x0, [sp, #32]
  60104176d4:	f9402fe1 	ldr	x1, [sp, #88]
  60104176d8:	eb00003f 	cmp	x1, x0
  60104176dc:	1a9f97e0 	cset	w0, hi  // hi = pmore
  60104176e0:	12001c00 	and	w0, w0, #0xff
  60104176e4:	92401c00 	and	x0, x0, #0xff
  60104176e8:	f100001f 	cmp	x0, #0x0
  60104176ec:	54000060 	b.eq	60104176f8 <_free_user_pgdir+0x234>  // b.none
                                raw_free((char*)page_paddr);
  60104176f0:	f94013e0 	ldr	x0, [sp, #32]
  60104176f4:	97fffc31 	bl	60104167b8 <raw_free>
                    for (uintptr_t page_entry_idx = 0; page_entry_idx < NUM_LEVEL4_PTE; page_entry_idx++) {
  60104176f8:	f9403fe0 	ldr	x0, [sp, #120]
  60104176fc:	91000400 	add	x0, x0, #0x1
  6010417700:	f9003fe0 	str	x0, [sp, #120]
  6010417704:	f9403fe0 	ldr	x0, [sp, #120]
  6010417708:	f107fc1f 	cmp	x0, #0x1ff
  601041770c:	54fff549 	b.ls	60104175b4 <_free_user_pgdir+0xf0>  // b.plast
                            }
                        }
                    }
                    kfree(P2V(l4_table_paddr));
  6010417710:	f9401fe1 	ldr	x1, [sp, #56]
  6010417714:	d2c00c00 	mov	x0, #0x6000000000          	// #412316860416
  6010417718:	8b000020 	add	x0, x1, x0
  601041771c:	97fffc09 	bl	6010416740 <kfree>
            for (uintptr_t l3_entry_idx = 0; l3_entry_idx < NUM_LEVEL3_PDE; l3_entry_idx++) {
  6010417720:	f94043e0 	ldr	x0, [sp, #128]
  6010417724:	91000400 	add	x0, x0, #0x1
  6010417728:	f90043e0 	str	x0, [sp, #128]
  601041772c:	f94043e0 	ldr	x0, [sp, #128]
  6010417730:	f107fc1f 	cmp	x0, #0x1ff
  6010417734:	54fff209 	b.ls	6010417574 <_free_user_pgdir+0xb0>  // b.plast
                }
            }
            kfree(P2V(l3_table_paddr));
  6010417738:	f94027e1 	ldr	x1, [sp, #72]
  601041773c:	d2c00c00 	mov	x0, #0x6000000000          	// #412316860416
  6010417740:	8b000020 	add	x0, x1, x0
  6010417744:	97fffbff 	bl	6010416740 <kfree>
    for (uintptr_t l2_entry_idx = 0; l2_entry_idx < end_idx; l2_entry_idx++) {
  6010417748:	f94047e0 	ldr	x0, [sp, #136]
  601041774c:	91000400 	add	x0, x0, #0x1
  6010417750:	f90047e0 	str	x0, [sp, #136]
  6010417754:	f94047e1 	ldr	x1, [sp, #136]
  6010417758:	f9402be0 	ldr	x0, [sp, #80]
  601041775c:	eb00003f 	cmp	x1, x0
  6010417760:	54ffee83 	b.cc	6010417530 <_free_user_pgdir+0x6c>  // b.lo, b.ul, b.last
        }
    }
    kfree((char*)pgdir->pd_addr);
  6010417764:	f9400fe0 	ldr	x0, [sp, #24]
  6010417768:	f9400000 	ldr	x0, [x0]
  601041776c:	97fffbf5 	bl	6010416740 <kfree>
  6010417770:	14000002 	b	6010417778 <_free_user_pgdir+0x2b4>
        return;
  6010417774:	d503201f 	nop
}
  6010417778:	a8c97bfd 	ldp	x29, x30, [sp], #144
  601041777c:	d65f03c0 	ret

0000006010417780 <_buddy_split_page>:
#include "buddy.h"
#include "kalloc.h"
#include "log.h"

static void _buddy_split_page(struct KPage* page, uintptr_t low_order, uintptr_t high_order, struct KFreeList* list)
{
  6010417780:	d10143ff 	sub	sp, sp, #0x50
  6010417784:	f9000fe0 	str	x0, [sp, #24]
  6010417788:	f9000be1 	str	x1, [sp, #16]
  601041778c:	f90007e2 	str	x2, [sp, #8]
  6010417790:	f90003e3 	str	x3, [sp]
    uintptr_t size = (1 << high_order);
  6010417794:	f94007e0 	ldr	x0, [sp, #8]
  6010417798:	2a0003e1 	mov	w1, w0
  601041779c:	52800020 	mov	w0, #0x1                   	// #1
  60104177a0:	1ac12000 	lsl	w0, w0, w1
  60104177a4:	93407c00 	sxtw	x0, w0
  60104177a8:	f90027e0 	str	x0, [sp, #72]
    while (high_order > low_order) {
  60104177ac:	1400002d 	b	6010417860 <_buddy_split_page+0xe0>
        list--;
  60104177b0:	f94003e0 	ldr	x0, [sp]
  60104177b4:	d1006000 	sub	x0, x0, #0x18
  60104177b8:	f90003e0 	str	x0, [sp]
        size >>= 1;
  60104177bc:	f94027e0 	ldr	x0, [sp, #72]
  60104177c0:	d341fc00 	lsr	x0, x0, #1
  60104177c4:	f90027e0 	str	x0, [sp, #72]
        doubleListAddOnHead(&page[size].node, &list->list_head);
  60104177c8:	f94027e0 	ldr	x0, [sp, #72]
  60104177cc:	d37be800 	lsl	x0, x0, #5
  60104177d0:	f9400fe1 	ldr	x1, [sp, #24]
  60104177d4:	8b000020 	add	x0, x1, x0
  60104177d8:	aa0003e1 	mov	x1, x0
  60104177dc:	f94003e0 	ldr	x0, [sp]
  60104177e0:	91002000 	add	x0, x0, #0x8
  60104177e4:	f90023e1 	str	x1, [sp, #64]
  60104177e8:	f9001fe0 	str	x0, [sp, #56]
    _double_list_add(new_node, head, head->next);
  60104177ec:	f9401fe0 	ldr	x0, [sp, #56]
  60104177f0:	f9400000 	ldr	x0, [x0]
  60104177f4:	f94023e1 	ldr	x1, [sp, #64]
  60104177f8:	f9001be1 	str	x1, [sp, #48]
  60104177fc:	f9401fe1 	ldr	x1, [sp, #56]
  6010417800:	f90017e1 	str	x1, [sp, #40]
  6010417804:	f90013e0 	str	x0, [sp, #32]
    next->prev = new_node;
  6010417808:	f94013e0 	ldr	x0, [sp, #32]
  601041780c:	f9401be1 	ldr	x1, [sp, #48]
  6010417810:	f9000401 	str	x1, [x0, #8]
    new_node->next = next;
  6010417814:	f9401be0 	ldr	x0, [sp, #48]
  6010417818:	f94013e1 	ldr	x1, [sp, #32]
  601041781c:	f9000001 	str	x1, [x0]
    new_node->prev = prev;
  6010417820:	f9401be0 	ldr	x0, [sp, #48]
  6010417824:	f94017e1 	ldr	x1, [sp, #40]
  6010417828:	f9000401 	str	x1, [x0, #8]
    prev->next = new_node;
  601041782c:	f94017e0 	ldr	x0, [sp, #40]
  6010417830:	f9401be1 	ldr	x1, [sp, #48]
  6010417834:	f9000001 	str	x1, [x0]
}
  6010417838:	d503201f 	nop
}
  601041783c:	d503201f 	nop
        list->n_free_pages++;
  6010417840:	f94003e0 	ldr	x0, [sp]
  6010417844:	f9400000 	ldr	x0, [x0]
  6010417848:	91000401 	add	x1, x0, #0x1
  601041784c:	f94003e0 	ldr	x0, [sp]
  6010417850:	f9000001 	str	x1, [x0]
        high_order--;
  6010417854:	f94007e0 	ldr	x0, [sp, #8]
  6010417858:	d1000400 	sub	x0, x0, #0x1
  601041785c:	f90007e0 	str	x0, [sp, #8]
    while (high_order > low_order) {
  6010417860:	f94007e1 	ldr	x1, [sp, #8]
  6010417864:	f9400be0 	ldr	x0, [sp, #16]
  6010417868:	eb00003f 	cmp	x1, x0
  601041786c:	54fffa28 	b.hi	60104177b0 <_buddy_split_page+0x30>  // b.pmore
    }
}
  6010417870:	d503201f 	nop
  6010417874:	d503201f 	nop
  6010417878:	910143ff 	add	sp, sp, #0x50
  601041787c:	d65f03c0 	ret

0000006010417880 <KBuddyPagesAlloc>:
    return;
}

// find free page and split it to small page if need
static struct KPage* KBuddyPagesAlloc(struct KBuddy* pbuddy, int nPages)
{
  6010417880:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
  6010417884:	910003fd 	mov	x29, sp
  6010417888:	f9000fe0 	str	x0, [sp, #24]
  601041788c:	b90017e1 	str	w1, [sp, #20]
    struct KPage* page = NULL;
  6010417890:	f90033ff 	str	xzr, [sp, #96]
    struct KFreeList* list = NULL;
  6010417894:	f9002fff 	str	xzr, [sp, #88]
    int i = 0, order = 0;
  6010417898:	b9006fff 	str	wzr, [sp, #108]
  601041789c:	b9006bff 	str	wzr, [sp, #104]

    // find order
    for (order = 0; (FREE_LIST_INDEX(order)) < nPages; order++)
  60104178a0:	b9006bff 	str	wzr, [sp, #104]
  60104178a4:	14000004 	b	60104178b4 <KBuddyPagesAlloc+0x34>
  60104178a8:	b9406be0 	ldr	w0, [sp, #104]
  60104178ac:	11000400 	add	w0, w0, #0x1
  60104178b0:	b9006be0 	str	w0, [sp, #104]
  60104178b4:	b9406be0 	ldr	w0, [sp, #104]
  60104178b8:	52800021 	mov	w1, #0x1                   	// #1
  60104178bc:	1ac02020 	lsl	w0, w1, w0
  60104178c0:	b94017e1 	ldr	w1, [sp, #20]
  60104178c4:	6b00003f 	cmp	w1, w0
  60104178c8:	54ffff0c 	b.gt	60104178a8 <KBuddyPagesAlloc+0x28>
        ;

    // find the free page list
    for (i = order; i < MAX_BUDDY_ORDER; i++) {
  60104178cc:	b9406be0 	ldr	w0, [sp, #104]
  60104178d0:	b9006fe0 	str	w0, [sp, #108]
  60104178d4:	14000056 	b	6010417a2c <KBuddyPagesAlloc+0x1ac>
        list = pbuddy->free_list + i;
  60104178d8:	f9400fe0 	ldr	x0, [sp, #24]
  60104178dc:	91010001 	add	x1, x0, #0x40
  60104178e0:	b9806fe2 	ldrsw	x2, [sp, #108]
  60104178e4:	d2800300 	mov	x0, #0x18                  	// #24
  60104178e8:	9b007c40 	mul	x0, x2, x0
  60104178ec:	8b000020 	add	x0, x1, x0
  60104178f0:	f9002fe0 	str	x0, [sp, #88]
        if (IS_DOUBLE_LIST_EMPTY(&list->list_head)) {
  60104178f4:	f9402fe0 	ldr	x0, [sp, #88]
  60104178f8:	f9400401 	ldr	x1, [x0, #8]
  60104178fc:	f9402fe0 	ldr	x0, [sp, #88]
  6010417900:	91002000 	add	x0, x0, #0x8
  6010417904:	eb00003f 	cmp	x1, x0
  6010417908:	540000a1 	b.ne	601041791c <KBuddyPagesAlloc+0x9c>  // b.any
    for (i = order; i < MAX_BUDDY_ORDER; i++) {
  601041790c:	b9406fe0 	ldr	w0, [sp, #108]
  6010417910:	11000400 	add	w0, w0, #0x1
  6010417914:	b9006fe0 	str	w0, [sp, #108]
  6010417918:	14000045 	b	6010417a2c <KBuddyPagesAlloc+0x1ac>
            continue;
        }

        // find the page
        page = CONTAINER_OF(list->list_head.next, struct KPage, node);
  601041791c:	f9402fe0 	ldr	x0, [sp, #88]
  6010417920:	f9400400 	ldr	x0, [x0, #8]
  6010417924:	f90033e0 	str	x0, [sp, #96]
        doubleListDel(&page->node);
  6010417928:	f94033e0 	ldr	x0, [sp, #96]
  601041792c:	f9001be0 	str	x0, [sp, #48]
    _double_list_del(entry->prev, entry->next);
  6010417930:	f9401be0 	ldr	x0, [sp, #48]
  6010417934:	f9400401 	ldr	x1, [x0, #8]
  6010417938:	f9401be0 	ldr	x0, [sp, #48]
  601041793c:	f9400000 	ldr	x0, [x0]
  6010417940:	f90017e1 	str	x1, [sp, #40]
  6010417944:	f90013e0 	str	x0, [sp, #32]
    next->prev = prev;
  6010417948:	f94013e0 	ldr	x0, [sp, #32]
  601041794c:	f94017e1 	ldr	x1, [sp, #40]
  6010417950:	f9000401 	str	x1, [x0, #8]
    prev->next = next;
  6010417954:	f94017e0 	ldr	x0, [sp, #40]
  6010417958:	f94013e1 	ldr	x1, [sp, #32]
  601041795c:	f9000001 	str	x1, [x0]
}
  6010417960:	d503201f 	nop
    entry->next = entry;
  6010417964:	f9401be0 	ldr	x0, [sp, #48]
  6010417968:	f9401be1 	ldr	x1, [sp, #48]
  601041796c:	f9000001 	str	x1, [x0]
    entry->prev = entry;
  6010417970:	f9401be0 	ldr	x0, [sp, #48]
  6010417974:	f9401be1 	ldr	x1, [sp, #48]
  6010417978:	f9000401 	str	x1, [x0, #8]
}
  601041797c:	d503201f 	nop
        list->n_free_pages--;
  6010417980:	f9402fe0 	ldr	x0, [sp, #88]
  6010417984:	f9400000 	ldr	x0, [x0]
  6010417988:	d1000401 	sub	x1, x0, #0x1
  601041798c:	f9402fe0 	ldr	x0, [sp, #88]
  6010417990:	f9000001 	str	x1, [x0]

        // split the page to some small pages
        _buddy_split_page(page, order, i, list);
  6010417994:	b9806be0 	ldrsw	x0, [sp, #104]
  6010417998:	b9806fe1 	ldrsw	x1, [sp, #108]
  601041799c:	f9402fe3 	ldr	x3, [sp, #88]
  60104179a0:	aa0103e2 	mov	x2, x1
  60104179a4:	aa0003e1 	mov	x1, x0
  60104179a8:	f94033e0 	ldr	x0, [sp, #96]
  60104179ac:	97ffff75 	bl	6010417780 <_buddy_split_page>
  60104179b0:	f94033e0 	ldr	x0, [sp, #96]
  60104179b4:	f9002be0 	str	x0, [sp, #80]
  60104179b8:	b9406be0 	ldr	w0, [sp, #104]
  60104179bc:	b9004fe0 	str	w0, [sp, #76]
    struct KPage* p = NULL;
  60104179c0:	f90023ff 	str	xzr, [sp, #64]
    page->order = order;
  60104179c4:	b9804fe1 	ldrsw	x1, [sp, #76]
  60104179c8:	f9402be0 	ldr	x0, [sp, #80]
  60104179cc:	f9000801 	str	x1, [x0, #16]
    for (i = 1; i < FREE_LIST_INDEX(order); i++) {
  60104179d0:	52800020 	mov	w0, #0x1                   	// #1
  60104179d4:	b9003fe0 	str	w0, [sp, #60]
  60104179d8:	1400000c 	b	6010417a08 <KBuddyPagesAlloc+0x188>
        p = page + i;
  60104179dc:	b9803fe0 	ldrsw	x0, [sp, #60]
  60104179e0:	d37be800 	lsl	x0, x0, #5
  60104179e4:	f9402be1 	ldr	x1, [sp, #80]
  60104179e8:	8b000020 	add	x0, x1, x0
  60104179ec:	f90023e0 	str	x0, [sp, #64]
        p->page_node = page;
  60104179f0:	f94023e0 	ldr	x0, [sp, #64]
  60104179f4:	f9402be1 	ldr	x1, [sp, #80]
  60104179f8:	f9000801 	str	x1, [x0, #16]
    for (i = 1; i < FREE_LIST_INDEX(order); i++) {
  60104179fc:	b9403fe0 	ldr	w0, [sp, #60]
  6010417a00:	11000400 	add	w0, w0, #0x1
  6010417a04:	b9003fe0 	str	w0, [sp, #60]
  6010417a08:	b9404fe0 	ldr	w0, [sp, #76]
  6010417a0c:	52800021 	mov	w1, #0x1                   	// #1
  6010417a10:	1ac02020 	lsl	w0, w1, w0
  6010417a14:	b9403fe1 	ldr	w1, [sp, #60]
  6010417a18:	6b00003f 	cmp	w1, w0
  6010417a1c:	54fffe0b 	b.lt	60104179dc <KBuddyPagesAlloc+0x15c>  // b.tstop
}
  6010417a20:	d503201f 	nop

        // set the pages' order
        _buddy_set_pages_order(page, order);

        return page;
  6010417a24:	f94033e0 	ldr	x0, [sp, #96]
  6010417a28:	14000005 	b	6010417a3c <KBuddyPagesAlloc+0x1bc>
    for (i = order; i < MAX_BUDDY_ORDER; i++) {
  6010417a2c:	b9406fe0 	ldr	w0, [sp, #108]
  6010417a30:	7100241f 	cmp	w0, #0x9
  6010417a34:	54fff52d 	b.le	60104178d8 <KBuddyPagesAlloc+0x58>
    }

    // there is no enough free page to satisfy the nPages
    return NULL;
  6010417a38:	d2800000 	mov	x0, #0x0                   	// #0
}
  6010417a3c:	a8c77bfd 	ldp	x29, x30, [sp], #112
  6010417a40:	d65f03c0 	ret

0000006010417a44 <KBuddyPagesFree>:

// free continuous pages from page pointer
static void KBuddyPagesFree(struct KBuddy* pbuddy, struct KPage* page)
{
  6010417a44:	d10203ff 	sub	sp, sp, #0x80
  6010417a48:	f90007e0 	str	x0, [sp, #8]
  6010417a4c:	f90003e1 	str	x1, [sp]
    struct KPage* buddy = NULL;
  6010417a50:	f90037ff 	str	xzr, [sp, #104]
    uintptr_t order = (page->order >= MAX_BUDDY_ORDER) ? 0 : page->order;
  6010417a54:	f94003e0 	ldr	x0, [sp]
  6010417a58:	f9400800 	ldr	x0, [x0, #16]
  6010417a5c:	f100241f 	cmp	x0, #0x9
  6010417a60:	54000088 	b.hi	6010417a70 <KBuddyPagesFree+0x2c>  // b.pmore
  6010417a64:	f94003e0 	ldr	x0, [sp]
  6010417a68:	f9400800 	ldr	x0, [x0, #16]
  6010417a6c:	14000002 	b	6010417a74 <KBuddyPagesFree+0x30>
  6010417a70:	d2800000 	mov	x0, #0x0                   	// #0
  6010417a74:	f9003fe0 	str	x0, [sp, #120]
    uintptr_t page_idx = page - pbuddy->pages;
  6010417a78:	f94007e0 	ldr	x0, [sp, #8]
  6010417a7c:	f940a400 	ldr	x0, [x0, #328]
  6010417a80:	f94003e1 	ldr	x1, [sp]
  6010417a84:	cb000020 	sub	x0, x1, x0
  6010417a88:	9345fc00 	asr	x0, x0, #5
  6010417a8c:	f9003be0 	str	x0, [sp, #112]

    for (; order < MAX_BUDDY_ORDER - 1; order++) {
  6010417a90:	1400005b 	b	6010417bfc <KBuddyPagesFree+0x1b8>
        // find and delete buddy to combine
        uintptr_t buddy_idx = BUDDY_PAGE_INDEX(page_idx, order);
  6010417a94:	f9403fe0 	ldr	x0, [sp, #120]
  6010417a98:	2a0003e1 	mov	w1, w0
  6010417a9c:	52800020 	mov	w0, #0x1                   	// #1
  6010417aa0:	1ac12000 	lsl	w0, w0, w1
  6010417aa4:	93407c00 	sxtw	x0, w0
  6010417aa8:	f9403be1 	ldr	x1, [sp, #112]
  6010417aac:	ca000020 	eor	x0, x1, x0
  6010417ab0:	f90033e0 	str	x0, [sp, #96]
        if (buddy_idx > pbuddy->n_pages - 1) {
  6010417ab4:	f94007e0 	ldr	x0, [sp, #8]
  6010417ab8:	f9400000 	ldr	x0, [x0]
  6010417abc:	d1000400 	sub	x0, x0, #0x1
  6010417ac0:	f94033e1 	ldr	x1, [sp, #96]
  6010417ac4:	eb00003f 	cmp	x1, x0
  6010417ac8:	54000a28 	b.hi	6010417c0c <KBuddyPagesFree+0x1c8>  // b.pmore
            break;
        }
        buddy = page + (buddy_idx - page_idx);
  6010417acc:	f94033e1 	ldr	x1, [sp, #96]
  6010417ad0:	f9403be0 	ldr	x0, [sp, #112]
  6010417ad4:	cb000020 	sub	x0, x1, x0
  6010417ad8:	d37be800 	lsl	x0, x0, #5
  6010417adc:	f94003e1 	ldr	x1, [sp]
  6010417ae0:	8b000020 	add	x0, x1, x0
  6010417ae4:	f90037e0 	str	x0, [sp, #104]
        if (!IS_BUDDY_PAGE(buddy, order)) {
  6010417ae8:	f94037e0 	ldr	x0, [sp, #104]
  6010417aec:	f9400800 	ldr	x0, [x0, #16]
  6010417af0:	f9403fe1 	ldr	x1, [sp, #120]
  6010417af4:	eb00003f 	cmp	x1, x0
  6010417af8:	540008c1 	b.ne	6010417c10 <KBuddyPagesFree+0x1cc>  // b.any
  6010417afc:	f94037e0 	ldr	x0, [sp, #104]
  6010417b00:	f9400001 	ldr	x1, [x0]
  6010417b04:	f94037e0 	ldr	x0, [sp, #104]
  6010417b08:	eb00003f 	cmp	x1, x0
  6010417b0c:	54000820 	b.eq	6010417c10 <KBuddyPagesFree+0x1cc>  // b.none
            break;
        }
        // remove buddy
        doubleListDel(&buddy->node);
  6010417b10:	f94037e0 	ldr	x0, [sp, #104]
  6010417b14:	f9002be0 	str	x0, [sp, #80]
    _double_list_del(entry->prev, entry->next);
  6010417b18:	f9402be0 	ldr	x0, [sp, #80]
  6010417b1c:	f9400401 	ldr	x1, [x0, #8]
  6010417b20:	f9402be0 	ldr	x0, [sp, #80]
  6010417b24:	f9400000 	ldr	x0, [x0]
  6010417b28:	f90027e1 	str	x1, [sp, #72]
  6010417b2c:	f90023e0 	str	x0, [sp, #64]
    next->prev = prev;
  6010417b30:	f94023e0 	ldr	x0, [sp, #64]
  6010417b34:	f94027e1 	ldr	x1, [sp, #72]
  6010417b38:	f9000401 	str	x1, [x0, #8]
    prev->next = next;
  6010417b3c:	f94027e0 	ldr	x0, [sp, #72]
  6010417b40:	f94023e1 	ldr	x1, [sp, #64]
  6010417b44:	f9000001 	str	x1, [x0]
}
  6010417b48:	d503201f 	nop
    entry->next = entry;
  6010417b4c:	f9402be0 	ldr	x0, [sp, #80]
  6010417b50:	f9402be1 	ldr	x1, [sp, #80]
  6010417b54:	f9000001 	str	x1, [x0]
    entry->prev = entry;
  6010417b58:	f9402be0 	ldr	x0, [sp, #80]
  6010417b5c:	f9402be1 	ldr	x1, [sp, #80]
  6010417b60:	f9000401 	str	x1, [x0, #8]
}
  6010417b64:	d503201f 	nop
        pbuddy->free_list[order].n_free_pages--;
  6010417b68:	f94007e1 	ldr	x1, [sp, #8]
  6010417b6c:	f9403fe2 	ldr	x2, [sp, #120]
  6010417b70:	d2800300 	mov	x0, #0x18                  	// #24
  6010417b74:	9b007c40 	mul	x0, x2, x0
  6010417b78:	8b000020 	add	x0, x1, x0
  6010417b7c:	f9402000 	ldr	x0, [x0, #64]
  6010417b80:	d1000401 	sub	x1, x0, #0x1
  6010417b84:	f94007e2 	ldr	x2, [sp, #8]
  6010417b88:	f9403fe3 	ldr	x3, [sp, #120]
  6010417b8c:	d2800300 	mov	x0, #0x18                  	// #24
  6010417b90:	9b007c60 	mul	x0, x3, x0
  6010417b94:	8b000040 	add	x0, x2, x0
  6010417b98:	f9002001 	str	x1, [x0, #64]
        buddy->order = MAX_BUDDY_ORDER;
  6010417b9c:	f94037e0 	ldr	x0, [sp, #104]
  6010417ba0:	d2800141 	mov	x1, #0xa                   	// #10
  6010417ba4:	f9000801 	str	x1, [x0, #16]
        // update page and page_idx after combined
        uintptr_t new_buddy_idx = COMBINED_PAGE_INDEX(page_idx, order);
  6010417ba8:	f9403fe0 	ldr	x0, [sp, #120]
  6010417bac:	2a0003e1 	mov	w1, w0
  6010417bb0:	52800020 	mov	w0, #0x1                   	// #1
  6010417bb4:	1ac12000 	lsl	w0, w0, w1
  6010417bb8:	2a2003e0 	mvn	w0, w0
  6010417bbc:	93407c00 	sxtw	x0, w0
  6010417bc0:	f9403be1 	ldr	x1, [sp, #112]
  6010417bc4:	8a000020 	and	x0, x1, x0
  6010417bc8:	f9002fe0 	str	x0, [sp, #88]
        page = page + (new_buddy_idx - page_idx);
  6010417bcc:	f9402fe1 	ldr	x1, [sp, #88]
  6010417bd0:	f9403be0 	ldr	x0, [sp, #112]
  6010417bd4:	cb000020 	sub	x0, x1, x0
  6010417bd8:	d37be800 	lsl	x0, x0, #5
  6010417bdc:	f94003e1 	ldr	x1, [sp]
  6010417be0:	8b000020 	add	x0, x1, x0
  6010417be4:	f90003e0 	str	x0, [sp]
        page_idx = new_buddy_idx;
  6010417be8:	f9402fe0 	ldr	x0, [sp, #88]
  6010417bec:	f9003be0 	str	x0, [sp, #112]
    for (; order < MAX_BUDDY_ORDER - 1; order++) {
  6010417bf0:	f9403fe0 	ldr	x0, [sp, #120]
  6010417bf4:	91000400 	add	x0, x0, #0x1
  6010417bf8:	f9003fe0 	str	x0, [sp, #120]
  6010417bfc:	f9403fe0 	ldr	x0, [sp, #120]
  6010417c00:	f100201f 	cmp	x0, #0x8
  6010417c04:	54fff489 	b.ls	6010417a94 <KBuddyPagesFree+0x50>  // b.plast
  6010417c08:	14000002 	b	6010417c10 <KBuddyPagesFree+0x1cc>
            break;
  6010417c0c:	d503201f 	nop
    }
    page->order = order;
  6010417c10:	f94003e0 	ldr	x0, [sp]
  6010417c14:	f9403fe1 	ldr	x1, [sp, #120]
  6010417c18:	f9000801 	str	x1, [x0, #16]
    doubleListAddOnHead(&page->node, &pbuddy->free_list[order].list_head);
  6010417c1c:	f94003e1 	ldr	x1, [sp]
  6010417c20:	f9403fe2 	ldr	x2, [sp, #120]
  6010417c24:	d2800300 	mov	x0, #0x18                  	// #24
  6010417c28:	9b007c40 	mul	x0, x2, x0
  6010417c2c:	91010000 	add	x0, x0, #0x40
  6010417c30:	f94007e2 	ldr	x2, [sp, #8]
  6010417c34:	8b000040 	add	x0, x2, x0
  6010417c38:	91002000 	add	x0, x0, #0x8
  6010417c3c:	f9001fe1 	str	x1, [sp, #56]
  6010417c40:	f9001be0 	str	x0, [sp, #48]
    _double_list_add(new_node, head, head->next);
  6010417c44:	f9401be0 	ldr	x0, [sp, #48]
  6010417c48:	f9400000 	ldr	x0, [x0]
  6010417c4c:	f9401fe1 	ldr	x1, [sp, #56]
  6010417c50:	f90017e1 	str	x1, [sp, #40]
  6010417c54:	f9401be1 	ldr	x1, [sp, #48]
  6010417c58:	f90013e1 	str	x1, [sp, #32]
  6010417c5c:	f9000fe0 	str	x0, [sp, #24]
    next->prev = new_node;
  6010417c60:	f9400fe0 	ldr	x0, [sp, #24]
  6010417c64:	f94017e1 	ldr	x1, [sp, #40]
  6010417c68:	f9000401 	str	x1, [x0, #8]
    new_node->next = next;
  6010417c6c:	f94017e0 	ldr	x0, [sp, #40]
  6010417c70:	f9400fe1 	ldr	x1, [sp, #24]
  6010417c74:	f9000001 	str	x1, [x0]
    new_node->prev = prev;
  6010417c78:	f94017e0 	ldr	x0, [sp, #40]
  6010417c7c:	f94013e1 	ldr	x1, [sp, #32]
  6010417c80:	f9000401 	str	x1, [x0, #8]
    prev->next = new_node;
  6010417c84:	f94013e0 	ldr	x0, [sp, #32]
  6010417c88:	f94017e1 	ldr	x1, [sp, #40]
  6010417c8c:	f9000001 	str	x1, [x0]
}
  6010417c90:	d503201f 	nop
}
  6010417c94:	d503201f 	nop
    pbuddy->free_list[order].n_free_pages++;
  6010417c98:	f94007e1 	ldr	x1, [sp, #8]
  6010417c9c:	f9403fe2 	ldr	x2, [sp, #120]
  6010417ca0:	d2800300 	mov	x0, #0x18                  	// #24
  6010417ca4:	9b007c40 	mul	x0, x2, x0
  6010417ca8:	8b000020 	add	x0, x1, x0
  6010417cac:	f9402000 	ldr	x0, [x0, #64]
  6010417cb0:	91000401 	add	x1, x0, #0x1
  6010417cb4:	f94007e2 	ldr	x2, [sp, #8]
  6010417cb8:	f9403fe3 	ldr	x3, [sp, #120]
  6010417cbc:	d2800300 	mov	x0, #0x18                  	// #24
  6010417cc0:	9b007c60 	mul	x0, x3, x0
  6010417cc4:	8b000040 	add	x0, x2, x0
  6010417cc8:	f9002001 	str	x1, [x0, #64]

    return;
  6010417ccc:	d503201f 	nop
}
  6010417cd0:	910203ff 	add	sp, sp, #0x80
  6010417cd4:	d65f03c0 	ret

0000006010417cd8 <KBuddyInit>:

bool KBuddyInit(struct KBuddy* pbuddy, uintptr_t mem_start, uintptr_t mem_end)
{
  6010417cd8:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  6010417cdc:	910003fd 	mov	x29, sp
  6010417ce0:	f90017e0 	str	x0, [sp, #40]
  6010417ce4:	f90013e1 	str	x1, [sp, #32]
  6010417ce8:	f9000fe2 	str	x2, [sp, #24]
    if (pbuddy->pages == NULL) {
  6010417cec:	f94017e0 	ldr	x0, [sp, #40]
  6010417cf0:	f940a400 	ldr	x0, [x0, #328]
  6010417cf4:	f100001f 	cmp	x0, #0x0
  6010417cf8:	54000321 	b.ne	6010417d5c <KBuddyInit+0x84>  // b.any
        if ((pbuddy->pages = (struct KPage*)kalloc(((mem_end - mem_start) >> LEVEL4_PTE_SHIFT) * sizeof(struct KPage))) == NULL) {
  6010417cfc:	f9400fe1 	ldr	x1, [sp, #24]
  6010417d00:	f94013e0 	ldr	x0, [sp, #32]
  6010417d04:	cb000020 	sub	x0, x1, x0
  6010417d08:	d34cfc00 	lsr	x0, x0, #12
  6010417d0c:	d37be800 	lsl	x0, x0, #5
  6010417d10:	97fffa4b 	bl	601041663c <kalloc>
  6010417d14:	aa0003e1 	mov	x1, x0
  6010417d18:	f94017e0 	ldr	x0, [sp, #40]
  6010417d1c:	f900a401 	str	x1, [x0, #328]
  6010417d20:	f94017e0 	ldr	x0, [sp, #40]
  6010417d24:	f940a400 	ldr	x0, [x0, #328]
  6010417d28:	f100001f 	cmp	x0, #0x0
  6010417d2c:	54000181 	b.ne	6010417d5c <KBuddyInit+0x84>  // b.any
            ERROR("Not space to init a buddy object.\n");
  6010417d30:	52801222 	mov	w2, #0x91                  	// #145
  6010417d34:	f0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010417d38:	9102e001 	add	x1, x0, #0xb8
  6010417d3c:	d0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010417d40:	913f2000 	add	x0, x0, #0xfc8
  6010417d44:	97fff10d 	bl	6010414178 <printf_>
  6010417d48:	d0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010417d4c:	913f6000 	add	x0, x0, #0xfd8
  6010417d50:	97fff10a 	bl	6010414178 <printf_>
            return false;
  6010417d54:	52800000 	mov	w0, #0x0                   	// #0
  6010417d58:	1400006b 	b	6010417f04 <KBuddyInit+0x22c>
        }
    }

    uintptr_t i = 0;
  6010417d5c:	f9002fff 	str	xzr, [sp, #88]
    struct KPage* page = NULL;
  6010417d60:	f9002bff 	str	xzr, [sp, #80]
    struct KFreeList* free_list = NULL;
  6010417d64:	f90027ff 	str	xzr, [sp, #72]

    // init global kernel Buddy system
    pbuddy->mem_start = mem_start;
  6010417d68:	f94017e0 	ldr	x0, [sp, #40]
  6010417d6c:	f94013e1 	ldr	x1, [sp, #32]
  6010417d70:	f9009c01 	str	x1, [x0, #312]
    pbuddy->mem_end = mem_end;
  6010417d74:	f94017e0 	ldr	x0, [sp, #40]
  6010417d78:	f9400fe1 	ldr	x1, [sp, #24]
  6010417d7c:	f900a001 	str	x1, [x0, #320]

    // k_page is used to manage free pages
    pbuddy->mem_start = ALIGNUP(pbuddy->mem_start, 4 * PAGE_SIZE);
  6010417d80:	f94017e0 	ldr	x0, [sp, #40]
  6010417d84:	f9409c01 	ldr	x1, [x0, #312]
  6010417d88:	d287ffe0 	mov	x0, #0x3fff                	// #16383
  6010417d8c:	8b000020 	add	x0, x1, x0
  6010417d90:	9272c401 	and	x1, x0, #0xffffffffffffc000
  6010417d94:	f94017e0 	ldr	x0, [sp, #40]
  6010417d98:	f9009c01 	str	x1, [x0, #312]

    // total number of free pages
    pbuddy->n_pages = (pbuddy->mem_end - (uintptr_t)pbuddy->mem_start) >> LEVEL4_PTE_SHIFT;
  6010417d9c:	f94017e0 	ldr	x0, [sp, #40]
  6010417da0:	f940a001 	ldr	x1, [x0, #320]
  6010417da4:	f94017e0 	ldr	x0, [sp, #40]
  6010417da8:	f9409c00 	ldr	x0, [x0, #312]
  6010417dac:	cb000020 	sub	x0, x1, x0
  6010417db0:	d34cfc01 	lsr	x1, x0, #12
  6010417db4:	f94017e0 	ldr	x0, [sp, #40]
  6010417db8:	f9000001 	str	x1, [x0]

    memset(pbuddy->pages, 0, pbuddy->n_pages);
  6010417dbc:	f94017e0 	ldr	x0, [sp, #40]
  6010417dc0:	f940a403 	ldr	x3, [x0, #328]
  6010417dc4:	f94017e0 	ldr	x0, [sp, #40]
  6010417dc8:	f9400000 	ldr	x0, [x0]
  6010417dcc:	aa0003e2 	mov	x2, x0
  6010417dd0:	52800001 	mov	w1, #0x0                   	// #0
  6010417dd4:	aa0303e0 	mov	x0, x3
  6010417dd8:	97ffd93a 	bl	601040e2c0 <memset>

    // init each free page list from 2^0 to 2^8
    for (; i < MAX_BUDDY_ORDER; i++) {
  6010417ddc:	14000017 	b	6010417e38 <KBuddyInit+0x160>
        free_list = pbuddy->free_list + i;
  6010417de0:	f94017e0 	ldr	x0, [sp, #40]
  6010417de4:	91010001 	add	x1, x0, #0x40
  6010417de8:	f9402fe2 	ldr	x2, [sp, #88]
  6010417dec:	d2800300 	mov	x0, #0x18                  	// #24
  6010417df0:	9b007c40 	mul	x0, x2, x0
  6010417df4:	8b000020 	add	x0, x1, x0
  6010417df8:	f90027e0 	str	x0, [sp, #72]
        doubleListNodeInit(&free_list->list_head);
  6010417dfc:	f94027e0 	ldr	x0, [sp, #72]
  6010417e00:	91002000 	add	x0, x0, #0x8
  6010417e04:	f90023e0 	str	x0, [sp, #64]
    list->next = list;
  6010417e08:	f94023e0 	ldr	x0, [sp, #64]
  6010417e0c:	f94023e1 	ldr	x1, [sp, #64]
  6010417e10:	f9000001 	str	x1, [x0]
    list->prev = list;
  6010417e14:	f94023e0 	ldr	x0, [sp, #64]
  6010417e18:	f94023e1 	ldr	x1, [sp, #64]
  6010417e1c:	f9000401 	str	x1, [x0, #8]
}
  6010417e20:	d503201f 	nop
        free_list->n_free_pages = 0;
  6010417e24:	f94027e0 	ldr	x0, [sp, #72]
  6010417e28:	f900001f 	str	xzr, [x0]
    for (; i < MAX_BUDDY_ORDER; i++) {
  6010417e2c:	f9402fe0 	ldr	x0, [sp, #88]
  6010417e30:	91000400 	add	x0, x0, #0x1
  6010417e34:	f9002fe0 	str	x0, [sp, #88]
  6010417e38:	f9402fe0 	ldr	x0, [sp, #88]
  6010417e3c:	f100241f 	cmp	x0, #0x9
  6010417e40:	54fffd09 	b.ls	6010417de0 <KBuddyInit+0x108>  // b.plast
    }

    // init and free each page
    for (i = 0; i < pbuddy->n_pages; i++) {
  6010417e44:	f9002fff 	str	xzr, [sp, #88]
  6010417e48:	1400000d 	b	6010417e7c <KBuddyInit+0x1a4>
        page = pbuddy->pages + i;
  6010417e4c:	f94017e0 	ldr	x0, [sp, #40]
  6010417e50:	f940a401 	ldr	x1, [x0, #328]
  6010417e54:	f9402fe0 	ldr	x0, [sp, #88]
  6010417e58:	d37be800 	lsl	x0, x0, #5
  6010417e5c:	8b000020 	add	x0, x1, x0
  6010417e60:	f9002be0 	str	x0, [sp, #80]
        page->order = MAX_BUDDY_ORDER;
  6010417e64:	f9402be0 	ldr	x0, [sp, #80]
  6010417e68:	d2800141 	mov	x1, #0xa                   	// #10
  6010417e6c:	f9000801 	str	x1, [x0, #16]
    for (i = 0; i < pbuddy->n_pages; i++) {
  6010417e70:	f9402fe0 	ldr	x0, [sp, #88]
  6010417e74:	91000400 	add	x0, x0, #0x1
  6010417e78:	f9002fe0 	str	x0, [sp, #88]
  6010417e7c:	f94017e0 	ldr	x0, [sp, #40]
  6010417e80:	f9400000 	ldr	x0, [x0]
  6010417e84:	f9402fe1 	ldr	x1, [sp, #88]
  6010417e88:	eb00003f 	cmp	x1, x0
  6010417e8c:	54fffe03 	b.cc	6010417e4c <KBuddyInit+0x174>  // b.lo, b.ul, b.last
    }
    for (i = 0; i < pbuddy->n_pages; i++) {
  6010417e90:	f9002fff 	str	xzr, [sp, #88]
  6010417e94:	14000016 	b	6010417eec <KBuddyInit+0x214>
        page = pbuddy->pages + i;
  6010417e98:	f94017e0 	ldr	x0, [sp, #40]
  6010417e9c:	f940a401 	ldr	x1, [x0, #328]
  6010417ea0:	f9402fe0 	ldr	x0, [sp, #88]
  6010417ea4:	d37be800 	lsl	x0, x0, #5
  6010417ea8:	8b000020 	add	x0, x1, x0
  6010417eac:	f9002be0 	str	x0, [sp, #80]
        doubleListNodeInit(&page->node);
  6010417eb0:	f9402be0 	ldr	x0, [sp, #80]
  6010417eb4:	f9001fe0 	str	x0, [sp, #56]
    list->next = list;
  6010417eb8:	f9401fe0 	ldr	x0, [sp, #56]
  6010417ebc:	f9401fe1 	ldr	x1, [sp, #56]
  6010417ec0:	f9000001 	str	x1, [x0]
    list->prev = list;
  6010417ec4:	f9401fe0 	ldr	x0, [sp, #56]
  6010417ec8:	f9401fe1 	ldr	x1, [sp, #56]
  6010417ecc:	f9000401 	str	x1, [x0, #8]
}
  6010417ed0:	d503201f 	nop
        KBuddyPagesFree(pbuddy, page);
  6010417ed4:	f9402be1 	ldr	x1, [sp, #80]
  6010417ed8:	f94017e0 	ldr	x0, [sp, #40]
  6010417edc:	97fffeda 	bl	6010417a44 <KBuddyPagesFree>
    for (i = 0; i < pbuddy->n_pages; i++) {
  6010417ee0:	f9402fe0 	ldr	x0, [sp, #88]
  6010417ee4:	91000400 	add	x0, x0, #0x1
  6010417ee8:	f9002fe0 	str	x0, [sp, #88]
  6010417eec:	f94017e0 	ldr	x0, [sp, #40]
  6010417ef0:	f9400000 	ldr	x0, [x0]
  6010417ef4:	f9402fe1 	ldr	x1, [sp, #88]
  6010417ef8:	eb00003f 	cmp	x1, x0
  6010417efc:	54fffce3 	b.cc	6010417e98 <KBuddyInit+0x1c0>  // b.lo, b.ul, b.last
    }

    return true;
  6010417f00:	52800020 	mov	w0, #0x1                   	// #1
}
  6010417f04:	a8c67bfd 	ldp	x29, x30, [sp], #96
  6010417f08:	d65f03c0 	ret

0000006010417f0c <KBuddySysInit>:

void KBuddySysInit(struct KBuddy* pbuddy, uintptr_t mem_start, uintptr_t mem_end)
{
  6010417f0c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  6010417f10:	910003fd 	mov	x29, sp
  6010417f14:	f90017e0 	str	x0, [sp, #40]
  6010417f18:	f90013e1 	str	x1, [sp, #32]
  6010417f1c:	f9000fe2 	str	x2, [sp, #24]
#define MAX_NR_PAGES MAX_NR_FREE_PAGES
    static struct KPage kern_free_pages[MAX_NR_PAGES];
    pbuddy->pages = kern_free_pages;
  6010417f20:	f94017e0 	ldr	x0, [sp, #40]
  6010417f24:	90008961 	adrp	x1, 6011543000 <_binary_default_fs_start+0x96000>
  6010417f28:	912ae021 	add	x1, x1, #0xab8
  6010417f2c:	f900a401 	str	x1, [x0, #328]
    KBuddyInit(pbuddy, mem_start, mem_end);
  6010417f30:	f9400fe2 	ldr	x2, [sp, #24]
  6010417f34:	f94013e1 	ldr	x1, [sp, #32]
  6010417f38:	f94017e0 	ldr	x0, [sp, #40]
  6010417f3c:	97ffff67 	bl	6010417cd8 <KBuddyInit>
}
  6010417f40:	d503201f 	nop
  6010417f44:	a8c37bfd 	ldp	x29, x30, [sp], #48
  6010417f48:	d65f03c0 	ret

0000006010417f4c <KBuddyAlloc>:

char* KBuddyAlloc(struct KBuddy* pbuddy, uintptr_t size)
{
  6010417f4c:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  6010417f50:	910003fd 	mov	x29, sp
  6010417f54:	f9000fe0 	str	x0, [sp, #24]
  6010417f58:	f9000be1 	str	x1, [sp, #16]
    int nPages = CALCULATE_NPAGES(size);
  6010417f5c:	f9400be0 	ldr	x0, [sp, #16]
  6010417f60:	913ffc00 	add	x0, x0, #0xfff
  6010417f64:	d34cfc00 	lsr	x0, x0, #12
  6010417f68:	b9005fe0 	str	w0, [sp, #92]
    struct KPage* page = KBuddyPagesAlloc(pbuddy, nPages);
  6010417f6c:	b9405fe1 	ldr	w1, [sp, #92]
  6010417f70:	f9400fe0 	ldr	x0, [sp, #24]
  6010417f74:	97fffe43 	bl	6010417880 <KBuddyPagesAlloc>
  6010417f78:	f9002be0 	str	x0, [sp, #80]
    if (page == NULL)
  6010417f7c:	f9402be0 	ldr	x0, [sp, #80]
  6010417f80:	f100001f 	cmp	x0, #0x0
  6010417f84:	54000061 	b.ne	6010417f90 <KBuddyAlloc+0x44>  // b.any
        return NULL;
  6010417f88:	d2800000 	mov	x0, #0x0                   	// #0
  6010417f8c:	14000018 	b	6010417fec <KBuddyAlloc+0xa0>

    char* v_addr = NULL;
  6010417f90:	f90017ff 	str	xzr, [sp, #40]
  6010417f94:	f9400fe0 	ldr	x0, [sp, #24]
  6010417f98:	f90027e0 	str	x0, [sp, #72]
  6010417f9c:	f9402be0 	ldr	x0, [sp, #80]
  6010417fa0:	f90023e0 	str	x0, [sp, #64]
  6010417fa4:	9100a3e0 	add	x0, sp, #0x28
  6010417fa8:	f9001fe0 	str	x0, [sp, #56]
    uintptr_t offset = page - pbuddy->pages;
  6010417fac:	f94027e0 	ldr	x0, [sp, #72]
  6010417fb0:	f940a400 	ldr	x0, [x0, #328]
  6010417fb4:	f94023e1 	ldr	x1, [sp, #64]
  6010417fb8:	cb000020 	sub	x0, x1, x0
  6010417fbc:	9345fc00 	asr	x0, x0, #5
  6010417fc0:	f9001be0 	str	x0, [sp, #48]
    *vaddr = (char*)(pbuddy->mem_start + (offset << LEVEL4_PTE_SHIFT));
  6010417fc4:	f94027e0 	ldr	x0, [sp, #72]
  6010417fc8:	f9409c01 	ldr	x1, [x0, #312]
  6010417fcc:	f9401be0 	ldr	x0, [sp, #48]
  6010417fd0:	d374cc00 	lsl	x0, x0, #12
  6010417fd4:	8b000020 	add	x0, x1, x0
  6010417fd8:	aa0003e1 	mov	x1, x0
  6010417fdc:	f9401fe0 	ldr	x0, [sp, #56]
  6010417fe0:	f9000001 	str	x1, [x0]
    return;
  6010417fe4:	d503201f 	nop
    _buddy_page_to_vaddr(pbuddy, page, &v_addr);

    return v_addr;
  6010417fe8:	f94017e0 	ldr	x0, [sp, #40]
}
  6010417fec:	a8c67bfd 	ldp	x29, x30, [sp], #96
  6010417ff0:	d65f03c0 	ret

0000006010417ff4 <KBuddyFree>:

bool KBuddyFree(struct KBuddy* pbuddy, char* vaddr)
{
  6010417ff4:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  6010417ff8:	910003fd 	mov	x29, sp
  6010417ffc:	f9000fe0 	str	x0, [sp, #24]
  6010418000:	f9000be1 	str	x1, [sp, #16]
    struct KPage* page = NULL;
  6010418004:	f90017ff 	str	xzr, [sp, #40]

    if ((uintptr_t)vaddr % (PAGE_SIZE)) {
  6010418008:	f9400be0 	ldr	x0, [sp, #16]
  601041800c:	92402c00 	and	x0, x0, #0xfff
  6010418010:	f100001f 	cmp	x0, #0x0
  6010418014:	540001a0 	b.eq	6010418048 <KBuddyFree+0x54>  // b.none
        ERROR("kbuddyfree - unaligned: %x\n", vaddr);
  6010418018:	52801aa2 	mov	w2, #0xd5                  	// #213
  601041801c:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010418020:	91032001 	add	x1, x0, #0xc8
  6010418024:	b0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  6010418028:	913f2000 	add	x0, x0, #0xfc8
  601041802c:	97fff053 	bl	6010414178 <printf_>
  6010418030:	f9400be1 	ldr	x1, [sp, #16]
  6010418034:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010418038:	91000000 	add	x0, x0, #0x0
  601041803c:	97fff04f 	bl	6010414178 <printf_>
        return false;
  6010418040:	52800000 	mov	w0, #0x0                   	// #0
  6010418044:	1400003c 	b	6010418134 <KBuddyFree+0x140>
    }
    if ((uintptr_t)vaddr < pbuddy->mem_start) {
  6010418048:	f9400fe0 	ldr	x0, [sp, #24]
  601041804c:	f9409c01 	ldr	x1, [x0, #312]
  6010418050:	f9400be0 	ldr	x0, [sp, #16]
  6010418054:	eb00003f 	cmp	x1, x0
  6010418058:	540001a9 	b.ls	601041808c <KBuddyFree+0x98>  // b.plast
        ERROR("kbuddyfree - under buddy free page address: %x\n", vaddr);
  601041805c:	52801b22 	mov	w2, #0xd9                  	// #217
  6010418060:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010418064:	91032001 	add	x1, x0, #0xc8
  6010418068:	b0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  601041806c:	913f2000 	add	x0, x0, #0xfc8
  6010418070:	97fff042 	bl	6010414178 <printf_>
  6010418074:	f9400be1 	ldr	x1, [sp, #16]
  6010418078:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041807c:	91008000 	add	x0, x0, #0x20
  6010418080:	97fff03e 	bl	6010414178 <printf_>
        return false;
  6010418084:	52800000 	mov	w0, #0x0                   	// #0
  6010418088:	1400002b 	b	6010418134 <KBuddyFree+0x140>
    }
    if ((uintptr_t)vaddr >= pbuddy->mem_end) {
  601041808c:	f9400fe0 	ldr	x0, [sp, #24]
  6010418090:	f940a001 	ldr	x1, [x0, #320]
  6010418094:	f9400be0 	ldr	x0, [sp, #16]
  6010418098:	eb00003f 	cmp	x1, x0
  601041809c:	540001a8 	b.hi	60104180d0 <KBuddyFree+0xdc>  // b.pmore
        ERROR("kbuddyfree - over buddy free page address: %x\n", vaddr);
  60104180a0:	52801ba2 	mov	w2, #0xdd                  	// #221
  60104180a4:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  60104180a8:	91032001 	add	x1, x0, #0xc8
  60104180ac:	b0000040 	adrp	x0, 6010421000 <__func__.0+0x508>
  60104180b0:	913f2000 	add	x0, x0, #0xfc8
  60104180b4:	97fff031 	bl	6010414178 <printf_>
  60104180b8:	f9400be1 	ldr	x1, [sp, #16]
  60104180bc:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  60104180c0:	91014000 	add	x0, x0, #0x50
  60104180c4:	97fff02d 	bl	6010414178 <printf_>
        return false;
  60104180c8:	52800000 	mov	w0, #0x0                   	// #0
  60104180cc:	1400001a 	b	6010418134 <KBuddyFree+0x140>
  60104180d0:	f9400fe0 	ldr	x0, [sp, #24]
  60104180d4:	f90027e0 	str	x0, [sp, #72]
  60104180d8:	9100a3e0 	add	x0, sp, #0x28
  60104180dc:	f90023e0 	str	x0, [sp, #64]
  60104180e0:	f9400be0 	ldr	x0, [sp, #16]
  60104180e4:	f9001fe0 	str	x0, [sp, #56]
    uintptr_t offset = (uintptr_t)vaddr - pbuddy->mem_start;
  60104180e8:	f9401fe1 	ldr	x1, [sp, #56]
  60104180ec:	f94027e0 	ldr	x0, [sp, #72]
  60104180f0:	f9409c00 	ldr	x0, [x0, #312]
  60104180f4:	cb000020 	sub	x0, x1, x0
  60104180f8:	f9001be0 	str	x0, [sp, #48]
    *page = (struct KPage*)(pbuddy->pages + (offset >> LEVEL4_PTE_SHIFT));
  60104180fc:	f94027e0 	ldr	x0, [sp, #72]
  6010418100:	f940a401 	ldr	x1, [x0, #328]
  6010418104:	f9401be0 	ldr	x0, [sp, #48]
  6010418108:	d34cfc00 	lsr	x0, x0, #12
  601041810c:	d37be800 	lsl	x0, x0, #5
  6010418110:	8b000021 	add	x1, x1, x0
  6010418114:	f94023e0 	ldr	x0, [sp, #64]
  6010418118:	f9000001 	str	x1, [x0]
    return;
  601041811c:	d503201f 	nop
    }

    _buddy_vaddr_to_page(pbuddy, &page, vaddr);
    KBuddyPagesFree(pbuddy, page);
  6010418120:	f94017e0 	ldr	x0, [sp, #40]
  6010418124:	aa0003e1 	mov	x1, x0
  6010418128:	f9400fe0 	ldr	x0, [sp, #24]
  601041812c:	97fffe46 	bl	6010417a44 <KBuddyPagesFree>

    return true;
  6010418130:	52800020 	mov	w0, #0x1                   	// #1
}
  6010418134:	a8c57bfd 	ldp	x29, x30, [sp], #80
  6010418138:	d65f03c0 	ret

000000601041813c <KBuddyDestory>:

void KBuddyDestory(struct KBuddy* pbuddy)
{
  601041813c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  6010418140:	910003fd 	mov	x29, sp
  6010418144:	f9000fe0 	str	x0, [sp, #24]
    if (pbuddy->pages) {
  6010418148:	f9400fe0 	ldr	x0, [sp, #24]
  601041814c:	f940a400 	ldr	x0, [x0, #328]
  6010418150:	f100001f 	cmp	x0, #0x0
  6010418154:	54000080 	b.eq	6010418164 <KBuddyDestory+0x28>  // b.none
        kfree((void*)pbuddy->pages);
  6010418158:	f9400fe0 	ldr	x0, [sp, #24]
  601041815c:	f940a400 	ldr	x0, [x0, #328]
  6010418160:	97fff978 	bl	6010416740 <kfree>
    }
}
  6010418164:	d503201f 	nop
  6010418168:	a8c27bfd 	ldp	x29, x30, [sp], #32
  601041816c:	d65f03c0 	ret

0000006010418170 <KFreePagesInfo>:

void KFreePagesInfo(struct KBuddy* pbuddy)
{
  6010418170:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  6010418174:	910003fd 	mov	x29, sp
  6010418178:	f9000fe0 	str	x0, [sp, #24]
    DEBUG("Buddy structure:");
  601041817c:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010418180:	91036001 	add	x1, x0, #0xd8
  6010418184:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010418188:	91020000 	add	x0, x0, #0x80
  601041818c:	97ffeffb 	bl	6010414178 <printf_>
  6010418190:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010418194:	91024000 	add	x0, x0, #0x90
  6010418198:	97ffeff8 	bl	6010414178 <printf_>
    for (int j = 0; j < MAX_BUDDY_ORDER; j++) {
  601041819c:	b9002fff 	str	wzr, [sp, #44]
  60104181a0:	1400000e 	b	60104181d8 <KFreePagesInfo+0x68>
        DEBUG_PRINTF(" %d ", pbuddy->free_list[j].n_free_pages);
  60104181a4:	f9400fe1 	ldr	x1, [sp, #24]
  60104181a8:	b9802fe2 	ldrsw	x2, [sp, #44]
  60104181ac:	d2800300 	mov	x0, #0x18                  	// #24
  60104181b0:	9b007c40 	mul	x0, x2, x0
  60104181b4:	8b000020 	add	x0, x1, x0
  60104181b8:	f9402000 	ldr	x0, [x0, #64]
  60104181bc:	aa0003e1 	mov	x1, x0
  60104181c0:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  60104181c4:	9102a000 	add	x0, x0, #0xa8
  60104181c8:	97ffefec 	bl	6010414178 <printf_>
    for (int j = 0; j < MAX_BUDDY_ORDER; j++) {
  60104181cc:	b9402fe0 	ldr	w0, [sp, #44]
  60104181d0:	11000400 	add	w0, w0, #0x1
  60104181d4:	b9002fe0 	str	w0, [sp, #44]
  60104181d8:	b9402fe0 	ldr	w0, [sp, #44]
  60104181dc:	7100241f 	cmp	w0, #0x9
  60104181e0:	54fffe2d 	b.le	60104181a4 <KFreePagesInfo+0x34>
    }
    DEBUG_PRINTF("\n");
  60104181e4:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  60104181e8:	9102c000 	add	x0, x0, #0xb0
  60104181ec:	97ffefe3 	bl	6010414178 <printf_>
  60104181f0:	d503201f 	nop
  60104181f4:	a8c37bfd 	ldp	x29, x30, [sp], #48
  60104181f8:	d65f03c0 	ret

00000060104181fc <slab_init>:

#define ARENA_SIZE_PER_INCREASE PAGE_SIZE
#define MAX_NR_ELEMENT_PER_SLABPAGE 64

void slab_init(struct slab_allocator* const allocator, const size_t element_size)
{
  60104181fc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  6010418200:	910003fd 	mov	x29, sp
  6010418204:	f9000fe0 	str	x0, [sp, #24]
  6010418208:	f9000be1 	str	x1, [sp, #16]
    if (allocator == NULL) {
  601041820c:	f9400fe0 	ldr	x0, [sp, #24]
  6010418210:	f100001f 	cmp	x0, #0x0
  6010418214:	54000081 	b.ne	6010418224 <slab_init+0x28>  // b.any
        panic("init a NULL slab_allocator\n");
  6010418218:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041821c:	9103a000 	add	x0, x0, #0xe8
  6010418220:	97ffdc22 	bl	601040f2a8 <panic>
    }
    if (element_size > ARENA_SIZE_PER_INCREASE) {
  6010418224:	f9400be0 	ldr	x0, [sp, #16]
  6010418228:	f140041f 	cmp	x0, #0x1, lsl #12
  601041822c:	54000089 	b.ls	601041823c <slab_init+0x40>  // b.plast
        panic("Not supported slab element size\n");
  6010418230:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010418234:	91042000 	add	x0, x0, #0x108
  6010418238:	97ffdc1c 	bl	601040f2a8 <panic>
    }

    allocator->element_size = element_size;
  601041823c:	f9400fe0 	ldr	x0, [sp, #24]
  6010418240:	f9400be1 	ldr	x1, [sp, #16]
  6010418244:	f9000001 	str	x1, [x0]
    allocator->slabsize = ARENA_SIZE_PER_INCREASE;
  6010418248:	f9400fe0 	ldr	x0, [sp, #24]
  601041824c:	d2820001 	mov	x1, #0x1000                	// #4096
  6010418250:	f9000801 	str	x1, [x0, #16]

    allocator->nr_elements = (allocator->slabsize - offsetof(struct slab_state, data)) / element_size;
  6010418254:	f9400fe0 	ldr	x0, [sp, #24]
  6010418258:	f9400800 	ldr	x0, [x0, #16]
  601041825c:	d1008001 	sub	x1, x0, #0x20
  6010418260:	f9400be0 	ldr	x0, [sp, #16]
  6010418264:	9ac00821 	udiv	x1, x1, x0
  6010418268:	f9400fe0 	ldr	x0, [sp, #24]
  601041826c:	f9000401 	str	x1, [x0, #8]
    allocator->nr_elements = allocator->nr_elements > MAX_NR_ELEMENT_PER_SLABPAGE ? MAX_NR_ELEMENT_PER_SLABPAGE : allocator->nr_elements;
  6010418270:	f9400fe0 	ldr	x0, [sp, #24]
  6010418274:	f9400400 	ldr	x0, [x0, #8]
  6010418278:	d2800801 	mov	x1, #0x40                  	// #64
  601041827c:	f101001f 	cmp	x0, #0x40
  6010418280:	9a819001 	csel	x1, x0, x1, ls  // ls = plast
  6010418284:	f9400fe0 	ldr	x0, [sp, #24]
  6010418288:	f9000401 	str	x1, [x0, #8]

    allocator->bitmap_empty = ~BITMAP_BITS_EMPTY_FULL >> (MAX_NR_ELEMENT_PER_SLABPAGE - allocator->nr_elements);
  601041828c:	f9400fe0 	ldr	x0, [sp, #24]
  6010418290:	f9400400 	ldr	x0, [x0, #8]
  6010418294:	2a0003e1 	mov	w1, w0
  6010418298:	52800800 	mov	w0, #0x40                  	// #64
  601041829c:	4b010000 	sub	w0, w0, w1
  60104182a0:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  60104182a4:	9ac02421 	lsr	x1, x1, x0
  60104182a8:	f9400fe0 	ldr	x0, [sp, #24]
  60104182ac:	f9000c01 	str	x1, [x0, #24]

    allocator->partial = allocator->empty = allocator->full = NULL;
  60104182b0:	f9400fe0 	ldr	x0, [sp, #24]
  60104182b4:	f900181f 	str	xzr, [x0, #48]
  60104182b8:	f9400fe0 	ldr	x0, [sp, #24]
  60104182bc:	f9401801 	ldr	x1, [x0, #48]
  60104182c0:	f9400fe0 	ldr	x0, [sp, #24]
  60104182c4:	f9001401 	str	x1, [x0, #40]
  60104182c8:	f9400fe0 	ldr	x0, [sp, #24]
  60104182cc:	f9401401 	ldr	x1, [x0, #40]
  60104182d0:	f9400fe0 	ldr	x0, [sp, #24]
  60104182d4:	f9001001 	str	x1, [x0, #32]
}
  60104182d8:	d503201f 	nop
  60104182dc:	a8c27bfd 	ldp	x29, x30, [sp], #32
  60104182e0:	d65f03c0 	ret

00000060104182e4 <slab_alloc>:

void* slab_alloc(struct slab_allocator* const allocator)
{
  60104182e4:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  60104182e8:	910003fd 	mov	x29, sp
  60104182ec:	f9000bf3 	str	x19, [sp, #16]
  60104182f0:	f90017e0 	str	x0, [sp, #40]
    assert(allocator != NULL);
  60104182f4:	f94017e0 	ldr	x0, [sp, #40]
  60104182f8:	f100001f 	cmp	x0, #0x0
  60104182fc:	540001e1 	b.ne	6010418338 <slab_alloc+0x54>  // b.any
  6010418300:	52800902 	mov	w2, #0x48                  	// #72
  6010418304:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010418308:	91070001 	add	x1, x0, #0x1c0
  601041830c:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010418310:	9104c000 	add	x0, x0, #0x130
  6010418314:	97ffef99 	bl	6010414178 <printf_>
  6010418318:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041831c:	91050001 	add	x1, x0, #0x140
  6010418320:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010418324:	91056000 	add	x0, x0, #0x158
  6010418328:	97ffef94 	bl	6010414178 <printf_>
  601041832c:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010418330:	9105a000 	add	x0, x0, #0x168
  6010418334:	97ffdbdd 	bl	601040f2a8 <panic>

    if (LIKELY(allocator->partial != NULL)) {
  6010418338:	f94017e0 	ldr	x0, [sp, #40]
  601041833c:	f9401000 	ldr	x0, [x0, #32]
  6010418340:	f100001f 	cmp	x0, #0x0
  6010418344:	1a9f07e0 	cset	w0, ne  // ne = any
  6010418348:	12001c00 	and	w0, w0, #0xff
  601041834c:	92401c00 	and	x0, x0, #0xff
  6010418350:	f100001f 	cmp	x0, #0x0
  6010418354:	54000b00 	b.eq	60104184b4 <slab_alloc+0x1d0>  // b.none
        register const size_t slot = BITMAP_FIND_FIRST_BIT(allocator->partial->bitmap);
  6010418358:	f94017e0 	ldr	x0, [sp, #40]
  601041835c:	f9401000 	ldr	x0, [x0, #32]
  6010418360:	f9400800 	ldr	x0, [x0, #16]
  6010418364:	dac00000 	rbit	x0, x0
  6010418368:	dac01000 	clz	x0, x0
  601041836c:	93407c13 	sxtw	x19, w0
        allocator->partial->bitmap ^= BITMAP_FIRST_BIT << slot;
  6010418370:	f94017e0 	ldr	x0, [sp, #40]
  6010418374:	f9401000 	ldr	x0, [x0, #32]
  6010418378:	f9400802 	ldr	x2, [x0, #16]
  601041837c:	2a1303e1 	mov	w1, w19
  6010418380:	d2800020 	mov	x0, #0x1                   	// #1
  6010418384:	9ac12001 	lsl	x1, x0, x1
  6010418388:	f94017e0 	ldr	x0, [sp, #40]
  601041838c:	f9401000 	ldr	x0, [x0, #32]
  6010418390:	ca010041 	eor	x1, x2, x1
  6010418394:	f9000801 	str	x1, [x0, #16]

        if (UNLIKELY(allocator->partial->bitmap == BITMAP_BITS_EMPTY_FULL)) {
  6010418398:	f94017e0 	ldr	x0, [sp, #40]
  601041839c:	f9401000 	ldr	x0, [x0, #32]
  60104183a0:	f9400800 	ldr	x0, [x0, #16]
  60104183a4:	f100001f 	cmp	x0, #0x0
  60104183a8:	1a9f17e0 	cset	w0, eq  // eq = none
  60104183ac:	12001c00 	and	w0, w0, #0xff
  60104183b0:	92401c00 	and	x0, x0, #0xff
  60104183b4:	f100001f 	cmp	x0, #0x0
  60104183b8:	540005e0 	b.eq	6010418474 <slab_alloc+0x190>  // b.none
            struct slab_state* const full_head = allocator->partial;
  60104183bc:	f94017e0 	ldr	x0, [sp, #40]
  60104183c0:	f9401000 	ldr	x0, [x0, #32]
  60104183c4:	f90023e0 	str	x0, [sp, #64]
            if ((allocator->partial = allocator->partial->next) != NULL) {
  60104183c8:	f94017e0 	ldr	x0, [sp, #40]
  60104183cc:	f9401000 	ldr	x0, [x0, #32]
  60104183d0:	f9400401 	ldr	x1, [x0, #8]
  60104183d4:	f94017e0 	ldr	x0, [sp, #40]
  60104183d8:	f9001001 	str	x1, [x0, #32]
  60104183dc:	f94017e0 	ldr	x0, [sp, #40]
  60104183e0:	f9401000 	ldr	x0, [x0, #32]
  60104183e4:	f100001f 	cmp	x0, #0x0
  60104183e8:	54000080 	b.eq	60104183f8 <slab_alloc+0x114>  // b.none
                allocator->partial->prev = NULL;
  60104183ec:	f94017e0 	ldr	x0, [sp, #40]
  60104183f0:	f9401000 	ldr	x0, [x0, #32]
  60104183f4:	f900001f 	str	xzr, [x0]
            }
            if ((full_head->next = allocator->full) != NULL) {
  60104183f8:	f94017e0 	ldr	x0, [sp, #40]
  60104183fc:	f9401801 	ldr	x1, [x0, #48]
  6010418400:	f94023e0 	ldr	x0, [sp, #64]
  6010418404:	f9000401 	str	x1, [x0, #8]
  6010418408:	f94023e0 	ldr	x0, [sp, #64]
  601041840c:	f9400400 	ldr	x0, [x0, #8]
  6010418410:	f100001f 	cmp	x0, #0x0
  6010418414:	540000a0 	b.eq	6010418428 <slab_alloc+0x144>  // b.none
                allocator->full->prev = full_head;
  6010418418:	f94017e0 	ldr	x0, [sp, #40]
  601041841c:	f9401800 	ldr	x0, [x0, #48]
  6010418420:	f94023e1 	ldr	x1, [sp, #64]
  6010418424:	f9000001 	str	x1, [x0]
            }
            allocator->full = full_head;
  6010418428:	f94017e0 	ldr	x0, [sp, #40]
  601041842c:	f94023e1 	ldr	x1, [sp, #64]
  6010418430:	f9001801 	str	x1, [x0, #48]

            void* return_addr = allocator->full->data + slot * allocator->element_size;
  6010418434:	f94017e0 	ldr	x0, [sp, #40]
  6010418438:	f9401800 	ldr	x0, [x0, #48]
  601041843c:	91008001 	add	x1, x0, #0x20
  6010418440:	f94017e0 	ldr	x0, [sp, #40]
  6010418444:	f9400000 	ldr	x0, [x0]
  6010418448:	9b007e60 	mul	x0, x19, x0
  601041844c:	8b000020 	add	x0, x1, x0
  6010418450:	f9001fe0 	str	x0, [sp, #56]
            memset(return_addr, 0, allocator->element_size);
  6010418454:	f94017e0 	ldr	x0, [sp, #40]
  6010418458:	f9400000 	ldr	x0, [x0]
  601041845c:	aa0003e2 	mov	x2, x0
  6010418460:	52800001 	mov	w1, #0x0                   	// #0
  6010418464:	f9401fe0 	ldr	x0, [sp, #56]
  6010418468:	97ffd796 	bl	601040e2c0 <memset>
            return return_addr;
  601041846c:	f9401fe0 	ldr	x0, [sp, #56]
  6010418470:	14000081 	b	6010418674 <slab_alloc+0x390>
        } else {
            void* return_addr = allocator->partial->data + slot * allocator->element_size;
  6010418474:	f94017e0 	ldr	x0, [sp, #40]
  6010418478:	f9401000 	ldr	x0, [x0, #32]
  601041847c:	91008001 	add	x1, x0, #0x20
  6010418480:	f94017e0 	ldr	x0, [sp, #40]
  6010418484:	f9400000 	ldr	x0, [x0]
  6010418488:	9b007e60 	mul	x0, x19, x0
  601041848c:	8b000020 	add	x0, x1, x0
  6010418490:	f90027e0 	str	x0, [sp, #72]
            memset(return_addr, 0, allocator->element_size);
  6010418494:	f94017e0 	ldr	x0, [sp, #40]
  6010418498:	f9400000 	ldr	x0, [x0]
  601041849c:	aa0003e2 	mov	x2, x0
  60104184a0:	52800001 	mov	w1, #0x0                   	// #0
  60104184a4:	f94027e0 	ldr	x0, [sp, #72]
  60104184a8:	97ffd786 	bl	601040e2c0 <memset>
            return return_addr;
  60104184ac:	f94027e0 	ldr	x0, [sp, #72]
  60104184b0:	14000071 	b	6010418674 <slab_alloc+0x390>
        }
    }

    /* there is no partial slab */
    if (LIKELY((allocator->partial = allocator->empty) != NULL)) {
  60104184b4:	f94017e0 	ldr	x0, [sp, #40]
  60104184b8:	f9401401 	ldr	x1, [x0, #40]
  60104184bc:	f94017e0 	ldr	x0, [sp, #40]
  60104184c0:	f9001001 	str	x1, [x0, #32]
  60104184c4:	f94017e0 	ldr	x0, [sp, #40]
  60104184c8:	f9401000 	ldr	x0, [x0, #32]
  60104184cc:	f100001f 	cmp	x0, #0x0
  60104184d0:	1a9f07e0 	cset	w0, ne  // ne = any
  60104184d4:	12001c00 	and	w0, w0, #0xff
  60104184d8:	92401c00 	and	x0, x0, #0xff
  60104184dc:	f100001f 	cmp	x0, #0x0
  60104184e0:	54000340 	b.eq	6010418548 <slab_alloc+0x264>  // b.none
        /* achieve (partial) slab from empty */
        if (LIKELY((allocator->empty = allocator->empty->next) != NULL)) {
  60104184e4:	f94017e0 	ldr	x0, [sp, #40]
  60104184e8:	f9401400 	ldr	x0, [x0, #40]
  60104184ec:	f9400401 	ldr	x1, [x0, #8]
  60104184f0:	f94017e0 	ldr	x0, [sp, #40]
  60104184f4:	f9001401 	str	x1, [x0, #40]
  60104184f8:	f94017e0 	ldr	x0, [sp, #40]
  60104184fc:	f9401400 	ldr	x0, [x0, #40]
  6010418500:	f100001f 	cmp	x0, #0x0
  6010418504:	1a9f07e0 	cset	w0, ne  // ne = any
  6010418508:	12001c00 	and	w0, w0, #0xff
  601041850c:	92401c00 	and	x0, x0, #0xff
  6010418510:	f100001f 	cmp	x0, #0x0
  6010418514:	54000080 	b.eq	6010418524 <slab_alloc+0x240>  // b.none
            allocator->empty->prev = NULL;
  6010418518:	f94017e0 	ldr	x0, [sp, #40]
  601041851c:	f9401400 	ldr	x0, [x0, #40]
  6010418520:	f900001f 	str	xzr, [x0]
        }
        allocator->partial->next = NULL;
  6010418524:	f94017e0 	ldr	x0, [sp, #40]
  6010418528:	f9401000 	ldr	x0, [x0, #32]
  601041852c:	f900041f 	str	xzr, [x0, #8]
        allocator->partial->refcount++;
  6010418530:	f94017e0 	ldr	x0, [sp, #40]
  6010418534:	f9401000 	ldr	x0, [x0, #32]
  6010418538:	f9400c01 	ldr	x1, [x0, #24]
  601041853c:	91000421 	add	x1, x1, #0x1
  6010418540:	f9000c01 	str	x1, [x0, #24]
  6010418544:	14000027 	b	60104185e0 <slab_alloc+0x2fc>
    } else {
        /* achieve slab from outer arena */
        allocator->partial = (struct slab_state*)LOWLEVEL_ALLOC(allocator->slabsize);
  6010418548:	f94017e0 	ldr	x0, [sp, #40]
  601041854c:	f9400800 	ldr	x0, [x0, #16]
  6010418550:	97fff83b 	bl	601041663c <kalloc>
  6010418554:	aa0003e1 	mov	x1, x0
  6010418558:	f94017e0 	ldr	x0, [sp, #40]
  601041855c:	f9001001 	str	x1, [x0, #32]
        if (UNLIKELY(allocator->partial == NULL)) {
  6010418560:	f94017e0 	ldr	x0, [sp, #40]
  6010418564:	f9401000 	ldr	x0, [x0, #32]
  6010418568:	f100001f 	cmp	x0, #0x0
  601041856c:	1a9f17e0 	cset	w0, eq  // eq = none
  6010418570:	12001c00 	and	w0, w0, #0xff
  6010418574:	92401c00 	and	x0, x0, #0xff
  6010418578:	f100001f 	cmp	x0, #0x0
  601041857c:	540001c0 	b.eq	60104185b4 <slab_alloc+0x2d0>  // b.none
            ERROR("no enough memory\n");
  6010418580:	52800dc2 	mov	w2, #0x6e                  	// #110
  6010418584:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010418588:	91070001 	add	x1, x0, #0x1c0
  601041858c:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010418590:	9104c000 	add	x0, x0, #0x130
  6010418594:	97ffeef9 	bl	6010414178 <printf_>
  6010418598:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041859c:	9105c000 	add	x0, x0, #0x170
  60104185a0:	97ffeef6 	bl	6010414178 <printf_>
            return allocator->partial = NULL;
  60104185a4:	f94017e0 	ldr	x0, [sp, #40]
  60104185a8:	f900101f 	str	xzr, [x0, #32]
  60104185ac:	d2800000 	mov	x0, #0x0                   	// #0
  60104185b0:	14000031 	b	6010418674 <slab_alloc+0x390>
        }
        allocator->partial->prev = allocator->partial->next = NULL;
  60104185b4:	f94017e0 	ldr	x0, [sp, #40]
  60104185b8:	f9401000 	ldr	x0, [x0, #32]
  60104185bc:	f900041f 	str	xzr, [x0, #8]
  60104185c0:	f94017e1 	ldr	x1, [sp, #40]
  60104185c4:	f9401021 	ldr	x1, [x1, #32]
  60104185c8:	f9400400 	ldr	x0, [x0, #8]
  60104185cc:	f9000020 	str	x0, [x1]
        allocator->partial->refcount = 1;
  60104185d0:	f94017e0 	ldr	x0, [sp, #40]
  60104185d4:	f9401000 	ldr	x0, [x0, #32]
  60104185d8:	d2800021 	mov	x1, #0x1                   	// #1
  60104185dc:	f9000c01 	str	x1, [x0, #24]
    }
    allocator->partial->bitmap = allocator->bitmap_empty ^ BITMAP_FIRST_BIT;
  60104185e0:	f94017e0 	ldr	x0, [sp, #40]
  60104185e4:	f9400c01 	ldr	x1, [x0, #24]
  60104185e8:	f94017e0 	ldr	x0, [sp, #40]
  60104185ec:	f9401000 	ldr	x0, [x0, #32]
  60104185f0:	d2400021 	eor	x1, x1, #0x1
  60104185f4:	f9000801 	str	x1, [x0, #16]
    assert(allocator->partial->data != NULL);
  60104185f8:	f94017e0 	ldr	x0, [sp, #40]
  60104185fc:	f9401000 	ldr	x0, [x0, #32]
  6010418600:	91008000 	add	x0, x0, #0x20
  6010418604:	f100001f 	cmp	x0, #0x0
  6010418608:	540001e1 	b.ne	6010418644 <slab_alloc+0x360>  // b.any
  601041860c:	52800ea2 	mov	w2, #0x75                  	// #117
  6010418610:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010418614:	91070001 	add	x1, x0, #0x1c0
  6010418618:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041861c:	9104c000 	add	x0, x0, #0x130
  6010418620:	97ffeed6 	bl	6010414178 <printf_>
  6010418624:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010418628:	91062001 	add	x1, x0, #0x188
  601041862c:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010418630:	91056000 	add	x0, x0, #0x158
  6010418634:	97ffeed1 	bl	6010414178 <printf_>
  6010418638:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041863c:	9105a000 	add	x0, x0, #0x168
  6010418640:	97ffdb1a 	bl	601040f2a8 <panic>
    memset(allocator->partial->data, 0, allocator->element_size);
  6010418644:	f94017e0 	ldr	x0, [sp, #40]
  6010418648:	f9401000 	ldr	x0, [x0, #32]
  601041864c:	91008003 	add	x3, x0, #0x20
  6010418650:	f94017e0 	ldr	x0, [sp, #40]
  6010418654:	f9400000 	ldr	x0, [x0]
  6010418658:	aa0003e2 	mov	x2, x0
  601041865c:	52800001 	mov	w1, #0x0                   	// #0
  6010418660:	aa0303e0 	mov	x0, x3
  6010418664:	97ffd717 	bl	601040e2c0 <memset>
    return allocator->partial->data;
  6010418668:	f94017e0 	ldr	x0, [sp, #40]
  601041866c:	f9401000 	ldr	x0, [x0, #32]
  6010418670:	91008000 	add	x0, x0, #0x20
}
  6010418674:	f9400bf3 	ldr	x19, [sp, #16]
  6010418678:	a8c57bfd 	ldp	x29, x30, [sp], #80
  601041867c:	d65f03c0 	ret

0000006010418680 <slab_free>:

void slab_free(struct slab_allocator* const allocator, const void* const addr)
{
  6010418680:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  6010418684:	910003fd 	mov	x29, sp
  6010418688:	f9000bf3 	str	x19, [sp, #16]
  601041868c:	f90017e0 	str	x0, [sp, #40]
  6010418690:	f90013e1 	str	x1, [sp, #32]
    assert(allocator != NULL);
  6010418694:	f94017e0 	ldr	x0, [sp, #40]
  6010418698:	f100001f 	cmp	x0, #0x0
  601041869c:	540001e1 	b.ne	60104186d8 <slab_free+0x58>  // b.any
  60104186a0:	52800f82 	mov	w2, #0x7c                  	// #124
  60104186a4:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  60104186a8:	91074001 	add	x1, x0, #0x1d0
  60104186ac:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  60104186b0:	9104c000 	add	x0, x0, #0x130
  60104186b4:	97ffeeb1 	bl	6010414178 <printf_>
  60104186b8:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  60104186bc:	91050001 	add	x1, x0, #0x140
  60104186c0:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  60104186c4:	91056000 	add	x0, x0, #0x158
  60104186c8:	97ffeeac 	bl	6010414178 <printf_>
  60104186cc:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  60104186d0:	9105a000 	add	x0, x0, #0x168
  60104186d4:	97ffdaf5 	bl	601040f2a8 <panic>
    assert(addr != NULL);
  60104186d8:	f94013e0 	ldr	x0, [sp, #32]
  60104186dc:	f100001f 	cmp	x0, #0x0
  60104186e0:	540001e1 	b.ne	601041871c <slab_free+0x9c>  // b.any
  60104186e4:	52800fa2 	mov	w2, #0x7d                  	// #125
  60104186e8:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  60104186ec:	91074001 	add	x1, x0, #0x1d0
  60104186f0:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  60104186f4:	9104c000 	add	x0, x0, #0x130
  60104186f8:	97ffeea0 	bl	6010414178 <printf_>
  60104186fc:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010418700:	9106c001 	add	x1, x0, #0x1b0
  6010418704:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010418708:	91056000 	add	x0, x0, #0x158
  601041870c:	97ffee9b 	bl	6010414178 <printf_>
  6010418710:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010418714:	9105a000 	add	x0, x0, #0x168
  6010418718:	97ffdae4 	bl	601040f2a8 <panic>

    struct slab_state* const slab_to_free = (void*)ALIGNDOWN(addr, allocator->slabsize);
  601041871c:	f94017e0 	ldr	x0, [sp, #40]
  6010418720:	f9400800 	ldr	x0, [x0, #16]
  6010418724:	cb0003e1 	neg	x1, x0
  6010418728:	f94013e0 	ldr	x0, [sp, #32]
  601041872c:	8a000020 	and	x0, x1, x0
  6010418730:	f9001fe0 	str	x0, [sp, #56]
    register const size_t slot = ((char*)addr - (char*)slab_to_free - offsetof(struct slab_state, data)) / allocator->element_size;
  6010418734:	f94013e1 	ldr	x1, [sp, #32]
  6010418738:	f9401fe0 	ldr	x0, [sp, #56]
  601041873c:	cb000020 	sub	x0, x1, x0
  6010418740:	d1008001 	sub	x1, x0, #0x20
  6010418744:	f94017e0 	ldr	x0, [sp, #40]
  6010418748:	f9400000 	ldr	x0, [x0]
  601041874c:	9ac00833 	udiv	x19, x1, x0

    if (UNLIKELY(slab_to_free->bitmap == BITMAP_BITS_EMPTY_FULL)) {
  6010418750:	f9401fe0 	ldr	x0, [sp, #56]
  6010418754:	f9400800 	ldr	x0, [x0, #16]
  6010418758:	f100001f 	cmp	x0, #0x0
  601041875c:	1a9f17e0 	cset	w0, eq  // eq = none
  6010418760:	12001c00 	and	w0, w0, #0xff
  6010418764:	92401c00 	and	x0, x0, #0xff
  6010418768:	f100001f 	cmp	x0, #0x0
  601041876c:	54000860 	b.eq	6010418878 <slab_free+0x1f8>  // b.none
        /* free element from full slab */
        slab_to_free->bitmap = BITMAP_FIRST_BIT << slot;
  6010418770:	2a1303e1 	mov	w1, w19
  6010418774:	d2800020 	mov	x0, #0x1                   	// #1
  6010418778:	9ac12001 	lsl	x1, x0, x1
  601041877c:	f9401fe0 	ldr	x0, [sp, #56]
  6010418780:	f9000801 	str	x1, [x0, #16]

        if (LIKELY(slab_to_free != allocator->full)) {
  6010418784:	f94017e0 	ldr	x0, [sp, #40]
  6010418788:	f9401800 	ldr	x0, [x0, #48]
  601041878c:	f9401fe1 	ldr	x1, [sp, #56]
  6010418790:	eb00003f 	cmp	x1, x0
  6010418794:	1a9f07e0 	cset	w0, ne  // ne = any
  6010418798:	12001c00 	and	w0, w0, #0xff
  601041879c:	92401c00 	and	x0, x0, #0xff
  60104187a0:	f100001f 	cmp	x0, #0x0
  60104187a4:	540002a0 	b.eq	60104187f8 <slab_free+0x178>  // b.none
            if (LIKELY((slab_to_free->prev->next = slab_to_free->next) != NULL)) {
  60104187a8:	f9401fe0 	ldr	x0, [sp, #56]
  60104187ac:	f9400000 	ldr	x0, [x0]
  60104187b0:	f9401fe1 	ldr	x1, [sp, #56]
  60104187b4:	f9400421 	ldr	x1, [x1, #8]
  60104187b8:	f9000401 	str	x1, [x0, #8]
  60104187bc:	f9400400 	ldr	x0, [x0, #8]
  60104187c0:	f100001f 	cmp	x0, #0x0
  60104187c4:	1a9f07e0 	cset	w0, ne  // ne = any
  60104187c8:	12001c00 	and	w0, w0, #0xff
  60104187cc:	92401c00 	and	x0, x0, #0xff
  60104187d0:	f100001f 	cmp	x0, #0x0
  60104187d4:	540000c0 	b.eq	60104187ec <slab_free+0x16c>  // b.none
                slab_to_free->next->prev = slab_to_free->prev;
  60104187d8:	f9401fe0 	ldr	x0, [sp, #56]
  60104187dc:	f9400400 	ldr	x0, [x0, #8]
  60104187e0:	f9401fe1 	ldr	x1, [sp, #56]
  60104187e4:	f9400021 	ldr	x1, [x1]
  60104187e8:	f9000001 	str	x1, [x0]
            }
            slab_to_free->prev = NULL;
  60104187ec:	f9401fe0 	ldr	x0, [sp, #56]
  60104187f0:	f900001f 	str	xzr, [x0]
  60104187f4:	1400000d 	b	6010418828 <slab_free+0x1a8>
        } else if ((allocator->full = allocator->full->next) != NULL) {
  60104187f8:	f94017e0 	ldr	x0, [sp, #40]
  60104187fc:	f9401800 	ldr	x0, [x0, #48]
  6010418800:	f9400401 	ldr	x1, [x0, #8]
  6010418804:	f94017e0 	ldr	x0, [sp, #40]
  6010418808:	f9001801 	str	x1, [x0, #48]
  601041880c:	f94017e0 	ldr	x0, [sp, #40]
  6010418810:	f9401800 	ldr	x0, [x0, #48]
  6010418814:	f100001f 	cmp	x0, #0x0
  6010418818:	54000080 	b.eq	6010418828 <slab_free+0x1a8>  // b.none
            allocator->full->prev = NULL;
  601041881c:	f94017e0 	ldr	x0, [sp, #40]
  6010418820:	f9401800 	ldr	x0, [x0, #48]
  6010418824:	f900001f 	str	xzr, [x0]
        }

        slab_to_free->next = allocator->partial;
  6010418828:	f94017e0 	ldr	x0, [sp, #40]
  601041882c:	f9401001 	ldr	x1, [x0, #32]
  6010418830:	f9401fe0 	ldr	x0, [sp, #56]
  6010418834:	f9000401 	str	x1, [x0, #8]
        if (LIKELY(allocator->partial != NULL)) {
  6010418838:	f94017e0 	ldr	x0, [sp, #40]
  601041883c:	f9401000 	ldr	x0, [x0, #32]
  6010418840:	f100001f 	cmp	x0, #0x0
  6010418844:	1a9f07e0 	cset	w0, ne  // ne = any
  6010418848:	12001c00 	and	w0, w0, #0xff
  601041884c:	92401c00 	and	x0, x0, #0xff
  6010418850:	f100001f 	cmp	x0, #0x0
  6010418854:	540000a0 	b.eq	6010418868 <slab_free+0x1e8>  // b.none
            allocator->partial->prev = slab_to_free;
  6010418858:	f94017e0 	ldr	x0, [sp, #40]
  601041885c:	f9401000 	ldr	x0, [x0, #32]
  6010418860:	f9401fe1 	ldr	x1, [sp, #56]
  6010418864:	f9000001 	str	x1, [x0]
        }
        allocator->partial = slab_to_free;
  6010418868:	f94017e0 	ldr	x0, [sp, #40]
  601041886c:	f9401fe1 	ldr	x1, [sp, #56]
  6010418870:	f9001001 	str	x1, [x0, #32]
            slab_to_free->refcount--;
        }
    } else {
        slab_to_free->bitmap |= BITMAP_FIRST_BIT << slot;
    }
}
  6010418874:	14000095 	b	6010418ac8 <slab_free+0x448>
    } else if (UNLIKELY(BITMAP_USED_SOLE_BIT(slab_to_free->bitmap, allocator->bitmap_empty))) {
  6010418878:	f9401fe0 	ldr	x0, [sp, #56]
  601041887c:	f9400800 	ldr	x0, [x0, #16]
  6010418880:	aa2003e1 	mvn	x1, x0
  6010418884:	f94017e0 	ldr	x0, [sp, #40]
  6010418888:	f9400c00 	ldr	x0, [x0, #24]
  601041888c:	8a000021 	and	x1, x1, x0
  6010418890:	f9401fe0 	ldr	x0, [sp, #56]
  6010418894:	f9400800 	ldr	x0, [x0, #16]
  6010418898:	aa2003e2 	mvn	x2, x0
  601041889c:	f94017e0 	ldr	x0, [sp, #40]
  60104188a0:	f9400c00 	ldr	x0, [x0, #24]
  60104188a4:	8a000040 	and	x0, x2, x0
  60104188a8:	d1000400 	sub	x0, x0, #0x1
  60104188ac:	8a000020 	and	x0, x1, x0
  60104188b0:	f100001f 	cmp	x0, #0x0
  60104188b4:	1a9f17e0 	cset	w0, eq  // eq = none
  60104188b8:	12001c00 	and	w0, w0, #0xff
  60104188bc:	92401c00 	and	x0, x0, #0xff
  60104188c0:	f100001f 	cmp	x0, #0x0
  60104188c4:	54000f20 	b.eq	6010418aa8 <slab_free+0x428>  // b.none
        if (LIKELY(slab_to_free->refcount == 1)) {
  60104188c8:	f9401fe0 	ldr	x0, [sp, #56]
  60104188cc:	f9400c00 	ldr	x0, [x0, #24]
  60104188d0:	f100041f 	cmp	x0, #0x1
  60104188d4:	1a9f17e0 	cset	w0, eq  // eq = none
  60104188d8:	12001c00 	and	w0, w0, #0xff
  60104188dc:	92401c00 	and	x0, x0, #0xff
  60104188e0:	f100001f 	cmp	x0, #0x0
  60104188e4:	54000560 	b.eq	6010418990 <slab_free+0x310>  // b.none
            if (LIKELY(slab_to_free != allocator->partial)) {
  60104188e8:	f94017e0 	ldr	x0, [sp, #40]
  60104188ec:	f9401000 	ldr	x0, [x0, #32]
  60104188f0:	f9401fe1 	ldr	x1, [sp, #56]
  60104188f4:	eb00003f 	cmp	x1, x0
  60104188f8:	1a9f07e0 	cset	w0, ne  // ne = any
  60104188fc:	12001c00 	and	w0, w0, #0xff
  6010418900:	92401c00 	and	x0, x0, #0xff
  6010418904:	f100001f 	cmp	x0, #0x0
  6010418908:	540001e0 	b.eq	6010418944 <slab_free+0x2c4>  // b.none
                if ((slab_to_free->prev->next = slab_to_free->next) != NULL) {
  601041890c:	f9401fe0 	ldr	x0, [sp, #56]
  6010418910:	f9400000 	ldr	x0, [x0]
  6010418914:	f9401fe1 	ldr	x1, [sp, #56]
  6010418918:	f9400421 	ldr	x1, [x1, #8]
  601041891c:	f9000401 	str	x1, [x0, #8]
  6010418920:	f9400400 	ldr	x0, [x0, #8]
  6010418924:	f100001f 	cmp	x0, #0x0
  6010418928:	540002e0 	b.eq	6010418984 <slab_free+0x304>  // b.none
                    slab_to_free->next->prev = slab_to_free->prev;
  601041892c:	f9401fe0 	ldr	x0, [sp, #56]
  6010418930:	f9400400 	ldr	x0, [x0, #8]
  6010418934:	f9401fe1 	ldr	x1, [sp, #56]
  6010418938:	f9400021 	ldr	x1, [x1]
  601041893c:	f9000001 	str	x1, [x0]
  6010418940:	14000011 	b	6010418984 <slab_free+0x304>
            } else if (LIKELY((allocator->partial = allocator->partial->next) != NULL)) {
  6010418944:	f94017e0 	ldr	x0, [sp, #40]
  6010418948:	f9401000 	ldr	x0, [x0, #32]
  601041894c:	f9400401 	ldr	x1, [x0, #8]
  6010418950:	f94017e0 	ldr	x0, [sp, #40]
  6010418954:	f9001001 	str	x1, [x0, #32]
  6010418958:	f94017e0 	ldr	x0, [sp, #40]
  601041895c:	f9401000 	ldr	x0, [x0, #32]
  6010418960:	f100001f 	cmp	x0, #0x0
  6010418964:	1a9f07e0 	cset	w0, ne  // ne = any
  6010418968:	12001c00 	and	w0, w0, #0xff
  601041896c:	92401c00 	and	x0, x0, #0xff
  6010418970:	f100001f 	cmp	x0, #0x0
  6010418974:	54000080 	b.eq	6010418984 <slab_free+0x304>  // b.none
                allocator->partial->prev = NULL;
  6010418978:	f94017e0 	ldr	x0, [sp, #40]
  601041897c:	f9401000 	ldr	x0, [x0, #32]
  6010418980:	f900001f 	str	xzr, [x0]
            LOWLEVEL_FREE((void*)slab_to_free);
  6010418984:	f9401fe0 	ldr	x0, [sp, #56]
  6010418988:	97fff76e 	bl	6010416740 <kfree>
}
  601041898c:	1400004f 	b	6010418ac8 <slab_free+0x448>
            slab_to_free->bitmap = allocator->bitmap_empty;
  6010418990:	f94017e0 	ldr	x0, [sp, #40]
  6010418994:	f9400c01 	ldr	x1, [x0, #24]
  6010418998:	f9401fe0 	ldr	x0, [sp, #56]
  601041899c:	f9000801 	str	x1, [x0, #16]
            if (LIKELY(slab_to_free != allocator->partial)) {
  60104189a0:	f94017e0 	ldr	x0, [sp, #40]
  60104189a4:	f9401000 	ldr	x0, [x0, #32]
  60104189a8:	f9401fe1 	ldr	x1, [sp, #56]
  60104189ac:	eb00003f 	cmp	x1, x0
  60104189b0:	1a9f07e0 	cset	w0, ne  // ne = any
  60104189b4:	12001c00 	and	w0, w0, #0xff
  60104189b8:	92401c00 	and	x0, x0, #0xff
  60104189bc:	f100001f 	cmp	x0, #0x0
  60104189c0:	54000220 	b.eq	6010418a04 <slab_free+0x384>  // b.none
                if ((slab_to_free->prev->next = slab_to_free->next) != NULL) {
  60104189c4:	f9401fe0 	ldr	x0, [sp, #56]
  60104189c8:	f9400000 	ldr	x0, [x0]
  60104189cc:	f9401fe1 	ldr	x1, [sp, #56]
  60104189d0:	f9400421 	ldr	x1, [x1, #8]
  60104189d4:	f9000401 	str	x1, [x0, #8]
  60104189d8:	f9400400 	ldr	x0, [x0, #8]
  60104189dc:	f100001f 	cmp	x0, #0x0
  60104189e0:	540000c0 	b.eq	60104189f8 <slab_free+0x378>  // b.none
                    slab_to_free->next->prev = slab_to_free->prev;
  60104189e4:	f9401fe0 	ldr	x0, [sp, #56]
  60104189e8:	f9400400 	ldr	x0, [x0, #8]
  60104189ec:	f9401fe1 	ldr	x1, [sp, #56]
  60104189f0:	f9400021 	ldr	x1, [x1]
  60104189f4:	f9000001 	str	x1, [x0]
                slab_to_free->prev = NULL;
  60104189f8:	f9401fe0 	ldr	x0, [sp, #56]
  60104189fc:	f900001f 	str	xzr, [x0]
  6010418a00:	14000011 	b	6010418a44 <slab_free+0x3c4>
            } else if (LIKELY((allocator->partial = allocator->partial->next) != NULL)) {
  6010418a04:	f94017e0 	ldr	x0, [sp, #40]
  6010418a08:	f9401000 	ldr	x0, [x0, #32]
  6010418a0c:	f9400401 	ldr	x1, [x0, #8]
  6010418a10:	f94017e0 	ldr	x0, [sp, #40]
  6010418a14:	f9001001 	str	x1, [x0, #32]
  6010418a18:	f94017e0 	ldr	x0, [sp, #40]
  6010418a1c:	f9401000 	ldr	x0, [x0, #32]
  6010418a20:	f100001f 	cmp	x0, #0x0
  6010418a24:	1a9f07e0 	cset	w0, ne  // ne = any
  6010418a28:	12001c00 	and	w0, w0, #0xff
  6010418a2c:	92401c00 	and	x0, x0, #0xff
  6010418a30:	f100001f 	cmp	x0, #0x0
  6010418a34:	54000080 	b.eq	6010418a44 <slab_free+0x3c4>  // b.none
                allocator->partial->prev = NULL;
  6010418a38:	f94017e0 	ldr	x0, [sp, #40]
  6010418a3c:	f9401000 	ldr	x0, [x0, #32]
  6010418a40:	f900001f 	str	xzr, [x0]
            slab_to_free->next = allocator->empty;
  6010418a44:	f94017e0 	ldr	x0, [sp, #40]
  6010418a48:	f9401401 	ldr	x1, [x0, #40]
  6010418a4c:	f9401fe0 	ldr	x0, [sp, #56]
  6010418a50:	f9000401 	str	x1, [x0, #8]
            if (UNLIKELY(allocator->empty != NULL))
  6010418a54:	f94017e0 	ldr	x0, [sp, #40]
  6010418a58:	f9401400 	ldr	x0, [x0, #40]
  6010418a5c:	f100001f 	cmp	x0, #0x0
  6010418a60:	1a9f07e0 	cset	w0, ne  // ne = any
  6010418a64:	12001c00 	and	w0, w0, #0xff
  6010418a68:	92401c00 	and	x0, x0, #0xff
  6010418a6c:	f100001f 	cmp	x0, #0x0
  6010418a70:	540000a0 	b.eq	6010418a84 <slab_free+0x404>  // b.none
                allocator->empty->prev = slab_to_free;
  6010418a74:	f94017e0 	ldr	x0, [sp, #40]
  6010418a78:	f9401400 	ldr	x0, [x0, #40]
  6010418a7c:	f9401fe1 	ldr	x1, [sp, #56]
  6010418a80:	f9000001 	str	x1, [x0]
            allocator->empty = slab_to_free;
  6010418a84:	f94017e0 	ldr	x0, [sp, #40]
  6010418a88:	f9401fe1 	ldr	x1, [sp, #56]
  6010418a8c:	f9001401 	str	x1, [x0, #40]
            slab_to_free->refcount--;
  6010418a90:	f9401fe0 	ldr	x0, [sp, #56]
  6010418a94:	f9400c00 	ldr	x0, [x0, #24]
  6010418a98:	d1000401 	sub	x1, x0, #0x1
  6010418a9c:	f9401fe0 	ldr	x0, [sp, #56]
  6010418aa0:	f9000c01 	str	x1, [x0, #24]
}
  6010418aa4:	14000009 	b	6010418ac8 <slab_free+0x448>
        slab_to_free->bitmap |= BITMAP_FIRST_BIT << slot;
  6010418aa8:	f9401fe0 	ldr	x0, [sp, #56]
  6010418aac:	f9400801 	ldr	x1, [x0, #16]
  6010418ab0:	2a1303e2 	mov	w2, w19
  6010418ab4:	d2800020 	mov	x0, #0x1                   	// #1
  6010418ab8:	9ac22000 	lsl	x0, x0, x2
  6010418abc:	aa000021 	orr	x1, x1, x0
  6010418ac0:	f9401fe0 	ldr	x0, [sp, #56]
  6010418ac4:	f9000801 	str	x1, [x0, #16]
}
  6010418ac8:	d503201f 	nop
  6010418acc:	f9400bf3 	ldr	x19, [sp, #16]
  6010418ad0:	a8c47bfd 	ldp	x29, x30, [sp], #64
  6010418ad4:	d65f03c0 	ret

0000006010418ad8 <slab_destroy>:

void slab_destroy(const struct slab_allocator* const allocator)
{
  6010418ad8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  6010418adc:	910003fd 	mov	x29, sp
  6010418ae0:	f9000fe0 	str	x0, [sp, #24]
    assert(allocator != NULL);
  6010418ae4:	f9400fe0 	ldr	x0, [sp, #24]
  6010418ae8:	f100001f 	cmp	x0, #0x0
  6010418aec:	540001e1 	b.ne	6010418b28 <slab_destroy+0x50>  // b.any
  6010418af0:	52801742 	mov	w2, #0xba                  	// #186
  6010418af4:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010418af8:	91078001 	add	x1, x0, #0x1e0
  6010418afc:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010418b00:	9104c000 	add	x0, x0, #0x130
  6010418b04:	97ffed9d 	bl	6010414178 <printf_>
  6010418b08:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010418b0c:	91050001 	add	x1, x0, #0x140
  6010418b10:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010418b14:	91056000 	add	x0, x0, #0x158
  6010418b18:	97ffed98 	bl	6010414178 <printf_>
  6010418b1c:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010418b20:	9105a000 	add	x0, x0, #0x168
  6010418b24:	97ffd9e1 	bl	601040f2a8 <panic>

    struct slab_state* const slab_lists[] = { allocator->partial, allocator->empty, allocator->full };
  6010418b28:	f9400fe0 	ldr	x0, [sp, #24]
  6010418b2c:	f9401000 	ldr	x0, [x0, #32]
  6010418b30:	f90017e0 	str	x0, [sp, #40]
  6010418b34:	f9400fe0 	ldr	x0, [sp, #24]
  6010418b38:	f9401400 	ldr	x0, [x0, #40]
  6010418b3c:	f9001be0 	str	x0, [sp, #48]
  6010418b40:	f9400fe0 	ldr	x0, [sp, #24]
  6010418b44:	f9401800 	ldr	x0, [x0, #48]
  6010418b48:	f9001fe0 	str	x0, [sp, #56]
    for (size_t i = 0; i < (sizeof(slab_lists) / sizeof(struct slab_state*)); i++) {
  6010418b4c:	f90027ff 	str	xzr, [sp, #72]
  6010418b50:	14000017 	b	6010418bac <slab_destroy+0xd4>
        struct slab_state* slab = slab_lists[i];
  6010418b54:	f94027e0 	ldr	x0, [sp, #72]
  6010418b58:	d37df000 	lsl	x0, x0, #3
  6010418b5c:	9100a3e1 	add	x1, sp, #0x28
  6010418b60:	f8606820 	ldr	x0, [x1, x0]
  6010418b64:	f90023e0 	str	x0, [sp, #64]

        while (slab != NULL) {
  6010418b68:	1400000b 	b	6010418b94 <slab_destroy+0xbc>
            if (slab->refcount != 0) {
  6010418b6c:	f94023e0 	ldr	x0, [sp, #64]
  6010418b70:	f9400c00 	ldr	x0, [x0, #24]
  6010418b74:	f100001f 	cmp	x0, #0x0
  6010418b78:	54000080 	b.eq	6010418b88 <slab_destroy+0xb0>  // b.none
                LOWLEVEL_FREE((void*)slab);
  6010418b7c:	f94023e0 	ldr	x0, [sp, #64]
  6010418b80:	97fff6f0 	bl	6010416740 <kfree>
  6010418b84:	14000004 	b	6010418b94 <slab_destroy+0xbc>
            } else {
                slab = slab->next;
  6010418b88:	f94023e0 	ldr	x0, [sp, #64]
  6010418b8c:	f9400400 	ldr	x0, [x0, #8]
  6010418b90:	f90023e0 	str	x0, [sp, #64]
        while (slab != NULL) {
  6010418b94:	f94023e0 	ldr	x0, [sp, #64]
  6010418b98:	f100001f 	cmp	x0, #0x0
  6010418b9c:	54fffe81 	b.ne	6010418b6c <slab_destroy+0x94>  // b.any
    for (size_t i = 0; i < (sizeof(slab_lists) / sizeof(struct slab_state*)); i++) {
  6010418ba0:	f94027e0 	ldr	x0, [sp, #72]
  6010418ba4:	91000400 	add	x0, x0, #0x1
  6010418ba8:	f90027e0 	str	x0, [sp, #72]
  6010418bac:	f94027e0 	ldr	x0, [sp, #72]
  6010418bb0:	f100081f 	cmp	x0, #0x2
  6010418bb4:	54fffd09 	b.ls	6010418b54 <slab_destroy+0x7c>  // b.plast
            }
        }
    }
  6010418bb8:	d503201f 	nop
  6010418bbc:	d503201f 	nop
  6010418bc0:	a8c57bfd 	ldp	x29, x30, [sp], #80
  6010418bc4:	d65f03c0 	ret

0000006010418bc8 <cur_cpuid>:
{
  6010418bc8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  6010418bcc:	910003fd 	mov	x29, sp
    return cpu_get_current();
  6010418bd0:	97ffd6b2 	bl	601040e698 <cpu_get_current>
}
  6010418bd4:	a8c17bfd 	ldp	x29, x30, [sp], #16
  6010418bd8:	d65f03c0 	ret

0000006010418bdc <cur_cpu>:
{
  6010418bdc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  6010418be0:	910003fd 	mov	x29, sp
    return &global_cpus[cur_cpuid()];
  6010418be4:	97fffff9 	bl	6010418bc8 <cur_cpuid>
  6010418be8:	93407c01 	sxtw	x1, w0
  6010418bec:	d2800300 	mov	x0, #0x18                  	// #24
  6010418bf0:	9b007c21 	mul	x1, x1, x0
  6010418bf4:	f0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010418bf8:	f942f400 	ldr	x0, [x0, #1512]
  6010418bfc:	8b000020 	add	x0, x1, x0
}
  6010418c00:	a8c17bfd 	ldp	x29, x30, [sp], #16
  6010418c04:	d65f03c0 	ret

0000006010418c08 <SessionAllocator>:
#include "task.h"

static struct SharePageRightGroup right_group;

static struct slab_allocator* SessionAllocator()
{
  6010418c08:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  6010418c0c:	910003fd 	mov	x29, sp
    static bool init = false;
    static struct slab_allocator session_slab;
    if (!init) {
  6010418c10:	f000b940 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  6010418c14:	912b2000 	add	x0, x0, #0xac8
  6010418c18:	39400000 	ldrb	w0, [x0]
  6010418c1c:	52000000 	eor	w0, w0, #0x1
  6010418c20:	12001c00 	and	w0, w0, #0xff
  6010418c24:	7100001f 	cmp	w0, #0x0
  6010418c28:	540000a0 	b.eq	6010418c3c <SessionAllocator+0x34>  // b.none
        slab_init(&session_slab, sizeof(struct session_backend));
  6010418c2c:	d2800d01 	mov	x1, #0x68                  	// #104
  6010418c30:	f000b940 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  6010418c34:	912b4000 	add	x0, x0, #0xad0
  6010418c38:	97fffd71 	bl	60104181fc <slab_init>
    }
    return &session_slab;
  6010418c3c:	f000b940 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  6010418c40:	912b4000 	add	x0, x0, #0xad0
}
  6010418c44:	a8c17bfd 	ldp	x29, x30, [sp], #16
  6010418c48:	d65f03c0 	ret

0000006010418c4c <check_pages_unmapped>:
/// @param task
/// @param vaddr
/// @param nr_pages
/// @return true if mem range is free, false if at least one page inside [vaddr, vaddr + nr_pages * PAGE_SIZE) is mapped
static inline bool check_pages_unmapped(struct Thread* task, uintptr_t vaddr, int nr_pages)
{
  6010418c4c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  6010418c50:	910003fd 	mov	x29, sp
  6010418c54:	f90017e0 	str	x0, [sp, #40]
  6010418c58:	f90013e1 	str	x1, [sp, #32]
  6010418c5c:	b9001fe2 	str	w2, [sp, #28]
    for (uintptr_t i = 0; i < nr_pages; i++) {
  6010418c60:	f9001fff 	str	xzr, [sp, #56]
  6010418c64:	14000016 	b	6010418cbc <check_pages_unmapped+0x70>
        uintptr_t paddr = UINT32_MAX;
  6010418c68:	b2407fe0 	mov	x0, #0xffffffff            	// #4294967295
  6010418c6c:	f9001be0 	str	x0, [sp, #48]
        if ((paddr = xizi_pager.address_translate(&task->memspace->pgdir, vaddr)) != (uintptr_t)NULL) {
  6010418c70:	f0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010418c74:	f942b000 	ldr	x0, [x0, #1376]
  6010418c78:	f9401402 	ldr	x2, [x0, #40]
  6010418c7c:	f94017e0 	ldr	x0, [sp, #40]
  6010418c80:	f9402800 	ldr	x0, [x0, #80]
  6010418c84:	f94013e1 	ldr	x1, [sp, #32]
  6010418c88:	d63f0040 	blr	x2
  6010418c8c:	f9001be0 	str	x0, [sp, #48]
  6010418c90:	f9401be0 	ldr	x0, [sp, #48]
  6010418c94:	f100001f 	cmp	x0, #0x0
  6010418c98:	54000060 	b.eq	6010418ca4 <check_pages_unmapped+0x58>  // b.none
            return false;
  6010418c9c:	52800000 	mov	w0, #0x0                   	// #0
  6010418ca0:	1400000c 	b	6010418cd0 <check_pages_unmapped+0x84>
        }
        vaddr += PAGE_SIZE;
  6010418ca4:	f94013e0 	ldr	x0, [sp, #32]
  6010418ca8:	91400400 	add	x0, x0, #0x1, lsl #12
  6010418cac:	f90013e0 	str	x0, [sp, #32]
    for (uintptr_t i = 0; i < nr_pages; i++) {
  6010418cb0:	f9401fe0 	ldr	x0, [sp, #56]
  6010418cb4:	91000400 	add	x0, x0, #0x1
  6010418cb8:	f9001fe0 	str	x0, [sp, #56]
  6010418cbc:	b9801fe0 	ldrsw	x0, [sp, #28]
  6010418cc0:	f9401fe1 	ldr	x1, [sp, #56]
  6010418cc4:	eb00003f 	cmp	x1, x0
  6010418cc8:	54fffd03 	b.cc	6010418c68 <check_pages_unmapped+0x1c>  // b.lo, b.ul, b.last
    }
    return true;
  6010418ccc:	52800020 	mov	w0, #0x1                   	// #1
}
  6010418cd0:	a8c47bfd 	ldp	x29, x30, [sp], #64
  6010418cd4:	d65f03c0 	ret

0000006010418cd8 <alloc_share_page_addr>:
/// @param task
/// @param nr_pages continuously map nr_pages
/// @return addr to be mapped, aligned by page
/// @todo optimize, and suppurt multiple pages
static uintptr_t alloc_share_page_addr(struct Thread* task, const int nr_pages)
{
  6010418cd8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  6010418cdc:	910003fd 	mov	x29, sp
  6010418ce0:	f9000fe0 	str	x0, [sp, #24]
  6010418ce4:	b90017e1 	str	w1, [sp, #20]
    uintptr_t vaddr = USER_IPC_SPACE_BASE;
  6010418ce8:	d2c00600 	mov	x0, #0x3000000000          	// #206158430208
  6010418cec:	f90017e0 	str	x0, [sp, #40]
    while (!check_pages_unmapped(task, vaddr, nr_pages)) {
  6010418cf0:	14000016 	b	6010418d48 <alloc_share_page_addr+0x70>
        // vaddr is destinate to be (2 * PAGE_SIZE) aligned
        vaddr += 2 * PAGE_SIZE;
  6010418cf4:	f94017e0 	ldr	x0, [sp, #40]
  6010418cf8:	91400800 	add	x0, x0, #0x2, lsl #12
  6010418cfc:	f90017e0 	str	x0, [sp, #40]
        assert(vaddr % PAGE_SIZE == 0);
  6010418d00:	f94017e0 	ldr	x0, [sp, #40]
  6010418d04:	92402c00 	and	x0, x0, #0xfff
  6010418d08:	f100001f 	cmp	x0, #0x0
  6010418d0c:	540001e0 	b.eq	6010418d48 <alloc_share_page_addr+0x70>  // b.none
  6010418d10:	52800a02 	mov	w2, #0x50                  	// #80
  6010418d14:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010418d18:	9112a001 	add	x1, x0, #0x4a8
  6010418d1c:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010418d20:	9107c000 	add	x0, x0, #0x1f0
  6010418d24:	97ffed15 	bl	6010414178 <printf_>
  6010418d28:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010418d2c:	91080001 	add	x1, x0, #0x200
  6010418d30:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010418d34:	91086000 	add	x0, x0, #0x218
  6010418d38:	97ffed10 	bl	6010414178 <printf_>
  6010418d3c:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010418d40:	9108a000 	add	x0, x0, #0x228
  6010418d44:	97ffd959 	bl	601040f2a8 <panic>
    while (!check_pages_unmapped(task, vaddr, nr_pages)) {
  6010418d48:	b94017e2 	ldr	w2, [sp, #20]
  6010418d4c:	f94017e1 	ldr	x1, [sp, #40]
  6010418d50:	f9400fe0 	ldr	x0, [sp, #24]
  6010418d54:	97ffffbe 	bl	6010418c4c <check_pages_unmapped>
  6010418d58:	12001c00 	and	w0, w0, #0xff
  6010418d5c:	52000000 	eor	w0, w0, #0x1
  6010418d60:	12001c00 	and	w0, w0, #0xff
  6010418d64:	7100001f 	cmp	w0, #0x0
  6010418d68:	54fffc61 	b.ne	6010418cf4 <alloc_share_page_addr+0x1c>  // b.any
    }

    // now that nr_pages size after vaddr is unmapped
    if (UNLIKELY(vaddr >= USER_IPC_SPACE_TOP)) {
  6010418d6c:	f94017e1 	ldr	x1, [sp, #40]
  6010418d70:	b2406fe0 	mov	x0, #0xfffffff             	// #268435455
  6010418d74:	f2c00600 	movk	x0, #0x30, lsl #32
  6010418d78:	eb00003f 	cmp	x1, x0
  6010418d7c:	1a9f97e0 	cset	w0, hi  // hi = pmore
  6010418d80:	12001c00 	and	w0, w0, #0xff
  6010418d84:	92401c00 	and	x0, x0, #0xff
  6010418d88:	f100001f 	cmp	x0, #0x0
  6010418d8c:	54000060 	b.eq	6010418d98 <alloc_share_page_addr+0xc0>  // b.none
        return (uintptr_t)NULL;
  6010418d90:	d2800000 	mov	x0, #0x0                   	// #0
  6010418d94:	14000002 	b	6010418d9c <alloc_share_page_addr+0xc4>
    }

    return vaddr;
  6010418d98:	f94017e0 	ldr	x0, [sp, #40]
}
  6010418d9c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  6010418da0:	d65f03c0 	ret

0000006010418da4 <map_task_share_page>:

static uintptr_t map_task_share_page(struct Thread* task, const uintptr_t paddr, const int nr_pages)
{
  6010418da4:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  6010418da8:	910003fd 	mov	x29, sp
  6010418dac:	f9000bf3 	str	x19, [sp, #16]
  6010418db0:	f9001fe0 	str	x0, [sp, #56]
  6010418db4:	f9001be1 	str	x1, [sp, #48]
  6010418db8:	b9002fe2 	str	w2, [sp, #44]
    /* get driver codes */
    struct DCacheDone* p_dcache_done = AchieveResource(&right_group.dcache_driver_tag);
  6010418dbc:	f000b940 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  6010418dc0:	912ae000 	add	x0, x0, #0xab8
  6010418dc4:	97fff473 	bl	6010415f90 <AchieveResource>
  6010418dc8:	f9002be0 	str	x0, [sp, #80]
    struct MmuCommonDone* p_mmu_driver = AchieveResource(&right_group.mmu_driver_tag);
  6010418dcc:	f000b940 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  6010418dd0:	912b0000 	add	x0, x0, #0xac0
  6010418dd4:	97fff46f 	bl	6010415f90 <AchieveResource>
  6010418dd8:	f90027e0 	str	x0, [sp, #72]

    // map double vaddr page to support uniform ring buffer r/w
    uintptr_t vaddr = (uintptr_t)NULL;
  6010418ddc:	f9002fff 	str	xzr, [sp, #88]
    if (task->memspace->massive_ipc_allocator != NULL) {
  6010418de0:	f9401fe0 	ldr	x0, [sp, #56]
  6010418de4:	f9402800 	ldr	x0, [x0, #80]
  6010418de8:	f9400c00 	ldr	x0, [x0, #24]
  6010418dec:	f100001f 	cmp	x0, #0x0
  6010418df0:	54000660 	b.eq	6010418ebc <map_task_share_page+0x118>  // b.none
        // alloc from ipc area buddy
        vaddr = (uintptr_t)KBuddyAlloc(task->memspace->massive_ipc_allocator, PAGE_SIZE * nr_pages * 2);
  6010418df4:	f9401fe0 	ldr	x0, [sp, #56]
  6010418df8:	f9402800 	ldr	x0, [x0, #80]
  6010418dfc:	f9400c02 	ldr	x2, [x0, #24]
  6010418e00:	b9402fe0 	ldr	w0, [sp, #44]
  6010418e04:	53134800 	lsl	w0, w0, #13
  6010418e08:	93407c00 	sxtw	x0, w0
  6010418e0c:	aa0003e1 	mov	x1, x0
  6010418e10:	aa0203e0 	mov	x0, x2
  6010418e14:	97fffc4e 	bl	6010417f4c <KBuddyAlloc>
  6010418e18:	f9002fe0 	str	x0, [sp, #88]
        if (vaddr == (uintptr_t)NULL) {
  6010418e1c:	f9402fe0 	ldr	x0, [sp, #88]
  6010418e20:	f100001f 	cmp	x0, #0x0
  6010418e24:	540001c1 	b.ne	6010418e5c <map_task_share_page+0xb8>  // b.any
            ERROR("Task %s drains all ipc area.\n", task->name);
  6010418e28:	52800ce2 	mov	w2, #0x67                  	// #103
  6010418e2c:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010418e30:	91130001 	add	x1, x0, #0x4c0
  6010418e34:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010418e38:	9107c000 	add	x0, x0, #0x1f0
  6010418e3c:	97ffeccf 	bl	6010414178 <printf_>
  6010418e40:	f9401fe0 	ldr	x0, [sp, #56]
  6010418e44:	aa0003e1 	mov	x1, x0
  6010418e48:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010418e4c:	9108c000 	add	x0, x0, #0x230
  6010418e50:	97ffecca 	bl	6010414178 <printf_>
            return (uintptr_t)NULL;
  6010418e54:	d2800000 	mov	x0, #0x0                   	// #0
  6010418e58:	140000b6 	b	6010419130 <map_task_share_page+0x38c>
        }

        // allocated ipc share vaddr must not been used
        assert(xizi_pager.address_translate(&task->memspace->pgdir, vaddr) == (uintptr_t)NULL);
  6010418e5c:	f0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010418e60:	f942b000 	ldr	x0, [x0, #1376]
  6010418e64:	f9401402 	ldr	x2, [x0, #40]
  6010418e68:	f9401fe0 	ldr	x0, [sp, #56]
  6010418e6c:	f9402800 	ldr	x0, [x0, #80]
  6010418e70:	f9402fe1 	ldr	x1, [sp, #88]
  6010418e74:	d63f0040 	blr	x2
  6010418e78:	f100001f 	cmp	x0, #0x0
  6010418e7c:	54000b40 	b.eq	6010418fe4 <map_task_share_page+0x240>  // b.none
  6010418e80:	52800d82 	mov	w2, #0x6c                  	// #108
  6010418e84:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010418e88:	91130001 	add	x1, x0, #0x4c0
  6010418e8c:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010418e90:	9107c000 	add	x0, x0, #0x1f0
  6010418e94:	97ffecb9 	bl	6010414178 <printf_>
  6010418e98:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010418e9c:	91094001 	add	x1, x0, #0x250
  6010418ea0:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010418ea4:	91086000 	add	x0, x0, #0x218
  6010418ea8:	97ffecb4 	bl	6010414178 <printf_>
  6010418eac:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010418eb0:	9108a000 	add	x0, x0, #0x228
  6010418eb4:	97ffd8fd 	bl	601040f2a8 <panic>
  6010418eb8:	1400004b 	b	6010418fe4 <map_task_share_page+0x240>
    } else {
        // simple allocation
        vaddr = alloc_share_page_addr(task, nr_pages * 2);
  6010418ebc:	b9402fe0 	ldr	w0, [sp, #44]
  6010418ec0:	0b000000 	add	w0, w0, w0
  6010418ec4:	2a0003e1 	mov	w1, w0
  6010418ec8:	f9401fe0 	ldr	x0, [sp, #56]
  6010418ecc:	97ffff83 	bl	6010418cd8 <alloc_share_page_addr>
  6010418ed0:	f9002fe0 	str	x0, [sp, #88]

        // time to use buddy
        if (vaddr >= USER_IPC_USE_ALLOCATOR_WATERMARK) {
  6010418ed4:	f9402fe1 	ldr	x1, [sp, #88]
  6010418ed8:	d29fffe0 	mov	x0, #0xffff                	// #65535
  6010418edc:	f2c00600 	movk	x0, #0x30, lsl #32
  6010418ee0:	eb00003f 	cmp	x1, x0
  6010418ee4:	54000809 	b.ls	6010418fe4 <map_task_share_page+0x240>  // b.plast
            task->memspace->massive_ipc_allocator = (struct KBuddy*)slab_alloc(&xizi_task_manager.task_buddy_allocator);
  6010418ee8:	f9401fe0 	ldr	x0, [sp, #56]
  6010418eec:	f9402813 	ldr	x19, [x0, #80]
  6010418ef0:	f0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010418ef4:	f942ec00 	ldr	x0, [x0, #1496]
  6010418ef8:	910b8000 	add	x0, x0, #0x2e0
  6010418efc:	97fffcfa 	bl	60104182e4 <slab_alloc>
  6010418f00:	f9000e60 	str	x0, [x19, #24]
            if (!task->memspace->massive_ipc_allocator) {
  6010418f04:	f9401fe0 	ldr	x0, [sp, #56]
  6010418f08:	f9402800 	ldr	x0, [x0, #80]
  6010418f0c:	f9400c00 	ldr	x0, [x0, #24]
  6010418f10:	f100001f 	cmp	x0, #0x0
  6010418f14:	54000181 	b.ne	6010418f44 <map_task_share_page+0x1a0>  // b.any
                ERROR("Alloc task buddy failed.\n");
  6010418f18:	52800ea2 	mov	w2, #0x75                  	// #117
  6010418f1c:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010418f20:	91130001 	add	x1, x0, #0x4c0
  6010418f24:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010418f28:	9107c000 	add	x0, x0, #0x1f0
  6010418f2c:	97ffec93 	bl	6010414178 <printf_>
  6010418f30:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010418f34:	910a8000 	add	x0, x0, #0x2a0
  6010418f38:	97ffec90 	bl	6010414178 <printf_>
                return (uintptr_t)NULL;
  6010418f3c:	d2800000 	mov	x0, #0x0                   	// #0
  6010418f40:	1400007c 	b	6010419130 <map_task_share_page+0x38c>
            }
            if (!KBuddyInit(task->memspace->massive_ipc_allocator, USER_IPC_USE_ALLOCATOR_WATERMARK, USER_IPC_SPACE_TOP)) {
  6010418f44:	f9401fe0 	ldr	x0, [sp, #56]
  6010418f48:	f9402800 	ldr	x0, [x0, #80]
  6010418f4c:	f9400c00 	ldr	x0, [x0, #24]
  6010418f50:	d2a20002 	mov	x2, #0x10000000            	// #268435456
  6010418f54:	f2c00602 	movk	x2, #0x30, lsl #32
  6010418f58:	d2a00021 	mov	x1, #0x10000               	// #65536
  6010418f5c:	f2c00601 	movk	x1, #0x30, lsl #32
  6010418f60:	97fffb5e 	bl	6010417cd8 <KBuddyInit>
  6010418f64:	12001c00 	and	w0, w0, #0xff
  6010418f68:	52000000 	eor	w0, w0, #0x1
  6010418f6c:	12001c00 	and	w0, w0, #0xff
  6010418f70:	7100001f 	cmp	w0, #0x0
  6010418f74:	540002e0 	b.eq	6010418fd0 <map_task_share_page+0x22c>  // b.none
                ERROR("Alloc task buddy failed.\n");
  6010418f78:	52800f22 	mov	w2, #0x79                  	// #121
  6010418f7c:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010418f80:	91130001 	add	x1, x0, #0x4c0
  6010418f84:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010418f88:	9107c000 	add	x0, x0, #0x1f0
  6010418f8c:	97ffec7b 	bl	6010414178 <printf_>
  6010418f90:	d0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010418f94:	910a8000 	add	x0, x0, #0x2a0
  6010418f98:	97ffec78 	bl	6010414178 <printf_>
                slab_free(&xizi_task_manager.task_buddy_allocator, task->memspace->massive_ipc_allocator);
  6010418f9c:	f9401fe0 	ldr	x0, [sp, #56]
  6010418fa0:	f9402800 	ldr	x0, [x0, #80]
  6010418fa4:	f9400c00 	ldr	x0, [x0, #24]
  6010418fa8:	aa0003e1 	mov	x1, x0
  6010418fac:	f0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010418fb0:	f942ec00 	ldr	x0, [x0, #1496]
  6010418fb4:	910b8000 	add	x0, x0, #0x2e0
  6010418fb8:	97fffdb2 	bl	6010418680 <slab_free>
                task->memspace->massive_ipc_allocator = NULL;
  6010418fbc:	f9401fe0 	ldr	x0, [sp, #56]
  6010418fc0:	f9402800 	ldr	x0, [x0, #80]
  6010418fc4:	f9000c1f 	str	xzr, [x0, #24]
                return (uintptr_t)NULL;
  6010418fc8:	d2800000 	mov	x0, #0x0                   	// #0
  6010418fcc:	14000059 	b	6010419130 <map_task_share_page+0x38c>
            }

            return map_task_share_page(task, paddr, nr_pages);
  6010418fd0:	b9402fe2 	ldr	w2, [sp, #44]
  6010418fd4:	f9401be1 	ldr	x1, [sp, #48]
  6010418fd8:	f9401fe0 	ldr	x0, [sp, #56]
  6010418fdc:	97ffff72 	bl	6010418da4 <map_task_share_page>
  6010418fe0:	14000054 	b	6010419130 <map_task_share_page+0x38c>
        }
    }

    if (UNLIKELY(vaddr == (uintptr_t)NULL)) {
  6010418fe4:	f9402fe0 	ldr	x0, [sp, #88]
  6010418fe8:	f100001f 	cmp	x0, #0x0
  6010418fec:	1a9f17e0 	cset	w0, eq  // eq = none
  6010418ff0:	12001c00 	and	w0, w0, #0xff
  6010418ff4:	92401c00 	and	x0, x0, #0xff
  6010418ff8:	f100001f 	cmp	x0, #0x0
  6010418ffc:	54000060 	b.eq	6010419008 <map_task_share_page+0x264>  // b.none
        return (uintptr_t)NULL;
  6010419000:	d2800000 	mov	x0, #0x0                   	// #0
  6010419004:	1400004b 	b	6010419130 <map_task_share_page+0x38c>
    }

    // map first area
    if (!xizi_pager.map_pages(task->memspace->pgdir.pd_addr, vaddr, paddr, nr_pages * PAGE_SIZE, false)) {
  6010419008:	d0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041900c:	f942b000 	ldr	x0, [x0, #1376]
  6010419010:	f9400805 	ldr	x5, [x0, #16]
  6010419014:	f9401fe0 	ldr	x0, [sp, #56]
  6010419018:	f9402800 	ldr	x0, [x0, #80]
  601041901c:	f9400006 	ldr	x6, [x0]
  6010419020:	b9402fe0 	ldr	w0, [sp, #44]
  6010419024:	53144c00 	lsl	w0, w0, #12
  6010419028:	52800004 	mov	w4, #0x0                   	// #0
  601041902c:	2a0003e3 	mov	w3, w0
  6010419030:	f9401be2 	ldr	x2, [sp, #48]
  6010419034:	f9402fe1 	ldr	x1, [sp, #88]
  6010419038:	aa0603e0 	mov	x0, x6
  601041903c:	d63f00a0 	blr	x5
  6010419040:	12001c00 	and	w0, w0, #0xff
  6010419044:	52000000 	eor	w0, w0, #0x1
  6010419048:	12001c00 	and	w0, w0, #0xff
  601041904c:	7100001f 	cmp	w0, #0x0
  6010419050:	54000060 	b.eq	601041905c <map_task_share_page+0x2b8>  // b.none
        return (uintptr_t)NULL;
  6010419054:	d2800000 	mov	x0, #0x0                   	// #0
  6010419058:	14000036 	b	6010419130 <map_task_share_page+0x38c>
    }

    // map second area
    if (!xizi_pager.map_pages(task->memspace->pgdir.pd_addr, vaddr + (nr_pages * PAGE_SIZE), paddr, nr_pages * PAGE_SIZE, false)) {
  601041905c:	d0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010419060:	f942b000 	ldr	x0, [x0, #1376]
  6010419064:	f9400805 	ldr	x5, [x0, #16]
  6010419068:	f9401fe0 	ldr	x0, [sp, #56]
  601041906c:	f9402800 	ldr	x0, [x0, #80]
  6010419070:	f9400006 	ldr	x6, [x0]
  6010419074:	b9402fe0 	ldr	w0, [sp, #44]
  6010419078:	53144c00 	lsl	w0, w0, #12
  601041907c:	93407c01 	sxtw	x1, w0
  6010419080:	f9402fe0 	ldr	x0, [sp, #88]
  6010419084:	8b000021 	add	x1, x1, x0
  6010419088:	b9402fe0 	ldr	w0, [sp, #44]
  601041908c:	53144c00 	lsl	w0, w0, #12
  6010419090:	52800004 	mov	w4, #0x0                   	// #0
  6010419094:	2a0003e3 	mov	w3, w0
  6010419098:	f9401be2 	ldr	x2, [sp, #48]
  601041909c:	aa0603e0 	mov	x0, x6
  60104190a0:	d63f00a0 	blr	x5
  60104190a4:	12001c00 	and	w0, w0, #0xff
  60104190a8:	52000000 	eor	w0, w0, #0x1
  60104190ac:	12001c00 	and	w0, w0, #0xff
  60104190b0:	7100001f 	cmp	w0, #0x0
  60104190b4:	540001e0 	b.eq	60104190f0 <map_task_share_page+0x34c>  // b.none
        xizi_pager.unmap_pages(task->memspace->pgdir.pd_addr, vaddr, nr_pages * PAGE_SIZE);
  60104190b8:	d0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  60104190bc:	f942b000 	ldr	x0, [x0, #1376]
  60104190c0:	f9400c03 	ldr	x3, [x0, #24]
  60104190c4:	f9401fe0 	ldr	x0, [sp, #56]
  60104190c8:	f9402800 	ldr	x0, [x0, #80]
  60104190cc:	f9400004 	ldr	x4, [x0]
  60104190d0:	b9402fe0 	ldr	w0, [sp, #44]
  60104190d4:	53144c00 	lsl	w0, w0, #12
  60104190d8:	2a0003e2 	mov	w2, w0
  60104190dc:	f9402fe1 	ldr	x1, [sp, #88]
  60104190e0:	aa0403e0 	mov	x0, x4
  60104190e4:	d63f0060 	blr	x3
        return (uintptr_t)NULL;
  60104190e8:	d2800000 	mov	x0, #0x0                   	// #0
  60104190ec:	14000011 	b	6010419130 <map_task_share_page+0x38c>
    }

    // flush tlb
    if (task == cur_cpu()->task) {
  60104190f0:	97fffebb 	bl	6010418bdc <cur_cpu>
  60104190f4:	f9400400 	ldr	x0, [x0, #8]
  60104190f8:	f9401fe1 	ldr	x1, [sp, #56]
  60104190fc:	eb00003f 	cmp	x1, x0
  6010419100:	54000161 	b.ne	601041912c <map_task_share_page+0x388>  // b.any
        p_mmu_driver->TlbFlush(vaddr, 2 * nr_pages * PAGE_SIZE);
  6010419104:	f94027e0 	ldr	x0, [sp, #72]
  6010419108:	f9401c02 	ldr	x2, [x0, #56]
  601041910c:	b9402fe0 	ldr	w0, [sp, #44]
  6010419110:	53134800 	lsl	w0, w0, #13
  6010419114:	2a0003e1 	mov	w1, w0
  6010419118:	f9402fe0 	ldr	x0, [sp, #88]
  601041911c:	d63f0040 	blr	x2
        /// @todo clean range rather than all
        p_dcache_done->invalidateall();
  6010419120:	f9402be0 	ldr	x0, [sp, #80]
  6010419124:	f9401c00 	ldr	x0, [x0, #56]
  6010419128:	d63f0000 	blr	x0
    }

    return vaddr;
  601041912c:	f9402fe0 	ldr	x0, [sp, #88]
}
  6010419130:	f9400bf3 	ldr	x19, [sp, #16]
  6010419134:	a8c67bfd 	ldp	x29, x30, [sp], #96
  6010419138:	d65f03c0 	ret

000000601041913c <task_map_pages>:

uintptr_t task_map_pages(struct Thread* task, const uintptr_t vaddr, const uintptr_t paddr, const int nr_pages, const int is_dev)
{
  601041913c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  6010419140:	910003fd 	mov	x29, sp
  6010419144:	f90017e0 	str	x0, [sp, #40]
  6010419148:	f90013e1 	str	x1, [sp, #32]
  601041914c:	f9000fe2 	str	x2, [sp, #24]
  6010419150:	b90017e3 	str	w3, [sp, #20]
  6010419154:	b90013e4 	str	w4, [sp, #16]
    /* get driver codes */
    struct DCacheDone* p_dcache_done = AchieveResource(&right_group.dcache_driver_tag);
  6010419158:	d000b940 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041915c:	912ae000 	add	x0, x0, #0xab8
  6010419160:	97fff38c 	bl	6010415f90 <AchieveResource>
  6010419164:	f90023e0 	str	x0, [sp, #64]
    struct MmuCommonDone* p_mmu_driver = AchieveResource(&right_group.mmu_driver_tag);
  6010419168:	d000b940 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041916c:	912b0000 	add	x0, x0, #0xac0
  6010419170:	97fff388 	bl	6010415f90 <AchieveResource>
  6010419174:	f9001fe0 	str	x0, [sp, #56]

    bool ret = false;
  6010419178:	39013fff 	strb	wzr, [sp, #79]
    if (is_dev) {
  601041917c:	b94013e0 	ldr	w0, [sp, #16]
  6010419180:	7100001f 	cmp	w0, #0x0
  6010419184:	54000220 	b.eq	60104191c8 <task_map_pages+0x8c>  // b.none
        ret = xizi_pager.map_pages(task->memspace->pgdir.pd_addr, vaddr, paddr, nr_pages * PAGE_SIZE, true);
  6010419188:	d0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041918c:	f942b000 	ldr	x0, [x0, #1376]
  6010419190:	f9400805 	ldr	x5, [x0, #16]
  6010419194:	f94017e0 	ldr	x0, [sp, #40]
  6010419198:	f9402800 	ldr	x0, [x0, #80]
  601041919c:	f9400006 	ldr	x6, [x0]
  60104191a0:	b94017e0 	ldr	w0, [sp, #20]
  60104191a4:	53144c00 	lsl	w0, w0, #12
  60104191a8:	52800024 	mov	w4, #0x1                   	// #1
  60104191ac:	2a0003e3 	mov	w3, w0
  60104191b0:	f9400fe2 	ldr	x2, [sp, #24]
  60104191b4:	f94013e1 	ldr	x1, [sp, #32]
  60104191b8:	aa0603e0 	mov	x0, x6
  60104191bc:	d63f00a0 	blr	x5
  60104191c0:	39013fe0 	strb	w0, [sp, #79]
  60104191c4:	14000010 	b	6010419204 <task_map_pages+0xc8>
    } else {
        ret = xizi_pager.map_pages(task->memspace->pgdir.pd_addr, vaddr, paddr, nr_pages * PAGE_SIZE, false);
  60104191c8:	d0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  60104191cc:	f942b000 	ldr	x0, [x0, #1376]
  60104191d0:	f9400805 	ldr	x5, [x0, #16]
  60104191d4:	f94017e0 	ldr	x0, [sp, #40]
  60104191d8:	f9402800 	ldr	x0, [x0, #80]
  60104191dc:	f9400006 	ldr	x6, [x0]
  60104191e0:	b94017e0 	ldr	w0, [sp, #20]
  60104191e4:	53144c00 	lsl	w0, w0, #12
  60104191e8:	52800004 	mov	w4, #0x0                   	// #0
  60104191ec:	2a0003e3 	mov	w3, w0
  60104191f0:	f9400fe2 	ldr	x2, [sp, #24]
  60104191f4:	f94013e1 	ldr	x1, [sp, #32]
  60104191f8:	aa0603e0 	mov	x0, x6
  60104191fc:	d63f00a0 	blr	x5
  6010419200:	39013fe0 	strb	w0, [sp, #79]
    }

    if (!ret) {
  6010419204:	39413fe0 	ldrb	w0, [sp, #79]
  6010419208:	52000000 	eor	w0, w0, #0x1
  601041920c:	12001c00 	and	w0, w0, #0xff
  6010419210:	7100001f 	cmp	w0, #0x0
  6010419214:	54000060 	b.eq	6010419220 <task_map_pages+0xe4>  // b.none
        return (uintptr_t)NULL;
  6010419218:	d2800000 	mov	x0, #0x0                   	// #0
  601041921c:	14000011 	b	6010419260 <task_map_pages+0x124>
    }

    if (task == cur_cpu()->task) {
  6010419220:	97fffe6f 	bl	6010418bdc <cur_cpu>
  6010419224:	f9400400 	ldr	x0, [x0, #8]
  6010419228:	f94017e1 	ldr	x1, [sp, #40]
  601041922c:	eb00003f 	cmp	x1, x0
  6010419230:	54000161 	b.ne	601041925c <task_map_pages+0x120>  // b.any
        p_mmu_driver->TlbFlush(vaddr, nr_pages * PAGE_SIZE);
  6010419234:	f9401fe0 	ldr	x0, [sp, #56]
  6010419238:	f9401c02 	ldr	x2, [x0, #56]
  601041923c:	b94017e0 	ldr	w0, [sp, #20]
  6010419240:	53144c00 	lsl	w0, w0, #12
  6010419244:	2a0003e1 	mov	w1, w0
  6010419248:	f94013e0 	ldr	x0, [sp, #32]
  601041924c:	d63f0040 	blr	x2
        /// @todo clean range rather than all
        p_dcache_done->invalidateall();
  6010419250:	f94023e0 	ldr	x0, [sp, #64]
  6010419254:	f9401c00 	ldr	x0, [x0, #56]
  6010419258:	d63f0000 	blr	x0
    }

    return vaddr;
  601041925c:	f94013e0 	ldr	x0, [sp, #32]
}
  6010419260:	a8c57bfd 	ldp	x29, x30, [sp], #80
  6010419264:	d65f03c0 	ret

0000006010419268 <unmap_task_share_pages>:

void unmap_task_share_pages(struct Thread* task, const uintptr_t task_vaddr, const int nr_pages)
{
  6010419268:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  601041926c:	910003fd 	mov	x29, sp
  6010419270:	f90017e0 	str	x0, [sp, #40]
  6010419274:	f90013e1 	str	x1, [sp, #32]
  6010419278:	b9001fe2 	str	w2, [sp, #28]
    // usages of unmap_task_share_pages must be correct
    assert(task_vaddr >= USER_IPC_SPACE_BASE && task_vaddr < USER_IPC_SPACE_TOP);
  601041927c:	f94013e1 	ldr	x1, [sp, #32]
  6010419280:	d2c00600 	mov	x0, #0x3000000000          	// #206158430208
  6010419284:	eb00003f 	cmp	x1, x0
  6010419288:	540000c3 	b.cc	60104192a0 <unmap_task_share_pages+0x38>  // b.lo, b.ul, b.last
  601041928c:	f94013e1 	ldr	x1, [sp, #32]
  6010419290:	b2406fe0 	mov	x0, #0xfffffff             	// #268435455
  6010419294:	f2c00600 	movk	x0, #0x30, lsl #32
  6010419298:	eb00003f 	cmp	x1, x0
  601041929c:	540001e9 	b.ls	60104192d8 <unmap_task_share_pages+0x70>  // b.plast
  60104192a0:	52801722 	mov	w2, #0xb9                  	// #185
  60104192a4:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  60104192a8:	91136001 	add	x1, x0, #0x4d8
  60104192ac:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  60104192b0:	9107c000 	add	x0, x0, #0x1f0
  60104192b4:	97ffebb1 	bl	6010414178 <printf_>
  60104192b8:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  60104192bc:	910b0001 	add	x1, x0, #0x2c0
  60104192c0:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  60104192c4:	91086000 	add	x0, x0, #0x218
  60104192c8:	97ffebac 	bl	6010414178 <printf_>
  60104192cc:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  60104192d0:	9108a000 	add	x0, x0, #0x228
  60104192d4:	97ffd7f5 	bl	601040f2a8 <panic>

    /* get driver codes */
    struct DCacheDone* p_dcache_done = AchieveResource(&right_group.dcache_driver_tag);
  60104192d8:	d000b940 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  60104192dc:	912ae000 	add	x0, x0, #0xab8
  60104192e0:	97fff32c 	bl	6010415f90 <AchieveResource>
  60104192e4:	f9001fe0 	str	x0, [sp, #56]
    struct MmuCommonDone* p_mmu_driver = AchieveResource(&right_group.mmu_driver_tag);
  60104192e8:	d000b940 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  60104192ec:	912b0000 	add	x0, x0, #0xac0
  60104192f0:	97fff328 	bl	6010415f90 <AchieveResource>
  60104192f4:	f9001be0 	str	x0, [sp, #48]

    // unmap must be correct
    assert(xizi_pager.unmap_pages(task->memspace->pgdir.pd_addr, task_vaddr, nr_pages * PAGE_SIZE));
  60104192f8:	d0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  60104192fc:	f942b000 	ldr	x0, [x0, #1376]
  6010419300:	f9400c03 	ldr	x3, [x0, #24]
  6010419304:	f94017e0 	ldr	x0, [sp, #40]
  6010419308:	f9402800 	ldr	x0, [x0, #80]
  601041930c:	f9400004 	ldr	x4, [x0]
  6010419310:	b9401fe0 	ldr	w0, [sp, #28]
  6010419314:	53144c00 	lsl	w0, w0, #12
  6010419318:	2a0003e2 	mov	w2, w0
  601041931c:	f94013e1 	ldr	x1, [sp, #32]
  6010419320:	aa0403e0 	mov	x0, x4
  6010419324:	d63f0060 	blr	x3
  6010419328:	12001c00 	and	w0, w0, #0xff
  601041932c:	52000000 	eor	w0, w0, #0x1
  6010419330:	12001c00 	and	w0, w0, #0xff
  6010419334:	7100001f 	cmp	w0, #0x0
  6010419338:	540001e0 	b.eq	6010419374 <unmap_task_share_pages+0x10c>  // b.none
  601041933c:	52801802 	mov	w2, #0xc0                  	// #192
  6010419340:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010419344:	91136001 	add	x1, x0, #0x4d8
  6010419348:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041934c:	9107c000 	add	x0, x0, #0x1f0
  6010419350:	97ffeb8a 	bl	6010414178 <printf_>
  6010419354:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010419358:	910c2001 	add	x1, x0, #0x308
  601041935c:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010419360:	91086000 	add	x0, x0, #0x218
  6010419364:	97ffeb85 	bl	6010414178 <printf_>
  6010419368:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041936c:	9108a000 	add	x0, x0, #0x228
  6010419370:	97ffd7ce 	bl	601040f2a8 <panic>
    assert(xizi_pager.unmap_pages(task->memspace->pgdir.pd_addr, task_vaddr + (nr_pages * PAGE_SIZE), nr_pages * PAGE_SIZE));
  6010419374:	d0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010419378:	f942b000 	ldr	x0, [x0, #1376]
  601041937c:	f9400c03 	ldr	x3, [x0, #24]
  6010419380:	f94017e0 	ldr	x0, [sp, #40]
  6010419384:	f9402800 	ldr	x0, [x0, #80]
  6010419388:	f9400004 	ldr	x4, [x0]
  601041938c:	b9401fe0 	ldr	w0, [sp, #28]
  6010419390:	53144c00 	lsl	w0, w0, #12
  6010419394:	93407c01 	sxtw	x1, w0
  6010419398:	f94013e0 	ldr	x0, [sp, #32]
  601041939c:	8b000021 	add	x1, x1, x0
  60104193a0:	b9401fe0 	ldr	w0, [sp, #28]
  60104193a4:	53144c00 	lsl	w0, w0, #12
  60104193a8:	2a0003e2 	mov	w2, w0
  60104193ac:	aa0403e0 	mov	x0, x4
  60104193b0:	d63f0060 	blr	x3
  60104193b4:	12001c00 	and	w0, w0, #0xff
  60104193b8:	52000000 	eor	w0, w0, #0x1
  60104193bc:	12001c00 	and	w0, w0, #0xff
  60104193c0:	7100001f 	cmp	w0, #0x0
  60104193c4:	540001e0 	b.eq	6010419400 <unmap_task_share_pages+0x198>  // b.none
  60104193c8:	52801822 	mov	w2, #0xc1                  	// #193
  60104193cc:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  60104193d0:	91136001 	add	x1, x0, #0x4d8
  60104193d4:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  60104193d8:	9107c000 	add	x0, x0, #0x1f0
  60104193dc:	97ffeb67 	bl	6010414178 <printf_>
  60104193e0:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  60104193e4:	910d8001 	add	x1, x0, #0x360
  60104193e8:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  60104193ec:	91086000 	add	x0, x0, #0x218
  60104193f0:	97ffeb62 	bl	6010414178 <printf_>
  60104193f4:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  60104193f8:	9108a000 	add	x0, x0, #0x228
  60104193fc:	97ffd7ab 	bl	601040f2a8 <panic>

    // retrieve virtual address
    if (task_vaddr >= USER_IPC_USE_ALLOCATOR_WATERMARK) {
  6010419400:	f94013e1 	ldr	x1, [sp, #32]
  6010419404:	d29fffe0 	mov	x0, #0xffff                	// #65535
  6010419408:	f2c00600 	movk	x0, #0x30, lsl #32
  601041940c:	eb00003f 	cmp	x1, x0
  6010419410:	540000c9 	b.ls	6010419428 <unmap_task_share_pages+0x1c0>  // b.plast
        KBuddyFree(task->memspace->massive_ipc_allocator, (void*)task_vaddr);
  6010419414:	f94017e0 	ldr	x0, [sp, #40]
  6010419418:	f9402800 	ldr	x0, [x0, #80]
  601041941c:	f9400c00 	ldr	x0, [x0, #24]
  6010419420:	f94013e1 	ldr	x1, [sp, #32]
  6010419424:	97fffaf4 	bl	6010417ff4 <KBuddyFree>
    }

    if (task == cur_cpu()->task) {
  6010419428:	97fffded 	bl	6010418bdc <cur_cpu>
  601041942c:	f9400400 	ldr	x0, [x0, #8]
  6010419430:	f94017e1 	ldr	x1, [sp, #40]
  6010419434:	eb00003f 	cmp	x1, x0
  6010419438:	54000161 	b.ne	6010419464 <unmap_task_share_pages+0x1fc>  // b.any
        p_mmu_driver->TlbFlush(task_vaddr, 2 * nr_pages * PAGE_SIZE);
  601041943c:	f9401be0 	ldr	x0, [sp, #48]
  6010419440:	f9401c02 	ldr	x2, [x0, #56]
  6010419444:	b9401fe0 	ldr	w0, [sp, #28]
  6010419448:	53134800 	lsl	w0, w0, #13
  601041944c:	2a0003e1 	mov	w1, w0
  6010419450:	f94013e0 	ldr	x0, [sp, #32]
  6010419454:	d63f0040 	blr	x2
        /// @todo clean range rather than all
        p_dcache_done->invalidateall();
  6010419458:	f9401fe0 	ldr	x0, [sp, #56]
  601041945c:	f9401c00 	ldr	x0, [x0, #56]
  6010419460:	d63f0000 	blr	x0
    }
}
  6010419464:	d503201f 	nop
  6010419468:	a8c47bfd 	ldp	x29, x30, [sp], #64
  601041946c:	d65f03c0 	ret

0000006010419470 <create_share_pages>:

static int next_session_id = 1;
struct session_backend* create_share_pages(struct Thread* client, struct Thread* server, const int capacity)
{
  6010419470:	a9b47bfd 	stp	x29, x30, [sp, #-192]!
  6010419474:	910003fd 	mov	x29, sp
  6010419478:	f90017e0 	str	x0, [sp, #40]
  601041947c:	f90013e1 	str	x1, [sp, #32]
  6010419480:	b9001fe2 	str	w2, [sp, #28]
    /* alloc session backend */
    struct session_backend* session_backend = (struct session_backend*)slab_alloc(SessionAllocator());
  6010419484:	97fffde1 	bl	6010418c08 <SessionAllocator>
  6010419488:	97fffb97 	bl	60104182e4 <slab_alloc>
  601041948c:	f9005fe0 	str	x0, [sp, #184]
    if (UNLIKELY(session_backend == NULL)) {
  6010419490:	f9405fe0 	ldr	x0, [sp, #184]
  6010419494:	f100001f 	cmp	x0, #0x0
  6010419498:	1a9f17e0 	cset	w0, eq  // eq = none
  601041949c:	12001c00 	and	w0, w0, #0xff
  60104194a0:	92401c00 	and	x0, x0, #0xff
  60104194a4:	f100001f 	cmp	x0, #0x0
  60104194a8:	54000060 	b.eq	60104194b4 <create_share_pages+0x44>  // b.none
        return NULL;
  60104194ac:	d2800000 	mov	x0, #0x0                   	// #0
  60104194b0:	140000e9 	b	6010419854 <create_share_pages+0x3e4>
    }

    int true_capacity = ALIGNUP(capacity, PAGE_SIZE);
  60104194b4:	b9401fe0 	ldr	w0, [sp, #28]
  60104194b8:	113ffc00 	add	w0, w0, #0xfff
  60104194bc:	12144c00 	and	w0, w0, #0xfffff000
  60104194c0:	b900b7e0 	str	w0, [sp, #180]
    int nr_pages = true_capacity / PAGE_SIZE;
  60104194c4:	b940b7e0 	ldr	w0, [sp, #180]
  60104194c8:	113ffc01 	add	w1, w0, #0xfff
  60104194cc:	7100001f 	cmp	w0, #0x0
  60104194d0:	1a80b020 	csel	w0, w1, w0, lt  // lt = tstop
  60104194d4:	130c7c00 	asr	w0, w0, #12
  60104194d8:	b900b3e0 	str	w0, [sp, #176]
    /* alloc free memory as share memory */
    uintptr_t kern_vaddr = (uintptr_t)kalloc(true_capacity);
  60104194dc:	b980b7e0 	ldrsw	x0, [sp, #180]
  60104194e0:	97fff457 	bl	601041663c <kalloc>
  60104194e4:	f90057e0 	str	x0, [sp, #168]
    if (UNLIKELY(kern_vaddr == (uintptr_t)NULL)) {
  60104194e8:	f94057e0 	ldr	x0, [sp, #168]
  60104194ec:	f100001f 	cmp	x0, #0x0
  60104194f0:	1a9f17e0 	cset	w0, eq  // eq = none
  60104194f4:	12001c00 	and	w0, w0, #0xff
  60104194f8:	92401c00 	and	x0, x0, #0xff
  60104194fc:	f100001f 	cmp	x0, #0x0
  6010419500:	540001e0 	b.eq	601041953c <create_share_pages+0xcc>  // b.none
        ERROR("No memory for session\n");
  6010419504:	52801ba2 	mov	w2, #0xdd                  	// #221
  6010419508:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041950c:	9113c001 	add	x1, x0, #0x4f0
  6010419510:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010419514:	9107c000 	add	x0, x0, #0x1f0
  6010419518:	97ffeb18 	bl	6010414178 <printf_>
  601041951c:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010419520:	910f6000 	add	x0, x0, #0x3d8
  6010419524:	97ffeb15 	bl	6010414178 <printf_>
        slab_free(SessionAllocator(), session_backend);
  6010419528:	97fffdb8 	bl	6010418c08 <SessionAllocator>
  601041952c:	f9405fe1 	ldr	x1, [sp, #184]
  6010419530:	97fffc54 	bl	6010418680 <slab_free>
        return NULL;
  6010419534:	d2800000 	mov	x0, #0x0                   	// #0
  6010419538:	140000c7 	b	6010419854 <create_share_pages+0x3e4>
    }

    assert(kern_vaddr % PAGE_SIZE == 0);
  601041953c:	f94057e0 	ldr	x0, [sp, #168]
  6010419540:	92402c00 	and	x0, x0, #0xfff
  6010419544:	f100001f 	cmp	x0, #0x0
  6010419548:	540001e0 	b.eq	6010419584 <create_share_pages+0x114>  // b.none
  601041954c:	52801c42 	mov	w2, #0xe2                  	// #226
  6010419550:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010419554:	9113c001 	add	x1, x0, #0x4f0
  6010419558:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041955c:	9107c000 	add	x0, x0, #0x1f0
  6010419560:	97ffeb06 	bl	6010414178 <printf_>
  6010419564:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010419568:	910fc001 	add	x1, x0, #0x3f0
  601041956c:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010419570:	91086000 	add	x0, x0, #0x218
  6010419574:	97ffeb01 	bl	6010414178 <printf_>
  6010419578:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041957c:	9108a000 	add	x0, x0, #0x228
  6010419580:	97ffd74a 	bl	601040f2a8 <panic>
    /* map client vspace */
    uintptr_t client_vaddr = map_task_share_page(client, V2P_WO(kern_vaddr), nr_pages);
  6010419584:	f94057e1 	ldr	x1, [sp, #168]
  6010419588:	d2dff400 	mov	x0, #0xffa000000000        	// #281062659850240
  601041958c:	f2ffffe0 	movk	x0, #0xffff, lsl #48
  6010419590:	8b000020 	add	x0, x1, x0
  6010419594:	b940b3e2 	ldr	w2, [sp, #176]
  6010419598:	aa0003e1 	mov	x1, x0
  601041959c:	f94017e0 	ldr	x0, [sp, #40]
  60104195a0:	97fffe01 	bl	6010418da4 <map_task_share_page>
  60104195a4:	f90053e0 	str	x0, [sp, #160]
    if (UNLIKELY(client_vaddr == (uintptr_t)NULL)) {
  60104195a8:	f94053e0 	ldr	x0, [sp, #160]
  60104195ac:	f100001f 	cmp	x0, #0x0
  60104195b0:	1a9f17e0 	cset	w0, eq  // eq = none
  60104195b4:	12001c00 	and	w0, w0, #0xff
  60104195b8:	92401c00 	and	x0, x0, #0xff
  60104195bc:	f100001f 	cmp	x0, #0x0
  60104195c0:	54000100 	b.eq	60104195e0 <create_share_pages+0x170>  // b.none
        kfree((char*)kern_vaddr);
  60104195c4:	f94057e0 	ldr	x0, [sp, #168]
  60104195c8:	97fff45e 	bl	6010416740 <kfree>
        slab_free(SessionAllocator(), session_backend);
  60104195cc:	97fffd8f 	bl	6010418c08 <SessionAllocator>
  60104195d0:	f9405fe1 	ldr	x1, [sp, #184]
  60104195d4:	97fffc2b 	bl	6010418680 <slab_free>
        return NULL;
  60104195d8:	d2800000 	mov	x0, #0x0                   	// #0
  60104195dc:	1400009e 	b	6010419854 <create_share_pages+0x3e4>
    }

    /* map server vspace */
    uintptr_t server_vaddr = map_task_share_page(server, V2P_WO(kern_vaddr), nr_pages);
  60104195e0:	f94057e1 	ldr	x1, [sp, #168]
  60104195e4:	d2dff400 	mov	x0, #0xffa000000000        	// #281062659850240
  60104195e8:	f2ffffe0 	movk	x0, #0xffff, lsl #48
  60104195ec:	8b000020 	add	x0, x1, x0
  60104195f0:	b940b3e2 	ldr	w2, [sp, #176]
  60104195f4:	aa0003e1 	mov	x1, x0
  60104195f8:	f94013e0 	ldr	x0, [sp, #32]
  60104195fc:	97fffdea 	bl	6010418da4 <map_task_share_page>
  6010419600:	f9004fe0 	str	x0, [sp, #152]
    if (UNLIKELY(server_vaddr == (uintptr_t)NULL)) {
  6010419604:	f9404fe0 	ldr	x0, [sp, #152]
  6010419608:	f100001f 	cmp	x0, #0x0
  601041960c:	1a9f17e0 	cset	w0, eq  // eq = none
  6010419610:	12001c00 	and	w0, w0, #0xff
  6010419614:	92401c00 	and	x0, x0, #0xff
  6010419618:	f100001f 	cmp	x0, #0x0
  601041961c:	54000180 	b.eq	601041964c <create_share_pages+0x1dc>  // b.none
        unmap_task_share_pages(client, client_vaddr, nr_pages);
  6010419620:	b940b3e2 	ldr	w2, [sp, #176]
  6010419624:	f94053e1 	ldr	x1, [sp, #160]
  6010419628:	f94017e0 	ldr	x0, [sp, #40]
  601041962c:	97ffff0f 	bl	6010419268 <unmap_task_share_pages>
        kfree((char*)kern_vaddr);
  6010419630:	f94057e0 	ldr	x0, [sp, #168]
  6010419634:	97fff443 	bl	6010416740 <kfree>
        slab_free(SessionAllocator(), session_backend);
  6010419638:	97fffd74 	bl	6010418c08 <SessionAllocator>
  601041963c:	f9405fe1 	ldr	x1, [sp, #184]
  6010419640:	97fffc10 	bl	6010418680 <slab_free>
        return NULL;
  6010419644:	d2800000 	mov	x0, #0x0                   	// #0
  6010419648:	14000083 	b	6010419854 <create_share_pages+0x3e4>
    }

    /* build session_backend */
    session_backend->session_id = next_session_id++;
  601041964c:	f0000040 	adrp	x0, 6010424000 <impure_data+0x210>
  6010419650:	913f6000 	add	x0, x0, #0xfd8
  6010419654:	b9400000 	ldr	w0, [x0]
  6010419658:	11000402 	add	w2, w0, #0x1
  601041965c:	f0000041 	adrp	x1, 6010424000 <impure_data+0x210>
  6010419660:	913f6021 	add	x1, x1, #0xfd8
  6010419664:	b9000022 	str	w2, [x1]
  6010419668:	f9405fe1 	ldr	x1, [sp, #184]
  601041966c:	b9004820 	str	w0, [x1, #72]
    session_backend->buf_kernel_addr = kern_vaddr;
  6010419670:	f9405fe0 	ldr	x0, [sp, #184]
  6010419674:	f94057e1 	ldr	x1, [sp, #168]
  6010419678:	f9003001 	str	x1, [x0, #96]
    session_backend->nr_pages = nr_pages;
  601041967c:	f9405fe0 	ldr	x0, [sp, #184]
  6010419680:	b940b3e1 	ldr	w1, [sp, #176]
  6010419684:	b9004c01 	str	w1, [x0, #76]
    session_backend->client = client;
  6010419688:	f9405fe0 	ldr	x0, [sp, #184]
  601041968c:	f94017e1 	ldr	x1, [sp, #40]
  6010419690:	f9002801 	str	x1, [x0, #80]
    session_backend->server = server;
  6010419694:	f9405fe0 	ldr	x0, [sp, #184]
  6010419698:	f94013e1 	ldr	x1, [sp, #32]
  601041969c:	f9002c01 	str	x1, [x0, #88]
    // init client side session struct
    session_backend->client_side.buf_addr = client_vaddr;
  60104196a0:	f9405fe0 	ldr	x0, [sp, #184]
  60104196a4:	f94053e1 	ldr	x1, [sp, #160]
  60104196a8:	f9001c01 	str	x1, [x0, #56]
    session_backend->client_side.capacity = true_capacity;
  60104196ac:	f9405fe0 	ldr	x0, [sp, #184]
  60104196b0:	b940b7e1 	ldr	w1, [sp, #180]
  60104196b4:	b9004001 	str	w1, [x0, #64]
    session_backend->client_side.closed = false;
  60104196b8:	f9405fe0 	ldr	x0, [sp, #184]
  60104196bc:	3901101f 	strb	wzr, [x0, #68]
    doubleListNodeInit(&session_backend->client_side.node);
  60104196c0:	f9405fe0 	ldr	x0, [sp, #184]
  60104196c4:	9100a000 	add	x0, x0, #0x28
  60104196c8:	f9001fe0 	str	x0, [sp, #56]
    list->next = list;
  60104196cc:	f9401fe0 	ldr	x0, [sp, #56]
  60104196d0:	f9401fe1 	ldr	x1, [sp, #56]
  60104196d4:	f9000001 	str	x1, [x0]
    list->prev = list;
  60104196d8:	f9401fe0 	ldr	x0, [sp, #56]
  60104196dc:	f9401fe1 	ldr	x1, [sp, #56]
  60104196e0:	f9000401 	str	x1, [x0, #8]
}
  60104196e4:	d503201f 	nop
    doubleListAddOnBack(&session_backend->client_side.node, &client->cli_sess_listhead);
  60104196e8:	f9405fe0 	ldr	x0, [sp, #184]
  60104196ec:	9100a001 	add	x1, x0, #0x28
  60104196f0:	f94017e0 	ldr	x0, [sp, #40]
  60104196f4:	9101a000 	add	x0, x0, #0x68
  60104196f8:	f90033e1 	str	x1, [sp, #96]
  60104196fc:	f9002fe0 	str	x0, [sp, #88]
    _double_list_add(new_node, head->prev, head);
  6010419700:	f9402fe0 	ldr	x0, [sp, #88]
  6010419704:	f9400400 	ldr	x0, [x0, #8]
  6010419708:	f94033e1 	ldr	x1, [sp, #96]
  601041970c:	f9002be1 	str	x1, [sp, #80]
  6010419710:	f90027e0 	str	x0, [sp, #72]
  6010419714:	f9402fe0 	ldr	x0, [sp, #88]
  6010419718:	f90023e0 	str	x0, [sp, #64]
    next->prev = new_node;
  601041971c:	f94023e0 	ldr	x0, [sp, #64]
  6010419720:	f9402be1 	ldr	x1, [sp, #80]
  6010419724:	f9000401 	str	x1, [x0, #8]
    new_node->next = next;
  6010419728:	f9402be0 	ldr	x0, [sp, #80]
  601041972c:	f94023e1 	ldr	x1, [sp, #64]
  6010419730:	f9000001 	str	x1, [x0]
    new_node->prev = prev;
  6010419734:	f9402be0 	ldr	x0, [sp, #80]
  6010419738:	f94027e1 	ldr	x1, [sp, #72]
  601041973c:	f9000401 	str	x1, [x0, #8]
    prev->next = new_node;
  6010419740:	f94027e0 	ldr	x0, [sp, #72]
  6010419744:	f9402be1 	ldr	x1, [sp, #80]
  6010419748:	f9000001 	str	x1, [x0]
}
  601041974c:	d503201f 	nop
}
  6010419750:	d503201f 	nop
    // init server side session struct
    session_backend->server_side.buf_addr = server_vaddr;
  6010419754:	f9405fe0 	ldr	x0, [sp, #184]
  6010419758:	f9404fe1 	ldr	x1, [sp, #152]
  601041975c:	f9000801 	str	x1, [x0, #16]
    session_backend->server_side.capacity = true_capacity;
  6010419760:	f9405fe0 	ldr	x0, [sp, #184]
  6010419764:	b940b7e1 	ldr	w1, [sp, #180]
  6010419768:	b9001801 	str	w1, [x0, #24]
    session_backend->server_side.head = 0;
  601041976c:	f9405fe0 	ldr	x0, [sp, #184]
  6010419770:	b9001c1f 	str	wzr, [x0, #28]
    session_backend->server_side.tail = 0;
  6010419774:	f9405fe0 	ldr	x0, [sp, #184]
  6010419778:	b900201f 	str	wzr, [x0, #32]
    session_backend->server_side.closed = false;
  601041977c:	f9405fe0 	ldr	x0, [sp, #184]
  6010419780:	3900901f 	strb	wzr, [x0, #36]
    doubleListNodeInit(&session_backend->server_side.node);
  6010419784:	f9405fe0 	ldr	x0, [sp, #184]
  6010419788:	f90037e0 	str	x0, [sp, #104]
    list->next = list;
  601041978c:	f94037e0 	ldr	x0, [sp, #104]
  6010419790:	f94037e1 	ldr	x1, [sp, #104]
  6010419794:	f9000001 	str	x1, [x0]
    list->prev = list;
  6010419798:	f94037e0 	ldr	x0, [sp, #104]
  601041979c:	f94037e1 	ldr	x1, [sp, #104]
  60104197a0:	f9000401 	str	x1, [x0, #8]
}
  60104197a4:	d503201f 	nop
    doubleListAddOnBack(&session_backend->server_side.node, &server->svr_sess_listhead);
  60104197a8:	f9405fe1 	ldr	x1, [sp, #184]
  60104197ac:	f94013e0 	ldr	x0, [sp, #32]
  60104197b0:	9101e000 	add	x0, x0, #0x78
  60104197b4:	f9004be1 	str	x1, [sp, #144]
  60104197b8:	f90047e0 	str	x0, [sp, #136]
    _double_list_add(new_node, head->prev, head);
  60104197bc:	f94047e0 	ldr	x0, [sp, #136]
  60104197c0:	f9400400 	ldr	x0, [x0, #8]
  60104197c4:	f9404be1 	ldr	x1, [sp, #144]
  60104197c8:	f90043e1 	str	x1, [sp, #128]
  60104197cc:	f9003fe0 	str	x0, [sp, #120]
  60104197d0:	f94047e0 	ldr	x0, [sp, #136]
  60104197d4:	f9003be0 	str	x0, [sp, #112]
    next->prev = new_node;
  60104197d8:	f9403be0 	ldr	x0, [sp, #112]
  60104197dc:	f94043e1 	ldr	x1, [sp, #128]
  60104197e0:	f9000401 	str	x1, [x0, #8]
    new_node->next = next;
  60104197e4:	f94043e0 	ldr	x0, [sp, #128]
  60104197e8:	f9403be1 	ldr	x1, [sp, #112]
  60104197ec:	f9000001 	str	x1, [x0]
    new_node->prev = prev;
  60104197f0:	f94043e0 	ldr	x0, [sp, #128]
  60104197f4:	f9403fe1 	ldr	x1, [sp, #120]
  60104197f8:	f9000401 	str	x1, [x0, #8]
    prev->next = new_node;
  60104197fc:	f9403fe0 	ldr	x0, [sp, #120]
  6010419800:	f94043e1 	ldr	x1, [sp, #128]
  6010419804:	f9000001 	str	x1, [x0]
}
  6010419808:	d503201f 	nop
}
  601041980c:	d503201f 	nop

    server->memspace->mem_size += true_capacity;
  6010419810:	f94013e0 	ldr	x0, [sp, #32]
  6010419814:	f9402800 	ldr	x0, [x0, #80]
  6010419818:	f9400802 	ldr	x2, [x0, #16]
  601041981c:	b980b7e1 	ldrsw	x1, [sp, #180]
  6010419820:	f94013e0 	ldr	x0, [sp, #32]
  6010419824:	f9402800 	ldr	x0, [x0, #80]
  6010419828:	8b010041 	add	x1, x2, x1
  601041982c:	f9000801 	str	x1, [x0, #16]
    client->memspace->mem_size += true_capacity;
  6010419830:	f94017e0 	ldr	x0, [sp, #40]
  6010419834:	f9402800 	ldr	x0, [x0, #80]
  6010419838:	f9400802 	ldr	x2, [x0, #16]
  601041983c:	b980b7e1 	ldrsw	x1, [sp, #180]
  6010419840:	f94017e0 	ldr	x0, [sp, #40]
  6010419844:	f9402800 	ldr	x0, [x0, #80]
  6010419848:	8b010041 	add	x1, x2, x1
  601041984c:	f9000801 	str	x1, [x0, #16]

    return session_backend;
  6010419850:	f9405fe0 	ldr	x0, [sp, #184]
}
  6010419854:	a8cc7bfd 	ldp	x29, x30, [sp], #192
  6010419858:	d65f03c0 	ret

000000601041985c <delete_share_pages>:
 *  1. task exits, close its side of sessions and found opposite side is also closed.
 *  2. server poll found a closed client side session.
 *  3. client close a session, and found server side has closed.
 */
int delete_share_pages(struct session_backend* session_backend)
{
  601041985c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  6010419860:	910003fd 	mov	x29, sp
  6010419864:	f9000fe0 	str	x0, [sp, #24]
    if (session_backend == NULL) {
  6010419868:	f9400fe0 	ldr	x0, [sp, #24]
  601041986c:	f100001f 	cmp	x0, #0x0
  6010419870:	54000061 	b.ne	601041987c <delete_share_pages+0x20>  // b.any
        return -1;
  6010419874:	12800000 	mov	w0, #0xffffffff            	// #-1
  6010419878:	140000b3 	b	6010419b44 <delete_share_pages+0x2e8>
    }

    assert(session_backend->server_side.closed || session_backend->client_side.closed);
  601041987c:	f9400fe0 	ldr	x0, [sp, #24]
  6010419880:	39409000 	ldrb	w0, [x0, #36]
  6010419884:	52000000 	eor	w0, w0, #0x1
  6010419888:	12001c00 	and	w0, w0, #0xff
  601041988c:	7100001f 	cmp	w0, #0x0
  6010419890:	540002a0 	b.eq	60104198e4 <delete_share_pages+0x88>  // b.none
  6010419894:	f9400fe0 	ldr	x0, [sp, #24]
  6010419898:	39411000 	ldrb	w0, [x0, #68]
  601041989c:	52000000 	eor	w0, w0, #0x1
  60104198a0:	12001c00 	and	w0, w0, #0xff
  60104198a4:	7100001f 	cmp	w0, #0x0
  60104198a8:	540001e0 	b.eq	60104198e4 <delete_share_pages+0x88>  // b.none
  60104198ac:	52802362 	mov	w2, #0x11b                 	// #283
  60104198b0:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  60104198b4:	91142001 	add	x1, x0, #0x508
  60104198b8:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  60104198bc:	9107c000 	add	x0, x0, #0x1f0
  60104198c0:	97ffea2e 	bl	6010414178 <printf_>
  60104198c4:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  60104198c8:	91104001 	add	x1, x0, #0x410
  60104198cc:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  60104198d0:	91086000 	add	x0, x0, #0x218
  60104198d4:	97ffea29 	bl	6010414178 <printf_>
  60104198d8:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  60104198dc:	9108a000 	add	x0, x0, #0x228
  60104198e0:	97ffd672 	bl	601040f2a8 <panic>

    /* unmap share pages */
    // close ssesion in server's perspective
    if (session_backend->server_side.closed && session_backend->server != NULL) {
  60104198e4:	f9400fe0 	ldr	x0, [sp, #24]
  60104198e8:	39409000 	ldrb	w0, [x0, #36]
  60104198ec:	7100001f 	cmp	w0, #0x0
  60104198f0:	540006c0 	b.eq	60104199c8 <delete_share_pages+0x16c>  // b.none
  60104198f4:	f9400fe0 	ldr	x0, [sp, #24]
  60104198f8:	f9402c00 	ldr	x0, [x0, #88]
  60104198fc:	f100001f 	cmp	x0, #0x0
  6010419900:	54000640 	b.eq	60104199c8 <delete_share_pages+0x16c>  // b.none
        xizi_share_page_manager.unmap_task_share_pages(session_backend->server, session_backend->server_side.buf_addr, session_backend->nr_pages);
  6010419904:	d0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010419908:	f942e400 	ldr	x0, [x0, #1480]
  601041990c:	f9400403 	ldr	x3, [x0, #8]
  6010419910:	f9400fe0 	ldr	x0, [sp, #24]
  6010419914:	f9402c04 	ldr	x4, [x0, #88]
  6010419918:	f9400fe0 	ldr	x0, [sp, #24]
  601041991c:	f9400801 	ldr	x1, [x0, #16]
  6010419920:	f9400fe0 	ldr	x0, [sp, #24]
  6010419924:	b9404c00 	ldr	w0, [x0, #76]
  6010419928:	2a0003e2 	mov	w2, w0
  601041992c:	aa0403e0 	mov	x0, x4
  6010419930:	d63f0060 	blr	x3
        doubleListDel(&session_backend->server_side.node);
  6010419934:	f9400fe0 	ldr	x0, [sp, #24]
  6010419938:	f90027e0 	str	x0, [sp, #72]
    _double_list_del(entry->prev, entry->next);
  601041993c:	f94027e0 	ldr	x0, [sp, #72]
  6010419940:	f9400401 	ldr	x1, [x0, #8]
  6010419944:	f94027e0 	ldr	x0, [sp, #72]
  6010419948:	f9400000 	ldr	x0, [x0]
  601041994c:	f90023e1 	str	x1, [sp, #64]
  6010419950:	f9001fe0 	str	x0, [sp, #56]
    next->prev = prev;
  6010419954:	f9401fe0 	ldr	x0, [sp, #56]
  6010419958:	f94023e1 	ldr	x1, [sp, #64]
  601041995c:	f9000401 	str	x1, [x0, #8]
    prev->next = next;
  6010419960:	f94023e0 	ldr	x0, [sp, #64]
  6010419964:	f9401fe1 	ldr	x1, [sp, #56]
  6010419968:	f9000001 	str	x1, [x0]
}
  601041996c:	d503201f 	nop
    entry->next = entry;
  6010419970:	f94027e0 	ldr	x0, [sp, #72]
  6010419974:	f94027e1 	ldr	x1, [sp, #72]
  6010419978:	f9000001 	str	x1, [x0]
    entry->prev = entry;
  601041997c:	f94027e0 	ldr	x0, [sp, #72]
  6010419980:	f94027e1 	ldr	x1, [sp, #72]
  6010419984:	f9000401 	str	x1, [x0, #8]
}
  6010419988:	d503201f 	nop
        session_backend->server->memspace->mem_size -= session_backend->nr_pages * PAGE_SIZE;
  601041998c:	f9400fe0 	ldr	x0, [sp, #24]
  6010419990:	f9402c00 	ldr	x0, [x0, #88]
  6010419994:	f9402800 	ldr	x0, [x0, #80]
  6010419998:	f9400802 	ldr	x2, [x0, #16]
  601041999c:	f9400fe0 	ldr	x0, [sp, #24]
  60104199a0:	b9404c00 	ldr	w0, [x0, #76]
  60104199a4:	53144c00 	lsl	w0, w0, #12
  60104199a8:	93407c01 	sxtw	x1, w0
  60104199ac:	f9400fe0 	ldr	x0, [sp, #24]
  60104199b0:	f9402c00 	ldr	x0, [x0, #88]
  60104199b4:	f9402800 	ldr	x0, [x0, #80]
  60104199b8:	cb010041 	sub	x1, x2, x1
  60104199bc:	f9000801 	str	x1, [x0, #16]
        session_backend->server = NULL;
  60104199c0:	f9400fe0 	ldr	x0, [sp, #24]
  60104199c4:	f9002c1f 	str	xzr, [x0, #88]
    }

    // close ssesion in client's perspective
    if (session_backend->client_side.closed && session_backend->client != NULL) {
  60104199c8:	f9400fe0 	ldr	x0, [sp, #24]
  60104199cc:	39411000 	ldrb	w0, [x0, #68]
  60104199d0:	7100001f 	cmp	w0, #0x0
  60104199d4:	540006e0 	b.eq	6010419ab0 <delete_share_pages+0x254>  // b.none
  60104199d8:	f9400fe0 	ldr	x0, [sp, #24]
  60104199dc:	f9402800 	ldr	x0, [x0, #80]
  60104199e0:	f100001f 	cmp	x0, #0x0
  60104199e4:	54000660 	b.eq	6010419ab0 <delete_share_pages+0x254>  // b.none
        xizi_share_page_manager.unmap_task_share_pages(session_backend->client, session_backend->client_side.buf_addr, session_backend->nr_pages);
  60104199e8:	d0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  60104199ec:	f942e400 	ldr	x0, [x0, #1480]
  60104199f0:	f9400403 	ldr	x3, [x0, #8]
  60104199f4:	f9400fe0 	ldr	x0, [sp, #24]
  60104199f8:	f9402804 	ldr	x4, [x0, #80]
  60104199fc:	f9400fe0 	ldr	x0, [sp, #24]
  6010419a00:	f9401c01 	ldr	x1, [x0, #56]
  6010419a04:	f9400fe0 	ldr	x0, [sp, #24]
  6010419a08:	b9404c00 	ldr	w0, [x0, #76]
  6010419a0c:	2a0003e2 	mov	w2, w0
  6010419a10:	aa0403e0 	mov	x0, x4
  6010419a14:	d63f0060 	blr	x3
        doubleListDel(&session_backend->client_side.node);
  6010419a18:	f9400fe0 	ldr	x0, [sp, #24]
  6010419a1c:	9100a000 	add	x0, x0, #0x28
  6010419a20:	f9001be0 	str	x0, [sp, #48]
    _double_list_del(entry->prev, entry->next);
  6010419a24:	f9401be0 	ldr	x0, [sp, #48]
  6010419a28:	f9400401 	ldr	x1, [x0, #8]
  6010419a2c:	f9401be0 	ldr	x0, [sp, #48]
  6010419a30:	f9400000 	ldr	x0, [x0]
  6010419a34:	f90017e1 	str	x1, [sp, #40]
  6010419a38:	f90013e0 	str	x0, [sp, #32]
    next->prev = prev;
  6010419a3c:	f94013e0 	ldr	x0, [sp, #32]
  6010419a40:	f94017e1 	ldr	x1, [sp, #40]
  6010419a44:	f9000401 	str	x1, [x0, #8]
    prev->next = next;
  6010419a48:	f94017e0 	ldr	x0, [sp, #40]
  6010419a4c:	f94013e1 	ldr	x1, [sp, #32]
  6010419a50:	f9000001 	str	x1, [x0]
}
  6010419a54:	d503201f 	nop
    entry->next = entry;
  6010419a58:	f9401be0 	ldr	x0, [sp, #48]
  6010419a5c:	f9401be1 	ldr	x1, [sp, #48]
  6010419a60:	f9000001 	str	x1, [x0]
    entry->prev = entry;
  6010419a64:	f9401be0 	ldr	x0, [sp, #48]
  6010419a68:	f9401be1 	ldr	x1, [sp, #48]
  6010419a6c:	f9000401 	str	x1, [x0, #8]
}
  6010419a70:	d503201f 	nop
        session_backend->client->memspace->mem_size -= session_backend->nr_pages * PAGE_SIZE;
  6010419a74:	f9400fe0 	ldr	x0, [sp, #24]
  6010419a78:	f9402800 	ldr	x0, [x0, #80]
  6010419a7c:	f9402800 	ldr	x0, [x0, #80]
  6010419a80:	f9400802 	ldr	x2, [x0, #16]
  6010419a84:	f9400fe0 	ldr	x0, [sp, #24]
  6010419a88:	b9404c00 	ldr	w0, [x0, #76]
  6010419a8c:	53144c00 	lsl	w0, w0, #12
  6010419a90:	93407c01 	sxtw	x1, w0
  6010419a94:	f9400fe0 	ldr	x0, [sp, #24]
  6010419a98:	f9402800 	ldr	x0, [x0, #80]
  6010419a9c:	f9402800 	ldr	x0, [x0, #80]
  6010419aa0:	cb010041 	sub	x1, x2, x1
  6010419aa4:	f9000801 	str	x1, [x0, #16]
        session_backend->client = NULL;
  6010419aa8:	f9400fe0 	ldr	x0, [sp, #24]
  6010419aac:	f900281f 	str	xzr, [x0, #80]
    }

    /* free seesion backend */
    if (session_backend->server_side.closed && session_backend->client_side.closed) {
  6010419ab0:	f9400fe0 	ldr	x0, [sp, #24]
  6010419ab4:	39409000 	ldrb	w0, [x0, #36]
  6010419ab8:	7100001f 	cmp	w0, #0x0
  6010419abc:	54000420 	b.eq	6010419b40 <delete_share_pages+0x2e4>  // b.none
  6010419ac0:	f9400fe0 	ldr	x0, [sp, #24]
  6010419ac4:	39411000 	ldrb	w0, [x0, #68]
  6010419ac8:	7100001f 	cmp	w0, #0x0
  6010419acc:	540003a0 	b.eq	6010419b40 <delete_share_pages+0x2e4>  // b.none
        assert(session_backend->client == NULL && session_backend->server == NULL);
  6010419ad0:	f9400fe0 	ldr	x0, [sp, #24]
  6010419ad4:	f9402800 	ldr	x0, [x0, #80]
  6010419ad8:	f100001f 	cmp	x0, #0x0
  6010419adc:	540000a1 	b.ne	6010419af0 <delete_share_pages+0x294>  // b.any
  6010419ae0:	f9400fe0 	ldr	x0, [sp, #24]
  6010419ae4:	f9402c00 	ldr	x0, [x0, #88]
  6010419ae8:	f100001f 	cmp	x0, #0x0
  6010419aec:	540001e0 	b.eq	6010419b28 <delete_share_pages+0x2cc>  // b.none
  6010419af0:	52802602 	mov	w2, #0x130                 	// #304
  6010419af4:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010419af8:	91142001 	add	x1, x0, #0x508
  6010419afc:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010419b00:	9107c000 	add	x0, x0, #0x1f0
  6010419b04:	97ffe99d 	bl	6010414178 <printf_>
  6010419b08:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010419b0c:	91118001 	add	x1, x0, #0x460
  6010419b10:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010419b14:	91086000 	add	x0, x0, #0x218
  6010419b18:	97ffe998 	bl	6010414178 <printf_>
  6010419b1c:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010419b20:	9108a000 	add	x0, x0, #0x228
  6010419b24:	97ffd5e1 	bl	601040f2a8 <panic>
        kfree((void*)session_backend->buf_kernel_addr);
  6010419b28:	f9400fe0 	ldr	x0, [sp, #24]
  6010419b2c:	f9403000 	ldr	x0, [x0, #96]
  6010419b30:	97fff304 	bl	6010416740 <kfree>
        slab_free(SessionAllocator(), (void*)session_backend);
  6010419b34:	97fffc35 	bl	6010418c08 <SessionAllocator>
  6010419b38:	f9400fe1 	ldr	x1, [sp, #24]
  6010419b3c:	97fffad1 	bl	6010418680 <slab_free>
    }

    return 0;
  6010419b40:	52800000 	mov	w0, #0x0                   	// #0
}
  6010419b44:	a8c57bfd 	ldp	x29, x30, [sp], #80
  6010419b48:	d65f03c0 	ret

0000006010419b4c <module_share_page_init>:
    .delete_share_pages = delete_share_pages,
    .task_map_pages = task_map_pages,
};

int module_share_page_init(struct SharePageRightGroup* _right_group)
{
  6010419b4c:	d10043ff 	sub	sp, sp, #0x10
  6010419b50:	f90007e0 	str	x0, [sp, #8]
    /* assign rights to share page module */
    right_group = *_right_group;
  6010419b54:	d000b940 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  6010419b58:	912ae002 	add	x2, x0, #0xab8
  6010419b5c:	f94007e0 	ldr	x0, [sp, #8]
  6010419b60:	a9400400 	ldp	x0, x1, [x0]
  6010419b64:	a9000440 	stp	x0, x1, [x2]
    return 0;
  6010419b68:	52800000 	mov	w0, #0x0                   	// #0
  6010419b6c:	910043ff 	add	sp, sp, #0x10
  6010419b70:	d65f03c0 	ret

0000006010419b74 <cur_cpuid>:
{
  6010419b74:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  6010419b78:	910003fd 	mov	x29, sp
    return cpu_get_current();
  6010419b7c:	97ffd2c7 	bl	601040e698 <cpu_get_current>
}
  6010419b80:	a8c17bfd 	ldp	x29, x30, [sp], #16
  6010419b84:	d65f03c0 	ret

0000006010419b88 <cur_cpu>:
{
  6010419b88:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  6010419b8c:	910003fd 	mov	x29, sp
    return &global_cpus[cur_cpuid()];
  6010419b90:	97fffff9 	bl	6010419b74 <cur_cpuid>
  6010419b94:	93407c01 	sxtw	x1, w0
  6010419b98:	d2800300 	mov	x0, #0x18                  	// #24
  6010419b9c:	9b007c21 	mul	x1, x1, x0
  6010419ba0:	d0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010419ba4:	f942f400 	ldr	x0, [x0, #1512]
  6010419ba8:	8b000020 	add	x0, x1, x0
}
  6010419bac:	a8c17bfd 	ldp	x29, x30, [sp], #16
  6010419bb0:	d65f03c0 	ret

0000006010419bb4 <intr_distributer_init>:
#include "task.h"

static struct IrqDispatcherRightGroup right_group;
static struct XiziTrapDriver* p_intr_driver = NULL;
bool intr_distributer_init(struct IrqDispatcherRightGroup* _right_group)
{
  6010419bb4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  6010419bb8:	910003fd 	mov	x29, sp
  6010419bbc:	f9000fe0 	str	x0, [sp, #24]
    right_group = *_right_group;
  6010419bc0:	d000b940 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  6010419bc4:	912c2000 	add	x0, x0, #0xb08
  6010419bc8:	f9400fe1 	ldr	x1, [sp, #24]
  6010419bcc:	f9400021 	ldr	x1, [x1]
  6010419bd0:	f9000001 	str	x1, [x0]
    p_intr_driver = AchieveResource(&_right_group->intr_driver_tag);
  6010419bd4:	f9400fe0 	ldr	x0, [sp, #24]
  6010419bd8:	97fff0ee 	bl	6010415f90 <AchieveResource>
  6010419bdc:	aa0003e1 	mov	x1, x0
  6010419be0:	d000b940 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  6010419be4:	912c4000 	add	x0, x0, #0xb10
  6010419be8:	f9000001 	str	x1, [x0]
    return p_intr_driver != NULL;
  6010419bec:	d000b940 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  6010419bf0:	912c4000 	add	x0, x0, #0xb10
  6010419bf4:	f9400000 	ldr	x0, [x0]
  6010419bf8:	f100001f 	cmp	x0, #0x0
  6010419bfc:	1a9f07e0 	cset	w0, ne  // ne = any
  6010419c00:	12001c00 	and	w0, w0, #0xff
}
  6010419c04:	a8c27bfd 	ldp	x29, x30, [sp], #32
  6010419c08:	d65f03c0 	ret

0000006010419c0c <default_interrupt_routine>:

void default_interrupt_routine(int irq)
{
  6010419c0c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  6010419c10:	910003fd 	mov	x29, sp
  6010419c14:	b9001fe0 	str	w0, [sp, #28]
    /* default handler borrow the rights of dispatcher */
    ///@todo Support other cores. (currently assume that CPU_0 is used)
    ERROR("Interrupt %d has been asserted\n", irq);
  6010419c18:	528006a2 	mov	w2, #0x35                  	// #53
  6010419c1c:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010419c20:	91176001 	add	x1, x0, #0x5d8
  6010419c24:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010419c28:	91148000 	add	x0, x0, #0x520
  6010419c2c:	97ffe953 	bl	6010414178 <printf_>
  6010419c30:	b9401fe1 	ldr	w1, [sp, #28]
  6010419c34:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010419c38:	9114c000 	add	x0, x0, #0x530
  6010419c3c:	97ffe94f 	bl	6010414178 <printf_>
}
  6010419c40:	d503201f 	nop
  6010419c44:	a8c27bfd 	ldp	x29, x30, [sp], #32
  6010419c48:	d65f03c0 	ret

0000006010419c4c <intr_irq_dispatch>:

extern void context_switch(struct context**, struct context*);
void intr_irq_dispatch(struct trapframe* tf)
{
  6010419c4c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  6010419c50:	910003fd 	mov	x29, sp
  6010419c54:	f9000bf3 	str	x19, [sp, #16]
  6010419c58:	f90017e0 	str	x0, [sp, #40]
}

__attribute__((always_inline)) inline void xizi_enter_kernel()
{
    /// @warning trampoline is responsible for closing interrupt
    spinlock_lock(&whole_kernel_lock);
  6010419c5c:	d0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010419c60:	f9429000 	ldr	x0, [x0, #1312]
  6010419c64:	97ffdde6 	bl	60104113fc <spinlock_lock>
}
  6010419c68:	d503201f 	nop
    assert(p_intr_driver != NULL);
  6010419c6c:	d000b940 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  6010419c70:	912c4000 	add	x0, x0, #0xb10
  6010419c74:	f9400000 	ldr	x0, [x0]
  6010419c78:	f100001f 	cmp	x0, #0x0
  6010419c7c:	540001e1 	b.ne	6010419cb8 <intr_irq_dispatch+0x6c>  // b.any
  6010419c80:	528007c2 	mov	w2, #0x3e                  	// #62
  6010419c84:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010419c88:	9117e001 	add	x1, x0, #0x5f8
  6010419c8c:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010419c90:	91148000 	add	x0, x0, #0x520
  6010419c94:	97ffe939 	bl	6010414178 <printf_>
  6010419c98:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010419c9c:	91154001 	add	x1, x0, #0x550
  6010419ca0:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010419ca4:	9115a000 	add	x0, x0, #0x568
  6010419ca8:	97ffe934 	bl	6010414178 <printf_>
  6010419cac:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010419cb0:	9115e000 	add	x0, x0, #0x578
  6010419cb4:	97ffd57d 	bl	601040f2a8 <panic>
    uintptr_t int_info = 0;
  6010419cb8:	f90027ff 	str	xzr, [sp, #72]
    if ((int_info = p_intr_driver->hw_before_irq()) == 0) {
  6010419cbc:	d000b940 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  6010419cc0:	912c4000 	add	x0, x0, #0xb10
  6010419cc4:	f9400000 	ldr	x0, [x0]
  6010419cc8:	f9445800 	ldr	x0, [x0, #2224]
  6010419ccc:	d63f0000 	blr	x0
  6010419cd0:	2a0003e0 	mov	w0, w0
  6010419cd4:	f90027e0 	str	x0, [sp, #72]
  6010419cd8:	f94027e0 	ldr	x0, [sp, #72]
  6010419cdc:	f100001f 	cmp	x0, #0x0
  6010419ce0:	54000e20 	b.eq	6010419ea4 <intr_irq_dispatch+0x258>  // b.none
    struct Thread* current_task = cur_cpu()->task;
  6010419ce4:	97ffffa9 	bl	6010419b88 <cur_cpu>
  6010419ce8:	f9400400 	ldr	x0, [x0, #8]
  6010419cec:	f90023e0 	str	x0, [sp, #64]
    assert(current_task != NULL);
  6010419cf0:	f94023e0 	ldr	x0, [sp, #64]
  6010419cf4:	f100001f 	cmp	x0, #0x0
  6010419cf8:	540001e1 	b.ne	6010419d34 <intr_irq_dispatch+0xe8>  // b.any
  6010419cfc:	528008a2 	mov	w2, #0x45                  	// #69
  6010419d00:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010419d04:	9117e001 	add	x1, x0, #0x5f8
  6010419d08:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010419d0c:	91148000 	add	x0, x0, #0x520
  6010419d10:	97ffe91a 	bl	6010414178 <printf_>
  6010419d14:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010419d18:	91160001 	add	x1, x0, #0x580
  6010419d1c:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010419d20:	9115a000 	add	x0, x0, #0x568
  6010419d24:	97ffe915 	bl	6010414178 <printf_>
  6010419d28:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010419d2c:	9115e000 	add	x0, x0, #0x578
  6010419d30:	97ffd55e 	bl	601040f2a8 <panic>
    current_task->thread_context.trapframe = tf;
  6010419d34:	f94023e0 	ldr	x0, [sp, #64]
  6010419d38:	f94017e1 	ldr	x1, [sp, #40]
  6010419d3c:	f9002401 	str	x1, [x0, #72]
    int cpu = cur_cpuid();
  6010419d40:	97ffff8d 	bl	6010419b74 <cur_cpuid>
  6010419d44:	b9003fe0 	str	w0, [sp, #60]
    assert(cpu >= 0 && cpu < NR_CPU);
  6010419d48:	b9403fe0 	ldr	w0, [sp, #60]
  6010419d4c:	7100001f 	cmp	w0, #0x0
  6010419d50:	5400008b 	b.lt	6010419d60 <intr_irq_dispatch+0x114>  // b.tstop
  6010419d54:	b9403fe0 	ldr	w0, [sp, #60]
  6010419d58:	7100001f 	cmp	w0, #0x0
  6010419d5c:	540001ed 	b.le	6010419d98 <intr_irq_dispatch+0x14c>
  6010419d60:	52800922 	mov	w2, #0x49                  	// #73
  6010419d64:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010419d68:	9117e001 	add	x1, x0, #0x5f8
  6010419d6c:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010419d70:	91148000 	add	x0, x0, #0x520
  6010419d74:	97ffe901 	bl	6010414178 <printf_>
  6010419d78:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010419d7c:	91166001 	add	x1, x0, #0x598
  6010419d80:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010419d84:	9115a000 	add	x0, x0, #0x568
  6010419d88:	97ffe8fc 	bl	6010414178 <printf_>
  6010419d8c:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010419d90:	9115e000 	add	x0, x0, #0x578
  6010419d94:	97ffd545 	bl	601040f2a8 <panic>
    unsigned irq = p_intr_driver->hw_cur_int_num(int_info);
  6010419d98:	d000b940 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  6010419d9c:	912c4000 	add	x0, x0, #0xb10
  6010419da0:	f9400000 	ldr	x0, [x0]
  6010419da4:	f9445c01 	ldr	x1, [x0, #2232]
  6010419da8:	f94027e0 	ldr	x0, [sp, #72]
  6010419dac:	d63f0020 	blr	x1
  6010419db0:	b9003be0 	str	w0, [sp, #56]
    irq_handler_t isr = p_intr_driver->sw_irqtbl[irq].handler;
  6010419db4:	d000b940 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  6010419db8:	912c4000 	add	x0, x0, #0xb10
  6010419dbc:	f9400000 	ldr	x0, [x0]
  6010419dc0:	b9403be1 	ldr	w1, [sp, #56]
  6010419dc4:	f8617800 	ldr	x0, [x0, x1, lsl #3]
  6010419dc8:	f9001be0 	str	x0, [sp, #48]
    if (isr != NULL) {
  6010419dcc:	f9401be0 	ldr	x0, [sp, #48]
  6010419dd0:	f100001f 	cmp	x0, #0x0
  6010419dd4:	540000e0 	b.eq	6010419df0 <intr_irq_dispatch+0x1a4>  // b.none
        isr(irq, tf, NULL);
  6010419dd8:	b9403be0 	ldr	w0, [sp, #56]
  6010419ddc:	f9401be3 	ldr	x3, [sp, #48]
  6010419de0:	d2800002 	mov	x2, #0x0                   	// #0
  6010419de4:	f94017e1 	ldr	x1, [sp, #40]
  6010419de8:	d63f0060 	blr	x3
  6010419dec:	14000003 	b	6010419df8 <intr_irq_dispatch+0x1ac>
        default_interrupt_routine(irq);
  6010419df0:	b9403be0 	ldr	w0, [sp, #56]
  6010419df4:	97ffff86 	bl	6010419c0c <default_interrupt_routine>
    p_intr_driver->hw_after_irq(int_info);
  6010419df8:	d000b940 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  6010419dfc:	912c4000 	add	x0, x0, #0xb10
  6010419e00:	f9400000 	ldr	x0, [x0]
  6010419e04:	f9446001 	ldr	x1, [x0, #2240]
  6010419e08:	f94027e0 	ldr	x0, [sp, #72]
  6010419e0c:	d63f0020 	blr	x1
    if (cur_cpu()->task == NULL || current_task->state != RUNNING) {
  6010419e10:	97ffff5e 	bl	6010419b88 <cur_cpu>
  6010419e14:	f9400400 	ldr	x0, [x0, #8]
  6010419e18:	f100001f 	cmp	x0, #0x0
  6010419e1c:	540000a0 	b.eq	6010419e30 <intr_irq_dispatch+0x1e4>  // b.none
  6010419e20:	f94023e0 	ldr	x0, [sp, #64]
  6010419e24:	b940a800 	ldr	w0, [x0, #168]
  6010419e28:	7100081f 	cmp	w0, #0x2
  6010419e2c:	54000140 	b.eq	6010419e54 <intr_irq_dispatch+0x208>  // b.none
        cur_cpu()->task = NULL;
  6010419e30:	97ffff56 	bl	6010419b88 <cur_cpu>
  6010419e34:	f900041f 	str	xzr, [x0, #8]
        context_switch(&current_task->thread_context.context, cur_cpu()->scheduler);
  6010419e38:	f94023e0 	ldr	x0, [sp, #64]
  6010419e3c:	91010013 	add	x19, x0, #0x40
  6010419e40:	97ffff52 	bl	6010419b88 <cur_cpu>
  6010419e44:	f9400800 	ldr	x0, [x0, #16]
  6010419e48:	aa0003e1 	mov	x1, x0
  6010419e4c:	aa1303e0 	mov	x0, x19
  6010419e50:	97ffd217 	bl	601040e6ac <context_switch>
    assert(current_task == cur_cpu()->task);
  6010419e54:	97ffff4d 	bl	6010419b88 <cur_cpu>
  6010419e58:	f9400400 	ldr	x0, [x0, #8]
  6010419e5c:	f94023e1 	ldr	x1, [sp, #64]
  6010419e60:	eb00003f 	cmp	x1, x0
  6010419e64:	54000240 	b.eq	6010419eac <intr_irq_dispatch+0x260>  // b.none
  6010419e68:	52800b62 	mov	w2, #0x5b                  	// #91
  6010419e6c:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010419e70:	9117e001 	add	x1, x0, #0x5f8
  6010419e74:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010419e78:	91148000 	add	x0, x0, #0x520
  6010419e7c:	97ffe8bf 	bl	6010414178 <printf_>
  6010419e80:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010419e84:	9116e001 	add	x1, x0, #0x5b8
  6010419e88:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010419e8c:	9115a000 	add	x0, x0, #0x568
  6010419e90:	97ffe8ba 	bl	6010414178 <printf_>
  6010419e94:	b0000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  6010419e98:	9115e000 	add	x0, x0, #0x578
  6010419e9c:	97ffd503 	bl	601040f2a8 <panic>
  6010419ea0:	14000004 	b	6010419eb0 <intr_irq_dispatch+0x264>
        goto intr_leave_interrupt;
  6010419ea4:	d503201f 	nop
  6010419ea8:	14000002 	b	6010419eb0 <intr_irq_dispatch+0x264>
intr_leave_interrupt:
  6010419eac:	d503201f 	nop
}

__attribute__((always_inline)) inline void xizi_leave_kernel()
{
    /// @warning trampoline is responsible for eabling interrupt by using user's state register
    spinlock_unlock(&whole_kernel_lock);
  6010419eb0:	d0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010419eb4:	f9429000 	ldr	x0, [x0, #1312]
  6010419eb8:	97ffdda5 	bl	601041154c <spinlock_unlock>
}
  6010419ebc:	d503201f 	nop
}
  6010419ec0:	d503201f 	nop
  6010419ec4:	f9400bf3 	ldr	x19, [sp, #16]
  6010419ec8:	a8c57bfd 	ldp	x29, x30, [sp], #80
  6010419ecc:	d65f03c0 	ret

0000006010419ed0 <xizi_enter_kernel>:
{
  6010419ed0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  6010419ed4:	910003fd 	mov	x29, sp
    spinlock_lock(&whole_kernel_lock);
  6010419ed8:	d0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010419edc:	f9429000 	ldr	x0, [x0, #1312]
  6010419ee0:	97ffdd47 	bl	60104113fc <spinlock_lock>
}
  6010419ee4:	d503201f 	nop
  6010419ee8:	a8c17bfd 	ldp	x29, x30, [sp], #16
  6010419eec:	d65f03c0 	ret

0000006010419ef0 <xizi_try_enter_kernel>:
{
  6010419ef0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  6010419ef4:	910003fd 	mov	x29, sp
    if (spinlock_try_lock(&whole_kernel_lock)) {
  6010419ef8:	d0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010419efc:	f9429000 	ldr	x0, [x0, #1312]
  6010419f00:	97ffddcb 	bl	601041162c <spinlock_try_lock>
  6010419f04:	12001c00 	and	w0, w0, #0xff
  6010419f08:	7100001f 	cmp	w0, #0x0
  6010419f0c:	54000060 	b.eq	6010419f18 <xizi_try_enter_kernel+0x28>  // b.none
        return true;
  6010419f10:	52800020 	mov	w0, #0x1                   	// #1
  6010419f14:	14000002 	b	6010419f1c <xizi_try_enter_kernel+0x2c>
    return false;
  6010419f18:	52800000 	mov	w0, #0x0                   	// #0
}
  6010419f1c:	a8c17bfd 	ldp	x29, x30, [sp], #16
  6010419f20:	d65f03c0 	ret

0000006010419f24 <xizi_leave_kernel>:
{
  6010419f24:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  6010419f28:	910003fd 	mov	x29, sp
    spinlock_unlock(&whole_kernel_lock);
  6010419f2c:	d0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010419f30:	f9429000 	ldr	x0, [x0, #1312]
  6010419f34:	97ffdd86 	bl	601041154c <spinlock_unlock>
}
  6010419f38:	d503201f 	nop
  6010419f3c:	a8c17bfd 	ldp	x29, x30, [sp], #16
  6010419f40:	d65f03c0 	ret

0000006010419f44 <cur_cpuid>:
{
  6010419f44:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  6010419f48:	910003fd 	mov	x29, sp
    return cpu_get_current();
  6010419f4c:	97ffd1d3 	bl	601040e698 <cpu_get_current>
}
  6010419f50:	a8c17bfd 	ldp	x29, x30, [sp], #16
  6010419f54:	d65f03c0 	ret

0000006010419f58 <cur_cpu>:
{
  6010419f58:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  6010419f5c:	910003fd 	mov	x29, sp
    return &global_cpus[cur_cpuid()];
  6010419f60:	97fffff9 	bl	6010419f44 <cur_cpuid>
  6010419f64:	93407c01 	sxtw	x1, w0
  6010419f68:	d2800300 	mov	x0, #0x18                  	// #24
  6010419f6c:	9b007c21 	mul	x1, x1, x0
  6010419f70:	d0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010419f74:	f942f400 	ldr	x0, [x0, #1512]
  6010419f78:	8b000020 	add	x0, x1, x0
}
  6010419f7c:	a8c17bfd 	ldp	x29, x30, [sp], #16
  6010419f80:	d65f03c0 	ret

0000006010419f84 <clock_intr_handler_init>:

static struct TraceTag clock_driver_tag;
static struct XiziClockDriver* p_clock_driver = NULL;

bool clock_intr_handler_init(struct TraceTag* p_clock_driver_tag)
{
  6010419f84:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  6010419f88:	910003fd 	mov	x29, sp
  6010419f8c:	f9000fe0 	str	x0, [sp, #24]
    clock_driver_tag = *p_clock_driver_tag;
  6010419f90:	d000b940 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  6010419f94:	912c8000 	add	x0, x0, #0xb20
  6010419f98:	f9400fe1 	ldr	x1, [sp, #24]
  6010419f9c:	f9400021 	ldr	x1, [x1]
  6010419fa0:	f9000001 	str	x1, [x0]
    p_clock_driver = AchieveResource(p_clock_driver_tag);
  6010419fa4:	f9400fe0 	ldr	x0, [sp, #24]
  6010419fa8:	97ffeffa 	bl	6010415f90 <AchieveResource>
  6010419fac:	aa0003e1 	mov	x1, x0
  6010419fb0:	d000b940 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  6010419fb4:	912ca000 	add	x0, x0, #0xb28
  6010419fb8:	f9000001 	str	x1, [x0]
    return p_clock_driver != NULL;
  6010419fbc:	d000b940 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  6010419fc0:	912ca000 	add	x0, x0, #0xb28
  6010419fc4:	f9400000 	ldr	x0, [x0]
  6010419fc8:	f100001f 	cmp	x0, #0x0
  6010419fcc:	1a9f07e0 	cset	w0, ne  // ne = any
  6010419fd0:	12001c00 	and	w0, w0, #0xff
}
  6010419fd4:	a8c27bfd 	ldp	x29, x30, [sp], #32
  6010419fd8:	d65f03c0 	ret

0000006010419fdc <xizi_clock_handler>:

uint64_t global_tick = 0;
int xizi_clock_handler(int irq, void* tf, void* arg)
{
  6010419fdc:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  6010419fe0:	910003fd 	mov	x29, sp
  6010419fe4:	b9002fe0 	str	w0, [sp, #44]
  6010419fe8:	f90013e1 	str	x1, [sp, #32]
  6010419fec:	f9000fe2 	str	x2, [sp, #24]
    /* handle clock interrupt using driver */
    if (p_clock_driver->is_timer_expired()) {
  6010419ff0:	d000b940 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  6010419ff4:	912ca000 	add	x0, x0, #0xb28
  6010419ff8:	f9400000 	ldr	x0, [x0]
  6010419ffc:	f9400800 	ldr	x0, [x0, #16]
  601041a000:	d63f0000 	blr	x0
  601041a004:	12001c00 	and	w0, w0, #0xff
  601041a008:	7100001f 	cmp	w0, #0x0
  601041a00c:	540004e0 	b.eq	601041a0a8 <xizi_clock_handler+0xcc>  // b.none
        p_clock_driver->clear_clock_intr();
  601041a010:	b000b940 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041a014:	912ca000 	add	x0, x0, #0xb28
  601041a018:	f9400000 	ldr	x0, [x0]
  601041a01c:	f9400c00 	ldr	x0, [x0, #24]
  601041a020:	d63f0000 	blr	x0
        global_tick++;
  601041a024:	b0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041a028:	f942a400 	ldr	x0, [x0, #1352]
  601041a02c:	f9400000 	ldr	x0, [x0]
  601041a030:	91000401 	add	x1, x0, #0x1
  601041a034:	b0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041a038:	f942a400 	ldr	x0, [x0, #1352]
  601041a03c:	f9000001 	str	x1, [x0]
        struct Thread* current_task = cur_cpu()->task;
  601041a040:	97ffffc6 	bl	6010419f58 <cur_cpu>
  601041a044:	f9400400 	ldr	x0, [x0, #8]
  601041a048:	f9001fe0 	str	x0, [sp, #56]
        if (current_task) {
  601041a04c:	f9401fe0 	ldr	x0, [sp, #56]
  601041a050:	f100001f 	cmp	x0, #0x0
  601041a054:	540002a0 	b.eq	601041a0a8 <xizi_clock_handler+0xcc>  // b.none
            current_task->remain_tick--;
  601041a058:	f9401fe0 	ldr	x0, [sp, #56]
  601041a05c:	b940b000 	ldr	w0, [x0, #176]
  601041a060:	51000401 	sub	w1, w0, #0x1
  601041a064:	f9401fe0 	ldr	x0, [sp, #56]
  601041a068:	b900b001 	str	w1, [x0, #176]
            current_task->maxium_tick--;
  601041a06c:	f9401fe0 	ldr	x0, [sp, #56]
  601041a070:	b940b400 	ldr	w0, [x0, #180]
  601041a074:	51000401 	sub	w1, w0, #0x1
  601041a078:	f9401fe0 	ldr	x0, [sp, #56]
  601041a07c:	b900b401 	str	w1, [x0, #180]
            if (current_task->remain_tick == 0) {
  601041a080:	f9401fe0 	ldr	x0, [sp, #56]
  601041a084:	b940b000 	ldr	w0, [x0, #176]
  601041a088:	7100001f 	cmp	w0, #0x0
  601041a08c:	540000e1 	b.ne	601041a0a8 <xizi_clock_handler+0xcc>  // b.any
                xizi_task_manager.task_yield_noschedule(current_task, false);
  601041a090:	b0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041a094:	f942ec00 	ldr	x0, [x0, #1496]
  601041a098:	f941a802 	ldr	x2, [x0, #848]
  601041a09c:	52800001 	mov	w1, #0x0                   	// #0
  601041a0a0:	f9401fe0 	ldr	x0, [sp, #56]
  601041a0a4:	d63f0040 	blr	x2
            }
        }
    }
    return 0;
  601041a0a8:	52800000 	mov	w0, #0x0                   	// #0
  601041a0ac:	a8c47bfd 	ldp	x29, x30, [sp], #64
  601041a0b0:	d65f03c0 	ret

000000601041a0b4 <cur_cpuid>:
{
  601041a0b4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601041a0b8:	910003fd 	mov	x29, sp
    return cpu_get_current();
  601041a0bc:	97ffd177 	bl	601040e698 <cpu_get_current>
}
  601041a0c0:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601041a0c4:	d65f03c0 	ret

000000601041a0c8 <cur_cpu>:
{
  601041a0c8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601041a0cc:	910003fd 	mov	x29, sp
    return &global_cpus[cur_cpuid()];
  601041a0d0:	97fffff9 	bl	601041a0b4 <cur_cpuid>
  601041a0d4:	93407c01 	sxtw	x1, w0
  601041a0d8:	d2800300 	mov	x0, #0x18                  	// #24
  601041a0dc:	9b007c21 	mul	x1, x1, x0
  601041a0e0:	b0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041a0e4:	f942f400 	ldr	x0, [x0, #1512]
  601041a0e8:	8b000020 	add	x0, x1, x0
}
  601041a0ec:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601041a0f0:	d65f03c0 	ret

000000601041a0f4 <swi_distributer_init>:

static struct SwiDispatcherRightGroup right_group;
static struct XiziTrapDriver* p_intr_driver = NULL;

bool swi_distributer_init(struct SwiDispatcherRightGroup* _right_group)
{
  601041a0f4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  601041a0f8:	910003fd 	mov	x29, sp
  601041a0fc:	f9000fe0 	str	x0, [sp, #24]
    right_group = *_right_group;
  601041a100:	b000b940 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041a104:	912cc000 	add	x0, x0, #0xb30
  601041a108:	f9400fe1 	ldr	x1, [sp, #24]
  601041a10c:	f9400021 	ldr	x1, [x1]
  601041a110:	f9000001 	str	x1, [x0]
    p_intr_driver = AchieveResource(&_right_group->intr_driver_tag);
  601041a114:	f9400fe0 	ldr	x0, [sp, #24]
  601041a118:	97ffef9e 	bl	6010415f90 <AchieveResource>
  601041a11c:	aa0003e1 	mov	x1, x0
  601041a120:	b000b940 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041a124:	912ce000 	add	x0, x0, #0xb38
  601041a128:	f9000001 	str	x1, [x0]
    return p_intr_driver != NULL;
  601041a12c:	b000b940 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041a130:	912ce000 	add	x0, x0, #0xb38
  601041a134:	f9400000 	ldr	x0, [x0]
  601041a138:	f100001f 	cmp	x0, #0x0
  601041a13c:	1a9f07e0 	cset	w0, ne  // ne = any
  601041a140:	12001c00 	and	w0, w0, #0xff
}
  601041a144:	a8c27bfd 	ldp	x29, x30, [sp], #32
  601041a148:	d65f03c0 	ret

000000601041a14c <software_irq_dispatch>:

extern void context_switch(struct context**, struct context*);
void software_irq_dispatch(struct trapframe* tf)
{
  601041a14c:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
  601041a150:	910003fd 	mov	x29, sp
  601041a154:	f9000bf3 	str	x19, [sp, #16]
  601041a158:	f90017e0 	str	x0, [sp, #40]
    xizi_enter_kernel();
  601041a15c:	97ffff5d 	bl	6010419ed0 <xizi_enter_kernel>
    assert(p_intr_driver != NULL);
  601041a160:	b000b940 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041a164:	912ce000 	add	x0, x0, #0xb38
  601041a168:	f9400000 	ldr	x0, [x0]
  601041a16c:	f100001f 	cmp	x0, #0x0
  601041a170:	540001e1 	b.ne	601041a1ac <software_irq_dispatch+0x60>  // b.any
  601041a174:	52800682 	mov	w2, #0x34                  	// #52
  601041a178:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a17c:	911a0001 	add	x1, x0, #0x680
  601041a180:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a184:	91184000 	add	x0, x0, #0x610
  601041a188:	97ffe7fc 	bl	6010414178 <printf_>
  601041a18c:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a190:	91188001 	add	x1, x0, #0x620
  601041a194:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a198:	9118e000 	add	x0, x0, #0x638
  601041a19c:	97ffe7f7 	bl	6010414178 <printf_>
  601041a1a0:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a1a4:	91192000 	add	x0, x0, #0x648
  601041a1a8:	97ffd440 	bl	601040f2a8 <panic>

    // get current task
    struct Thread* cur_task = cur_cpu()->task;
  601041a1ac:	97ffffc7 	bl	601041a0c8 <cur_cpu>
  601041a1b0:	f9400400 	ldr	x0, [x0, #8]
  601041a1b4:	f90037e0 	str	x0, [sp, #104]
    /// @todo: Handle dead task

    int syscall_num = -1;
  601041a1b8:	12800000 	mov	w0, #0xffffffff            	// #-1
  601041a1bc:	b9003fe0 	str	w0, [sp, #60]
    if (cur_task && cur_task->state != DEAD) {
  601041a1c0:	f94037e0 	ldr	x0, [sp, #104]
  601041a1c4:	f100001f 	cmp	x0, #0x0
  601041a1c8:	54000500 	b.eq	601041a268 <software_irq_dispatch+0x11c>  // b.none
  601041a1cc:	f94037e0 	ldr	x0, [sp, #104]
  601041a1d0:	b940a800 	ldr	w0, [x0, #168]
  601041a1d4:	71000c1f 	cmp	w0, #0x3
  601041a1d8:	54000480 	b.eq	601041a268 <software_irq_dispatch+0x11c>  // b.none
        cur_task->thread_context.trapframe = tf;
  601041a1dc:	f94037e0 	ldr	x0, [sp, #104]
  601041a1e0:	f94017e1 	ldr	x1, [sp, #40]
  601041a1e4:	f9002401 	str	x1, [x0, #72]
        // call syscall

        int ret = arch_syscall(cur_task->thread_context.trapframe, &syscall_num);
  601041a1e8:	f94037e0 	ldr	x0, [sp, #104]
  601041a1ec:	f9402400 	ldr	x0, [x0, #72]
  601041a1f0:	f90027e0 	str	x0, [sp, #72]
  601041a1f4:	9100f3e0 	add	x0, sp, #0x3c
  601041a1f8:	f90023e0 	str	x0, [sp, #64]
/// @return
extern int syscall(int sys_num, uintptr_t param1, uintptr_t param2, uintptr_t param3, uintptr_t param4);
__attribute__((__always_inline__)) static inline int arch_syscall(struct trapframe* tf, int* syscall_num)
{
    // call syscall
    *syscall_num = tf->x0;
  601041a1fc:	f94027e0 	ldr	x0, [sp, #72]
  601041a200:	f9400000 	ldr	x0, [x0]
  601041a204:	2a0003e1 	mov	w1, w0
  601041a208:	f94023e0 	ldr	x0, [sp, #64]
  601041a20c:	b9000001 	str	w1, [x0]
    return syscall(*syscall_num, tf->x1, tf->x2, tf->x3, tf->x4);
  601041a210:	f94023e0 	ldr	x0, [sp, #64]
  601041a214:	b9400005 	ldr	w5, [x0]
  601041a218:	f94027e0 	ldr	x0, [sp, #72]
  601041a21c:	f9400401 	ldr	x1, [x0, #8]
  601041a220:	f94027e0 	ldr	x0, [sp, #72]
  601041a224:	f9400802 	ldr	x2, [x0, #16]
  601041a228:	f94027e0 	ldr	x0, [sp, #72]
  601041a22c:	f9400c03 	ldr	x3, [x0, #24]
  601041a230:	f94027e0 	ldr	x0, [sp, #72]
  601041a234:	f9401000 	ldr	x0, [x0, #32]
  601041a238:	aa0003e4 	mov	x4, x0
  601041a23c:	2a0503e0 	mov	w0, w5
  601041a240:	94000c3c 	bl	601041d330 <syscall>
  601041a244:	b90067e0 	str	w0, [sp, #100]
  601041a248:	f94017e0 	ldr	x0, [sp, #40]
  601041a24c:	f9002fe0 	str	x0, [sp, #88]
  601041a250:	b94067e0 	ldr	w0, [sp, #100]
  601041a254:	b90057e0 	str	w0, [sp, #84]
/// @brief set return reg to trapframe
/// @param tf
/// @param ret
__attribute__((__always_inline__)) static inline void arch_set_return(struct trapframe* tf, int ret)
{
    tf->x0 = (uint64_t)ret;
  601041a258:	b98057e1 	ldrsw	x1, [sp, #84]
  601041a25c:	f9402fe0 	ldr	x0, [sp, #88]
  601041a260:	f9000001 	str	x1, [x0]
}
  601041a264:	d503201f 	nop
        arch_set_return(tf, ret);
    }

    if ((cur_cpu()->task == NULL && cur_task != NULL) || cur_task->state != RUNNING) {
  601041a268:	97ffff98 	bl	601041a0c8 <cur_cpu>
  601041a26c:	f9400400 	ldr	x0, [x0, #8]
  601041a270:	f100001f 	cmp	x0, #0x0
  601041a274:	54000081 	b.ne	601041a284 <software_irq_dispatch+0x138>  // b.any
  601041a278:	f94037e0 	ldr	x0, [sp, #104]
  601041a27c:	f100001f 	cmp	x0, #0x0
  601041a280:	540000a1 	b.ne	601041a294 <software_irq_dispatch+0x148>  // b.any
  601041a284:	f94037e0 	ldr	x0, [sp, #104]
  601041a288:	b940a800 	ldr	w0, [x0, #168]
  601041a28c:	7100081f 	cmp	w0, #0x2
  601041a290:	54000140 	b.eq	601041a2b8 <software_irq_dispatch+0x16c>  // b.none
        cur_cpu()->task = NULL;
  601041a294:	97ffff8d 	bl	601041a0c8 <cur_cpu>
  601041a298:	f900041f 	str	xzr, [x0, #8]
        context_switch(&cur_task->thread_context.context, cur_cpu()->scheduler);
  601041a29c:	f94037e0 	ldr	x0, [sp, #104]
  601041a2a0:	91010013 	add	x19, x0, #0x40
  601041a2a4:	97ffff89 	bl	601041a0c8 <cur_cpu>
  601041a2a8:	f9400800 	ldr	x0, [x0, #16]
  601041a2ac:	aa0003e1 	mov	x1, x0
  601041a2b0:	aa1303e0 	mov	x0, x19
  601041a2b4:	97ffd0fe 	bl	601040e6ac <context_switch>
    }
    if (syscall_num == SYSCALL_EXIT) {
  601041a2b8:	b9403fe0 	ldr	w0, [sp, #60]
  601041a2bc:	7100081f 	cmp	w0, #0x2
  601041a2c0:	54000081 	b.ne	601041a2d0 <software_irq_dispatch+0x184>  // b.any
        panic("Exit reaches");
  601041a2c4:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a2c8:	91194000 	add	x0, x0, #0x650
  601041a2cc:	97ffd3f7 	bl	601040f2a8 <panic>
    }

    assert(cur_task == cur_cpu()->task);
  601041a2d0:	97ffff7e 	bl	601041a0c8 <cur_cpu>
  601041a2d4:	f9400400 	ldr	x0, [x0, #8]
  601041a2d8:	f94037e1 	ldr	x1, [sp, #104]
  601041a2dc:	eb00003f 	cmp	x1, x0
  601041a2e0:	540001e0 	b.eq	601041a31c <software_irq_dispatch+0x1d0>  // b.none
  601041a2e4:	52800962 	mov	w2, #0x4b                  	// #75
  601041a2e8:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a2ec:	911a0001 	add	x1, x0, #0x680
  601041a2f0:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a2f4:	91184000 	add	x0, x0, #0x610
  601041a2f8:	97ffe7a0 	bl	6010414178 <printf_>
  601041a2fc:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a300:	91198001 	add	x1, x0, #0x660
  601041a304:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a308:	9118e000 	add	x0, x0, #0x638
  601041a30c:	97ffe79b 	bl	6010414178 <printf_>
  601041a310:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a314:	91192000 	add	x0, x0, #0x648
  601041a318:	97ffd3e4 	bl	601040f2a8 <panic>
    xizi_leave_kernel();
  601041a31c:	97ffff02 	bl	6010419f24 <xizi_leave_kernel>
  601041a320:	d503201f 	nop
  601041a324:	f9400bf3 	ldr	x19, [sp, #16]
  601041a328:	a8c77bfd 	ldp	x29, x30, [sp], #112
  601041a32c:	d65f03c0 	ret

000000601041a330 <cur_cpuid>:
{
  601041a330:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601041a334:	910003fd 	mov	x29, sp
    return cpu_get_current();
  601041a338:	97ffd0d8 	bl	601040e698 <cpu_get_current>
}
  601041a33c:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601041a340:	d65f03c0 	ret

000000601041a344 <cur_cpu>:
{
  601041a344:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601041a348:	910003fd 	mov	x29, sp
    return &global_cpus[cur_cpuid()];
  601041a34c:	97fffff9 	bl	601041a330 <cur_cpuid>
  601041a350:	93407c01 	sxtw	x1, w0
  601041a354:	d2800300 	mov	x0, #0x18                  	// #24
  601041a358:	9b007c21 	mul	x1, x1, x0
  601041a35c:	b0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041a360:	f942f400 	ldr	x0, [x0, #1512]
  601041a364:	8b000020 	add	x0, x1, x0
}
  601041a368:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601041a36c:	d65f03c0 	ret

000000601041a370 <dabort_handler>:
#include "syscall.h"
#include "task.h"

extern void context_switch(struct context**, struct context*);
__attribute__((optimize("O0"))) void dabort_handler(struct trapframe* r)
{
  601041a370:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  601041a374:	910003fd 	mov	x29, sp
  601041a378:	f9000bf3 	str	x19, [sp, #16]
  601041a37c:	f90017e0 	str	x0, [sp, #40]
    if (r->pc >= DEV_VRTMEM_BASE && is_spinlock_hold_by_current_cpu(&whole_kernel_lock)) {
  601041a380:	f94017e0 	ldr	x0, [sp, #40]
  601041a384:	f9407c01 	ldr	x1, [x0, #248]
  601041a388:	12a20000 	mov	w0, #0xefffffff            	// #-268435457
  601041a38c:	f2c00800 	movk	x0, #0x40, lsl #32
  601041a390:	eb00003f 	cmp	x1, x0
  601041a394:	540006a9 	b.ls	601041a468 <dabort_handler+0xf8>  // b.plast
  601041a398:	b0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041a39c:	f9429000 	ldr	x0, [x0, #1312]
  601041a3a0:	97ffdd08 	bl	60104117c0 <is_spinlock_hold_by_current_cpu>
  601041a3a4:	12001c00 	and	w0, w0, #0xff
  601041a3a8:	7100001f 	cmp	w0, #0x0
  601041a3ac:	540005e0 	b.eq	601041a468 <dabort_handler+0xf8>  // b.none
        assert(is_spinlock_hold_by_current_cpu(&whole_kernel_lock));
  601041a3b0:	b0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041a3b4:	f9429000 	ldr	x0, [x0, #1312]
  601041a3b8:	97ffdd02 	bl	60104117c0 <is_spinlock_hold_by_current_cpu>
  601041a3bc:	12001c00 	and	w0, w0, #0xff
  601041a3c0:	52000000 	eor	w0, w0, #0x1
  601041a3c4:	12001c00 	and	w0, w0, #0xff
  601041a3c8:	7100001f 	cmp	w0, #0x0
  601041a3cc:	540001e0 	b.eq	601041a408 <dabort_handler+0x98>  // b.none
  601041a3d0:	528006e2 	mov	w2, #0x37                  	// #55
  601041a3d4:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a3d8:	9120e001 	add	x1, x0, #0x838
  601041a3dc:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a3e0:	911a6000 	add	x0, x0, #0x698
  601041a3e4:	97ffe765 	bl	6010414178 <printf_>
  601041a3e8:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a3ec:	911aa001 	add	x1, x0, #0x6a8
  601041a3f0:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a3f4:	911b8000 	add	x0, x0, #0x6e0
  601041a3f8:	97ffe760 	bl	6010414178 <printf_>
  601041a3fc:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a400:	911bc000 	add	x0, x0, #0x6f0
  601041a404:	97ffd3a9 	bl	601040f2a8 <panic>
        ERROR("dabort in kernel, current task: %s\n", cur_cpu()->task == NULL ? "NULL" : cur_cpu()->task->name);
  601041a408:	52800702 	mov	w2, #0x38                  	// #56
  601041a40c:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a410:	9120e001 	add	x1, x0, #0x838
  601041a414:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a418:	911a6000 	add	x0, x0, #0x698
  601041a41c:	97ffe757 	bl	6010414178 <printf_>
  601041a420:	97ffffc9 	bl	601041a344 <cur_cpu>
  601041a424:	f9400400 	ldr	x0, [x0, #8]
  601041a428:	f100001f 	cmp	x0, #0x0
  601041a42c:	54000080 	b.eq	601041a43c <dabort_handler+0xcc>  // b.none
  601041a430:	97ffffc5 	bl	601041a344 <cur_cpu>
  601041a434:	f9400400 	ldr	x0, [x0, #8]
  601041a438:	14000003 	b	601041a444 <dabort_handler+0xd4>
  601041a43c:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a440:	911be000 	add	x0, x0, #0x6f8
  601041a444:	aa0003e1 	mov	x1, x0
  601041a448:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a44c:	911c0000 	add	x0, x0, #0x700
  601041a450:	97ffe74a 	bl	6010414178 <printf_>
        dabort_reason(r);
  601041a454:	f94017e0 	ldr	x0, [sp, #40]
  601041a458:	97ffd60c 	bl	601040fc88 <dabort_reason>
        panic("data abort exception\n");
  601041a45c:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a460:	911ca000 	add	x0, x0, #0x728
  601041a464:	97ffd391 	bl	601040f2a8 <panic>
    }

    struct Thread* cur_task = cur_cpu()->task;
  601041a468:	97ffffb7 	bl	601041a344 <cur_cpu>
  601041a46c:	f9400400 	ldr	x0, [x0, #8]
  601041a470:	f9001fe0 	str	x0, [sp, #56]
    ERROR("dabort in user space: %s\n", cur_task->name);
  601041a474:	528007c2 	mov	w2, #0x3e                  	// #62
  601041a478:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a47c:	9120e001 	add	x1, x0, #0x838
  601041a480:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a484:	911a6000 	add	x0, x0, #0x698
  601041a488:	97ffe73c 	bl	6010414178 <printf_>
  601041a48c:	f9401fe0 	ldr	x0, [sp, #56]
  601041a490:	aa0003e1 	mov	x1, x0
  601041a494:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a498:	911d0000 	add	x0, x0, #0x740
  601041a49c:	97ffe737 	bl	6010414178 <printf_>
    dabort_reason(r);
  601041a4a0:	f94017e0 	ldr	x0, [sp, #40]
  601041a4a4:	97ffd5f9 	bl	601040fc88 <dabort_reason>

    xizi_enter_kernel();
  601041a4a8:	97fffe8a 	bl	6010419ed0 <xizi_enter_kernel>
    sys_exit(cur_task);
  601041a4ac:	f9401fe0 	ldr	x0, [sp, #56]
  601041a4b0:	94001316 	bl	601041f108 <sys_exit>
    assert(cur_cpu()->task == NULL);
  601041a4b4:	97ffffa4 	bl	601041a344 <cur_cpu>
  601041a4b8:	f9400400 	ldr	x0, [x0, #8]
  601041a4bc:	f100001f 	cmp	x0, #0x0
  601041a4c0:	540001e0 	b.eq	601041a4fc <dabort_handler+0x18c>  // b.none
  601041a4c4:	52800862 	mov	w2, #0x43                  	// #67
  601041a4c8:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a4cc:	9120e001 	add	x1, x0, #0x838
  601041a4d0:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a4d4:	911a6000 	add	x0, x0, #0x698
  601041a4d8:	97ffe728 	bl	6010414178 <printf_>
  601041a4dc:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a4e0:	911d8001 	add	x1, x0, #0x760
  601041a4e4:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a4e8:	911b8000 	add	x0, x0, #0x6e0
  601041a4ec:	97ffe723 	bl	6010414178 <printf_>
  601041a4f0:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a4f4:	911bc000 	add	x0, x0, #0x6f0
  601041a4f8:	97ffd36c 	bl	601040f2a8 <panic>
    context_switch(&cur_task->thread_context.context, cur_cpu()->scheduler);
  601041a4fc:	f9401fe0 	ldr	x0, [sp, #56]
  601041a500:	91010013 	add	x19, x0, #0x40
  601041a504:	97ffff90 	bl	601041a344 <cur_cpu>
  601041a508:	f9400800 	ldr	x0, [x0, #16]
  601041a50c:	aa0003e1 	mov	x1, x0
  601041a510:	aa1303e0 	mov	x0, x19
  601041a514:	97ffd066 	bl	601040e6ac <context_switch>
    panic("dabort end should never be reashed.\n");
  601041a518:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a51c:	911de000 	add	x0, x0, #0x778
  601041a520:	97ffd362 	bl	601040f2a8 <panic>
}
  601041a524:	d503201f 	nop
  601041a528:	f9400bf3 	ldr	x19, [sp, #16]
  601041a52c:	a8c47bfd 	ldp	x29, x30, [sp], #64
  601041a530:	d65f03c0 	ret

000000601041a534 <iabort_handler>:

__attribute__((optimize("O0"))) void iabort_handler(struct trapframe* r)
{
  601041a534:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  601041a538:	910003fd 	mov	x29, sp
  601041a53c:	f9000bf3 	str	x19, [sp, #16]
  601041a540:	f90017e0 	str	x0, [sp, #40]
    if (r->pc >= DEV_VRTMEM_BASE && is_spinlock_hold_by_current_cpu(&whole_kernel_lock)) {
  601041a544:	f94017e0 	ldr	x0, [sp, #40]
  601041a548:	f9407c01 	ldr	x1, [x0, #248]
  601041a54c:	12a20000 	mov	w0, #0xefffffff            	// #-268435457
  601041a550:	f2c00800 	movk	x0, #0x40, lsl #32
  601041a554:	eb00003f 	cmp	x1, x0
  601041a558:	540006a9 	b.ls	601041a62c <iabort_handler+0xf8>  // b.plast
  601041a55c:	b0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041a560:	f9429000 	ldr	x0, [x0, #1312]
  601041a564:	97ffdc97 	bl	60104117c0 <is_spinlock_hold_by_current_cpu>
  601041a568:	12001c00 	and	w0, w0, #0xff
  601041a56c:	7100001f 	cmp	w0, #0x0
  601041a570:	540005e0 	b.eq	601041a62c <iabort_handler+0xf8>  // b.none
        assert(is_spinlock_hold_by_current_cpu(&whole_kernel_lock));
  601041a574:	b0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041a578:	f9429000 	ldr	x0, [x0, #1312]
  601041a57c:	97ffdc91 	bl	60104117c0 <is_spinlock_hold_by_current_cpu>
  601041a580:	12001c00 	and	w0, w0, #0xff
  601041a584:	52000000 	eor	w0, w0, #0x1
  601041a588:	12001c00 	and	w0, w0, #0xff
  601041a58c:	7100001f 	cmp	w0, #0x0
  601041a590:	540001e0 	b.eq	601041a5cc <iabort_handler+0x98>  // b.none
  601041a594:	52800962 	mov	w2, #0x4b                  	// #75
  601041a598:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a59c:	91212001 	add	x1, x0, #0x848
  601041a5a0:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a5a4:	911a6000 	add	x0, x0, #0x698
  601041a5a8:	97ffe6f4 	bl	6010414178 <printf_>
  601041a5ac:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a5b0:	911aa001 	add	x1, x0, #0x6a8
  601041a5b4:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a5b8:	911b8000 	add	x0, x0, #0x6e0
  601041a5bc:	97ffe6ef 	bl	6010414178 <printf_>
  601041a5c0:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a5c4:	911bc000 	add	x0, x0, #0x6f0
  601041a5c8:	97ffd338 	bl	601040f2a8 <panic>
        ERROR("iabort in kernel, current task: %s\n", cur_cpu()->task == NULL ? "NULL" : cur_cpu()->task->name);
  601041a5cc:	52800982 	mov	w2, #0x4c                  	// #76
  601041a5d0:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a5d4:	91212001 	add	x1, x0, #0x848
  601041a5d8:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a5dc:	911a6000 	add	x0, x0, #0x698
  601041a5e0:	97ffe6e6 	bl	6010414178 <printf_>
  601041a5e4:	97ffff58 	bl	601041a344 <cur_cpu>
  601041a5e8:	f9400400 	ldr	x0, [x0, #8]
  601041a5ec:	f100001f 	cmp	x0, #0x0
  601041a5f0:	54000080 	b.eq	601041a600 <iabort_handler+0xcc>  // b.none
  601041a5f4:	97ffff54 	bl	601041a344 <cur_cpu>
  601041a5f8:	f9400400 	ldr	x0, [x0, #8]
  601041a5fc:	14000003 	b	601041a608 <iabort_handler+0xd4>
  601041a600:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a604:	911be000 	add	x0, x0, #0x6f8
  601041a608:	aa0003e1 	mov	x1, x0
  601041a60c:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a610:	911e8000 	add	x0, x0, #0x7a0
  601041a614:	97ffe6d9 	bl	6010414178 <printf_>
        iabort_reason(r);
  601041a618:	f94017e0 	ldr	x0, [sp, #40]
  601041a61c:	97ffd629 	bl	601040fec0 <iabort_reason>
        panic("kernel prefetch abort exception\n");
  601041a620:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a624:	911f2000 	add	x0, x0, #0x7c8
  601041a628:	97ffd320 	bl	601040f2a8 <panic>
    }

    struct Thread* cur_task = cur_cpu()->task;
  601041a62c:	97ffff46 	bl	601041a344 <cur_cpu>
  601041a630:	f9400400 	ldr	x0, [x0, #8]
  601041a634:	f9001fe0 	str	x0, [sp, #56]
    ERROR("iabort in user space: %s\n", cur_task->name);
  601041a638:	52800a42 	mov	w2, #0x52                  	// #82
  601041a63c:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a640:	91212001 	add	x1, x0, #0x848
  601041a644:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a648:	911a6000 	add	x0, x0, #0x698
  601041a64c:	97ffe6cb 	bl	6010414178 <printf_>
  601041a650:	f9401fe0 	ldr	x0, [sp, #56]
  601041a654:	aa0003e1 	mov	x1, x0
  601041a658:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a65c:	911fc000 	add	x0, x0, #0x7f0
  601041a660:	97ffe6c6 	bl	6010414178 <printf_>
    iabort_reason(r);
  601041a664:	f94017e0 	ldr	x0, [sp, #40]
  601041a668:	97ffd616 	bl	601040fec0 <iabort_reason>

    xizi_enter_kernel();
  601041a66c:	97fffe19 	bl	6010419ed0 <xizi_enter_kernel>
    sys_exit(cur_task);
  601041a670:	f9401fe0 	ldr	x0, [sp, #56]
  601041a674:	940012a5 	bl	601041f108 <sys_exit>
    assert(cur_cpu()->task == NULL);
  601041a678:	97ffff33 	bl	601041a344 <cur_cpu>
  601041a67c:	f9400400 	ldr	x0, [x0, #8]
  601041a680:	f100001f 	cmp	x0, #0x0
  601041a684:	540001e0 	b.eq	601041a6c0 <iabort_handler+0x18c>  // b.none
  601041a688:	52800ae2 	mov	w2, #0x57                  	// #87
  601041a68c:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a690:	91212001 	add	x1, x0, #0x848
  601041a694:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a698:	911a6000 	add	x0, x0, #0x698
  601041a69c:	97ffe6b7 	bl	6010414178 <printf_>
  601041a6a0:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a6a4:	911d8001 	add	x1, x0, #0x760
  601041a6a8:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a6ac:	911b8000 	add	x0, x0, #0x6e0
  601041a6b0:	97ffe6b2 	bl	6010414178 <printf_>
  601041a6b4:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a6b8:	911bc000 	add	x0, x0, #0x6f0
  601041a6bc:	97ffd2fb 	bl	601040f2a8 <panic>
    context_switch(&cur_task->thread_context.context, cur_cpu()->scheduler);
  601041a6c0:	f9401fe0 	ldr	x0, [sp, #56]
  601041a6c4:	91010013 	add	x19, x0, #0x40
  601041a6c8:	97ffff1f 	bl	601041a344 <cur_cpu>
  601041a6cc:	f9400800 	ldr	x0, [x0, #16]
  601041a6d0:	aa0003e1 	mov	x1, x0
  601041a6d4:	aa1303e0 	mov	x0, x19
  601041a6d8:	97ffcff5 	bl	601040e6ac <context_switch>
    panic("iabort end should never be reashed.\n");
  601041a6dc:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a6e0:	91204000 	add	x0, x0, #0x810
  601041a6e4:	97ffd2f1 	bl	601040f2a8 <panic>
}
  601041a6e8:	d503201f 	nop
  601041a6ec:	f9400bf3 	ldr	x19, [sp, #16]
  601041a6f0:	a8c47bfd 	ldp	x29, x30, [sp], #64
  601041a6f4:	d65f03c0 	ret

000000601041a6f8 <bitmap64_free>:
    bitmap->map |= (1 << (free_bit - 1));
    return free_bit - 1;
}

static inline void bitmap64_free(struct bitmap64* bitmap, int idx)
{
  601041a6f8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  601041a6fc:	910003fd 	mov	x29, sp
  601041a700:	f9000fe0 	str	x0, [sp, #24]
  601041a704:	b90017e1 	str	w1, [sp, #20]
    // usages of bitmap64 must be correct
    assert((bitmap->map & (1 << idx)) != 0);
  601041a708:	f9400fe0 	ldr	x0, [sp, #24]
  601041a70c:	f9400001 	ldr	x1, [x0]
  601041a710:	b94017e0 	ldr	w0, [sp, #20]
  601041a714:	52800022 	mov	w2, #0x1                   	// #1
  601041a718:	1ac02040 	lsl	w0, w2, w0
  601041a71c:	93407c00 	sxtw	x0, w0
  601041a720:	8a000020 	and	x0, x1, x0
  601041a724:	f100001f 	cmp	x0, #0x0
  601041a728:	540001e1 	b.ne	601041a764 <bitmap64_free+0x6c>  // b.any
  601041a72c:	52800802 	mov	w2, #0x40                  	// #64
  601041a730:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a734:	91324001 	add	x1, x0, #0xc90
  601041a738:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a73c:	91216000 	add	x0, x0, #0x858
  601041a740:	97ffe68e 	bl	6010414178 <printf_>
  601041a744:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a748:	9121a001 	add	x1, x0, #0x868
  601041a74c:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a750:	91222000 	add	x0, x0, #0x888
  601041a754:	97ffe689 	bl	6010414178 <printf_>
  601041a758:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041a75c:	91226000 	add	x0, x0, #0x898
  601041a760:	97ffd2d2 	bl	601040f2a8 <panic>
    // free bit
    bitmap->map &= ~(uint64_t)(1 << idx);
  601041a764:	f9400fe0 	ldr	x0, [sp, #24]
  601041a768:	f9400001 	ldr	x1, [x0]
  601041a76c:	b94017e0 	ldr	w0, [sp, #20]
  601041a770:	52800022 	mov	w2, #0x1                   	// #1
  601041a774:	1ac02040 	lsl	w0, w2, w0
  601041a778:	93407c00 	sxtw	x0, w0
  601041a77c:	aa2003e0 	mvn	x0, x0
  601041a780:	8a000021 	and	x1, x1, x0
  601041a784:	f9400fe0 	ldr	x0, [sp, #24]
  601041a788:	f9000001 	str	x1, [x0]
}
  601041a78c:	d503201f 	nop
  601041a790:	a8c27bfd 	ldp	x29, x30, [sp], #32
  601041a794:	d65f03c0 	ret

000000601041a798 <cur_cpuid>:
{
  601041a798:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601041a79c:	910003fd 	mov	x29, sp
    return cpu_get_current();
  601041a7a0:	97ffcfbe 	bl	601040e698 <cpu_get_current>
}
  601041a7a4:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601041a7a8:	d65f03c0 	ret

000000601041a7ac <cur_cpu>:
{
  601041a7ac:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601041a7b0:	910003fd 	mov	x29, sp
    return &global_cpus[cur_cpuid()];
  601041a7b4:	97fffff9 	bl	601041a798 <cur_cpuid>
  601041a7b8:	93407c01 	sxtw	x1, w0
  601041a7bc:	d2800300 	mov	x0, #0x18                  	// #24
  601041a7c0:	9b007c21 	mul	x1, x1, x0
  601041a7c4:	b0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041a7c8:	f942f400 	ldr	x0, [x0, #1512]
  601041a7cc:	8b000020 	add	x0, x1, x0
}
  601041a7d0:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601041a7d4:	d65f03c0 	ret

000000601041a7d8 <task_node_leave_list>:

struct CPU global_cpus[NR_CPU];
uint32_t ready_task_priority;

static inline void task_node_leave_list(struct Thread* task)
{
  601041a7d8:	d100c3ff 	sub	sp, sp, #0x30
  601041a7dc:	f90007e0 	str	x0, [sp, #8]
    doubleListDel(&task->node);
  601041a7e0:	f94007e0 	ldr	x0, [sp, #8]
  601041a7e4:	91026000 	add	x0, x0, #0x98
  601041a7e8:	f90017e0 	str	x0, [sp, #40]
    _double_list_del(entry->prev, entry->next);
  601041a7ec:	f94017e0 	ldr	x0, [sp, #40]
  601041a7f0:	f9400401 	ldr	x1, [x0, #8]
  601041a7f4:	f94017e0 	ldr	x0, [sp, #40]
  601041a7f8:	f9400000 	ldr	x0, [x0]
  601041a7fc:	f90013e1 	str	x1, [sp, #32]
  601041a800:	f9000fe0 	str	x0, [sp, #24]
    next->prev = prev;
  601041a804:	f9400fe0 	ldr	x0, [sp, #24]
  601041a808:	f94013e1 	ldr	x1, [sp, #32]
  601041a80c:	f9000401 	str	x1, [x0, #8]
    prev->next = next;
  601041a810:	f94013e0 	ldr	x0, [sp, #32]
  601041a814:	f9400fe1 	ldr	x1, [sp, #24]
  601041a818:	f9000001 	str	x1, [x0]
}
  601041a81c:	d503201f 	nop
    entry->next = entry;
  601041a820:	f94017e0 	ldr	x0, [sp, #40]
  601041a824:	f94017e1 	ldr	x1, [sp, #40]
  601041a828:	f9000001 	str	x1, [x0]
    entry->prev = entry;
  601041a82c:	f94017e0 	ldr	x0, [sp, #40]
  601041a830:	f94017e1 	ldr	x1, [sp, #40]
  601041a834:	f9000401 	str	x1, [x0, #8]
}
  601041a838:	d503201f 	nop
    if (IS_DOUBLE_LIST_EMPTY(&xizi_task_manager.task_list_head[task->priority])) {
  601041a83c:	f94007e0 	ldr	x0, [sp, #8]
  601041a840:	b940ac02 	ldr	w2, [x0, #172]
  601041a844:	b0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041a848:	f942ec01 	ldr	x1, [x0, #1496]
  601041a84c:	93407c40 	sxtw	x0, w2
  601041a850:	d37cec00 	lsl	x0, x0, #4
  601041a854:	8b000020 	add	x0, x1, x0
  601041a858:	f9400001 	ldr	x1, [x0]
  601041a85c:	f94007e0 	ldr	x0, [sp, #8]
  601041a860:	b940ac00 	ldr	w0, [x0, #172]
  601041a864:	93407c00 	sxtw	x0, w0
  601041a868:	d37cec02 	lsl	x2, x0, #4
  601041a86c:	b0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041a870:	f942ec00 	ldr	x0, [x0, #1496]
  601041a874:	8b000040 	add	x0, x2, x0
  601041a878:	eb00003f 	cmp	x1, x0
  601041a87c:	540001a1 	b.ne	601041a8b0 <task_node_leave_list+0xd8>  // b.any
        ready_task_priority &= ~((uint32_t)1 << task->priority);
  601041a880:	f94007e0 	ldr	x0, [sp, #8]
  601041a884:	b940ac00 	ldr	w0, [x0, #172]
  601041a888:	52800021 	mov	w1, #0x1                   	// #1
  601041a88c:	1ac02020 	lsl	w0, w1, w0
  601041a890:	2a2003e1 	mvn	w1, w0
  601041a894:	b0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041a898:	f942f800 	ldr	x0, [x0, #1520]
  601041a89c:	b9400000 	ldr	w0, [x0]
  601041a8a0:	0a000021 	and	w1, w1, w0
  601041a8a4:	b0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041a8a8:	f942f800 	ldr	x0, [x0, #1520]
  601041a8ac:	b9000001 	str	w1, [x0]
    }
}
  601041a8b0:	d503201f 	nop
  601041a8b4:	9100c3ff 	add	sp, sp, #0x30
  601041a8b8:	d65f03c0 	ret

000000601041a8bc <task_node_add_to_ready_list_head>:

static inline void task_node_add_to_ready_list_head(struct Thread* task)
{
  601041a8bc:	d10103ff 	sub	sp, sp, #0x40
  601041a8c0:	f90007e0 	str	x0, [sp, #8]
    doubleListAddOnHead(&task->node, &xizi_task_manager.task_list_head[task->priority]);
  601041a8c4:	f94007e0 	ldr	x0, [sp, #8]
  601041a8c8:	91026001 	add	x1, x0, #0x98
  601041a8cc:	f94007e0 	ldr	x0, [sp, #8]
  601041a8d0:	b940ac00 	ldr	w0, [x0, #172]
  601041a8d4:	93407c00 	sxtw	x0, w0
  601041a8d8:	d37cec02 	lsl	x2, x0, #4
  601041a8dc:	b0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041a8e0:	f942ec00 	ldr	x0, [x0, #1496]
  601041a8e4:	8b000040 	add	x0, x2, x0
  601041a8e8:	f9001fe1 	str	x1, [sp, #56]
  601041a8ec:	f9001be0 	str	x0, [sp, #48]
    _double_list_add(new_node, head, head->next);
  601041a8f0:	f9401be0 	ldr	x0, [sp, #48]
  601041a8f4:	f9400000 	ldr	x0, [x0]
  601041a8f8:	f9401fe1 	ldr	x1, [sp, #56]
  601041a8fc:	f90017e1 	str	x1, [sp, #40]
  601041a900:	f9401be1 	ldr	x1, [sp, #48]
  601041a904:	f90013e1 	str	x1, [sp, #32]
  601041a908:	f9000fe0 	str	x0, [sp, #24]
    next->prev = new_node;
  601041a90c:	f9400fe0 	ldr	x0, [sp, #24]
  601041a910:	f94017e1 	ldr	x1, [sp, #40]
  601041a914:	f9000401 	str	x1, [x0, #8]
    new_node->next = next;
  601041a918:	f94017e0 	ldr	x0, [sp, #40]
  601041a91c:	f9400fe1 	ldr	x1, [sp, #24]
  601041a920:	f9000001 	str	x1, [x0]
    new_node->prev = prev;
  601041a924:	f94017e0 	ldr	x0, [sp, #40]
  601041a928:	f94013e1 	ldr	x1, [sp, #32]
  601041a92c:	f9000401 	str	x1, [x0, #8]
    prev->next = new_node;
  601041a930:	f94013e0 	ldr	x0, [sp, #32]
  601041a934:	f94017e1 	ldr	x1, [sp, #40]
  601041a938:	f9000001 	str	x1, [x0]
}
  601041a93c:	d503201f 	nop
}
  601041a940:	d503201f 	nop
    ready_task_priority |= ((uint32_t)1 << task->priority);
  601041a944:	f94007e0 	ldr	x0, [sp, #8]
  601041a948:	b940ac00 	ldr	w0, [x0, #172]
  601041a94c:	52800021 	mov	w1, #0x1                   	// #1
  601041a950:	1ac02021 	lsl	w1, w1, w0
  601041a954:	b0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041a958:	f942f800 	ldr	x0, [x0, #1520]
  601041a95c:	b9400000 	ldr	w0, [x0]
  601041a960:	2a000021 	orr	w1, w1, w0
  601041a964:	b0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041a968:	f942f800 	ldr	x0, [x0, #1520]
  601041a96c:	b9000001 	str	w1, [x0]
}
  601041a970:	d503201f 	nop
  601041a974:	910103ff 	add	sp, sp, #0x40
  601041a978:	d65f03c0 	ret

000000601041a97c <task_node_add_to_ready_list_back>:

static inline void task_node_add_to_ready_list_back(struct Thread* task)
{
  601041a97c:	d10103ff 	sub	sp, sp, #0x40
  601041a980:	f90007e0 	str	x0, [sp, #8]
    doubleListAddOnBack(&task->node, &xizi_task_manager.task_list_head[task->priority]);
  601041a984:	f94007e0 	ldr	x0, [sp, #8]
  601041a988:	91026001 	add	x1, x0, #0x98
  601041a98c:	f94007e0 	ldr	x0, [sp, #8]
  601041a990:	b940ac00 	ldr	w0, [x0, #172]
  601041a994:	93407c00 	sxtw	x0, w0
  601041a998:	d37cec02 	lsl	x2, x0, #4
  601041a99c:	b0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041a9a0:	f942ec00 	ldr	x0, [x0, #1496]
  601041a9a4:	8b000040 	add	x0, x2, x0
  601041a9a8:	f9001fe1 	str	x1, [sp, #56]
  601041a9ac:	f9001be0 	str	x0, [sp, #48]
    _double_list_add(new_node, head->prev, head);
  601041a9b0:	f9401be0 	ldr	x0, [sp, #48]
  601041a9b4:	f9400400 	ldr	x0, [x0, #8]
  601041a9b8:	f9401fe1 	ldr	x1, [sp, #56]
  601041a9bc:	f90017e1 	str	x1, [sp, #40]
  601041a9c0:	f90013e0 	str	x0, [sp, #32]
  601041a9c4:	f9401be0 	ldr	x0, [sp, #48]
  601041a9c8:	f9000fe0 	str	x0, [sp, #24]
    next->prev = new_node;
  601041a9cc:	f9400fe0 	ldr	x0, [sp, #24]
  601041a9d0:	f94017e1 	ldr	x1, [sp, #40]
  601041a9d4:	f9000401 	str	x1, [x0, #8]
    new_node->next = next;
  601041a9d8:	f94017e0 	ldr	x0, [sp, #40]
  601041a9dc:	f9400fe1 	ldr	x1, [sp, #24]
  601041a9e0:	f9000001 	str	x1, [x0]
    new_node->prev = prev;
  601041a9e4:	f94017e0 	ldr	x0, [sp, #40]
  601041a9e8:	f94013e1 	ldr	x1, [sp, #32]
  601041a9ec:	f9000401 	str	x1, [x0, #8]
    prev->next = new_node;
  601041a9f0:	f94013e0 	ldr	x0, [sp, #32]
  601041a9f4:	f94017e1 	ldr	x1, [sp, #40]
  601041a9f8:	f9000001 	str	x1, [x0]
}
  601041a9fc:	d503201f 	nop
}
  601041aa00:	d503201f 	nop
    ready_task_priority |= ((uint32_t)1 << task->priority);
  601041aa04:	f94007e0 	ldr	x0, [sp, #8]
  601041aa08:	b940ac00 	ldr	w0, [x0, #172]
  601041aa0c:	52800021 	mov	w1, #0x1                   	// #1
  601041aa10:	1ac02021 	lsl	w1, w1, w0
  601041aa14:	b0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041aa18:	f942f800 	ldr	x0, [x0, #1520]
  601041aa1c:	b9400000 	ldr	w0, [x0]
  601041aa20:	2a000021 	orr	w1, w1, w0
  601041aa24:	b0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041aa28:	f942f800 	ldr	x0, [x0, #1520]
  601041aa2c:	b9000001 	str	w1, [x0]
}
  601041aa30:	d503201f 	nop
  601041aa34:	910103ff 	add	sp, sp, #0x40
  601041aa38:	d65f03c0 	ret

000000601041aa3c <_task_manager_init>:

static void _task_manager_init()
{
  601041aa3c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  601041aa40:	910003fd 	mov	x29, sp
    // init task list to NULL
    for (int i = 0; i < TASK_MAX_PRIORITY; i++) {
  601041aa44:	b9002fff 	str	wzr, [sp, #44]
  601041aa48:	14000011 	b	601041aa8c <_task_manager_init+0x50>
        doubleListNodeInit(&xizi_task_manager.task_list_head[i]);
  601041aa4c:	b9802fe0 	ldrsw	x0, [sp, #44]
  601041aa50:	d37cec01 	lsl	x1, x0, #4
  601041aa54:	b0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041aa58:	f942ec00 	ldr	x0, [x0, #1496]
  601041aa5c:	8b000020 	add	x0, x1, x0
  601041aa60:	f90013e0 	str	x0, [sp, #32]
    list->next = list;
  601041aa64:	f94013e0 	ldr	x0, [sp, #32]
  601041aa68:	f94013e1 	ldr	x1, [sp, #32]
  601041aa6c:	f9000001 	str	x1, [x0]
    list->prev = list;
  601041aa70:	f94013e0 	ldr	x0, [sp, #32]
  601041aa74:	f94013e1 	ldr	x1, [sp, #32]
  601041aa78:	f9000401 	str	x1, [x0, #8]
}
  601041aa7c:	d503201f 	nop
    for (int i = 0; i < TASK_MAX_PRIORITY; i++) {
  601041aa80:	b9402fe0 	ldr	w0, [sp, #44]
  601041aa84:	11000400 	add	w0, w0, #0x1
  601041aa88:	b9002fe0 	str	w0, [sp, #44]
  601041aa8c:	b9402fe0 	ldr	w0, [sp, #44]
  601041aa90:	71007c1f 	cmp	w0, #0x1f
  601041aa94:	54fffdcd 	b.le	601041aa4c <_task_manager_init+0x10>
  601041aa98:	b0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041aa9c:	f942ec00 	ldr	x0, [x0, #1496]
  601041aaa0:	91084000 	add	x0, x0, #0x210
  601041aaa4:	f9000be0 	str	x0, [sp, #16]
    list->next = list;
  601041aaa8:	f9400be0 	ldr	x0, [sp, #16]
  601041aaac:	f9400be1 	ldr	x1, [sp, #16]
  601041aab0:	f9000001 	str	x1, [x0]
    list->prev = list;
  601041aab4:	f9400be0 	ldr	x0, [sp, #16]
  601041aab8:	f9400be1 	ldr	x1, [sp, #16]
  601041aabc:	f9000401 	str	x1, [x0, #8]
}
  601041aac0:	d503201f 	nop
  601041aac4:	b0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041aac8:	f942ec00 	ldr	x0, [x0, #1496]
  601041aacc:	91080000 	add	x0, x0, #0x200
  601041aad0:	f9000fe0 	str	x0, [sp, #24]
    list->next = list;
  601041aad4:	f9400fe0 	ldr	x0, [sp, #24]
  601041aad8:	f9400fe1 	ldr	x1, [sp, #24]
  601041aadc:	f9000001 	str	x1, [x0]
    list->prev = list;
  601041aae0:	f9400fe0 	ldr	x0, [sp, #24]
  601041aae4:	f9400fe1 	ldr	x1, [sp, #24]
  601041aae8:	f9000401 	str	x1, [x0, #8]
}
  601041aaec:	d503201f 	nop
    }
    doubleListNodeInit(&xizi_task_manager.task_blocked_list_head);
    doubleListNodeInit(&xizi_task_manager.task_running_list_head);
    // init task (slab) allocator
    slab_init(&xizi_task_manager.memspace_allocator, sizeof(struct MemSpace));
  601041aaf0:	d2800701 	mov	x1, #0x38                  	// #56
  601041aaf4:	b0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041aaf8:	f942ec00 	ldr	x0, [x0, #1496]
  601041aafc:	9109c000 	add	x0, x0, #0x270
  601041ab00:	97fff5bf 	bl	60104181fc <slab_init>
    slab_init(&xizi_task_manager.task_allocator, sizeof(struct Thread));
  601041ab04:	d2801701 	mov	x1, #0xb8                  	// #184
  601041ab08:	b0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041ab0c:	f942ec00 	ldr	x0, [x0, #1496]
  601041ab10:	910aa000 	add	x0, x0, #0x2a8
  601041ab14:	97fff5ba 	bl	60104181fc <slab_init>
    slab_init(&xizi_task_manager.task_buddy_allocator, sizeof(struct KBuddy));
  601041ab18:	d2802c01 	mov	x1, #0x160                 	// #352
  601041ab1c:	b0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041ab20:	f942ec00 	ldr	x0, [x0, #1496]
  601041ab24:	910b8000 	add	x0, x0, #0x2e0
  601041ab28:	97fff5b5 	bl	60104181fc <slab_init>
    semaphore_pool_init(&xizi_task_manager.semaphore_pool);
  601041ab2c:	b0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041ab30:	f942ec00 	ldr	x0, [x0, #1496]
  601041ab34:	91088000 	add	x0, x0, #0x220
  601041ab38:	94000866 	bl	601041ccd0 <semaphore_pool_init>

    // tid pool
    xizi_task_manager.next_pid = 0;
  601041ab3c:	b0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041ab40:	f942ec00 	ldr	x0, [x0, #1496]
  601041ab44:	b903181f 	str	wzr, [x0, #792]

    // init priority bit map
    ready_task_priority = 0;
  601041ab48:	b0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041ab4c:	f942f800 	ldr	x0, [x0, #1520]
  601041ab50:	b900001f 	str	wzr, [x0]
}
  601041ab54:	d503201f 	nop
  601041ab58:	a8c37bfd 	ldp	x29, x30, [sp], #48
  601041ab5c:	d65f03c0 	ret

000000601041ab60 <_alloc_task_cb>:

/// @brief alloc a new task without init
static struct Thread* _alloc_task_cb()
{
  601041ab60:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  601041ab64:	910003fd 	mov	x29, sp
    // alloc task and add it to used task list
    struct Thread* task = (struct Thread*)slab_alloc(&xizi_task_manager.task_allocator);
  601041ab68:	b0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041ab6c:	f942ec00 	ldr	x0, [x0, #1496]
  601041ab70:	910aa000 	add	x0, x0, #0x2a8
  601041ab74:	97fff5dc 	bl	60104182e4 <slab_alloc>
  601041ab78:	f9000fe0 	str	x0, [sp, #24]
    if (UNLIKELY(task == NULL)) {
  601041ab7c:	f9400fe0 	ldr	x0, [sp, #24]
  601041ab80:	f100001f 	cmp	x0, #0x0
  601041ab84:	1a9f17e0 	cset	w0, eq  // eq = none
  601041ab88:	12001c00 	and	w0, w0, #0xff
  601041ab8c:	92401c00 	and	x0, x0, #0xff
  601041ab90:	f100001f 	cmp	x0, #0x0
  601041ab94:	54000180 	b.eq	601041abc4 <_alloc_task_cb+0x64>  // b.none
        ERROR("Not enough memory\n");
  601041ab98:	52800b82 	mov	w2, #0x5c                  	// #92
  601041ab9c:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041aba0:	91312001 	add	x1, x0, #0xc48
  601041aba4:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041aba8:	91216000 	add	x0, x0, #0x858
  601041abac:	97ffe573 	bl	6010414178 <printf_>
  601041abb0:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041abb4:	91228000 	add	x0, x0, #0x8a0
  601041abb8:	97ffe570 	bl	6010414178 <printf_>
        return NULL;
  601041abbc:	d2800000 	mov	x0, #0x0                   	// #0
  601041abc0:	14000013 	b	601041ac0c <_alloc_task_cb+0xac>
    }
    // set tid once task is allocated
    memset(task, 0, sizeof(*task));
  601041abc4:	d2801702 	mov	x2, #0xb8                  	// #184
  601041abc8:	52800001 	mov	w1, #0x0                   	// #0
  601041abcc:	f9400fe0 	ldr	x0, [sp, #24]
  601041abd0:	97ffcdbc 	bl	601040e2c0 <memset>
    task->tid = xizi_task_manager.next_pid++;
  601041abd4:	b0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041abd8:	f942ec00 	ldr	x0, [x0, #1496]
  601041abdc:	b9431800 	ldr	w0, [x0, #792]
  601041abe0:	11000402 	add	w2, w0, #0x1
  601041abe4:	b0008941 	adrp	x1, 6011543000 <_binary_default_fs_start+0x96000>
  601041abe8:	f942ec21 	ldr	x1, [x1, #1496]
  601041abec:	b9031822 	str	w2, [x1, #792]
  601041abf0:	2a0003e1 	mov	w1, w0
  601041abf4:	f9400fe0 	ldr	x0, [sp, #24]
  601041abf8:	b9001001 	str	w1, [x0, #16]
    task->thread_context.user_stack_idx = -1;
  601041abfc:	f9400fe0 	ldr	x0, [sp, #24]
  601041ac00:	12800001 	mov	w1, #0xffffffff            	// #-1
  601041ac04:	b9002801 	str	w1, [x0, #40]

    return task;
  601041ac08:	f9400fe0 	ldr	x0, [sp, #24]
}
  601041ac0c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  601041ac10:	d65f03c0 	ret

000000601041ac14 <_task_return_sys_resources>:

int _task_return_sys_resources(struct Thread* ptask)
{
  601041ac14:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  601041ac18:	910003fd 	mov	x29, sp
  601041ac1c:	f9000fe0 	str	x0, [sp, #24]
    assert(ptask != NULL);
  601041ac20:	f9400fe0 	ldr	x0, [sp, #24]
  601041ac24:	f100001f 	cmp	x0, #0x0
  601041ac28:	540001e1 	b.ne	601041ac64 <_task_return_sys_resources+0x50>  // b.any
  601041ac2c:	52800d22 	mov	w2, #0x69                  	// #105
  601041ac30:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041ac34:	91316001 	add	x1, x0, #0xc58
  601041ac38:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041ac3c:	91216000 	add	x0, x0, #0x858
  601041ac40:	97ffe54e 	bl	6010414178 <printf_>
  601041ac44:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041ac48:	9122e001 	add	x1, x0, #0x8b8
  601041ac4c:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041ac50:	91222000 	add	x0, x0, #0x888
  601041ac54:	97ffe549 	bl	6010414178 <printf_>
  601041ac58:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041ac5c:	91226000 	add	x0, x0, #0x898
  601041ac60:	97ffd192 	bl	601040f2a8 <panic>

    /* handle sessions for condition 1, ref. delete_share_pages() */
    struct session_backend* session_backend = NULL;
  601041ac64:	f9001fff 	str	xzr, [sp, #56]
    // close all server_sessions
    struct server_session* server_session = NULL;
  601041ac68:	f9001bff 	str	xzr, [sp, #48]
    while (!IS_DOUBLE_LIST_EMPTY(&ptask->svr_sess_listhead)) {
  601041ac6c:	14000032 	b	601041ad34 <_task_return_sys_resources+0x120>
        server_session = CONTAINER_OF(ptask->svr_sess_listhead.next, struct server_session, node);
  601041ac70:	f9400fe0 	ldr	x0, [sp, #24]
  601041ac74:	f9403c00 	ldr	x0, [x0, #120]
  601041ac78:	f9001be0 	str	x0, [sp, #48]
        assert(server_session != NULL);
  601041ac7c:	f9401be0 	ldr	x0, [sp, #48]
  601041ac80:	f100001f 	cmp	x0, #0x0
  601041ac84:	540001e1 	b.ne	601041acc0 <_task_return_sys_resources+0xac>  // b.any
  601041ac88:	52800e22 	mov	w2, #0x71                  	// #113
  601041ac8c:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041ac90:	91316001 	add	x1, x0, #0xc58
  601041ac94:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041ac98:	91216000 	add	x0, x0, #0x858
  601041ac9c:	97ffe537 	bl	6010414178 <printf_>
  601041aca0:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041aca4:	91232001 	add	x1, x0, #0x8c8
  601041aca8:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041acac:	91222000 	add	x0, x0, #0x888
  601041acb0:	97ffe532 	bl	6010414178 <printf_>
  601041acb4:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041acb8:	91226000 	add	x0, x0, #0x898
  601041acbc:	97ffd17b 	bl	601040f2a8 <panic>
        session_backend = SERVER_SESSION_BACKEND(server_session);
  601041acc0:	f9401be0 	ldr	x0, [sp, #48]
  601041acc4:	f9001fe0 	str	x0, [sp, #56]
        assert(session_backend->server == ptask);
  601041acc8:	f9401fe0 	ldr	x0, [sp, #56]
  601041accc:	f9402c00 	ldr	x0, [x0, #88]
  601041acd0:	f9400fe1 	ldr	x1, [sp, #24]
  601041acd4:	eb00003f 	cmp	x1, x0
  601041acd8:	540001e0 	b.eq	601041ad14 <_task_return_sys_resources+0x100>  // b.none
  601041acdc:	52800e62 	mov	w2, #0x73                  	// #115
  601041ace0:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041ace4:	91316001 	add	x1, x0, #0xc58
  601041ace8:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041acec:	91216000 	add	x0, x0, #0x858
  601041acf0:	97ffe522 	bl	6010414178 <printf_>
  601041acf4:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041acf8:	91238001 	add	x1, x0, #0x8e0
  601041acfc:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041ad00:	91222000 	add	x0, x0, #0x888
  601041ad04:	97ffe51d 	bl	6010414178 <printf_>
  601041ad08:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041ad0c:	91226000 	add	x0, x0, #0x898
  601041ad10:	97ffd166 	bl	601040f2a8 <panic>
        // cut the connection from task to session
        server_session->closed = true;
  601041ad14:	f9401be0 	ldr	x0, [sp, #48]
  601041ad18:	52800021 	mov	w1, #0x1                   	// #1
  601041ad1c:	39009001 	strb	w1, [x0, #36]
        xizi_share_page_manager.delete_share_pages(session_backend);
  601041ad20:	b0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041ad24:	f942e400 	ldr	x0, [x0, #1480]
  601041ad28:	f9400801 	ldr	x1, [x0, #16]
  601041ad2c:	f9401fe0 	ldr	x0, [sp, #56]
  601041ad30:	d63f0020 	blr	x1
    while (!IS_DOUBLE_LIST_EMPTY(&ptask->svr_sess_listhead)) {
  601041ad34:	f9400fe0 	ldr	x0, [sp, #24]
  601041ad38:	f9403c01 	ldr	x1, [x0, #120]
  601041ad3c:	f9400fe0 	ldr	x0, [sp, #24]
  601041ad40:	9101e000 	add	x0, x0, #0x78
  601041ad44:	eb00003f 	cmp	x1, x0
  601041ad48:	54fff941 	b.ne	601041ac70 <_task_return_sys_resources+0x5c>  // b.any
    }
    // close all client_sessions
    struct client_session* client_session = NULL;
  601041ad4c:	f90017ff 	str	xzr, [sp, #40]
    while (!IS_DOUBLE_LIST_EMPTY(&ptask->cli_sess_listhead)) {
  601041ad50:	14000033 	b	601041ae1c <_task_return_sys_resources+0x208>
        client_session = CONTAINER_OF(ptask->cli_sess_listhead.next, struct client_session, node);
  601041ad54:	f9400fe0 	ldr	x0, [sp, #24]
  601041ad58:	f9403400 	ldr	x0, [x0, #104]
  601041ad5c:	f90017e0 	str	x0, [sp, #40]
        assert(client_session != NULL);
  601041ad60:	f94017e0 	ldr	x0, [sp, #40]
  601041ad64:	f100001f 	cmp	x0, #0x0
  601041ad68:	540001e1 	b.ne	601041ada4 <_task_return_sys_resources+0x190>  // b.any
  601041ad6c:	52800f82 	mov	w2, #0x7c                  	// #124
  601041ad70:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041ad74:	91316001 	add	x1, x0, #0xc58
  601041ad78:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041ad7c:	91216000 	add	x0, x0, #0x858
  601041ad80:	97ffe4fe 	bl	6010414178 <printf_>
  601041ad84:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041ad88:	91242001 	add	x1, x0, #0x908
  601041ad8c:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041ad90:	91222000 	add	x0, x0, #0x888
  601041ad94:	97ffe4f9 	bl	6010414178 <printf_>
  601041ad98:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041ad9c:	91226000 	add	x0, x0, #0x898
  601041ada0:	97ffd142 	bl	601040f2a8 <panic>
        session_backend = CLIENT_SESSION_BACKEND(client_session);
  601041ada4:	f94017e0 	ldr	x0, [sp, #40]
  601041ada8:	d100a000 	sub	x0, x0, #0x28
  601041adac:	f9001fe0 	str	x0, [sp, #56]
        assert(session_backend->client == ptask);
  601041adb0:	f9401fe0 	ldr	x0, [sp, #56]
  601041adb4:	f9402800 	ldr	x0, [x0, #80]
  601041adb8:	f9400fe1 	ldr	x1, [sp, #24]
  601041adbc:	eb00003f 	cmp	x1, x0
  601041adc0:	540001e0 	b.eq	601041adfc <_task_return_sys_resources+0x1e8>  // b.none
  601041adc4:	52800fc2 	mov	w2, #0x7e                  	// #126
  601041adc8:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041adcc:	91316001 	add	x1, x0, #0xc58
  601041add0:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041add4:	91216000 	add	x0, x0, #0x858
  601041add8:	97ffe4e8 	bl	6010414178 <printf_>
  601041addc:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041ade0:	91248001 	add	x1, x0, #0x920
  601041ade4:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041ade8:	91222000 	add	x0, x0, #0x888
  601041adec:	97ffe4e3 	bl	6010414178 <printf_>
  601041adf0:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041adf4:	91226000 	add	x0, x0, #0x898
  601041adf8:	97ffd12c 	bl	601040f2a8 <panic>
        // cut the connection from task to session
        client_session->closed = true;
  601041adfc:	f94017e0 	ldr	x0, [sp, #40]
  601041ae00:	52800021 	mov	w1, #0x1                   	// #1
  601041ae04:	39007001 	strb	w1, [x0, #28]
        xizi_share_page_manager.delete_share_pages(session_backend);
  601041ae08:	b0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041ae0c:	f942e400 	ldr	x0, [x0, #1480]
  601041ae10:	f9400801 	ldr	x1, [x0, #16]
  601041ae14:	f9401fe0 	ldr	x0, [sp, #56]
  601041ae18:	d63f0020 	blr	x1
    while (!IS_DOUBLE_LIST_EMPTY(&ptask->cli_sess_listhead)) {
  601041ae1c:	f9400fe0 	ldr	x0, [sp, #24]
  601041ae20:	f9403401 	ldr	x1, [x0, #104]
  601041ae24:	f9400fe0 	ldr	x0, [sp, #24]
  601041ae28:	9101a000 	add	x0, x0, #0x68
  601041ae2c:	eb00003f 	cmp	x1, x0
  601041ae30:	54fff921 	b.ne	601041ad54 <_task_return_sys_resources+0x140>  // b.any
    }

    if (ptask->server_identifier.meta != NULL) {
  601041ae34:	f9400fe0 	ldr	x0, [sp, #24]
  601041ae38:	f9404800 	ldr	x0, [x0, #144]
  601041ae3c:	f100001f 	cmp	x0, #0x0
  601041ae40:	540003a0 	b.eq	601041aeb4 <_task_return_sys_resources+0x2a0>  // b.none
        struct TraceTag server_identifier_owner;
        AchieveResourceTag(&server_identifier_owner, RequireRootTag(), "softkernel/server-identifier");
  601041ae44:	97ffebfd 	bl	6010415e38 <RequireRootTag>
  601041ae48:	aa0003e1 	mov	x1, x0
  601041ae4c:	910083e3 	add	x3, sp, #0x20
  601041ae50:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041ae54:	91252002 	add	x2, x0, #0x948
  601041ae58:	aa0303e0 	mov	x0, x3
  601041ae5c:	97ffebfa 	bl	6010415e44 <AchieveResourceTag>
        assert(server_identifier_owner.meta != NULL);
  601041ae60:	f94013e0 	ldr	x0, [sp, #32]
  601041ae64:	f100001f 	cmp	x0, #0x0
  601041ae68:	540001e1 	b.ne	601041aea4 <_task_return_sys_resources+0x290>  // b.any
  601041ae6c:	528010e2 	mov	w2, #0x87                  	// #135
  601041ae70:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041ae74:	91316001 	add	x1, x0, #0xc58
  601041ae78:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041ae7c:	91216000 	add	x0, x0, #0x858
  601041ae80:	97ffe4be 	bl	6010414178 <printf_>
  601041ae84:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041ae88:	9125a001 	add	x1, x0, #0x968
  601041ae8c:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041ae90:	91222000 	add	x0, x0, #0x888
  601041ae94:	97ffe4b9 	bl	6010414178 <printf_>
  601041ae98:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041ae9c:	91226000 	add	x0, x0, #0x898
  601041aea0:	97ffd102 	bl	601040f2a8 <panic>
        DeleteResource(&ptask->server_identifier, &server_identifier_owner);
  601041aea4:	f9400fe0 	ldr	x0, [sp, #24]
  601041aea8:	91024000 	add	x0, x0, #0x90
  601041aeac:	910083e1 	add	x1, sp, #0x20
  601041aeb0:	97ffecde 	bl	6010416228 <DeleteResource>
    }

    // delete registered irq if there is one
    if (ptask->bind_irq) {
  601041aeb4:	f9400fe0 	ldr	x0, [sp, #24]
  601041aeb8:	39405000 	ldrb	w0, [x0, #20]
  601041aebc:	7100001f 	cmp	w0, #0x0
  601041aec0:	54000060 	b.eq	601041aecc <_task_return_sys_resources+0x2b8>  // b.none
        sys_unbind_irq_all(ptask);
  601041aec4:	f9400fe0 	ldr	x0, [sp, #24]
  601041aec8:	94001063 	bl	601041f054 <sys_unbind_irq_all>
    }

    return 0;
  601041aecc:	52800000 	mov	w0, #0x0                   	// #0
}
  601041aed0:	a8c47bfd 	ldp	x29, x30, [sp], #64
  601041aed4:	d65f03c0 	ret

000000601041aed8 <_dealloc_task_cb>:

/// @brief this function changes task list without locking, so it must be called inside a lock critical area
/// @param task
static void _dealloc_task_cb(struct Thread* task)
{
  601041aed8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  601041aedc:	910003fd 	mov	x29, sp
  601041aee0:	f9000fe0 	str	x0, [sp, #24]
    if (UNLIKELY(task == NULL)) {
  601041aee4:	f9400fe0 	ldr	x0, [sp, #24]
  601041aee8:	f100001f 	cmp	x0, #0x0
  601041aeec:	1a9f17e0 	cset	w0, eq  // eq = none
  601041aef0:	12001c00 	and	w0, w0, #0xff
  601041aef4:	92401c00 	and	x0, x0, #0xff
  601041aef8:	f100001f 	cmp	x0, #0x0
  601041aefc:	54000160 	b.eq	601041af28 <_dealloc_task_cb+0x50>  // b.none
        ERROR("deallocating a NULL task\n");
  601041af00:	52801302 	mov	w2, #0x98                  	// #152
  601041af04:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041af08:	9131e001 	add	x1, x0, #0xc78
  601041af0c:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041af10:	91216000 	add	x0, x0, #0x858
  601041af14:	97ffe499 	bl	6010414178 <printf_>
  601041af18:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041af1c:	91264000 	add	x0, x0, #0x990
  601041af20:	97ffe496 	bl	6010414178 <printf_>
        return;
  601041af24:	140000a0 	b	601041b1a4 <_dealloc_task_cb+0x2cc>
    }

    _task_return_sys_resources(task);
  601041af28:	f9400fe0 	ldr	x0, [sp, #24]
  601041af2c:	97ffff3a 	bl	601041ac14 <_task_return_sys_resources>

    /* free thread's user stack */
    if (task->thread_context.user_stack_idx != -1) {
  601041af30:	f9400fe0 	ldr	x0, [sp, #24]
  601041af34:	b9402800 	ldr	w0, [x0, #40]
  601041af38:	3100041f 	cmn	w0, #0x1
  601041af3c:	54000cc0 	b.eq	601041b0d4 <_dealloc_task_cb+0x1fc>  // b.none
        // stack is mapped in vspace, so it should be freed from pgdir
        assert(task->thread_context.user_stack_idx >= 0 && task->thread_context.user_stack_idx < 64);
  601041af40:	f9400fe0 	ldr	x0, [sp, #24]
  601041af44:	b9402800 	ldr	w0, [x0, #40]
  601041af48:	7100001f 	cmp	w0, #0x0
  601041af4c:	540000ab 	b.lt	601041af60 <_dealloc_task_cb+0x88>  // b.tstop
  601041af50:	f9400fe0 	ldr	x0, [sp, #24]
  601041af54:	b9402800 	ldr	w0, [x0, #40]
  601041af58:	7100fc1f 	cmp	w0, #0x3f
  601041af5c:	540001ed 	b.le	601041af98 <_dealloc_task_cb+0xc0>
  601041af60:	52801422 	mov	w2, #0xa1                  	// #161
  601041af64:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041af68:	9131e001 	add	x1, x0, #0xc78
  601041af6c:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041af70:	91216000 	add	x0, x0, #0x858
  601041af74:	97ffe481 	bl	6010414178 <printf_>
  601041af78:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041af7c:	9126c001 	add	x1, x0, #0x9b0
  601041af80:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041af84:	91222000 	add	x0, x0, #0x888
  601041af88:	97ffe47c 	bl	6010414178 <printf_>
  601041af8c:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041af90:	91226000 	add	x0, x0, #0x898
  601041af94:	97ffd0c5 	bl	601040f2a8 <panic>
        assert(task->memspace != NULL);
  601041af98:	f9400fe0 	ldr	x0, [sp, #24]
  601041af9c:	f9402800 	ldr	x0, [x0, #80]
  601041afa0:	f100001f 	cmp	x0, #0x0
  601041afa4:	540001e1 	b.ne	601041afe0 <_dealloc_task_cb+0x108>  // b.any
  601041afa8:	52801442 	mov	w2, #0xa2                  	// #162
  601041afac:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041afb0:	9131e001 	add	x1, x0, #0xc78
  601041afb4:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041afb8:	91216000 	add	x0, x0, #0x858
  601041afbc:	97ffe46f 	bl	6010414178 <printf_>
  601041afc0:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041afc4:	91282001 	add	x1, x0, #0xa08
  601041afc8:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041afcc:	91222000 	add	x0, x0, #0x888
  601041afd0:	97ffe46a 	bl	6010414178 <printf_>
  601041afd4:	90000040 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041afd8:	91226000 	add	x0, x0, #0x898
  601041afdc:	97ffd0b3 	bl	601040f2a8 <panic>

        /* the stack must have be set in memspace if bitmap has been set */
        assert(xizi_pager.unmap_pages(task->memspace->pgdir.pd_addr, task->thread_context.uspace_stack_addr, USER_STACK_SIZE));
  601041afe0:	b0008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041afe4:	f942b000 	ldr	x0, [x0, #1376]
  601041afe8:	f9400c03 	ldr	x3, [x0, #24]
  601041afec:	f9400fe0 	ldr	x0, [sp, #24]
  601041aff0:	f9402800 	ldr	x0, [x0, #80]
  601041aff4:	f9400004 	ldr	x4, [x0]
  601041aff8:	f9400fe0 	ldr	x0, [sp, #24]
  601041affc:	f9401800 	ldr	x0, [x0, #48]
  601041b000:	52820002 	mov	w2, #0x1000                	// #4096
  601041b004:	aa0003e1 	mov	x1, x0
  601041b008:	aa0403e0 	mov	x0, x4
  601041b00c:	d63f0060 	blr	x3
  601041b010:	12001c00 	and	w0, w0, #0xff
  601041b014:	52000000 	eor	w0, w0, #0x1
  601041b018:	12001c00 	and	w0, w0, #0xff
  601041b01c:	7100001f 	cmp	w0, #0x0
  601041b020:	540001e0 	b.eq	601041b05c <_dealloc_task_cb+0x184>  // b.none
  601041b024:	528014a2 	mov	w2, #0xa5                  	// #165
  601041b028:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b02c:	9131e001 	add	x1, x0, #0xc78
  601041b030:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b034:	91216000 	add	x0, x0, #0x858
  601041b038:	97ffe450 	bl	6010414178 <printf_>
  601041b03c:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b040:	91288001 	add	x1, x0, #0xa20
  601041b044:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b048:	91222000 	add	x0, x0, #0x888
  601041b04c:	97ffe44b 	bl	6010414178 <printf_>
  601041b050:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b054:	91226000 	add	x0, x0, #0x898
  601041b058:	97ffd094 	bl	601040f2a8 <panic>
        bitmap64_free(&task->memspace->thread_stack_idx_bitmap, task->thread_context.user_stack_idx);
  601041b05c:	f9400fe0 	ldr	x0, [sp, #24]
  601041b060:	f9402800 	ldr	x0, [x0, #80]
  601041b064:	91008002 	add	x2, x0, #0x20
  601041b068:	f9400fe0 	ldr	x0, [sp, #24]
  601041b06c:	b9402800 	ldr	w0, [x0, #40]
  601041b070:	2a0003e1 	mov	w1, w0
  601041b074:	aa0203e0 	mov	x0, x2
  601041b078:	97fffda0 	bl	601041a6f8 <bitmap64_free>
        /* thread's user stack space is also allocated for kernel free space */
        assert(kfree((char*)task->thread_context.ustack_kvaddr));
  601041b07c:	f9400fe0 	ldr	x0, [sp, #24]
  601041b080:	f9401c00 	ldr	x0, [x0, #56]
  601041b084:	97ffedaf 	bl	6010416740 <kfree>
  601041b088:	12001c00 	and	w0, w0, #0xff
  601041b08c:	52000000 	eor	w0, w0, #0x1
  601041b090:	12001c00 	and	w0, w0, #0xff
  601041b094:	7100001f 	cmp	w0, #0x0
  601041b098:	540001e0 	b.eq	601041b0d4 <_dealloc_task_cb+0x1fc>  // b.none
  601041b09c:	52801502 	mov	w2, #0xa8                  	// #168
  601041b0a0:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b0a4:	9131e001 	add	x1, x0, #0xc78
  601041b0a8:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b0ac:	91216000 	add	x0, x0, #0x858
  601041b0b0:	97ffe432 	bl	6010414178 <printf_>
  601041b0b4:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b0b8:	912a4001 	add	x1, x0, #0xa90
  601041b0bc:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b0c0:	91222000 	add	x0, x0, #0x888
  601041b0c4:	97ffe42d 	bl	6010414178 <printf_>
  601041b0c8:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b0cc:	91226000 	add	x0, x0, #0x898
  601041b0d0:	97ffd076 	bl	601040f2a8 <panic>
    }

    /* free thread's kernel stack */
    if (task->thread_context.kern_stack_addr) {
  601041b0d4:	f9400fe0 	ldr	x0, [sp, #24]
  601041b0d8:	f9401000 	ldr	x0, [x0, #32]
  601041b0dc:	f100001f 	cmp	x0, #0x0
  601041b0e0:	54000080 	b.eq	601041b0f0 <_dealloc_task_cb+0x218>  // b.none
        kfree((char*)task->thread_context.kern_stack_addr);
  601041b0e4:	f9400fe0 	ldr	x0, [sp, #24]
  601041b0e8:	f9401000 	ldr	x0, [x0, #32]
  601041b0ec:	97ffed95 	bl	6010416740 <kfree>
    }

    /* free memspace if needed to */
    if (task->memspace != NULL) {
  601041b0f0:	f9400fe0 	ldr	x0, [sp, #24]
  601041b0f4:	f9402800 	ldr	x0, [x0, #80]
  601041b0f8:	f100001f 	cmp	x0, #0x0
  601041b0fc:	54000460 	b.eq	601041b188 <_dealloc_task_cb+0x2b0>  // b.none
        doubleListDel(&task->memspace_list_node);
  601041b100:	f9400fe0 	ldr	x0, [sp, #24]
  601041b104:	91016000 	add	x0, x0, #0x58
  601041b108:	f9001fe0 	str	x0, [sp, #56]
    _double_list_del(entry->prev, entry->next);
  601041b10c:	f9401fe0 	ldr	x0, [sp, #56]
  601041b110:	f9400401 	ldr	x1, [x0, #8]
  601041b114:	f9401fe0 	ldr	x0, [sp, #56]
  601041b118:	f9400000 	ldr	x0, [x0]
  601041b11c:	f9001be1 	str	x1, [sp, #48]
  601041b120:	f90017e0 	str	x0, [sp, #40]
    next->prev = prev;
  601041b124:	f94017e0 	ldr	x0, [sp, #40]
  601041b128:	f9401be1 	ldr	x1, [sp, #48]
  601041b12c:	f9000401 	str	x1, [x0, #8]
    prev->next = next;
  601041b130:	f9401be0 	ldr	x0, [sp, #48]
  601041b134:	f94017e1 	ldr	x1, [sp, #40]
  601041b138:	f9000001 	str	x1, [x0]
}
  601041b13c:	d503201f 	nop
    entry->next = entry;
  601041b140:	f9401fe0 	ldr	x0, [sp, #56]
  601041b144:	f9401fe1 	ldr	x1, [sp, #56]
  601041b148:	f9000001 	str	x1, [x0]
    entry->prev = entry;
  601041b14c:	f9401fe0 	ldr	x0, [sp, #56]
  601041b150:	f9401fe1 	ldr	x1, [sp, #56]
  601041b154:	f9000401 	str	x1, [x0, #8]
}
  601041b158:	d503201f 	nop
        /* free memspace if thread is the last one using it */
        if (IS_DOUBLE_LIST_EMPTY(&task->memspace->thread_list_guard)) {
  601041b15c:	f9400fe0 	ldr	x0, [sp, #24]
  601041b160:	f9402800 	ldr	x0, [x0, #80]
  601041b164:	f9401401 	ldr	x1, [x0, #40]
  601041b168:	f9400fe0 	ldr	x0, [sp, #24]
  601041b16c:	f9402800 	ldr	x0, [x0, #80]
  601041b170:	9100a000 	add	x0, x0, #0x28
  601041b174:	eb00003f 	cmp	x1, x0
  601041b178:	54000081 	b.ne	601041b188 <_dealloc_task_cb+0x2b0>  // b.any
            // free memspace
            free_memspace(task->memspace);
  601041b17c:	f9400fe0 	ldr	x0, [sp, #24]
  601041b180:	f9402800 	ldr	x0, [x0, #80]
  601041b184:	94000424 	bl	601041c214 <free_memspace>
        }
    }

    // remove thread from used task list
    task_node_leave_list(task);
  601041b188:	f9400fe0 	ldr	x0, [sp, #24]
  601041b18c:	97fffd93 	bl	601041a7d8 <task_node_leave_list>

    // free task back to allocator
    slab_free(&xizi_task_manager.task_allocator, (void*)task);
  601041b190:	f9400fe1 	ldr	x1, [sp, #24]
  601041b194:	90008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041b198:	f942ec00 	ldr	x0, [x0, #1496]
  601041b19c:	910aa000 	add	x0, x0, #0x2a8
  601041b1a0:	97fff538 	bl	6010418680 <slab_free>
}
  601041b1a4:	a8c47bfd 	ldp	x29, x30, [sp], #64
  601041b1a8:	d65f03c0 	ret

000000601041b1ac <task_prepare_enter>:

/* alloc a new task with init */
extern void trap_return(void);
__attribute__((optimize("O0"))) void task_prepare_enter()
{
  601041b1ac:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601041b1b0:	910003fd 	mov	x29, sp
    xizi_leave_kernel();
  601041b1b4:	97fffb5c 	bl	6010419f24 <xizi_leave_kernel>
    trap_return();
  601041b1b8:	97ffd819 	bl	601041121c <trap_return>
}
  601041b1bc:	d503201f 	nop
  601041b1c0:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601041b1c4:	d65f03c0 	ret

000000601041b1c8 <_new_task_cb>:

static struct Thread* _new_task_cb(struct MemSpace* pmemspace)
{
  601041b1c8:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
  601041b1cc:	910003fd 	mov	x29, sp
  601041b1d0:	f9000fe0 	str	x0, [sp, #24]
    // alloc task space
    struct Thread* task = _alloc_task_cb();
  601041b1d4:	97fffe63 	bl	601041ab60 <_alloc_task_cb>
  601041b1d8:	f9003fe0 	str	x0, [sp, #120]
    if (!task) {
  601041b1dc:	f9403fe0 	ldr	x0, [sp, #120]
  601041b1e0:	f100001f 	cmp	x0, #0x0
  601041b1e4:	54000061 	b.ne	601041b1f0 <_new_task_cb+0x28>  // b.any
        return NULL;
  601041b1e8:	d2800000 	mov	x0, #0x0                   	// #0
  601041b1ec:	14000087 	b	601041b408 <_new_task_cb+0x240>
    }

    /* init basic task member */
    doubleListNodeInit(&task->cli_sess_listhead);
  601041b1f0:	f9403fe0 	ldr	x0, [sp, #120]
  601041b1f4:	9101a000 	add	x0, x0, #0x68
  601041b1f8:	f90033e0 	str	x0, [sp, #96]
    list->next = list;
  601041b1fc:	f94033e0 	ldr	x0, [sp, #96]
  601041b200:	f94033e1 	ldr	x1, [sp, #96]
  601041b204:	f9000001 	str	x1, [x0]
    list->prev = list;
  601041b208:	f94033e0 	ldr	x0, [sp, #96]
  601041b20c:	f94033e1 	ldr	x1, [sp, #96]
  601041b210:	f9000401 	str	x1, [x0, #8]
}
  601041b214:	d503201f 	nop
    doubleListNodeInit(&task->svr_sess_listhead);
  601041b218:	f9403fe0 	ldr	x0, [sp, #120]
  601041b21c:	9101e000 	add	x0, x0, #0x78
  601041b220:	f90037e0 	str	x0, [sp, #104]
    list->next = list;
  601041b224:	f94037e0 	ldr	x0, [sp, #104]
  601041b228:	f94037e1 	ldr	x1, [sp, #104]
  601041b22c:	f9000001 	str	x1, [x0]
    list->prev = list;
  601041b230:	f94037e0 	ldr	x0, [sp, #104]
  601041b234:	f94037e1 	ldr	x1, [sp, #104]
  601041b238:	f9000401 	str	x1, [x0, #8]
}
  601041b23c:	d503201f 	nop

    /* when creating a new task, memspace will be freed outside during memory shortage */
    task->memspace = NULL;
  601041b240:	f9403fe0 	ldr	x0, [sp, #120]
  601041b244:	f900281f 	str	xzr, [x0, #80]

    /* init main thread of task */
    task->thread_context.task = task;
  601041b248:	f9403fe0 	ldr	x0, [sp, #120]
  601041b24c:	f9403fe1 	ldr	x1, [sp, #120]
  601041b250:	f9000c01 	str	x1, [x0, #24]
    // alloc stack page for task
    if ((void*)(task->thread_context.kern_stack_addr = (uintptr_t)kalloc(USER_STACK_SIZE)) == NULL) {
  601041b254:	d2820000 	mov	x0, #0x1000                	// #4096
  601041b258:	97ffecf9 	bl	601041663c <kalloc>
  601041b25c:	aa0003e1 	mov	x1, x0
  601041b260:	f9403fe0 	ldr	x0, [sp, #120]
  601041b264:	f9001001 	str	x1, [x0, #32]
  601041b268:	f9403fe0 	ldr	x0, [sp, #120]
  601041b26c:	f9401000 	ldr	x0, [x0, #32]
  601041b270:	f100001f 	cmp	x0, #0x0
  601041b274:	540000a1 	b.ne	601041b288 <_new_task_cb+0xc0>  // b.any
        /* here inside, will no free memspace */
        _dealloc_task_cb(task);
  601041b278:	f9403fe0 	ldr	x0, [sp, #120]
  601041b27c:	97ffff17 	bl	601041aed8 <_dealloc_task_cb>
        return NULL;
  601041b280:	d2800000 	mov	x0, #0x0                   	// #0
  601041b284:	14000061 	b	601041b408 <_new_task_cb+0x240>
    }

    /* from now on, _new_task_cb() will not generate error */
    /* init vm */
    assert(pmemspace != NULL);
  601041b288:	f9400fe0 	ldr	x0, [sp, #24]
  601041b28c:	f100001f 	cmp	x0, #0x0
  601041b290:	540001e1 	b.ne	601041b2cc <_new_task_cb+0x104>  // b.any
  601041b294:	52801c62 	mov	w2, #0xe3                  	// #227
  601041b298:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b29c:	91328001 	add	x1, x0, #0xca0
  601041b2a0:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b2a4:	91216000 	add	x0, x0, #0x858
  601041b2a8:	97ffe3b4 	bl	6010414178 <printf_>
  601041b2ac:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b2b0:	912b2001 	add	x1, x0, #0xac8
  601041b2b4:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b2b8:	91222000 	add	x0, x0, #0x888
  601041b2bc:	97ffe3af 	bl	6010414178 <printf_>
  601041b2c0:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b2c4:	91226000 	add	x0, x0, #0x898
  601041b2c8:	97ffcff8 	bl	601040f2a8 <panic>
    task->memspace = pmemspace;
  601041b2cc:	f9403fe0 	ldr	x0, [sp, #120]
  601041b2d0:	f9400fe1 	ldr	x1, [sp, #24]
  601041b2d4:	f9002801 	str	x1, [x0, #80]
    task->thread_context.user_stack_idx = -1;
  601041b2d8:	f9403fe0 	ldr	x0, [sp, #120]
  601041b2dc:	12800001 	mov	w1, #0xffffffff            	// #-1
  601041b2e0:	b9002801 	str	w1, [x0, #40]
    doubleListNodeInit(&task->memspace_list_node);
  601041b2e4:	f9403fe0 	ldr	x0, [sp, #120]
  601041b2e8:	91016000 	add	x0, x0, #0x58
  601041b2ec:	f90017e0 	str	x0, [sp, #40]
    list->next = list;
  601041b2f0:	f94017e0 	ldr	x0, [sp, #40]
  601041b2f4:	f94017e1 	ldr	x1, [sp, #40]
  601041b2f8:	f9000001 	str	x1, [x0]
    list->prev = list;
  601041b2fc:	f94017e0 	ldr	x0, [sp, #40]
  601041b300:	f94017e1 	ldr	x1, [sp, #40]
  601041b304:	f9000401 	str	x1, [x0, #8]
}
  601041b308:	d503201f 	nop
    doubleListAddOnBack(&task->memspace_list_node, &pmemspace->thread_list_guard);
  601041b30c:	f9403fe0 	ldr	x0, [sp, #120]
  601041b310:	91016001 	add	x1, x0, #0x58
  601041b314:	f9400fe0 	ldr	x0, [sp, #24]
  601041b318:	9100a000 	add	x0, x0, #0x28
  601041b31c:	f9002be1 	str	x1, [sp, #80]
  601041b320:	f90027e0 	str	x0, [sp, #72]
    _double_list_add(new_node, head->prev, head);
  601041b324:	f94027e0 	ldr	x0, [sp, #72]
  601041b328:	f9400400 	ldr	x0, [x0, #8]
  601041b32c:	f9402be1 	ldr	x1, [sp, #80]
  601041b330:	f90023e1 	str	x1, [sp, #64]
  601041b334:	f9001fe0 	str	x0, [sp, #56]
  601041b338:	f94027e0 	ldr	x0, [sp, #72]
  601041b33c:	f9001be0 	str	x0, [sp, #48]
    next->prev = new_node;
  601041b340:	f9401be0 	ldr	x0, [sp, #48]
  601041b344:	f94023e1 	ldr	x1, [sp, #64]
  601041b348:	f9000401 	str	x1, [x0, #8]
    new_node->next = next;
  601041b34c:	f94023e0 	ldr	x0, [sp, #64]
  601041b350:	f9401be1 	ldr	x1, [sp, #48]
  601041b354:	f9000001 	str	x1, [x0]
    new_node->prev = prev;
  601041b358:	f94023e0 	ldr	x0, [sp, #64]
  601041b35c:	f9401fe1 	ldr	x1, [sp, #56]
  601041b360:	f9000401 	str	x1, [x0, #8]
    prev->next = new_node;
  601041b364:	f9401fe0 	ldr	x0, [sp, #56]
  601041b368:	f94023e1 	ldr	x1, [sp, #64]
  601041b36c:	f9000001 	str	x1, [x0]
}
  601041b370:	d503201f 	nop
}
  601041b374:	d503201f 	nop

    /* set context of main thread stack */
    /// stack bottom
    memset((void*)task->thread_context.kern_stack_addr, 0x00, USER_STACK_SIZE);
  601041b378:	f9403fe0 	ldr	x0, [sp, #120]
  601041b37c:	f9401000 	ldr	x0, [x0, #32]
  601041b380:	d2820002 	mov	x2, #0x1000                	// #4096
  601041b384:	52800001 	mov	w1, #0x0                   	// #0
  601041b388:	97ffcbce 	bl	601040e2c0 <memset>
    char* sp = (char*)task->thread_context.kern_stack_addr + USER_STACK_SIZE - 4;
  601041b38c:	f9403fe0 	ldr	x0, [sp, #120]
  601041b390:	f9401000 	ldr	x0, [x0, #32]
  601041b394:	913ff000 	add	x0, x0, #0xffc
  601041b398:	f9003be0 	str	x0, [sp, #112]

    /// 1. trap frame into stack, for process to nomally return by trap_return
    sp -= sizeof(*task->thread_context.trapframe);
  601041b39c:	f9403be0 	ldr	x0, [sp, #112]
  601041b3a0:	d1044000 	sub	x0, x0, #0x110
  601041b3a4:	f9003be0 	str	x0, [sp, #112]
    task->thread_context.trapframe = (struct trapframe*)sp;
  601041b3a8:	f9403fe0 	ldr	x0, [sp, #120]
  601041b3ac:	f9403be1 	ldr	x1, [sp, #112]
  601041b3b0:	f9002401 	str	x1, [x0, #72]

    /// 2. context into stack
    sp -= sizeof(*task->thread_context.context);
  601041b3b4:	f9403be0 	ldr	x0, [sp, #112]
  601041b3b8:	d101c000 	sub	x0, x0, #0x70
  601041b3bc:	f9003be0 	str	x0, [sp, #112]
    task->thread_context.context = (struct context*)sp;
  601041b3c0:	f9403fe0 	ldr	x0, [sp, #120]
  601041b3c4:	f9403be1 	ldr	x1, [sp, #112]
  601041b3c8:	f9002001 	str	x1, [x0, #64]
    arch_init_context(task->thread_context.context);
  601041b3cc:	f9403fe0 	ldr	x0, [sp, #120]
  601041b3d0:	f9402000 	ldr	x0, [x0, #64]
  601041b3d4:	f9002fe0 	str	x0, [sp, #88]
    memset(ctx, 0, sizeof(*ctx));
  601041b3d8:	d2800e02 	mov	x2, #0x70                  	// #112
  601041b3dc:	52800001 	mov	w1, #0x0                   	// #0
  601041b3e0:	f9402fe0 	ldr	x0, [sp, #88]
  601041b3e4:	97ffcbb7 	bl	601040e2c0 <memset>
    ctx->x30 = (uintptr_t)(task_prepare_enter + 4);
  601041b3e8:	90008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041b3ec:	f942a800 	ldr	x0, [x0, #1360]
  601041b3f0:	91001000 	add	x0, x0, #0x4
  601041b3f4:	aa0003e1 	mov	x1, x0
  601041b3f8:	f9402fe0 	ldr	x0, [sp, #88]
  601041b3fc:	f9003401 	str	x1, [x0, #104]
}
  601041b400:	d503201f 	nop

    return task;
  601041b404:	f9403fe0 	ldr	x0, [sp, #120]
}
  601041b408:	a8c87bfd 	ldp	x29, x30, [sp], #128
  601041b40c:	d65f03c0 	ret

000000601041b410 <_task_set_default_schedule_attr>:

static void _task_set_default_schedule_attr(struct Thread* task)
{
  601041b410:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  601041b414:	910003fd 	mov	x29, sp
  601041b418:	f9000fe0 	str	x0, [sp, #24]
    task->remain_tick = TASK_CLOCK_TICK;
  601041b41c:	f9400fe0 	ldr	x0, [sp, #24]
  601041b420:	52800641 	mov	w1, #0x32                  	// #50
  601041b424:	b900b001 	str	w1, [x0, #176]
    task->maxium_tick = TASK_CLOCK_TICK * 10;
  601041b428:	f9400fe0 	ldr	x0, [sp, #24]
  601041b42c:	52803e81 	mov	w1, #0x1f4                 	// #500
  601041b430:	b900b401 	str	w1, [x0, #180]
    task->state = READY;
  601041b434:	f9400fe0 	ldr	x0, [sp, #24]
  601041b438:	52800021 	mov	w1, #0x1                   	// #1
  601041b43c:	b900a801 	str	w1, [x0, #168]
    task->priority = TASK_DEFAULT_PRIORITY;
  601041b440:	f9400fe0 	ldr	x0, [sp, #24]
  601041b444:	52800041 	mov	w1, #0x2                   	// #2
  601041b448:	b900ac01 	str	w1, [x0, #172]
    task_node_add_to_ready_list_head(task);
  601041b44c:	f9400fe0 	ldr	x0, [sp, #24]
  601041b450:	97fffd1b 	bl	601041a8bc <task_node_add_to_ready_list_head>
}
  601041b454:	d503201f 	nop
  601041b458:	a8c27bfd 	ldp	x29, x30, [sp], #32
  601041b45c:	d65f03c0 	ret

000000601041b460 <task_state_set_running>:

static void task_state_set_running(struct Thread* task)
{
  601041b460:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  601041b464:	910003fd 	mov	x29, sp
  601041b468:	f9000fe0 	str	x0, [sp, #24]
    assert(task != NULL && task->state == READY);
  601041b46c:	f9400fe0 	ldr	x0, [sp, #24]
  601041b470:	f100001f 	cmp	x0, #0x0
  601041b474:	540000a0 	b.eq	601041b488 <task_state_set_running+0x28>  // b.none
  601041b478:	f9400fe0 	ldr	x0, [sp, #24]
  601041b47c:	b940a800 	ldr	w0, [x0, #168]
  601041b480:	7100041f 	cmp	w0, #0x1
  601041b484:	540001e0 	b.eq	601041b4c0 <task_state_set_running+0x60>  // b.none
  601041b488:	528020a2 	mov	w2, #0x105                 	// #261
  601041b48c:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b490:	9132c001 	add	x1, x0, #0xcb0
  601041b494:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b498:	91216000 	add	x0, x0, #0x858
  601041b49c:	97ffe337 	bl	6010414178 <printf_>
  601041b4a0:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b4a4:	912b8001 	add	x1, x0, #0xae0
  601041b4a8:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b4ac:	91222000 	add	x0, x0, #0x888
  601041b4b0:	97ffe332 	bl	6010414178 <printf_>
  601041b4b4:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b4b8:	91226000 	add	x0, x0, #0x898
  601041b4bc:	97ffcf7b 	bl	601040f2a8 <panic>
    task->state = RUNNING;
  601041b4c0:	f9400fe0 	ldr	x0, [sp, #24]
  601041b4c4:	52800041 	mov	w1, #0x2                   	// #2
  601041b4c8:	b900a801 	str	w1, [x0, #168]
    task_node_leave_list(task);
  601041b4cc:	f9400fe0 	ldr	x0, [sp, #24]
  601041b4d0:	97fffcc2 	bl	601041a7d8 <task_node_leave_list>
    doubleListAddOnHead(&task->node, &xizi_task_manager.task_running_list_head);
  601041b4d4:	f9400fe0 	ldr	x0, [sp, #24]
  601041b4d8:	91026000 	add	x0, x0, #0x98
  601041b4dc:	f90027e0 	str	x0, [sp, #72]
  601041b4e0:	90008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041b4e4:	f942ec00 	ldr	x0, [x0, #1496]
  601041b4e8:	91080000 	add	x0, x0, #0x200
  601041b4ec:	f90023e0 	str	x0, [sp, #64]
    _double_list_add(new_node, head, head->next);
  601041b4f0:	f94023e0 	ldr	x0, [sp, #64]
  601041b4f4:	f9400000 	ldr	x0, [x0]
  601041b4f8:	f94027e1 	ldr	x1, [sp, #72]
  601041b4fc:	f9001fe1 	str	x1, [sp, #56]
  601041b500:	f94023e1 	ldr	x1, [sp, #64]
  601041b504:	f9001be1 	str	x1, [sp, #48]
  601041b508:	f90017e0 	str	x0, [sp, #40]
    next->prev = new_node;
  601041b50c:	f94017e0 	ldr	x0, [sp, #40]
  601041b510:	f9401fe1 	ldr	x1, [sp, #56]
  601041b514:	f9000401 	str	x1, [x0, #8]
    new_node->next = next;
  601041b518:	f9401fe0 	ldr	x0, [sp, #56]
  601041b51c:	f94017e1 	ldr	x1, [sp, #40]
  601041b520:	f9000001 	str	x1, [x0]
    new_node->prev = prev;
  601041b524:	f9401fe0 	ldr	x0, [sp, #56]
  601041b528:	f9401be1 	ldr	x1, [sp, #48]
  601041b52c:	f9000401 	str	x1, [x0, #8]
    prev->next = new_node;
  601041b530:	f9401be0 	ldr	x0, [sp, #48]
  601041b534:	f9401fe1 	ldr	x1, [sp, #56]
  601041b538:	f9000001 	str	x1, [x0]
}
  601041b53c:	d503201f 	nop
}
  601041b540:	d503201f 	nop
}
  601041b544:	d503201f 	nop
  601041b548:	a8c57bfd 	ldp	x29, x30, [sp], #80
  601041b54c:	d65f03c0 	ret

000000601041b550 <_scheduler>:

struct Thread* next_task_emergency = NULL;
extern void context_switch(struct context**, struct context*);
static void _scheduler(struct SchedulerRightGroup right_group)
{
  601041b550:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  601041b554:	910003fd 	mov	x29, sp
  601041b558:	a90107e0 	stp	x0, x1, [sp, #16]
    struct MmuCommonDone* p_mmu_driver = AchieveResource(&right_group.mmu_driver_tag);
  601041b55c:	910043e0 	add	x0, sp, #0x10
  601041b560:	91002000 	add	x0, x0, #0x8
  601041b564:	97ffea8b 	bl	6010415f90 <AchieveResource>
  601041b568:	f9001be0 	str	x0, [sp, #48]
    struct Thread* next_task;
    struct CPU* cpu = cur_cpu();
  601041b56c:	97fffc90 	bl	601041a7ac <cur_cpu>
  601041b570:	f90017e0 	str	x0, [sp, #40]

    while (1) {
        next_task = NULL;
  601041b574:	f9001fff 	str	xzr, [sp, #56]
        /* find next runnable task */
        assert(cur_cpu()->task == NULL);
  601041b578:	97fffc8d 	bl	601041a7ac <cur_cpu>
  601041b57c:	f9400400 	ldr	x0, [x0, #8]
  601041b580:	f100001f 	cmp	x0, #0x0
  601041b584:	540001e0 	b.eq	601041b5c0 <_scheduler+0x70>  // b.none
  601041b588:	528022c2 	mov	w2, #0x116                 	// #278
  601041b58c:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b590:	91332001 	add	x1, x0, #0xcc8
  601041b594:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b598:	91216000 	add	x0, x0, #0x858
  601041b59c:	97ffe2f7 	bl	6010414178 <printf_>
  601041b5a0:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b5a4:	912c2001 	add	x1, x0, #0xb08
  601041b5a8:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b5ac:	91222000 	add	x0, x0, #0x888
  601041b5b0:	97ffe2f2 	bl	6010414178 <printf_>
  601041b5b4:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b5b8:	91226000 	add	x0, x0, #0x898
  601041b5bc:	97ffcf3b 	bl	601040f2a8 <panic>
        if (next_task_emergency != NULL && next_task_emergency->state == READY) {
  601041b5c0:	90008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041b5c4:	f9429400 	ldr	x0, [x0, #1320]
  601041b5c8:	f9400000 	ldr	x0, [x0]
  601041b5cc:	f100001f 	cmp	x0, #0x0
  601041b5d0:	54000180 	b.eq	601041b600 <_scheduler+0xb0>  // b.none
  601041b5d4:	90008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041b5d8:	f9429400 	ldr	x0, [x0, #1320]
  601041b5dc:	f9400000 	ldr	x0, [x0]
  601041b5e0:	b940a800 	ldr	w0, [x0, #168]
  601041b5e4:	7100041f 	cmp	w0, #0x1
  601041b5e8:	540000c1 	b.ne	601041b600 <_scheduler+0xb0>  // b.any
            next_task = next_task_emergency;
  601041b5ec:	90008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041b5f0:	f9429400 	ldr	x0, [x0, #1320]
  601041b5f4:	f9400000 	ldr	x0, [x0]
  601041b5f8:	f9001fe0 	str	x0, [sp, #56]
  601041b5fc:	14000006 	b	601041b614 <_scheduler+0xc4>
        } else {
            next_task = xizi_task_manager.next_runnable_task();
  601041b600:	90008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041b604:	f942ec00 	ldr	x0, [x0, #1496]
  601041b608:	f941a000 	ldr	x0, [x0, #832]
  601041b60c:	d63f0000 	blr	x0
  601041b610:	f9001fe0 	str	x0, [sp, #56]
        }
        next_task_emergency = NULL;
  601041b614:	90008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041b618:	f9429400 	ldr	x0, [x0, #1320]
  601041b61c:	f900001f 	str	xzr, [x0]

        /* if there's not a runnable task, wait for one */
        if (next_task == NULL) {
  601041b620:	f9401fe0 	ldr	x0, [sp, #56]
  601041b624:	f100001f 	cmp	x0, #0x0
  601041b628:	54000101 	b.ne	601041b648 <_scheduler+0xf8>  // b.any
            xizi_leave_kernel();
  601041b62c:	97fffa3e 	bl	6010419f24 <xizi_leave_kernel>
    WFE();
  601041b630:	d503205f 	wfe
}
  601041b634:	d503201f 	nop
            // there is no task to run, into low power mode
            cpu_into_low_power();

            /* leave kernel for other cores, so they may create a runnable task */
            xizi_enter_kernel();
  601041b638:	97fffa26 	bl	6010419ed0 <xizi_enter_kernel>
    SEV();
  601041b63c:	d503209f 	sev
}
  601041b640:	d503201f 	nop
            // activate cpu
            cpu_leave_low_power();
            continue;
  601041b644:	1400003c 	b	601041b734 <_scheduler+0x1e4>
        }

        /* run the chosen task */
        task_state_set_running(next_task);
  601041b648:	f9401fe0 	ldr	x0, [sp, #56]
  601041b64c:	97ffff85 	bl	601041b460 <task_state_set_running>
        cpu->task = next_task;
  601041b650:	f94017e0 	ldr	x0, [sp, #40]
  601041b654:	f9401fe1 	ldr	x1, [sp, #56]
  601041b658:	f9000401 	str	x1, [x0, #8]
        assert(next_task->memspace->pgdir.pd_addr != NULL);
  601041b65c:	f9401fe0 	ldr	x0, [sp, #56]
  601041b660:	f9402800 	ldr	x0, [x0, #80]
  601041b664:	f9400000 	ldr	x0, [x0]
  601041b668:	f100001f 	cmp	x0, #0x0
  601041b66c:	540001e1 	b.ne	601041b6a8 <_scheduler+0x158>  // b.any
  601041b670:	528025c2 	mov	w2, #0x12e                 	// #302
  601041b674:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b678:	91332001 	add	x1, x0, #0xcc8
  601041b67c:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b680:	91216000 	add	x0, x0, #0x858
  601041b684:	97ffe2bd 	bl	6010414178 <printf_>
  601041b688:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b68c:	912c8001 	add	x1, x0, #0xb20
  601041b690:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b694:	91222000 	add	x0, x0, #0x888
  601041b698:	97ffe2b8 	bl	6010414178 <printf_>
  601041b69c:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b6a0:	91226000 	add	x0, x0, #0x898
  601041b6a4:	97ffcf01 	bl	601040f2a8 <panic>
        p_mmu_driver->LoadPgdir((uintptr_t)V2P(next_task->memspace->pgdir.pd_addr));
  601041b6a8:	f9401be0 	ldr	x0, [sp, #48]
  601041b6ac:	f9401401 	ldr	x1, [x0, #40]
  601041b6b0:	f9401fe0 	ldr	x0, [sp, #56]
  601041b6b4:	f9402800 	ldr	x0, [x0, #80]
  601041b6b8:	f9400000 	ldr	x0, [x0]
  601041b6bc:	aa0003e2 	mov	x2, x0
  601041b6c0:	d2dff400 	mov	x0, #0xffa000000000        	// #281062659850240
  601041b6c4:	f2ffffe0 	movk	x0, #0xffff, lsl #48
  601041b6c8:	8b000040 	add	x0, x2, x0
  601041b6cc:	d63f0020 	blr	x1
        context_switch(&cpu->scheduler, next_task->thread_context.context);
  601041b6d0:	f94017e0 	ldr	x0, [sp, #40]
  601041b6d4:	91004002 	add	x2, x0, #0x10
  601041b6d8:	f9401fe0 	ldr	x0, [sp, #56]
  601041b6dc:	f9402000 	ldr	x0, [x0, #64]
  601041b6e0:	aa0003e1 	mov	x1, x0
  601041b6e4:	aa0203e0 	mov	x0, x2
  601041b6e8:	97ffcbf1 	bl	601040e6ac <context_switch>
        assert(next_task->state != RUNNING);
  601041b6ec:	f9401fe0 	ldr	x0, [sp, #56]
  601041b6f0:	b940a800 	ldr	w0, [x0, #168]
  601041b6f4:	7100081f 	cmp	w0, #0x2
  601041b6f8:	54fff3e1 	b.ne	601041b574 <_scheduler+0x24>  // b.any
  601041b6fc:	52802622 	mov	w2, #0x131                 	// #305
  601041b700:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b704:	91332001 	add	x1, x0, #0xcc8
  601041b708:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b70c:	91216000 	add	x0, x0, #0x858
  601041b710:	97ffe29a 	bl	6010414178 <printf_>
  601041b714:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b718:	912d4001 	add	x1, x0, #0xb50
  601041b71c:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b720:	91222000 	add	x0, x0, #0x888
  601041b724:	97ffe295 	bl	6010414178 <printf_>
  601041b728:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b72c:	91226000 	add	x0, x0, #0x898
  601041b730:	97ffcede 	bl	601040f2a8 <panic>
        next_task = NULL;
  601041b734:	17ffff90 	b	601041b574 <_scheduler+0x24>

000000601041b738 <_task_yield_noschedule>:
    }
}

static void _task_yield_noschedule(struct Thread* task, bool blocking)
{
  601041b738:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  601041b73c:	910003fd 	mov	x29, sp
  601041b740:	f9000fe0 	str	x0, [sp, #24]
  601041b744:	39005fe1 	strb	w1, [sp, #23]
    assert(task != NULL);
  601041b748:	f9400fe0 	ldr	x0, [sp, #24]
  601041b74c:	f100001f 	cmp	x0, #0x0
  601041b750:	540001e1 	b.ne	601041b78c <_task_yield_noschedule+0x54>  // b.any
  601041b754:	528026e2 	mov	w2, #0x137                 	// #311
  601041b758:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b75c:	91336001 	add	x1, x0, #0xcd8
  601041b760:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b764:	91216000 	add	x0, x0, #0x858
  601041b768:	97ffe284 	bl	6010414178 <printf_>
  601041b76c:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b770:	912dc001 	add	x1, x0, #0xb70
  601041b774:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b778:	91222000 	add	x0, x0, #0x888
  601041b77c:	97ffe27f 	bl	6010414178 <printf_>
  601041b780:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b784:	91226000 	add	x0, x0, #0x898
  601041b788:	97ffcec8 	bl	601040f2a8 <panic>
    /// @warning only support current task yield now
    assert(task == cur_cpu()->task && task->state == RUNNING);
  601041b78c:	97fffc08 	bl	601041a7ac <cur_cpu>
  601041b790:	f9400400 	ldr	x0, [x0, #8]
  601041b794:	f9400fe1 	ldr	x1, [sp, #24]
  601041b798:	eb00003f 	cmp	x1, x0
  601041b79c:	540000a1 	b.ne	601041b7b0 <_task_yield_noschedule+0x78>  // b.any
  601041b7a0:	f9400fe0 	ldr	x0, [sp, #24]
  601041b7a4:	b940a800 	ldr	w0, [x0, #168]
  601041b7a8:	7100081f 	cmp	w0, #0x2
  601041b7ac:	540001e0 	b.eq	601041b7e8 <_task_yield_noschedule+0xb0>  // b.none
  601041b7b0:	52802722 	mov	w2, #0x139                 	// #313
  601041b7b4:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b7b8:	91336001 	add	x1, x0, #0xcd8
  601041b7bc:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b7c0:	91216000 	add	x0, x0, #0x858
  601041b7c4:	97ffe26d 	bl	6010414178 <printf_>
  601041b7c8:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b7cc:	912e0001 	add	x1, x0, #0xb80
  601041b7d0:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b7d4:	91222000 	add	x0, x0, #0x888
  601041b7d8:	97ffe268 	bl	6010414178 <printf_>
  601041b7dc:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b7e0:	91226000 	add	x0, x0, #0x898
  601041b7e4:	97ffceb1 	bl	601040f2a8 <panic>

    // rearrage current task position
    task_node_leave_list(task);
  601041b7e8:	f9400fe0 	ldr	x0, [sp, #24]
  601041b7ec:	97fffbfb 	bl	601041a7d8 <task_node_leave_list>
    if (task->state == RUNNING) {
  601041b7f0:	f9400fe0 	ldr	x0, [sp, #24]
  601041b7f4:	b940a800 	ldr	w0, [x0, #168]
  601041b7f8:	7100081f 	cmp	w0, #0x2
  601041b7fc:	54000081 	b.ne	601041b80c <_task_yield_noschedule+0xd4>  // b.any
        task->state = READY;
  601041b800:	f9400fe0 	ldr	x0, [sp, #24]
  601041b804:	52800021 	mov	w1, #0x1                   	// #1
  601041b808:	b900a801 	str	w1, [x0, #168]
    }
    task->remain_tick = TASK_CLOCK_TICK;
  601041b80c:	f9400fe0 	ldr	x0, [sp, #24]
  601041b810:	52800641 	mov	w1, #0x32                  	// #50
  601041b814:	b900b001 	str	w1, [x0, #176]
    cur_cpu()->task = NULL;
  601041b818:	97fffbe5 	bl	601041a7ac <cur_cpu>
  601041b81c:	f900041f 	str	xzr, [x0, #8]
    task_node_add_to_ready_list_back(task);
  601041b820:	f9400fe0 	ldr	x0, [sp, #24]
  601041b824:	97fffc56 	bl	601041a97c <task_node_add_to_ready_list_back>
}
  601041b828:	d503201f 	nop
  601041b82c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  601041b830:	d65f03c0 	ret

000000601041b834 <_task_block>:

static void _task_block(struct double_list_node* head, struct Thread* task)
{
  601041b834:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  601041b838:	910003fd 	mov	x29, sp
  601041b83c:	f9000fe0 	str	x0, [sp, #24]
  601041b840:	f9000be1 	str	x1, [sp, #16]
    assert(head != NULL);
  601041b844:	f9400fe0 	ldr	x0, [sp, #24]
  601041b848:	f100001f 	cmp	x0, #0x0
  601041b84c:	540001e1 	b.ne	601041b888 <_task_block+0x54>  // b.any
  601041b850:	528028e2 	mov	w2, #0x147                 	// #327
  601041b854:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b858:	9133c001 	add	x1, x0, #0xcf0
  601041b85c:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b860:	91216000 	add	x0, x0, #0x858
  601041b864:	97ffe245 	bl	6010414178 <printf_>
  601041b868:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b86c:	912ee001 	add	x1, x0, #0xbb8
  601041b870:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b874:	91222000 	add	x0, x0, #0x888
  601041b878:	97ffe240 	bl	6010414178 <printf_>
  601041b87c:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b880:	91226000 	add	x0, x0, #0x898
  601041b884:	97ffce89 	bl	601040f2a8 <panic>
    assert(task != NULL);
  601041b888:	f9400be0 	ldr	x0, [sp, #16]
  601041b88c:	f100001f 	cmp	x0, #0x0
  601041b890:	540001e1 	b.ne	601041b8cc <_task_block+0x98>  // b.any
  601041b894:	52802902 	mov	w2, #0x148                 	// #328
  601041b898:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b89c:	9133c001 	add	x1, x0, #0xcf0
  601041b8a0:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b8a4:	91216000 	add	x0, x0, #0x858
  601041b8a8:	97ffe234 	bl	6010414178 <printf_>
  601041b8ac:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b8b0:	912dc001 	add	x1, x0, #0xb70
  601041b8b4:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b8b8:	91222000 	add	x0, x0, #0x888
  601041b8bc:	97ffe22f 	bl	6010414178 <printf_>
  601041b8c0:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b8c4:	91226000 	add	x0, x0, #0x898
  601041b8c8:	97ffce78 	bl	601040f2a8 <panic>
    assert(task->state != RUNNING);
  601041b8cc:	f9400be0 	ldr	x0, [sp, #16]
  601041b8d0:	b940a800 	ldr	w0, [x0, #168]
  601041b8d4:	7100081f 	cmp	w0, #0x2
  601041b8d8:	540001e1 	b.ne	601041b914 <_task_block+0xe0>  // b.any
  601041b8dc:	52802922 	mov	w2, #0x149                 	// #329
  601041b8e0:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b8e4:	9133c001 	add	x1, x0, #0xcf0
  601041b8e8:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b8ec:	91216000 	add	x0, x0, #0x858
  601041b8f0:	97ffe222 	bl	6010414178 <printf_>
  601041b8f4:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b8f8:	912f2001 	add	x1, x0, #0xbc8
  601041b8fc:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b900:	91222000 	add	x0, x0, #0x888
  601041b904:	97ffe21d 	bl	6010414178 <printf_>
  601041b908:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b90c:	91226000 	add	x0, x0, #0x898
  601041b910:	97ffce66 	bl	601040f2a8 <panic>
    task_node_leave_list(task);
  601041b914:	f9400be0 	ldr	x0, [sp, #16]
  601041b918:	97fffbb0 	bl	601041a7d8 <task_node_leave_list>
    task->state = BLOCKED;
  601041b91c:	f9400be0 	ldr	x0, [sp, #16]
  601041b920:	52800081 	mov	w1, #0x4                   	// #4
  601041b924:	b900a801 	str	w1, [x0, #168]
    doubleListAddOnHead(&task->node, head);
  601041b928:	f9400be0 	ldr	x0, [sp, #16]
  601041b92c:	91026000 	add	x0, x0, #0x98
  601041b930:	f90027e0 	str	x0, [sp, #72]
  601041b934:	f9400fe0 	ldr	x0, [sp, #24]
  601041b938:	f90023e0 	str	x0, [sp, #64]
    _double_list_add(new_node, head, head->next);
  601041b93c:	f94023e0 	ldr	x0, [sp, #64]
  601041b940:	f9400000 	ldr	x0, [x0]
  601041b944:	f94027e1 	ldr	x1, [sp, #72]
  601041b948:	f9001fe1 	str	x1, [sp, #56]
  601041b94c:	f94023e1 	ldr	x1, [sp, #64]
  601041b950:	f9001be1 	str	x1, [sp, #48]
  601041b954:	f90017e0 	str	x0, [sp, #40]
    next->prev = new_node;
  601041b958:	f94017e0 	ldr	x0, [sp, #40]
  601041b95c:	f9401fe1 	ldr	x1, [sp, #56]
  601041b960:	f9000401 	str	x1, [x0, #8]
    new_node->next = next;
  601041b964:	f9401fe0 	ldr	x0, [sp, #56]
  601041b968:	f94017e1 	ldr	x1, [sp, #40]
  601041b96c:	f9000001 	str	x1, [x0]
    new_node->prev = prev;
  601041b970:	f9401fe0 	ldr	x0, [sp, #56]
  601041b974:	f9401be1 	ldr	x1, [sp, #48]
  601041b978:	f9000401 	str	x1, [x0, #8]
    prev->next = new_node;
  601041b97c:	f9401be0 	ldr	x0, [sp, #48]
  601041b980:	f9401fe1 	ldr	x1, [sp, #56]
  601041b984:	f9000001 	str	x1, [x0]
}
  601041b988:	d503201f 	nop
}
  601041b98c:	d503201f 	nop
}
  601041b990:	d503201f 	nop
  601041b994:	a8c57bfd 	ldp	x29, x30, [sp], #80
  601041b998:	d65f03c0 	ret

000000601041b99c <_task_unblock>:

static void _task_unblock(struct Thread* task)
{
  601041b99c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  601041b9a0:	910003fd 	mov	x29, sp
  601041b9a4:	f9000fe0 	str	x0, [sp, #24]
    assert(task != NULL);
  601041b9a8:	f9400fe0 	ldr	x0, [sp, #24]
  601041b9ac:	f100001f 	cmp	x0, #0x0
  601041b9b0:	540001e1 	b.ne	601041b9ec <_task_unblock+0x50>  // b.any
  601041b9b4:	52802a22 	mov	w2, #0x151                 	// #337
  601041b9b8:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b9bc:	91340001 	add	x1, x0, #0xd00
  601041b9c0:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b9c4:	91216000 	add	x0, x0, #0x858
  601041b9c8:	97ffe1ec 	bl	6010414178 <printf_>
  601041b9cc:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b9d0:	912dc001 	add	x1, x0, #0xb70
  601041b9d4:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b9d8:	91222000 	add	x0, x0, #0x888
  601041b9dc:	97ffe1e7 	bl	6010414178 <printf_>
  601041b9e0:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041b9e4:	91226000 	add	x0, x0, #0x898
  601041b9e8:	97ffce30 	bl	601040f2a8 <panic>
    assert(task->state == BLOCKED);
  601041b9ec:	f9400fe0 	ldr	x0, [sp, #24]
  601041b9f0:	b940a800 	ldr	w0, [x0, #168]
  601041b9f4:	7100101f 	cmp	w0, #0x4
  601041b9f8:	540001e0 	b.eq	601041ba34 <_task_unblock+0x98>  // b.none
  601041b9fc:	52802a42 	mov	w2, #0x152                 	// #338
  601041ba00:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041ba04:	91340001 	add	x1, x0, #0xd00
  601041ba08:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041ba0c:	91216000 	add	x0, x0, #0x858
  601041ba10:	97ffe1da 	bl	6010414178 <printf_>
  601041ba14:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041ba18:	912f8001 	add	x1, x0, #0xbe0
  601041ba1c:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041ba20:	91222000 	add	x0, x0, #0x888
  601041ba24:	97ffe1d5 	bl	6010414178 <printf_>
  601041ba28:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041ba2c:	91226000 	add	x0, x0, #0x898
  601041ba30:	97ffce1e 	bl	601040f2a8 <panic>
    task_node_leave_list(task);
  601041ba34:	f9400fe0 	ldr	x0, [sp, #24]
  601041ba38:	97fffb68 	bl	601041a7d8 <task_node_leave_list>
    task->state = READY;
  601041ba3c:	f9400fe0 	ldr	x0, [sp, #24]
  601041ba40:	52800021 	mov	w1, #0x1                   	// #1
  601041ba44:	b900a801 	str	w1, [x0, #168]
    task_node_add_to_ready_list_head(task);
  601041ba48:	f9400fe0 	ldr	x0, [sp, #24]
  601041ba4c:	97fffb9c 	bl	601041a8bc <task_node_add_to_ready_list_head>
}
  601041ba50:	d503201f 	nop
  601041ba54:	a8c27bfd 	ldp	x29, x30, [sp], #32
  601041ba58:	d65f03c0 	ret

000000601041ba5c <_set_cur_task_priority>:

/// @brief  @warning not tested function
/// @param priority
static void _set_cur_task_priority(int priority)
{
  601041ba5c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  601041ba60:	910003fd 	mov	x29, sp
  601041ba64:	b9001fe0 	str	w0, [sp, #28]
    if (priority < 0 || priority >= TASK_MAX_PRIORITY) {
  601041ba68:	b9401fe0 	ldr	w0, [sp, #28]
  601041ba6c:	7100001f 	cmp	w0, #0x0
  601041ba70:	5400008b 	b.lt	601041ba80 <_set_cur_task_priority+0x24>  // b.tstop
  601041ba74:	b9401fe0 	ldr	w0, [sp, #28]
  601041ba78:	71007c1f 	cmp	w0, #0x1f
  601041ba7c:	5400016d 	b.le	601041baa8 <_set_cur_task_priority+0x4c>
        ERROR("priority is invalid\n");
  601041ba80:	52802ba2 	mov	w2, #0x15d                 	// #349
  601041ba84:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041ba88:	91344001 	add	x1, x0, #0xd10
  601041ba8c:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041ba90:	91216000 	add	x0, x0, #0x858
  601041ba94:	97ffe1b9 	bl	6010414178 <printf_>
  601041ba98:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041ba9c:	912fe000 	add	x0, x0, #0xbf8
  601041baa0:	97ffe1b6 	bl	6010414178 <printf_>
        return;
  601041baa4:	14000021 	b	601041bb28 <_set_cur_task_priority+0xcc>
    }

    struct Thread* current_task = cur_cpu()->task;
  601041baa8:	97fffb41 	bl	601041a7ac <cur_cpu>
  601041baac:	f9400400 	ldr	x0, [x0, #8]
  601041bab0:	f90017e0 	str	x0, [sp, #40]
    assert(current_task != NULL && current_task->state == RUNNING);
  601041bab4:	f94017e0 	ldr	x0, [sp, #40]
  601041bab8:	f100001f 	cmp	x0, #0x0
  601041babc:	540000a0 	b.eq	601041bad0 <_set_cur_task_priority+0x74>  // b.none
  601041bac0:	f94017e0 	ldr	x0, [sp, #40]
  601041bac4:	b940a800 	ldr	w0, [x0, #168]
  601041bac8:	7100081f 	cmp	w0, #0x2
  601041bacc:	540001e0 	b.eq	601041bb08 <_set_cur_task_priority+0xac>  // b.none
  601041bad0:	52802c42 	mov	w2, #0x162                 	// #354
  601041bad4:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041bad8:	91344001 	add	x1, x0, #0xd10
  601041badc:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041bae0:	91216000 	add	x0, x0, #0x858
  601041bae4:	97ffe1a5 	bl	6010414178 <printf_>
  601041bae8:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041baec:	91304001 	add	x1, x0, #0xc10
  601041baf0:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041baf4:	91222000 	add	x0, x0, #0x888
  601041baf8:	97ffe1a0 	bl	6010414178 <printf_>
  601041bafc:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041bb00:	91226000 	add	x0, x0, #0x898
  601041bb04:	97ffcde9 	bl	601040f2a8 <panic>

    task_node_leave_list(current_task);
  601041bb08:	f94017e0 	ldr	x0, [sp, #40]
  601041bb0c:	97fffb33 	bl	601041a7d8 <task_node_leave_list>

    current_task->priority = priority;
  601041bb10:	f94017e0 	ldr	x0, [sp, #40]
  601041bb14:	b9401fe1 	ldr	w1, [sp, #28]
  601041bb18:	b900ac01 	str	w1, [x0, #172]

    task_node_add_to_ready_list_back(current_task);
  601041bb1c:	f94017e0 	ldr	x0, [sp, #40]
  601041bb20:	97fffb97 	bl	601041a97c <task_node_add_to_ready_list_back>

    return;
  601041bb24:	d503201f 	nop
}
  601041bb28:	a8c37bfd 	ldp	x29, x30, [sp], #48
  601041bb2c:	d65f03c0 	ret

000000601041bb30 <module_task_manager_init>:
    .task_yield_noschedule = _task_yield_noschedule,
    .set_cur_task_priority = _set_cur_task_priority
};

bool module_task_manager_init(void)
{
  601041bb30:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601041bb34:	910003fd 	mov	x29, sp
    xizi_task_manager.init();
  601041bb38:	90008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041bb3c:	f942ec00 	ldr	x0, [x0, #1496]
  601041bb40:	f9419000 	ldr	x0, [x0, #800]
  601041bb44:	d63f0000 	blr	x0
    return true;
  601041bb48:	52800020 	mov	w0, #0x1                   	// #1
}
  601041bb4c:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601041bb50:	d65f03c0 	ret

000000601041bb54 <max_priority_runnable_task>:
*************************************************/
#include "log.h"
#include "scheduler.h"

struct Thread* max_priority_runnable_task(void)
{
  601041bb54:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601041bb58:	910003fd 	mov	x29, sp
    static struct Thread* task = NULL;
    static int priority = 0;

    priority = __builtin_ffs(ready_task_priority) - 1;
  601041bb5c:	90008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041bb60:	f942f800 	ldr	x0, [x0, #1520]
  601041bb64:	b9400000 	ldr	w0, [x0]
  601041bb68:	7100001f 	cmp	w0, #0x0
  601041bb6c:	5ac00000 	rbit	w0, w0
  601041bb70:	5ac01000 	clz	w0, w0
  601041bb74:	1a8007e0 	csinc	w0, wzr, w0, eq  // eq = none
  601041bb78:	51000401 	sub	w1, w0, #0x1
  601041bb7c:	9000b940 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041bb80:	912dc000 	add	x0, x0, #0xb70
  601041bb84:	b9000001 	str	w1, [x0]
    if (priority > 31 || priority < 0) {
  601041bb88:	9000b940 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041bb8c:	912dc000 	add	x0, x0, #0xb70
  601041bb90:	b9400000 	ldr	w0, [x0]
  601041bb94:	71007c1f 	cmp	w0, #0x1f
  601041bb98:	540000cc 	b.gt	601041bbb0 <max_priority_runnable_task+0x5c>
  601041bb9c:	9000b940 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041bba0:	912dc000 	add	x0, x0, #0xb70
  601041bba4:	b9400000 	ldr	w0, [x0]
  601041bba8:	7100001f 	cmp	w0, #0x0
  601041bbac:	5400006a 	b.ge	601041bbb8 <max_priority_runnable_task+0x64>  // b.tcont
        return NULL;
  601041bbb0:	d2800000 	mov	x0, #0x0                   	// #0
  601041bbb4:	14000060 	b	601041bd34 <max_priority_runnable_task+0x1e0>
    }

    DOUBLE_LIST_FOR_EACH_ENTRY(task, &xizi_task_manager.task_list_head[priority], node)
  601041bbb8:	9000b940 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041bbbc:	912dc000 	add	x0, x0, #0xb70
  601041bbc0:	b9400002 	ldr	w2, [x0]
  601041bbc4:	90008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041bbc8:	f942ec01 	ldr	x1, [x0, #1496]
  601041bbcc:	93407c40 	sxtw	x0, w2
  601041bbd0:	d37cec00 	lsl	x0, x0, #4
  601041bbd4:	8b000020 	add	x0, x1, x0
  601041bbd8:	f9400000 	ldr	x0, [x0]
  601041bbdc:	d1026001 	sub	x1, x0, #0x98
  601041bbe0:	9000b940 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041bbe4:	912da000 	add	x0, x0, #0xb68
  601041bbe8:	f9000001 	str	x1, [x0]
  601041bbec:	14000043 	b	601041bcf8 <max_priority_runnable_task+0x1a4>
    {
        assert(task != NULL);
  601041bbf0:	9000b940 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041bbf4:	912da000 	add	x0, x0, #0xb68
  601041bbf8:	f9400000 	ldr	x0, [x0]
  601041bbfc:	f100001f 	cmp	x0, #0x0
  601041bc00:	540001e1 	b.ne	601041bc3c <max_priority_runnable_task+0xe8>  // b.any
  601041bc04:	528005a2 	mov	w2, #0x2d                  	// #45
  601041bc08:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041bc0c:	91358001 	add	x1, x0, #0xd60
  601041bc10:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041bc14:	9134a000 	add	x0, x0, #0xd28
  601041bc18:	97ffe158 	bl	6010414178 <printf_>
  601041bc1c:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041bc20:	9134e001 	add	x1, x0, #0xd38
  601041bc24:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041bc28:	91352000 	add	x0, x0, #0xd48
  601041bc2c:	97ffe153 	bl	6010414178 <printf_>
  601041bc30:	f0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041bc34:	91356000 	add	x0, x0, #0xd58
  601041bc38:	97ffcd9c 	bl	601040f2a8 <panic>
        if (task->state == READY && !task->dead) {
  601041bc3c:	9000b940 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041bc40:	912da000 	add	x0, x0, #0xb68
  601041bc44:	f9400000 	ldr	x0, [x0]
  601041bc48:	b940a800 	ldr	w0, [x0, #168]
  601041bc4c:	7100041f 	cmp	w0, #0x1
  601041bc50:	540001a1 	b.ne	601041bc84 <max_priority_runnable_task+0x130>  // b.any
  601041bc54:	9000b940 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041bc58:	912da000 	add	x0, x0, #0xb68
  601041bc5c:	f9400000 	ldr	x0, [x0]
  601041bc60:	39405400 	ldrb	w0, [x0, #21]
  601041bc64:	52000000 	eor	w0, w0, #0x1
  601041bc68:	12001c00 	and	w0, w0, #0xff
  601041bc6c:	7100001f 	cmp	w0, #0x0
  601041bc70:	540000a0 	b.eq	601041bc84 <max_priority_runnable_task+0x130>  // b.none
            // found a runnable task, stop this look up
            return task;
  601041bc74:	9000b940 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041bc78:	912da000 	add	x0, x0, #0xb68
  601041bc7c:	f9400000 	ldr	x0, [x0]
  601041bc80:	1400002d 	b	601041bd34 <max_priority_runnable_task+0x1e0>
        } else if (task->dead && task->state != RUNNING) {
  601041bc84:	9000b940 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041bc88:	912da000 	add	x0, x0, #0xb68
  601041bc8c:	f9400000 	ldr	x0, [x0]
  601041bc90:	39405400 	ldrb	w0, [x0, #21]
  601041bc94:	7100001f 	cmp	w0, #0x0
  601041bc98:	54000200 	b.eq	601041bcd8 <max_priority_runnable_task+0x184>  // b.none
  601041bc9c:	9000b940 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041bca0:	912da000 	add	x0, x0, #0xb68
  601041bca4:	f9400000 	ldr	x0, [x0]
  601041bca8:	b940a800 	ldr	w0, [x0, #168]
  601041bcac:	7100081f 	cmp	w0, #0x2
  601041bcb0:	54000140 	b.eq	601041bcd8 <max_priority_runnable_task+0x184>  // b.none
            xizi_task_manager.free_pcb(task);
  601041bcb4:	90008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041bcb8:	f942ec00 	ldr	x0, [x0, #1496]
  601041bcbc:	f9419801 	ldr	x1, [x0, #816]
  601041bcc0:	9000b940 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041bcc4:	912da000 	add	x0, x0, #0xb68
  601041bcc8:	f9400000 	ldr	x0, [x0]
  601041bccc:	d63f0020 	blr	x1
            return NULL;
  601041bcd0:	d2800000 	mov	x0, #0x0                   	// #0
  601041bcd4:	14000018 	b	601041bd34 <max_priority_runnable_task+0x1e0>
    DOUBLE_LIST_FOR_EACH_ENTRY(task, &xizi_task_manager.task_list_head[priority], node)
  601041bcd8:	9000b940 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041bcdc:	912da000 	add	x0, x0, #0xb68
  601041bce0:	f9400000 	ldr	x0, [x0]
  601041bce4:	f9404c00 	ldr	x0, [x0, #152]
  601041bce8:	d1026001 	sub	x1, x0, #0x98
  601041bcec:	9000b940 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041bcf0:	912da000 	add	x0, x0, #0xb68
  601041bcf4:	f9000001 	str	x1, [x0]
  601041bcf8:	9000b940 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041bcfc:	912da000 	add	x0, x0, #0xb68
  601041bd00:	f9400000 	ldr	x0, [x0]
  601041bd04:	91026001 	add	x1, x0, #0x98
  601041bd08:	9000b940 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041bd0c:	912dc000 	add	x0, x0, #0xb70
  601041bd10:	b9400000 	ldr	w0, [x0]
  601041bd14:	93407c00 	sxtw	x0, w0
  601041bd18:	d37cec02 	lsl	x2, x0, #4
  601041bd1c:	90008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041bd20:	f942ec00 	ldr	x0, [x0, #1496]
  601041bd24:	8b000040 	add	x0, x2, x0
  601041bd28:	eb00003f 	cmp	x1, x0
  601041bd2c:	54fff621 	b.ne	601041bbf0 <max_priority_runnable_task+0x9c>  // b.any
        }
    }
    return NULL;
  601041bd30:	d2800000 	mov	x0, #0x0                   	// #0
}
  601041bd34:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601041bd38:	d65f03c0 	ret

000000601041bd3c <round_robin_runnable_task>:

struct Thread* round_robin_runnable_task(uint32_t priority)
{
  601041bd3c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  601041bd40:	910003fd 	mov	x29, sp
  601041bd44:	b9001fe0 	str	w0, [sp, #28]
    struct Thread* task = NULL;
  601041bd48:	f90017ff 	str	xzr, [sp, #40]

    DOUBLE_LIST_FOR_EACH_ENTRY(task, &xizi_task_manager.task_list_head[priority], node)
  601041bd4c:	90008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041bd50:	f942ec01 	ldr	x1, [x0, #1496]
  601041bd54:	b9401fe0 	ldr	w0, [sp, #28]
  601041bd58:	d37cec00 	lsl	x0, x0, #4
  601041bd5c:	8b000020 	add	x0, x1, x0
  601041bd60:	f9400000 	ldr	x0, [x0]
  601041bd64:	d1026000 	sub	x0, x0, #0x98
  601041bd68:	f90017e0 	str	x0, [sp, #40]
  601041bd6c:	14000020 	b	601041bdec <round_robin_runnable_task+0xb0>
    {
        if (task->state == READY && !task->dead) {
  601041bd70:	f94017e0 	ldr	x0, [sp, #40]
  601041bd74:	b940a800 	ldr	w0, [x0, #168]
  601041bd78:	7100041f 	cmp	w0, #0x1
  601041bd7c:	54000121 	b.ne	601041bda0 <round_robin_runnable_task+0x64>  // b.any
  601041bd80:	f94017e0 	ldr	x0, [sp, #40]
  601041bd84:	39405400 	ldrb	w0, [x0, #21]
  601041bd88:	52000000 	eor	w0, w0, #0x1
  601041bd8c:	12001c00 	and	w0, w0, #0xff
  601041bd90:	7100001f 	cmp	w0, #0x0
  601041bd94:	54000060 	b.eq	601041bda0 <round_robin_runnable_task+0x64>  // b.none
            // found a runnable task, stop this look up
            return task;
  601041bd98:	f94017e0 	ldr	x0, [sp, #40]
  601041bd9c:	1400001e 	b	601041be14 <round_robin_runnable_task+0xd8>
        } else if (task->dead && task->state != RUNNING) {
  601041bda0:	f94017e0 	ldr	x0, [sp, #40]
  601041bda4:	39405400 	ldrb	w0, [x0, #21]
  601041bda8:	7100001f 	cmp	w0, #0x0
  601041bdac:	54000180 	b.eq	601041bddc <round_robin_runnable_task+0xa0>  // b.none
  601041bdb0:	f94017e0 	ldr	x0, [sp, #40]
  601041bdb4:	b940a800 	ldr	w0, [x0, #168]
  601041bdb8:	7100081f 	cmp	w0, #0x2
  601041bdbc:	54000100 	b.eq	601041bddc <round_robin_runnable_task+0xa0>  // b.none
            xizi_task_manager.free_pcb(task);
  601041bdc0:	90008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041bdc4:	f942ec00 	ldr	x0, [x0, #1496]
  601041bdc8:	f9419801 	ldr	x1, [x0, #816]
  601041bdcc:	f94017e0 	ldr	x0, [sp, #40]
  601041bdd0:	d63f0020 	blr	x1
            return NULL;
  601041bdd4:	d2800000 	mov	x0, #0x0                   	// #0
  601041bdd8:	1400000f 	b	601041be14 <round_robin_runnable_task+0xd8>
    DOUBLE_LIST_FOR_EACH_ENTRY(task, &xizi_task_manager.task_list_head[priority], node)
  601041bddc:	f94017e0 	ldr	x0, [sp, #40]
  601041bde0:	f9404c00 	ldr	x0, [x0, #152]
  601041bde4:	d1026000 	sub	x0, x0, #0x98
  601041bde8:	f90017e0 	str	x0, [sp, #40]
  601041bdec:	f94017e0 	ldr	x0, [sp, #40]
  601041bdf0:	91026001 	add	x1, x0, #0x98
  601041bdf4:	b9401fe0 	ldr	w0, [sp, #28]
  601041bdf8:	d37cec02 	lsl	x2, x0, #4
  601041bdfc:	90008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041be00:	f942ec00 	ldr	x0, [x0, #1496]
  601041be04:	8b000040 	add	x0, x2, x0
  601041be08:	eb00003f 	cmp	x1, x0
  601041be0c:	54fffb21 	b.ne	601041bd70 <round_robin_runnable_task+0x34>  // b.any
        }
    }

    return NULL;
  601041be10:	d2800000 	mov	x0, #0x0                   	// #0
}
  601041be14:	a8c37bfd 	ldp	x29, x30, [sp], #48
  601041be18:	d65f03c0 	ret

000000601041be1c <recover_priority>:

/* recover task priority */
void recover_priority(void)
{
  601041be1c:	d10143ff 	sub	sp, sp, #0x50
    struct Thread* task = NULL;
  601041be20:	f90027ff 	str	xzr, [sp, #72]
    for (int i = 1; i < TASK_MAX_PRIORITY; i++) {
  601041be24:	52800020 	mov	w0, #0x1                   	// #1
  601041be28:	b90047e0 	str	w0, [sp, #68]
  601041be2c:	14000063 	b	601041bfb8 <recover_priority+0x19c>
        if (i == TASK_DEFAULT_PRIORITY)
  601041be30:	b94047e0 	ldr	w0, [sp, #68]
  601041be34:	7100081f 	cmp	w0, #0x2
  601041be38:	54000b80 	b.eq	601041bfa8 <recover_priority+0x18c>  // b.none
            continue;
        DOUBLE_LIST_FOR_EACH_ENTRY(task, &xizi_task_manager.task_list_head[i], node)
  601041be3c:	90008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041be40:	f942ec01 	ldr	x1, [x0, #1496]
  601041be44:	b98047e0 	ldrsw	x0, [sp, #68]
  601041be48:	d37cec00 	lsl	x0, x0, #4
  601041be4c:	8b000020 	add	x0, x1, x0
  601041be50:	f9400000 	ldr	x0, [x0]
  601041be54:	d1026000 	sub	x0, x0, #0x98
  601041be58:	f90027e0 	str	x0, [sp, #72]
  601041be5c:	14000049 	b	601041bf80 <recover_priority+0x164>
        {
            if (!IS_DOUBLE_LIST_EMPTY(&task->node)) {
  601041be60:	f94027e0 	ldr	x0, [sp, #72]
  601041be64:	f9404c01 	ldr	x1, [x0, #152]
  601041be68:	f94027e0 	ldr	x0, [sp, #72]
  601041be6c:	91026000 	add	x0, x0, #0x98
  601041be70:	eb00003f 	cmp	x1, x0
  601041be74:	540007e0 	b.eq	601041bf70 <recover_priority+0x154>  // b.none
                // DEBUG("%s priority recover\n", task->name);
                task->priority = TASK_DEFAULT_PRIORITY;
  601041be78:	f94027e0 	ldr	x0, [sp, #72]
  601041be7c:	52800041 	mov	w1, #0x2                   	// #2
  601041be80:	b900ac01 	str	w1, [x0, #172]
                doubleListDel(&task->node);
  601041be84:	f94027e0 	ldr	x0, [sp, #72]
  601041be88:	91026000 	add	x0, x0, #0x98
  601041be8c:	f9000be0 	str	x0, [sp, #16]
    _double_list_del(entry->prev, entry->next);
  601041be90:	f9400be0 	ldr	x0, [sp, #16]
  601041be94:	f9400401 	ldr	x1, [x0, #8]
  601041be98:	f9400be0 	ldr	x0, [sp, #16]
  601041be9c:	f9400000 	ldr	x0, [x0]
  601041bea0:	f90007e1 	str	x1, [sp, #8]
  601041bea4:	f90003e0 	str	x0, [sp]
    next->prev = prev;
  601041bea8:	f94003e0 	ldr	x0, [sp]
  601041beac:	f94007e1 	ldr	x1, [sp, #8]
  601041beb0:	f9000401 	str	x1, [x0, #8]
    prev->next = next;
  601041beb4:	f94007e0 	ldr	x0, [sp, #8]
  601041beb8:	f94003e1 	ldr	x1, [sp]
  601041bebc:	f9000001 	str	x1, [x0]
}
  601041bec0:	d503201f 	nop
    entry->next = entry;
  601041bec4:	f9400be0 	ldr	x0, [sp, #16]
  601041bec8:	f9400be1 	ldr	x1, [sp, #16]
  601041becc:	f9000001 	str	x1, [x0]
    entry->prev = entry;
  601041bed0:	f9400be0 	ldr	x0, [sp, #16]
  601041bed4:	f9400be1 	ldr	x1, [sp, #16]
  601041bed8:	f9000401 	str	x1, [x0, #8]
}
  601041bedc:	d503201f 	nop
                doubleListAddOnBack(&task->node, &xizi_task_manager.task_list_head[task->priority]);
  601041bee0:	f94027e0 	ldr	x0, [sp, #72]
  601041bee4:	91026001 	add	x1, x0, #0x98
  601041bee8:	f94027e0 	ldr	x0, [sp, #72]
  601041beec:	b940ac00 	ldr	w0, [x0, #172]
  601041bef0:	93407c00 	sxtw	x0, w0
  601041bef4:	d37cec02 	lsl	x2, x0, #4
  601041bef8:	90008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041befc:	f942ec00 	ldr	x0, [x0, #1496]
  601041bf00:	8b000040 	add	x0, x2, x0
  601041bf04:	f9001fe1 	str	x1, [sp, #56]
  601041bf08:	f9001be0 	str	x0, [sp, #48]
    _double_list_add(new_node, head->prev, head);
  601041bf0c:	f9401be0 	ldr	x0, [sp, #48]
  601041bf10:	f9400400 	ldr	x0, [x0, #8]
  601041bf14:	f9401fe1 	ldr	x1, [sp, #56]
  601041bf18:	f90017e1 	str	x1, [sp, #40]
  601041bf1c:	f90013e0 	str	x0, [sp, #32]
  601041bf20:	f9401be0 	ldr	x0, [sp, #48]
  601041bf24:	f9000fe0 	str	x0, [sp, #24]
    next->prev = new_node;
  601041bf28:	f9400fe0 	ldr	x0, [sp, #24]
  601041bf2c:	f94017e1 	ldr	x1, [sp, #40]
  601041bf30:	f9000401 	str	x1, [x0, #8]
    new_node->next = next;
  601041bf34:	f94017e0 	ldr	x0, [sp, #40]
  601041bf38:	f9400fe1 	ldr	x1, [sp, #24]
  601041bf3c:	f9000001 	str	x1, [x0]
    new_node->prev = prev;
  601041bf40:	f94017e0 	ldr	x0, [sp, #40]
  601041bf44:	f94013e1 	ldr	x1, [sp, #32]
  601041bf48:	f9000401 	str	x1, [x0, #8]
    prev->next = new_node;
  601041bf4c:	f94013e0 	ldr	x0, [sp, #32]
  601041bf50:	f94017e1 	ldr	x1, [sp, #40]
  601041bf54:	f9000001 	str	x1, [x0]
}
  601041bf58:	d503201f 	nop
}
  601041bf5c:	d503201f 	nop
                i--;
  601041bf60:	b94047e0 	ldr	w0, [sp, #68]
  601041bf64:	51000400 	sub	w0, w0, #0x1
  601041bf68:	b90047e0 	str	w0, [sp, #68]
                break;
  601041bf6c:	14000010 	b	601041bfac <recover_priority+0x190>
        DOUBLE_LIST_FOR_EACH_ENTRY(task, &xizi_task_manager.task_list_head[i], node)
  601041bf70:	f94027e0 	ldr	x0, [sp, #72]
  601041bf74:	f9404c00 	ldr	x0, [x0, #152]
  601041bf78:	d1026000 	sub	x0, x0, #0x98
  601041bf7c:	f90027e0 	str	x0, [sp, #72]
  601041bf80:	f94027e0 	ldr	x0, [sp, #72]
  601041bf84:	91026001 	add	x1, x0, #0x98
  601041bf88:	b98047e0 	ldrsw	x0, [sp, #68]
  601041bf8c:	d37cec02 	lsl	x2, x0, #4
  601041bf90:	90008940 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041bf94:	f942ec00 	ldr	x0, [x0, #1496]
  601041bf98:	8b000040 	add	x0, x2, x0
  601041bf9c:	eb00003f 	cmp	x1, x0
  601041bfa0:	54fff601 	b.ne	601041be60 <recover_priority+0x44>  // b.any
  601041bfa4:	14000002 	b	601041bfac <recover_priority+0x190>
            continue;
  601041bfa8:	d503201f 	nop
    for (int i = 1; i < TASK_MAX_PRIORITY; i++) {
  601041bfac:	b94047e0 	ldr	w0, [sp, #68]
  601041bfb0:	11000400 	add	w0, w0, #0x1
  601041bfb4:	b90047e0 	str	w0, [sp, #68]
  601041bfb8:	b94047e0 	ldr	w0, [sp, #68]
  601041bfbc:	71007c1f 	cmp	w0, #0x1f
  601041bfc0:	54fff38d 	b.le	601041be30 <recover_priority+0x14>
            }
        }
    }
  601041bfc4:	d503201f 	nop
  601041bfc8:	d503201f 	nop
  601041bfcc:	910143ff 	add	sp, sp, #0x50
  601041bfd0:	d65f03c0 	ret

000000601041bfd4 <bitmap64_init>:
{
  601041bfd4:	d10043ff 	sub	sp, sp, #0x10
  601041bfd8:	f90007e0 	str	x0, [sp, #8]
    bitmap->map = 0;
  601041bfdc:	f94007e0 	ldr	x0, [sp, #8]
  601041bfe0:	f900001f 	str	xzr, [x0]
}
  601041bfe4:	d503201f 	nop
  601041bfe8:	910043ff 	add	sp, sp, #0x10
  601041bfec:	d65f03c0 	ret

000000601041bff0 <bitmap64_alloc>:
{
  601041bff0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  601041bff4:	910003fd 	mov	x29, sp
  601041bff8:	f9000fe0 	str	x0, [sp, #24]
    int free_bit = -1;
  601041bffc:	12800000 	mov	w0, #0xffffffff            	// #-1
  601041c000:	b9002fe0 	str	w0, [sp, #44]
    free_bit = __builtin_ffsl(~(uint64_t)(bitmap->map));
  601041c004:	f9400fe0 	ldr	x0, [sp, #24]
  601041c008:	f9400000 	ldr	x0, [x0]
  601041c00c:	aa2003e0 	mvn	x0, x0
  601041c010:	f100001f 	cmp	x0, #0x0
  601041c014:	dac00000 	rbit	x0, x0
  601041c018:	dac01000 	clz	x0, x0
  601041c01c:	9a8007e0 	csinc	x0, xzr, x0, eq  // eq = none
  601041c020:	b9002fe0 	str	w0, [sp, #44]
    if (free_bit == 0) {
  601041c024:	b9402fe0 	ldr	w0, [sp, #44]
  601041c028:	7100001f 	cmp	w0, #0x0
  601041c02c:	54000061 	b.ne	601041c038 <bitmap64_alloc+0x48>  // b.any
        return -1;
  601041c030:	12800000 	mov	w0, #0xffffffff            	// #-1
  601041c034:	14000021 	b	601041c0b8 <bitmap64_alloc+0xc8>
    assert(free_bit < 64 && free_bit >= 1);
  601041c038:	b9402fe0 	ldr	w0, [sp, #44]
  601041c03c:	7100fc1f 	cmp	w0, #0x3f
  601041c040:	5400008c 	b.gt	601041c050 <bitmap64_alloc+0x60>
  601041c044:	b9402fe0 	ldr	w0, [sp, #44]
  601041c048:	7100001f 	cmp	w0, #0x0
  601041c04c:	540001ec 	b.gt	601041c088 <bitmap64_alloc+0x98>
  601041c050:	528006e2 	mov	w2, #0x37                  	// #55
  601041c054:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041c058:	9103a001 	add	x1, x0, #0xe8
  601041c05c:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c060:	91360000 	add	x0, x0, #0xd80
  601041c064:	97ffe045 	bl	6010414178 <printf_>
  601041c068:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c06c:	91364001 	add	x1, x0, #0xd90
  601041c070:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c074:	9136c000 	add	x0, x0, #0xdb0
  601041c078:	97ffe040 	bl	6010414178 <printf_>
  601041c07c:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c080:	91370000 	add	x0, x0, #0xdc0
  601041c084:	97ffcc89 	bl	601040f2a8 <panic>
    bitmap->map |= (1 << (free_bit - 1));
  601041c088:	f9400fe0 	ldr	x0, [sp, #24]
  601041c08c:	f9400001 	ldr	x1, [x0]
  601041c090:	b9402fe0 	ldr	w0, [sp, #44]
  601041c094:	51000400 	sub	w0, w0, #0x1
  601041c098:	52800022 	mov	w2, #0x1                   	// #1
  601041c09c:	1ac02040 	lsl	w0, w2, w0
  601041c0a0:	93407c00 	sxtw	x0, w0
  601041c0a4:	aa000021 	orr	x1, x1, x0
  601041c0a8:	f9400fe0 	ldr	x0, [sp, #24]
  601041c0ac:	f9000001 	str	x1, [x0]
    return free_bit - 1;
  601041c0b0:	b9402fe0 	ldr	w0, [sp, #44]
  601041c0b4:	51000400 	sub	w0, w0, #0x1
}
  601041c0b8:	a8c37bfd 	ldp	x29, x30, [sp], #48
  601041c0bc:	d65f03c0 	ret

000000601041c0c0 <bitmap64_free>:
{
  601041c0c0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  601041c0c4:	910003fd 	mov	x29, sp
  601041c0c8:	f9000fe0 	str	x0, [sp, #24]
  601041c0cc:	b90017e1 	str	w1, [sp, #20]
    assert((bitmap->map & (1 << idx)) != 0);
  601041c0d0:	f9400fe0 	ldr	x0, [sp, #24]
  601041c0d4:	f9400001 	ldr	x1, [x0]
  601041c0d8:	b94017e0 	ldr	w0, [sp, #20]
  601041c0dc:	52800022 	mov	w2, #0x1                   	// #1
  601041c0e0:	1ac02040 	lsl	w0, w2, w0
  601041c0e4:	93407c00 	sxtw	x0, w0
  601041c0e8:	8a000020 	and	x0, x1, x0
  601041c0ec:	f100001f 	cmp	x0, #0x0
  601041c0f0:	540001e1 	b.ne	601041c12c <bitmap64_free+0x6c>  // b.any
  601041c0f4:	52800802 	mov	w2, #0x40                  	// #64
  601041c0f8:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041c0fc:	91032001 	add	x1, x0, #0xc8
  601041c100:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c104:	91360000 	add	x0, x0, #0xd80
  601041c108:	97ffe01c 	bl	6010414178 <printf_>
  601041c10c:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c110:	91372001 	add	x1, x0, #0xdc8
  601041c114:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c118:	9136c000 	add	x0, x0, #0xdb0
  601041c11c:	97ffe017 	bl	6010414178 <printf_>
  601041c120:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c124:	91370000 	add	x0, x0, #0xdc0
  601041c128:	97ffcc60 	bl	601040f2a8 <panic>
    bitmap->map &= ~(uint64_t)(1 << idx);
  601041c12c:	f9400fe0 	ldr	x0, [sp, #24]
  601041c130:	f9400001 	ldr	x1, [x0]
  601041c134:	b94017e0 	ldr	w0, [sp, #20]
  601041c138:	52800022 	mov	w2, #0x1                   	// #1
  601041c13c:	1ac02040 	lsl	w0, w2, w0
  601041c140:	93407c00 	sxtw	x0, w0
  601041c144:	aa2003e0 	mvn	x0, x0
  601041c148:	8a000021 	and	x1, x1, x0
  601041c14c:	f9400fe0 	ldr	x0, [sp, #24]
  601041c150:	f9000001 	str	x1, [x0]
}
  601041c154:	d503201f 	nop
  601041c158:	a8c27bfd 	ldp	x29, x30, [sp], #32
  601041c15c:	d65f03c0 	ret

000000601041c160 <alloc_memspace>:
#include "task.h"

#define MAX_SUPPORT_PARAMS 32

struct MemSpace* alloc_memspace()
{
  601041c160:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  601041c164:	910003fd 	mov	x29, sp
    struct MemSpace* pmemspace = slab_alloc(&xizi_task_manager.memspace_allocator);
  601041c168:	f0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041c16c:	f942ec00 	ldr	x0, [x0, #1496]
  601041c170:	9109c000 	add	x0, x0, #0x270
  601041c174:	97fff05c 	bl	60104182e4 <slab_alloc>
  601041c178:	f9000fe0 	str	x0, [sp, #24]
    if (pmemspace == NULL) {
  601041c17c:	f9400fe0 	ldr	x0, [sp, #24]
  601041c180:	f100001f 	cmp	x0, #0x0
  601041c184:	54000181 	b.ne	601041c1b4 <alloc_memspace+0x54>  // b.any
        ERROR("Alloc memspace for thread failed.\n");
  601041c188:	52800602 	mov	w2, #0x30                  	// #48
  601041c18c:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041c190:	91026001 	add	x1, x0, #0x98
  601041c194:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c198:	91360000 	add	x0, x0, #0xd80
  601041c19c:	97ffdff7 	bl	6010414178 <printf_>
  601041c1a0:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c1a4:	9137a000 	add	x0, x0, #0xde8
  601041c1a8:	97ffdff4 	bl	6010414178 <printf_>
        return NULL;
  601041c1ac:	d2800000 	mov	x0, #0x0                   	// #0
  601041c1b0:	14000017 	b	601041c20c <alloc_memspace+0xac>
    }

    bitmap64_init(&pmemspace->thread_stack_idx_bitmap);
  601041c1b4:	f9400fe0 	ldr	x0, [sp, #24]
  601041c1b8:	91008000 	add	x0, x0, #0x20
  601041c1bc:	97ffff86 	bl	601041bfd4 <bitmap64_init>
    doubleListNodeInit(&pmemspace->thread_list_guard);
  601041c1c0:	f9400fe0 	ldr	x0, [sp, #24]
  601041c1c4:	9100a000 	add	x0, x0, #0x28
  601041c1c8:	f9000be0 	str	x0, [sp, #16]
    list->next = list;
  601041c1cc:	f9400be0 	ldr	x0, [sp, #16]
  601041c1d0:	f9400be1 	ldr	x1, [sp, #16]
  601041c1d4:	f9000001 	str	x1, [x0]
    list->prev = list;
  601041c1d8:	f9400be0 	ldr	x0, [sp, #16]
  601041c1dc:	f9400be1 	ldr	x1, [sp, #16]
  601041c1e0:	f9000401 	str	x1, [x0, #8]
}
  601041c1e4:	d503201f 	nop
    pmemspace->massive_ipc_allocator = NULL;
  601041c1e8:	f9400fe0 	ldr	x0, [sp, #24]
  601041c1ec:	f9000c1f 	str	xzr, [x0, #24]
    pmemspace->heap_base = 0;
  601041c1f0:	f9400fe0 	ldr	x0, [sp, #24]
  601041c1f4:	f900041f 	str	xzr, [x0, #8]
    pmemspace->mem_size = 0;
  601041c1f8:	f9400fe0 	ldr	x0, [sp, #24]
  601041c1fc:	f900081f 	str	xzr, [x0, #16]
    pmemspace->pgdir.pd_addr = 0;
  601041c200:	f9400fe0 	ldr	x0, [sp, #24]
  601041c204:	f900001f 	str	xzr, [x0]
    return pmemspace;
  601041c208:	f9400fe0 	ldr	x0, [sp, #24]
}
  601041c20c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  601041c210:	d65f03c0 	ret

000000601041c214 <free_memspace>:

void free_memspace(struct MemSpace* pmemspace)
{
  601041c214:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  601041c218:	910003fd 	mov	x29, sp
  601041c21c:	f9000fe0 	str	x0, [sp, #24]
    assert(pmemspace != NULL);
  601041c220:	f9400fe0 	ldr	x0, [sp, #24]
  601041c224:	f100001f 	cmp	x0, #0x0
  601041c228:	540001e1 	b.ne	601041c264 <free_memspace+0x50>  // b.any
  601041c22c:	528007e2 	mov	w2, #0x3f                  	// #63
  601041c230:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041c234:	9102a001 	add	x1, x0, #0xa8
  601041c238:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c23c:	91360000 	add	x0, x0, #0xd80
  601041c240:	97ffdfce 	bl	6010414178 <printf_>
  601041c244:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c248:	91384001 	add	x1, x0, #0xe10
  601041c24c:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c250:	9136c000 	add	x0, x0, #0xdb0
  601041c254:	97ffdfc9 	bl	6010414178 <printf_>
  601041c258:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c25c:	91370000 	add	x0, x0, #0xdc0
  601041c260:	97ffcc12 	bl	601040f2a8 <panic>

    /* free page table and all its allocated memories */
    if (pmemspace->pgdir.pd_addr != NULL) {
  601041c264:	f9400fe0 	ldr	x0, [sp, #24]
  601041c268:	f9400000 	ldr	x0, [x0]
  601041c26c:	f100001f 	cmp	x0, #0x0
  601041c270:	540000c0 	b.eq	601041c288 <free_memspace+0x74>  // b.none
        xizi_pager.free_user_pgdir(&pmemspace->pgdir);
  601041c274:	f0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041c278:	f942b000 	ldr	x0, [x0, #1376]
  601041c27c:	f9400401 	ldr	x1, [x0, #8]
  601041c280:	f9400fe0 	ldr	x0, [sp, #24]
  601041c284:	d63f0020 	blr	x1
    }

    /* free ipc virt address allocator */
    if (pmemspace->massive_ipc_allocator != NULL) {
  601041c288:	f9400fe0 	ldr	x0, [sp, #24]
  601041c28c:	f9400c00 	ldr	x0, [x0, #24]
  601041c290:	f100001f 	cmp	x0, #0x0
  601041c294:	54000160 	b.eq	601041c2c0 <free_memspace+0xac>  // b.none
        KBuddyDestory(pmemspace->massive_ipc_allocator);
  601041c298:	f9400fe0 	ldr	x0, [sp, #24]
  601041c29c:	f9400c00 	ldr	x0, [x0, #24]
  601041c2a0:	97ffefa7 	bl	601041813c <KBuddyDestory>
        slab_free(&xizi_task_manager.task_buddy_allocator, (void*)pmemspace->massive_ipc_allocator);
  601041c2a4:	f9400fe0 	ldr	x0, [sp, #24]
  601041c2a8:	f9400c00 	ldr	x0, [x0, #24]
  601041c2ac:	aa0003e1 	mov	x1, x0
  601041c2b0:	f0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041c2b4:	f942ec00 	ldr	x0, [x0, #1496]
  601041c2b8:	910b8000 	add	x0, x0, #0x2e0
  601041c2bc:	97fff0f1 	bl	6010418680 <slab_free>
    }

    slab_free(&xizi_task_manager.memspace_allocator, (void*)pmemspace);
  601041c2c0:	f9400fe1 	ldr	x1, [sp, #24]
  601041c2c4:	f0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041c2c8:	f942ec00 	ldr	x0, [x0, #1496]
  601041c2cc:	9109c000 	add	x0, x0, #0x270
  601041c2d0:	97fff0ec 	bl	6010418680 <slab_free>
}
  601041c2d4:	d503201f 	nop
  601041c2d8:	a8c27bfd 	ldp	x29, x30, [sp], #32
  601041c2dc:	d65f03c0 	ret

000000601041c2e0 <load_memspace>:

/// @return return the entry of program
uintptr_t* load_memspace(struct MemSpace* pmemspace, char* img_start)
{
  601041c2e0:	a9b37bfd 	stp	x29, x30, [sp, #-208]!
  601041c2e4:	910003fd 	mov	x29, sp
  601041c2e8:	f9000fe0 	str	x0, [sp, #24]
  601041c2ec:	f9000be1 	str	x1, [sp, #16]
    if (pmemspace == NULL) {
  601041c2f0:	f9400fe0 	ldr	x0, [sp, #24]
  601041c2f4:	f100001f 	cmp	x0, #0x0
  601041c2f8:	54000181 	b.ne	601041c328 <load_memspace+0x48>  // b.any
        ERROR("Loading an empty memspace.\n");
  601041c2fc:	52800a62 	mov	w2, #0x53                  	// #83
  601041c300:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041c304:	9102e001 	add	x1, x0, #0xb8
  601041c308:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c30c:	91360000 	add	x0, x0, #0xd80
  601041c310:	97ffdf9a 	bl	6010414178 <printf_>
  601041c314:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c318:	9138a000 	add	x0, x0, #0xe28
  601041c31c:	97ffdf97 	bl	6010414178 <printf_>
        return NULL;
  601041c320:	d2800000 	mov	x0, #0x0                   	// #0
  601041c324:	140000fc 	b	601041c714 <load_memspace+0x434>
    }

    if (img_start == NULL) {
  601041c328:	f9400be0 	ldr	x0, [sp, #16]
  601041c32c:	f100001f 	cmp	x0, #0x0
  601041c330:	54000181 	b.ne	601041c360 <load_memspace+0x80>  // b.any
        ERROR("Empty elf file.\n");
  601041c334:	52800b02 	mov	w2, #0x58                  	// #88
  601041c338:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041c33c:	9102e001 	add	x1, x0, #0xb8
  601041c340:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c344:	91360000 	add	x0, x0, #0xd80
  601041c348:	97ffdf8c 	bl	6010414178 <printf_>
  601041c34c:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c350:	91392000 	add	x0, x0, #0xe48
  601041c354:	97ffdf89 	bl	6010414178 <printf_>
        return NULL;
  601041c358:	d2800000 	mov	x0, #0x0                   	// #0
  601041c35c:	140000ee 	b	601041c714 <load_memspace+0x434>
    }

    /* 1. load elf header */
    struct elfhdr elf;
    memcpy((void*)&elf, img_start, sizeof(elf));
  601041c360:	9101a3e0 	add	x0, sp, #0x68
  601041c364:	d2800802 	mov	x2, #0x40                  	// #64
  601041c368:	f9400be1 	ldr	x1, [sp, #16]
  601041c36c:	94000fa5 	bl	6010420200 <memcpy>
    if (elf.magic != ELF_MAGIC) {
  601041c370:	b9406be1 	ldr	w1, [sp, #104]
  601041c374:	5288afe0 	mov	w0, #0x457f                	// #17791
  601041c378:	72a8c980 	movk	w0, #0x464c, lsl #16
  601041c37c:	6b00003f 	cmp	w1, w0
  601041c380:	54000180 	b.eq	601041c3b0 <load_memspace+0xd0>  // b.none
        ERROR("Not an elf file.\n");
  601041c384:	52800c02 	mov	w2, #0x60                  	// #96
  601041c388:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041c38c:	9102e001 	add	x1, x0, #0xb8
  601041c390:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c394:	91360000 	add	x0, x0, #0xd80
  601041c398:	97ffdf78 	bl	6010414178 <printf_>
  601041c39c:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c3a0:	91398000 	add	x0, x0, #0xe60
  601041c3a4:	97ffdf75 	bl	6010414178 <printf_>
        return NULL;
  601041c3a8:	d2800000 	mov	x0, #0x0                   	// #0
  601041c3ac:	140000da 	b	601041c714 <load_memspace+0x434>
    }

    /* allocate a pgdir */
    /* only supports first inited memspace */
    assert(pmemspace->pgdir.pd_addr == NULL);
  601041c3b0:	f9400fe0 	ldr	x0, [sp, #24]
  601041c3b4:	f9400000 	ldr	x0, [x0]
  601041c3b8:	f100001f 	cmp	x0, #0x0
  601041c3bc:	540001e0 	b.eq	601041c3f8 <load_memspace+0x118>  // b.none
  601041c3c0:	52800cc2 	mov	w2, #0x66                  	// #102
  601041c3c4:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041c3c8:	9102e001 	add	x1, x0, #0xb8
  601041c3cc:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c3d0:	91360000 	add	x0, x0, #0xd80
  601041c3d4:	97ffdf69 	bl	6010414178 <printf_>
  601041c3d8:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c3dc:	9139e001 	add	x1, x0, #0xe78
  601041c3e0:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c3e4:	9136c000 	add	x0, x0, #0xdb0
  601041c3e8:	97ffdf64 	bl	6010414178 <printf_>
  601041c3ec:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c3f0:	91370000 	add	x0, x0, #0xdc0
  601041c3f4:	97ffcbad 	bl	601040f2a8 <panic>
    struct TopLevelPageDirectory pgdir;
    pgdir.pd_addr = NULL;
  601041c3f8:	f90033ff 	str	xzr, [sp, #96]
    if (UNLIKELY(!xizi_pager.new_pgdir(&pgdir))) {
  601041c3fc:	f0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041c400:	f942b000 	ldr	x0, [x0, #1376]
  601041c404:	f9400001 	ldr	x1, [x0]
  601041c408:	910183e0 	add	x0, sp, #0x60
  601041c40c:	d63f0020 	blr	x1
  601041c410:	12001c00 	and	w0, w0, #0xff
  601041c414:	52000000 	eor	w0, w0, #0x1
  601041c418:	12001c00 	and	w0, w0, #0xff
  601041c41c:	92401c00 	and	x0, x0, #0xff
  601041c420:	f100001f 	cmp	x0, #0x0
  601041c424:	54000160 	b.eq	601041c450 <load_memspace+0x170>  // b.none
        ERROR("Create new pgdir failed.\n");
  601041c428:	52800d42 	mov	w2, #0x6a                  	// #106
  601041c42c:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041c430:	9102e001 	add	x1, x0, #0xb8
  601041c434:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c438:	91360000 	add	x0, x0, #0xd80
  601041c43c:	97ffdf4f 	bl	6010414178 <printf_>
  601041c440:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c444:	913a8000 	add	x0, x0, #0xea0
  601041c448:	97ffdf4c 	bl	6010414178 <printf_>
        goto error_exec;
  601041c44c:	140000a0 	b	601041c6cc <load_memspace+0x3ec>
    }
    /* copy kernel pagetable so that interrupt and syscall wont corrupt */
    memcpy(pgdir.pd_addr, kern_pgdir.pd_addr, TOPLEVLE_PAGEDIR_SIZE);
  601041c450:	f94033e3 	ldr	x3, [sp, #96]
  601041c454:	f0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041c458:	f942fc00 	ldr	x0, [x0, #1528]
  601041c45c:	f9400000 	ldr	x0, [x0]
  601041c460:	d2820002 	mov	x2, #0x1000                	// #4096
  601041c464:	aa0003e1 	mov	x1, x0
  601041c468:	aa0303e0 	mov	x0, x3
  601041c46c:	94000f65 	bl	6010420200 <memcpy>

    // read elf file by (header, section)
    uintptr_t load_size = 0;
  601041c470:	f90067ff 	str	xzr, [sp, #200]
    struct proghdr ph;
    for (int sec_idx = 0, off = elf.phoff; sec_idx < elf.phnum; sec_idx++, off += sizeof(ph)) {
  601041c474:	b900c7ff 	str	wzr, [sp, #196]
  601041c478:	f94047e0 	ldr	x0, [sp, #136]
  601041c47c:	b900c3e0 	str	w0, [sp, #192]
  601041c480:	14000080 	b	601041c680 <load_memspace+0x3a0>
        // load proghdr
        memcpy((char*)&ph, img_start + off, sizeof(ph));
  601041c484:	b980c3e0 	ldrsw	x0, [sp, #192]
  601041c488:	f9400be1 	ldr	x1, [sp, #16]
  601041c48c:	8b000021 	add	x1, x1, x0
  601041c490:	9100a3e0 	add	x0, sp, #0x28
  601041c494:	d2800702 	mov	x2, #0x38                  	// #56
  601041c498:	94000f5a 	bl	6010420200 <memcpy>

        if (ph.type != ELF_PROG_LOAD)
  601041c49c:	b9402be0 	ldr	w0, [sp, #40]
  601041c4a0:	7100041f 	cmp	w0, #0x1
  601041c4a4:	54000e01 	b.ne	601041c664 <load_memspace+0x384>  // b.any
            continue;
        if (ph.memsz < ph.filesz) {
  601041c4a8:	f9402be1 	ldr	x1, [sp, #80]
  601041c4ac:	f94027e0 	ldr	x0, [sp, #72]
  601041c4b0:	eb00003f 	cmp	x1, x0
  601041c4b4:	54000162 	b.cs	601041c4e0 <load_memspace+0x200>  // b.hs, b.nlast
            ERROR("elf header mem size less than file size\n");
  601041c4b8:	52800f42 	mov	w2, #0x7a                  	// #122
  601041c4bc:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041c4c0:	9102e001 	add	x1, x0, #0xb8
  601041c4c4:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c4c8:	91360000 	add	x0, x0, #0xd80
  601041c4cc:	97ffdf2b 	bl	6010414178 <printf_>
  601041c4d0:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c4d4:	913b0000 	add	x0, x0, #0xec0
  601041c4d8:	97ffdf28 	bl	6010414178 <printf_>
            goto error_exec;
  601041c4dc:	1400007c 	b	601041c6cc <load_memspace+0x3ec>
        }

        // read section
        // 1. alloc space
        if ((load_size = xizi_pager.resize_user_pgdir(&pgdir, load_size, ph.vaddr + ph.memsz))
  601041c4e0:	f0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041c4e4:	f942b000 	ldr	x0, [x0, #1376]
  601041c4e8:	f9401003 	ldr	x3, [x0, #32]
  601041c4ec:	f9401fe1 	ldr	x1, [sp, #56]
  601041c4f0:	f9402be0 	ldr	x0, [sp, #80]
  601041c4f4:	8b000021 	add	x1, x1, x0
  601041c4f8:	910183e0 	add	x0, sp, #0x60
  601041c4fc:	aa0103e2 	mov	x2, x1
  601041c500:	f94067e1 	ldr	x1, [sp, #200]
  601041c504:	d63f0060 	blr	x3
  601041c508:	f90067e0 	str	x0, [sp, #200]
            != ph.vaddr + ph.memsz) {
  601041c50c:	f9401fe1 	ldr	x1, [sp, #56]
  601041c510:	f9402be0 	ldr	x0, [sp, #80]
  601041c514:	8b000020 	add	x0, x1, x0
        if ((load_size = xizi_pager.resize_user_pgdir(&pgdir, load_size, ph.vaddr + ph.memsz))
  601041c518:	f94067e1 	ldr	x1, [sp, #200]
  601041c51c:	eb00003f 	cmp	x1, x0
  601041c520:	54000160 	b.eq	601041c54c <load_memspace+0x26c>  // b.none
            ERROR("Add uspace size failed.\n");
  601041c524:	52801042 	mov	w2, #0x82                  	// #130
  601041c528:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041c52c:	9102e001 	add	x1, x0, #0xb8
  601041c530:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c534:	91360000 	add	x0, x0, #0xd80
  601041c538:	97ffdf10 	bl	6010414178 <printf_>
  601041c53c:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c540:	913bc000 	add	x0, x0, #0xef0
  601041c544:	97ffdf0d 	bl	6010414178 <printf_>
            goto error_exec;
  601041c548:	14000061 	b	601041c6cc <load_memspace+0x3ec>
        }
        // 2. copy inode to space
        if (ph.vaddr % PAGE_SIZE != 0) {
  601041c54c:	f9401fe0 	ldr	x0, [sp, #56]
  601041c550:	92402c00 	and	x0, x0, #0xfff
  601041c554:	f100001f 	cmp	x0, #0x0
  601041c558:	54000120 	b.eq	601041c57c <load_memspace+0x29c>  // b.none
            LOG("Unsupported elf file, try use flag -N to compile.\n");
  601041c55c:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041c560:	9102e001 	add	x1, x0, #0xb8
  601041c564:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c568:	913c4000 	add	x0, x0, #0xf10
  601041c56c:	97ffdf03 	bl	6010414178 <printf_>
  601041c570:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c574:	913c8000 	add	x0, x0, #0xf20
  601041c578:	97ffdf00 	bl	6010414178 <printf_>
        }
        for (int addr_offset = 0; addr_offset < ph.filesz; addr_offset += PAGE_SIZE) {
  601041c57c:	b900bfff 	str	wzr, [sp, #188]
  601041c580:	14000034 	b	601041c650 <load_memspace+0x370>
            uintptr_t page_paddr = xizi_pager.address_translate(&pgdir, ph.vaddr + addr_offset);
  601041c584:	f0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041c588:	f942b000 	ldr	x0, [x0, #1376]
  601041c58c:	f9401402 	ldr	x2, [x0, #40]
  601041c590:	f9401fe1 	ldr	x1, [sp, #56]
  601041c594:	b980bfe0 	ldrsw	x0, [sp, #188]
  601041c598:	8b000021 	add	x1, x1, x0
  601041c59c:	910183e0 	add	x0, sp, #0x60
  601041c5a0:	d63f0040 	blr	x2
  601041c5a4:	f9005be0 	str	x0, [sp, #176]
            if (page_paddr == 0) {
  601041c5a8:	f9405be0 	ldr	x0, [sp, #176]
  601041c5ac:	f100001f 	cmp	x0, #0x0
  601041c5b0:	54000221 	b.ne	601041c5f4 <load_memspace+0x314>  // b.any
                ERROR("copy elf file to unmapped addr: %x(pgdir: %x)\n", ph.vaddr + addr_offset, pgdir.pd_addr);
  601041c5b4:	52801182 	mov	w2, #0x8c                  	// #140
  601041c5b8:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041c5bc:	9102e001 	add	x1, x0, #0xb8
  601041c5c0:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c5c4:	91360000 	add	x0, x0, #0xd80
  601041c5c8:	97ffdeec 	bl	6010414178 <printf_>
  601041c5cc:	f9401fe1 	ldr	x1, [sp, #56]
  601041c5d0:	b980bfe0 	ldrsw	x0, [sp, #188]
  601041c5d4:	8b000020 	add	x0, x1, x0
  601041c5d8:	f94033e1 	ldr	x1, [sp, #96]
  601041c5dc:	aa0103e2 	mov	x2, x1
  601041c5e0:	aa0003e1 	mov	x1, x0
  601041c5e4:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c5e8:	913d6000 	add	x0, x0, #0xf58
  601041c5ec:	97ffdee3 	bl	6010414178 <printf_>
                goto error_exec;
  601041c5f0:	14000037 	b	601041c6cc <load_memspace+0x3ec>
            }
            uintptr_t read_size = (ph.filesz - addr_offset < PAGE_SIZE ? ph.filesz - addr_offset : PAGE_SIZE);
  601041c5f4:	f94027e1 	ldr	x1, [sp, #72]
  601041c5f8:	b980bfe0 	ldrsw	x0, [sp, #188]
  601041c5fc:	cb000020 	sub	x0, x1, x0
  601041c600:	d2820001 	mov	x1, #0x1000                	// #4096
  601041c604:	f140041f 	cmp	x0, #0x1, lsl #12
  601041c608:	9a819000 	csel	x0, x0, x1, ls  // ls = plast
  601041c60c:	f90057e0 	str	x0, [sp, #168]
            memcpy(P2V(page_paddr), img_start + (ph.off + addr_offset), read_size);
  601041c610:	f9405be1 	ldr	x1, [sp, #176]
  601041c614:	d2c00c00 	mov	x0, #0x6000000000          	// #412316860416
  601041c618:	8b000020 	add	x0, x1, x0
  601041c61c:	aa0003e3 	mov	x3, x0
  601041c620:	f9401be1 	ldr	x1, [sp, #48]
  601041c624:	b980bfe0 	ldrsw	x0, [sp, #188]
  601041c628:	8b000020 	add	x0, x1, x0
  601041c62c:	f9400be1 	ldr	x1, [sp, #16]
  601041c630:	8b000020 	add	x0, x1, x0
  601041c634:	f94057e2 	ldr	x2, [sp, #168]
  601041c638:	aa0003e1 	mov	x1, x0
  601041c63c:	aa0303e0 	mov	x0, x3
  601041c640:	94000ef0 	bl	6010420200 <memcpy>
        for (int addr_offset = 0; addr_offset < ph.filesz; addr_offset += PAGE_SIZE) {
  601041c644:	b940bfe0 	ldr	w0, [sp, #188]
  601041c648:	11400400 	add	w0, w0, #0x1, lsl #12
  601041c64c:	b900bfe0 	str	w0, [sp, #188]
  601041c650:	b980bfe1 	ldrsw	x1, [sp, #188]
  601041c654:	f94027e0 	ldr	x0, [sp, #72]
  601041c658:	eb00003f 	cmp	x1, x0
  601041c65c:	54fff943 	b.cc	601041c584 <load_memspace+0x2a4>  // b.lo, b.ul, b.last
  601041c660:	14000002 	b	601041c668 <load_memspace+0x388>
            continue;
  601041c664:	d503201f 	nop
    for (int sec_idx = 0, off = elf.phoff; sec_idx < elf.phnum; sec_idx++, off += sizeof(ph)) {
  601041c668:	b940c7e0 	ldr	w0, [sp, #196]
  601041c66c:	11000400 	add	w0, w0, #0x1
  601041c670:	b900c7e0 	str	w0, [sp, #196]
  601041c674:	b940c3e0 	ldr	w0, [sp, #192]
  601041c678:	1100e000 	add	w0, w0, #0x38
  601041c67c:	b900c3e0 	str	w0, [sp, #192]
  601041c680:	794143e0 	ldrh	w0, [sp, #160]
  601041c684:	2a0003e1 	mov	w1, w0
  601041c688:	b940c7e0 	ldr	w0, [sp, #196]
  601041c68c:	6b01001f 	cmp	w0, w1
  601041c690:	54ffefab 	b.lt	601041c484 <load_memspace+0x1a4>  // b.tstop
        }
    }

    /// elf file content now in memory
    // memspace will use this page dir
    pmemspace->pgdir = pgdir;
  601041c694:	f9400fe0 	ldr	x0, [sp, #24]
  601041c698:	f94033e1 	ldr	x1, [sp, #96]
  601041c69c:	f9000001 	str	x1, [x0]
    pmemspace->heap_base = ALIGNUP(load_size, PAGE_SIZE);
  601041c6a0:	f94067e0 	ldr	x0, [sp, #200]
  601041c6a4:	913ffc00 	add	x0, x0, #0xfff
  601041c6a8:	9274cc01 	and	x1, x0, #0xfffffffffffff000
  601041c6ac:	f9400fe0 	ldr	x0, [sp, #24]
  601041c6b0:	f9000401 	str	x1, [x0, #8]
    pmemspace->mem_size = pmemspace->heap_base;
  601041c6b4:	f9400fe0 	ldr	x0, [sp, #24]
  601041c6b8:	f9400401 	ldr	x1, [x0, #8]
  601041c6bc:	f9400fe0 	ldr	x0, [sp, #24]
  601041c6c0:	f9000801 	str	x1, [x0, #16]

    return (uintptr_t*)elf.entry;
  601041c6c4:	f94043e0 	ldr	x0, [sp, #128]
  601041c6c8:	14000013 	b	601041c714 <load_memspace+0x434>

error_exec:
    if (pgdir.pd_addr != NULL) {
  601041c6cc:	f94033e0 	ldr	x0, [sp, #96]
  601041c6d0:	f100001f 	cmp	x0, #0x0
  601041c6d4:	540000c0 	b.eq	601041c6ec <load_memspace+0x40c>  // b.none
        xizi_pager.free_user_pgdir(&pgdir);
  601041c6d8:	f0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041c6dc:	f942b000 	ldr	x0, [x0, #1376]
  601041c6e0:	f9400401 	ldr	x1, [x0, #8]
  601041c6e4:	910183e0 	add	x0, sp, #0x60
  601041c6e8:	d63f0020 	blr	x1
    }
    ERROR("Error loading memspace.\n");
  601041c6ec:	52801402 	mov	w2, #0xa0                  	// #160
  601041c6f0:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041c6f4:	9102e001 	add	x1, x0, #0xb8
  601041c6f8:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c6fc:	91360000 	add	x0, x0, #0xd80
  601041c700:	97ffde9e 	bl	6010414178 <printf_>
  601041c704:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c708:	913e2000 	add	x0, x0, #0xf88
  601041c70c:	97ffde9b 	bl	6010414178 <printf_>
    return NULL;
  601041c710:	d2800000 	mov	x0, #0x0                   	// #0
}
  601041c714:	a8cd7bfd 	ldp	x29, x30, [sp], #208
  601041c718:	d65f03c0 	ret

000000601041c71c <handle_error_stack_loading>:

static void handle_error_stack_loading(struct MemSpace* pmemspace, int stack_idx, uintptr_t* stack_bottom, bool is_mapped_successful)
{
  601041c71c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  601041c720:	910003fd 	mov	x29, sp
  601041c724:	f90017e0 	str	x0, [sp, #40]
  601041c728:	b90027e1 	str	w1, [sp, #36]
  601041c72c:	f9000fe2 	str	x2, [sp, #24]
  601041c730:	39008fe3 	strb	w3, [sp, #35]
    if (stack_idx != -1) {
  601041c734:	b94027e0 	ldr	w0, [sp, #36]
  601041c738:	3100041f 	cmn	w0, #0x1
  601041c73c:	540000a0 	b.eq	601041c750 <handle_error_stack_loading+0x34>  // b.none
        bitmap64_free(&pmemspace->thread_stack_idx_bitmap, stack_idx);
  601041c740:	f94017e0 	ldr	x0, [sp, #40]
  601041c744:	91008000 	add	x0, x0, #0x20
  601041c748:	b94027e1 	ldr	w1, [sp, #36]
  601041c74c:	97fffe5d 	bl	601041c0c0 <bitmap64_free>
    }

    if (stack_bottom != NULL) {
  601041c750:	f9400fe0 	ldr	x0, [sp, #24]
  601041c754:	f100001f 	cmp	x0, #0x0
  601041c758:	54000060 	b.eq	601041c764 <handle_error_stack_loading+0x48>  // b.none
        kfree((char*)stack_bottom);
  601041c75c:	f9400fe0 	ldr	x0, [sp, #24]
  601041c760:	97ffe7f8 	bl	6010416740 <kfree>
    }

    if (is_mapped_successful) {
  601041c764:	39408fe0 	ldrb	w0, [sp, #35]
  601041c768:	7100001f 	cmp	w0, #0x0
  601041c76c:	54000200 	b.eq	601041c7ac <handle_error_stack_loading+0x90>  // b.none
        xizi_pager.unmap_pages(pmemspace->pgdir.pd_addr, USER_MEM_TOP - ((stack_idx + 1) * USER_STACK_SIZE), USER_STACK_SIZE);
  601041c770:	f0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041c774:	f942b000 	ldr	x0, [x0, #1376]
  601041c778:	f9400c03 	ldr	x3, [x0, #24]
  601041c77c:	f94017e0 	ldr	x0, [sp, #40]
  601041c780:	f9400004 	ldr	x4, [x0]
  601041c784:	b94027e0 	ldr	w0, [sp, #36]
  601041c788:	11000400 	add	w0, w0, #0x1
  601041c78c:	53144c00 	lsl	w0, w0, #12
  601041c790:	93407c00 	sxtw	x0, w0
  601041c794:	d2c00801 	mov	x1, #0x4000000000          	// #274877906944
  601041c798:	cb000020 	sub	x0, x1, x0
  601041c79c:	52820002 	mov	w2, #0x1000                	// #4096
  601041c7a0:	aa0003e1 	mov	x1, x0
  601041c7a4:	aa0403e0 	mov	x0, x4
  601041c7a8:	d63f0060 	blr	x3
    }
}
  601041c7ac:	d503201f 	nop
  601041c7b0:	a8c37bfd 	ldp	x29, x30, [sp], #48
  601041c7b4:	d65f03c0 	ret

000000601041c7b8 <load_user_stack>:

/// @return return thread's user stack index
struct ThreadStackPointer load_user_stack(struct MemSpace* pmemspace, char** argv)
{
  601041c7b8:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
  601041c7bc:	910003fd 	mov	x29, sp
  601041c7c0:	f9000bf3 	str	x19, [sp, #16]
  601041c7c4:	aa0803f3 	mov	x19, x8
  601041c7c8:	f90017e0 	str	x0, [sp, #40]
  601041c7cc:	f90013e1 	str	x1, [sp, #32]
    /* usages of load_user_stack() must be correct */
    assert(pmemspace != NULL);
  601041c7d0:	f94017e0 	ldr	x0, [sp, #40]
  601041c7d4:	f100001f 	cmp	x0, #0x0
  601041c7d8:	540001e1 	b.ne	601041c814 <load_user_stack+0x5c>  // b.any
  601041c7dc:	528016e2 	mov	w2, #0xb7                  	// #183
  601041c7e0:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041c7e4:	91036001 	add	x1, x0, #0xd8
  601041c7e8:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c7ec:	91360000 	add	x0, x0, #0xd80
  601041c7f0:	97ffde62 	bl	6010414178 <printf_>
  601041c7f4:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c7f8:	91384001 	add	x1, x0, #0xe10
  601041c7fc:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c800:	9136c000 	add	x0, x0, #0xdb0
  601041c804:	97ffde5d 	bl	6010414178 <printf_>
  601041c808:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c80c:	91370000 	add	x0, x0, #0xdc0
  601041c810:	97ffcaa6 	bl	601040f2a8 <panic>
    assert(pmemspace->pgdir.pd_addr != NULL);
  601041c814:	f94017e0 	ldr	x0, [sp, #40]
  601041c818:	f9400000 	ldr	x0, [x0]
  601041c81c:	f100001f 	cmp	x0, #0x0
  601041c820:	540001e1 	b.ne	601041c85c <load_user_stack+0xa4>  // b.any
  601041c824:	52801702 	mov	w2, #0xb8                  	// #184
  601041c828:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041c82c:	91036001 	add	x1, x0, #0xd8
  601041c830:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c834:	91360000 	add	x0, x0, #0xd80
  601041c838:	97ffde50 	bl	6010414178 <printf_>
  601041c83c:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c840:	913ea001 	add	x1, x0, #0xfa8
  601041c844:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c848:	9136c000 	add	x0, x0, #0xdb0
  601041c84c:	97ffde4b 	bl	6010414178 <printf_>
  601041c850:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c854:	91370000 	add	x0, x0, #0xdc0
  601041c858:	97ffca94 	bl	601040f2a8 <panic>
    assert(argv != NULL);
  601041c85c:	f94013e0 	ldr	x0, [sp, #32]
  601041c860:	f100001f 	cmp	x0, #0x0
  601041c864:	540001e1 	b.ne	601041c8a0 <load_user_stack+0xe8>  // b.any
  601041c868:	52801722 	mov	w2, #0xb9                  	// #185
  601041c86c:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041c870:	91036001 	add	x1, x0, #0xd8
  601041c874:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c878:	91360000 	add	x0, x0, #0xd80
  601041c87c:	97ffde3f 	bl	6010414178 <printf_>
  601041c880:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c884:	913f4001 	add	x1, x0, #0xfd0
  601041c888:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c88c:	9136c000 	add	x0, x0, #0xdb0
  601041c890:	97ffde3a 	bl	6010414178 <printf_>
  601041c894:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c898:	91370000 	add	x0, x0, #0xdc0
  601041c89c:	97ffca83 	bl	601040f2a8 <panic>

    struct ThreadStackPointer loaded_sp = {
  601041c8a0:	b90033ff 	str	wzr, [sp, #48]
  601041c8a4:	12800000 	mov	w0, #0xffffffff            	// #-1
  601041c8a8:	b90037e0 	str	w0, [sp, #52]
  601041c8ac:	f9001fff 	str	xzr, [sp, #56]
  601041c8b0:	f90023ff 	str	xzr, [sp, #64]
        .user_sp = 0,
        .user_stack_vaddr = 0,
    };

    /* alloc a user stack index */
    int stack_idx = bitmap64_alloc(&pmemspace->thread_stack_idx_bitmap);
  601041c8b4:	f94017e0 	ldr	x0, [sp, #40]
  601041c8b8:	91008000 	add	x0, x0, #0x20
  601041c8bc:	97fffdcd 	bl	601041bff0 <bitmap64_alloc>
  601041c8c0:	b9006fe0 	str	w0, [sp, #108]
    if (stack_idx == -1) {
  601041c8c4:	b9406fe0 	ldr	w0, [sp, #108]
  601041c8c8:	3100041f 	cmn	w0, #0x1
  601041c8cc:	540002c1 	b.ne	601041c924 <load_user_stack+0x16c>  // b.any
        ERROR("Number of threads created exceeds kernel support.\n");
  601041c8d0:	528018a2 	mov	w2, #0xc5                  	// #197
  601041c8d4:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041c8d8:	91036001 	add	x1, x0, #0xd8
  601041c8dc:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c8e0:	91360000 	add	x0, x0, #0xd80
  601041c8e4:	97ffde25 	bl	6010414178 <printf_>
  601041c8e8:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c8ec:	913f8000 	add	x0, x0, #0xfe0
  601041c8f0:	97ffde22 	bl	6010414178 <printf_>
        handle_error_stack_loading(pmemspace, stack_idx, NULL, false);
  601041c8f4:	52800003 	mov	w3, #0x0                   	// #0
  601041c8f8:	d2800002 	mov	x2, #0x0                   	// #0
  601041c8fc:	b9406fe1 	ldr	w1, [sp, #108]
  601041c900:	f94017e0 	ldr	x0, [sp, #40]
  601041c904:	97ffff86 	bl	601041c71c <handle_error_stack_loading>
        return loaded_sp;
  601041c908:	aa1303e3 	mov	x3, x19
  601041c90c:	9100c3e2 	add	x2, sp, #0x30
  601041c910:	a9400440 	ldp	x0, x1, [x2]
  601041c914:	a9000460 	stp	x0, x1, [x3]
  601041c918:	f9400840 	ldr	x0, [x2, #16]
  601041c91c:	f9000860 	str	x0, [x3, #16]
  601041c920:	140000e9 	b	601041ccc4 <load_user_stack+0x50c>
    }

    /* allocate memory space for user stack */
    uintptr_t* stack_bottom = (uintptr_t*)kalloc(USER_STACK_SIZE);
  601041c924:	d2820000 	mov	x0, #0x1000                	// #4096
  601041c928:	97ffe745 	bl	601041663c <kalloc>
  601041c92c:	f90033e0 	str	x0, [sp, #96]
    if (UNLIKELY(stack_bottom == NULL)) {
  601041c930:	f94033e0 	ldr	x0, [sp, #96]
  601041c934:	f100001f 	cmp	x0, #0x0
  601041c938:	1a9f17e0 	cset	w0, eq  // eq = none
  601041c93c:	12001c00 	and	w0, w0, #0xff
  601041c940:	92401c00 	and	x0, x0, #0xff
  601041c944:	f100001f 	cmp	x0, #0x0
  601041c948:	540002c0 	b.eq	601041c9a0 <load_user_stack+0x1e8>  // b.none
        ERROR("No memory to alloc user stack.\n");
  601041c94c:	528019a2 	mov	w2, #0xcd                  	// #205
  601041c950:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041c954:	91036001 	add	x1, x0, #0xd8
  601041c958:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041c95c:	91360000 	add	x0, x0, #0xd80
  601041c960:	97ffde06 	bl	6010414178 <printf_>
  601041c964:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041c968:	91006000 	add	x0, x0, #0x18
  601041c96c:	97ffde03 	bl	6010414178 <printf_>
        handle_error_stack_loading(pmemspace, stack_idx, stack_bottom, false);
  601041c970:	52800003 	mov	w3, #0x0                   	// #0
  601041c974:	f94033e2 	ldr	x2, [sp, #96]
  601041c978:	b9406fe1 	ldr	w1, [sp, #108]
  601041c97c:	f94017e0 	ldr	x0, [sp, #40]
  601041c980:	97ffff67 	bl	601041c71c <handle_error_stack_loading>
        return loaded_sp;
  601041c984:	aa1303e3 	mov	x3, x19
  601041c988:	9100c3e2 	add	x2, sp, #0x30
  601041c98c:	a9400440 	ldp	x0, x1, [x2]
  601041c990:	a9000460 	stp	x0, x1, [x3]
  601041c994:	f9400840 	ldr	x0, [x2, #16]
  601041c998:	f9000860 	str	x0, [x3, #16]
  601041c99c:	140000ca 	b	601041ccc4 <load_user_stack+0x50c>
    }

    /* map memory to user stack space in memspace*/
    if (!xizi_pager.map_pages(pmemspace->pgdir.pd_addr, USER_MEM_TOP - ((stack_idx + 1) * USER_STACK_SIZE), V2P(stack_bottom), USER_STACK_SIZE, false)) {
  601041c9a0:	f0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041c9a4:	f942b000 	ldr	x0, [x0, #1376]
  601041c9a8:	f9400805 	ldr	x5, [x0, #16]
  601041c9ac:	f94017e0 	ldr	x0, [sp, #40]
  601041c9b0:	f9400006 	ldr	x6, [x0]
  601041c9b4:	b9406fe0 	ldr	w0, [sp, #108]
  601041c9b8:	11000400 	add	w0, w0, #0x1
  601041c9bc:	53144c00 	lsl	w0, w0, #12
  601041c9c0:	93407c00 	sxtw	x0, w0
  601041c9c4:	d2c00801 	mov	x1, #0x4000000000          	// #274877906944
  601041c9c8:	cb000027 	sub	x7, x1, x0
  601041c9cc:	f94033e1 	ldr	x1, [sp, #96]
  601041c9d0:	d2dff400 	mov	x0, #0xffa000000000        	// #281062659850240
  601041c9d4:	f2ffffe0 	movk	x0, #0xffff, lsl #48
  601041c9d8:	8b000020 	add	x0, x1, x0
  601041c9dc:	52800004 	mov	w4, #0x0                   	// #0
  601041c9e0:	52820003 	mov	w3, #0x1000                	// #4096
  601041c9e4:	aa0003e2 	mov	x2, x0
  601041c9e8:	aa0703e1 	mov	x1, x7
  601041c9ec:	aa0603e0 	mov	x0, x6
  601041c9f0:	d63f00a0 	blr	x5
  601041c9f4:	12001c00 	and	w0, w0, #0xff
  601041c9f8:	52000000 	eor	w0, w0, #0x1
  601041c9fc:	12001c00 	and	w0, w0, #0xff
  601041ca00:	7100001f 	cmp	w0, #0x0
  601041ca04:	540002c0 	b.eq	601041ca5c <load_user_stack+0x2a4>  // b.none
        /* this could only fail due to inner page directory's allocation failure */
        ERROR("User stack map failed\n");
  601041ca08:	52801aa2 	mov	w2, #0xd5                  	// #213
  601041ca0c:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041ca10:	91036001 	add	x1, x0, #0xd8
  601041ca14:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041ca18:	91360000 	add	x0, x0, #0xd80
  601041ca1c:	97ffddd7 	bl	6010414178 <printf_>
  601041ca20:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041ca24:	9100e000 	add	x0, x0, #0x38
  601041ca28:	97ffddd4 	bl	6010414178 <printf_>
        handle_error_stack_loading(pmemspace, stack_idx, stack_bottom, false);
  601041ca2c:	52800003 	mov	w3, #0x0                   	// #0
  601041ca30:	f94033e2 	ldr	x2, [sp, #96]
  601041ca34:	b9406fe1 	ldr	w1, [sp, #108]
  601041ca38:	f94017e0 	ldr	x0, [sp, #40]
  601041ca3c:	97ffff38 	bl	601041c71c <handle_error_stack_loading>
        return loaded_sp;
  601041ca40:	aa1303e3 	mov	x3, x19
  601041ca44:	9100c3e2 	add	x2, sp, #0x30
  601041ca48:	a9400440 	ldp	x0, x1, [x2]
  601041ca4c:	a9000460 	stp	x0, x1, [x3]
  601041ca50:	f9400840 	ldr	x0, [x2, #16]
  601041ca54:	f9000860 	str	x0, [x3, #16]
  601041ca58:	1400009b 	b	601041ccc4 <load_user_stack+0x50c>
    }

    /* start loading main params into user stack */
    /// @warning supports only main style params
    uintptr_t user_vspace_sp = USER_MEM_TOP - (stack_idx * USER_STACK_SIZE);
  601041ca5c:	b9406fe0 	ldr	w0, [sp, #108]
  601041ca60:	53144c00 	lsl	w0, w0, #12
  601041ca64:	93407c00 	sxtw	x0, w0
  601041ca68:	d2c00801 	mov	x1, #0x4000000000          	// #274877906944
  601041ca6c:	cb000020 	sub	x0, x1, x0
  601041ca70:	f9003fe0 	str	x0, [sp, #120]
    static uintptr_t user_stack_init[MAX_SUPPORT_PARAMS];
    memset(user_stack_init, 0, sizeof(user_stack_init));
  601041ca74:	d2802002 	mov	x2, #0x100                 	// #256
  601041ca78:	52800001 	mov	w1, #0x0                   	// #0
  601041ca7c:	f000b920 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041ca80:	912de000 	add	x0, x0, #0xb78
  601041ca84:	97ffc60f 	bl	601040e2c0 <memset>
    uintptr_t argc = 0;
  601041ca88:	f9003bff 	str	xzr, [sp, #112]
    uintptr_t copy_len = 0;
  601041ca8c:	f9002fff 	str	xzr, [sp, #88]
    for (argc = 0; argv != NULL && argc < (MAX_SUPPORT_PARAMS - 1) && argv[argc] != NULL; argc++) {
  601041ca90:	f9003bff 	str	xzr, [sp, #112]
  601041ca94:	14000042 	b	601041cb9c <load_user_stack+0x3e4>
        /// @todo handle with large number of parameters (more than 32)
        // copy param to user stack
        copy_len = strlen(argv[argc]) + 1;
  601041ca98:	f9403be0 	ldr	x0, [sp, #112]
  601041ca9c:	d37df000 	lsl	x0, x0, #3
  601041caa0:	f94013e1 	ldr	x1, [sp, #32]
  601041caa4:	8b000020 	add	x0, x1, x0
  601041caa8:	f9400000 	ldr	x0, [x0]
  601041caac:	94000ee5 	bl	6010420640 <strlen>
  601041cab0:	91000400 	add	x0, x0, #0x1
  601041cab4:	f9002fe0 	str	x0, [sp, #88]
        user_vspace_sp = ALIGNDOWN(user_vspace_sp - copy_len, sizeof(uintptr_t));
  601041cab8:	f9403fe1 	ldr	x1, [sp, #120]
  601041cabc:	f9402fe0 	ldr	x0, [sp, #88]
  601041cac0:	cb000020 	sub	x0, x1, x0
  601041cac4:	927df000 	and	x0, x0, #0xfffffffffffffff8
  601041cac8:	f9003fe0 	str	x0, [sp, #120]
        uintptr_t copied_len = xizi_pager.cross_vspace_data_copy(&pmemspace->pgdir, user_vspace_sp, (uintptr_t)argv[argc], copy_len);
  601041cacc:	f0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041cad0:	f942b000 	ldr	x0, [x0, #1376]
  601041cad4:	f9401804 	ldr	x4, [x0, #48]
  601041cad8:	f94017e5 	ldr	x5, [sp, #40]
  601041cadc:	f9403be0 	ldr	x0, [sp, #112]
  601041cae0:	d37df000 	lsl	x0, x0, #3
  601041cae4:	f94013e1 	ldr	x1, [sp, #32]
  601041cae8:	8b000020 	add	x0, x1, x0
  601041caec:	f9400000 	ldr	x0, [x0]
  601041caf0:	f9402fe3 	ldr	x3, [sp, #88]
  601041caf4:	aa0003e2 	mov	x2, x0
  601041caf8:	f9403fe1 	ldr	x1, [sp, #120]
  601041cafc:	aa0503e0 	mov	x0, x5
  601041cb00:	d63f0080 	blr	x4
  601041cb04:	f9002be0 	str	x0, [sp, #80]
        if (UNLIKELY(copied_len != copy_len)) {
  601041cb08:	f9402be1 	ldr	x1, [sp, #80]
  601041cb0c:	f9402fe0 	ldr	x0, [sp, #88]
  601041cb10:	eb00003f 	cmp	x1, x0
  601041cb14:	1a9f07e0 	cset	w0, ne  // ne = any
  601041cb18:	12001c00 	and	w0, w0, #0xff
  601041cb1c:	92401c00 	and	x0, x0, #0xff
  601041cb20:	f100001f 	cmp	x0, #0x0
  601041cb24:	540002c0 	b.eq	601041cb7c <load_user_stack+0x3c4>  // b.none
            ERROR("Something went wrong when copying params.\n");
  601041cb28:	52801d02 	mov	w2, #0xe8                  	// #232
  601041cb2c:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041cb30:	91036001 	add	x1, x0, #0xd8
  601041cb34:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041cb38:	91360000 	add	x0, x0, #0xd80
  601041cb3c:	97ffdd8f 	bl	6010414178 <printf_>
  601041cb40:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041cb44:	91014000 	add	x0, x0, #0x50
  601041cb48:	97ffdd8c 	bl	6010414178 <printf_>
            handle_error_stack_loading(pmemspace, stack_idx, stack_bottom, true);
  601041cb4c:	52800023 	mov	w3, #0x1                   	// #1
  601041cb50:	f94033e2 	ldr	x2, [sp, #96]
  601041cb54:	b9406fe1 	ldr	w1, [sp, #108]
  601041cb58:	f94017e0 	ldr	x0, [sp, #40]
  601041cb5c:	97fffef0 	bl	601041c71c <handle_error_stack_loading>
            return loaded_sp;
  601041cb60:	aa1303e3 	mov	x3, x19
  601041cb64:	9100c3e2 	add	x2, sp, #0x30
  601041cb68:	a9400440 	ldp	x0, x1, [x2]
  601041cb6c:	a9000460 	stp	x0, x1, [x3]
  601041cb70:	f9400840 	ldr	x0, [x2, #16]
  601041cb74:	f9000860 	str	x0, [x3, #16]
  601041cb78:	14000053 	b	601041ccc4 <load_user_stack+0x50c>
        }
        user_stack_init[argc] = user_vspace_sp;
  601041cb7c:	f000b920 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041cb80:	912de000 	add	x0, x0, #0xb78
  601041cb84:	f9403be1 	ldr	x1, [sp, #112]
  601041cb88:	f9403fe2 	ldr	x2, [sp, #120]
  601041cb8c:	f8217802 	str	x2, [x0, x1, lsl #3]
    for (argc = 0; argv != NULL && argc < (MAX_SUPPORT_PARAMS - 1) && argv[argc] != NULL; argc++) {
  601041cb90:	f9403be0 	ldr	x0, [sp, #112]
  601041cb94:	91000400 	add	x0, x0, #0x1
  601041cb98:	f9003be0 	str	x0, [sp, #112]
  601041cb9c:	f94013e0 	ldr	x0, [sp, #32]
  601041cba0:	f100001f 	cmp	x0, #0x0
  601041cba4:	54000160 	b.eq	601041cbd0 <load_user_stack+0x418>  // b.none
  601041cba8:	f9403be0 	ldr	x0, [sp, #112]
  601041cbac:	f100781f 	cmp	x0, #0x1e
  601041cbb0:	54000108 	b.hi	601041cbd0 <load_user_stack+0x418>  // b.pmore
  601041cbb4:	f9403be0 	ldr	x0, [sp, #112]
  601041cbb8:	d37df000 	lsl	x0, x0, #3
  601041cbbc:	f94013e1 	ldr	x1, [sp, #32]
  601041cbc0:	8b000020 	add	x0, x1, x0
  601041cbc4:	f9400000 	ldr	x0, [x0]
  601041cbc8:	f100001f 	cmp	x0, #0x0
  601041cbcc:	54fff661 	b.ne	601041ca98 <load_user_stack+0x2e0>  // b.any
    }

    user_stack_init[argc] = 0;
  601041cbd0:	f000b920 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041cbd4:	912de000 	add	x0, x0, #0xb78
  601041cbd8:	f9403be1 	ldr	x1, [sp, #112]
  601041cbdc:	f821781f 	str	xzr, [x0, x1, lsl #3]
    copy_len = (argc + 1) * sizeof(uintptr_t);
  601041cbe0:	f9403be0 	ldr	x0, [sp, #112]
  601041cbe4:	91000400 	add	x0, x0, #0x1
  601041cbe8:	d37df000 	lsl	x0, x0, #3
  601041cbec:	f9002fe0 	str	x0, [sp, #88]
    user_vspace_sp -= copy_len;
  601041cbf0:	f9403fe1 	ldr	x1, [sp, #120]
  601041cbf4:	f9402fe0 	ldr	x0, [sp, #88]
  601041cbf8:	cb000020 	sub	x0, x1, x0
  601041cbfc:	f9003fe0 	str	x0, [sp, #120]
    /* this copy has no reason to fail */
    uintptr_t copied_len = xizi_pager.cross_vspace_data_copy(&pmemspace->pgdir, user_vspace_sp, (uintptr_t)user_stack_init, copy_len);
  601041cc00:	f0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041cc04:	f942b000 	ldr	x0, [x0, #1376]
  601041cc08:	f9401804 	ldr	x4, [x0, #48]
  601041cc0c:	f94017e5 	ldr	x5, [sp, #40]
  601041cc10:	f000b920 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041cc14:	912de000 	add	x0, x0, #0xb78
  601041cc18:	f9402fe3 	ldr	x3, [sp, #88]
  601041cc1c:	aa0003e2 	mov	x2, x0
  601041cc20:	f9403fe1 	ldr	x1, [sp, #120]
  601041cc24:	aa0503e0 	mov	x0, x5
  601041cc28:	d63f0080 	blr	x4
  601041cc2c:	f90027e0 	str	x0, [sp, #72]
    assert(copied_len == copy_len);
  601041cc30:	f94027e1 	ldr	x1, [sp, #72]
  601041cc34:	f9402fe0 	ldr	x0, [sp, #88]
  601041cc38:	eb00003f 	cmp	x1, x0
  601041cc3c:	540001e0 	b.eq	601041cc78 <load_user_stack+0x4c0>  // b.none
  601041cc40:	52801e82 	mov	w2, #0xf4                  	// #244
  601041cc44:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041cc48:	91036001 	add	x1, x0, #0xd8
  601041cc4c:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041cc50:	91360000 	add	x0, x0, #0xd80
  601041cc54:	97ffdd49 	bl	6010414178 <printf_>
  601041cc58:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041cc5c:	91020001 	add	x1, x0, #0x80
  601041cc60:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041cc64:	9136c000 	add	x0, x0, #0xdb0
  601041cc68:	97ffdd44 	bl	6010414178 <printf_>
  601041cc6c:	d0000020 	adrp	x0, 6010422000 <__func__.0+0x50>
  601041cc70:	91370000 	add	x0, x0, #0xdc0
  601041cc74:	97ffc98d 	bl	601040f2a8 <panic>

    pmemspace->mem_size += USER_STACK_SIZE;
  601041cc78:	f94017e0 	ldr	x0, [sp, #40]
  601041cc7c:	f9400800 	ldr	x0, [x0, #16]
  601041cc80:	91400401 	add	x1, x0, #0x1, lsl #12
  601041cc84:	f94017e0 	ldr	x0, [sp, #40]
  601041cc88:	f9000801 	str	x1, [x0, #16]

    loaded_sp.argc = argc;
  601041cc8c:	f9403be0 	ldr	x0, [sp, #112]
  601041cc90:	b90033e0 	str	w0, [sp, #48]
    loaded_sp.stack_idx = stack_idx;
  601041cc94:	b9406fe0 	ldr	w0, [sp, #108]
  601041cc98:	b90037e0 	str	w0, [sp, #52]
    loaded_sp.user_sp = user_vspace_sp;
  601041cc9c:	f9403fe0 	ldr	x0, [sp, #120]
  601041cca0:	f9001fe0 	str	x0, [sp, #56]
    loaded_sp.user_stack_vaddr = (uintptr_t)stack_bottom;
  601041cca4:	f94033e0 	ldr	x0, [sp, #96]
  601041cca8:	f90023e0 	str	x0, [sp, #64]
    return loaded_sp;
  601041ccac:	aa1303e3 	mov	x3, x19
  601041ccb0:	9100c3e2 	add	x2, sp, #0x30
  601041ccb4:	a9400440 	ldp	x0, x1, [x2]
  601041ccb8:	a9000460 	stp	x0, x1, [x3]
  601041ccbc:	f9400840 	ldr	x0, [x2, #16]
  601041ccc0:	f9000860 	str	x0, [x3, #16]
  601041ccc4:	f9400bf3 	ldr	x19, [sp, #16]
  601041ccc8:	a8c87bfd 	ldp	x29, x30, [sp], #128
  601041cccc:	d65f03c0 	ret

000000601041ccd0 <semaphore_pool_init>:
#include "assert.h"
#include "ksemaphore.h"
#include "task.h"

void semaphore_pool_init(struct XiziSemaphorePool* sem_pool)
{
  601041ccd0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  601041ccd4:	910003fd 	mov	x29, sp
  601041ccd8:	f9000fe0 	str	x0, [sp, #24]
    assert(sem_pool != NULL);
  601041ccdc:	f9400fe0 	ldr	x0, [sp, #24]
  601041cce0:	f100001f 	cmp	x0, #0x0
  601041cce4:	540001e1 	b.ne	601041cd20 <semaphore_pool_init+0x50>  // b.any
  601041cce8:	52800342 	mov	w2, #0x1a                  	// #26
  601041ccec:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041ccf0:	9106c001 	add	x1, x0, #0x1b0
  601041ccf4:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041ccf8:	9103e000 	add	x0, x0, #0xf8
  601041ccfc:	97ffdd1f 	bl	6010414178 <printf_>
  601041cd00:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041cd04:	91042001 	add	x1, x0, #0x108
  601041cd08:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041cd0c:	91048000 	add	x0, x0, #0x120
  601041cd10:	97ffdd1a 	bl	6010414178 <printf_>
  601041cd14:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041cd18:	9104c000 	add	x0, x0, #0x130
  601041cd1c:	97ffc963 	bl	601040f2a8 <panic>
    sem_pool->next_sem_id = 1;
  601041cd20:	f9400fe0 	ldr	x0, [sp, #24]
  601041cd24:	52800021 	mov	w1, #0x1                   	// #1
  601041cd28:	b9000001 	str	w1, [x0]
    slab_init(&sem_pool->allocator, sizeof(struct ksemaphore));
  601041cd2c:	f9400fe0 	ldr	x0, [sp, #24]
  601041cd30:	91002000 	add	x0, x0, #0x8
  601041cd34:	d2800501 	mov	x1, #0x28                  	// #40
  601041cd38:	97ffed31 	bl	60104181fc <slab_init>
    doubleListNodeInit(&sem_pool->sem_list_guard);
  601041cd3c:	f9400fe0 	ldr	x0, [sp, #24]
  601041cd40:	91010000 	add	x0, x0, #0x40
  601041cd44:	f90017e0 	str	x0, [sp, #40]
    list->next = list;
  601041cd48:	f94017e0 	ldr	x0, [sp, #40]
  601041cd4c:	f94017e1 	ldr	x1, [sp, #40]
  601041cd50:	f9000001 	str	x1, [x0]
    list->prev = list;
  601041cd54:	f94017e0 	ldr	x0, [sp, #40]
  601041cd58:	f94017e1 	ldr	x1, [sp, #40]
  601041cd5c:	f9000401 	str	x1, [x0, #8]
}
  601041cd60:	d503201f 	nop
}
  601041cd64:	d503201f 	nop
  601041cd68:	a8c37bfd 	ldp	x29, x30, [sp], #48
  601041cd6c:	d65f03c0 	ret

000000601041cd70 <ksemaphore_get_by_id>:

static inline struct ksemaphore* ksemaphore_get_by_id(struct XiziSemaphorePool* sem_pool, int sem_id)
{
  601041cd70:	d10083ff 	sub	sp, sp, #0x20
  601041cd74:	f90007e0 	str	x0, [sp, #8]
  601041cd78:	b90007e1 	str	w1, [sp, #4]
    struct ksemaphore* sem = NULL;
  601041cd7c:	f9000fff 	str	xzr, [sp, #24]
    DOUBLE_LIST_FOR_EACH_ENTRY(sem, &sem_pool->sem_list_guard, sem_list_node)
  601041cd80:	f94007e0 	ldr	x0, [sp, #8]
  601041cd84:	f9402000 	ldr	x0, [x0, #64]
  601041cd88:	d1006000 	sub	x0, x0, #0x18
  601041cd8c:	f9000fe0 	str	x0, [sp, #24]
  601041cd90:	1400000c 	b	601041cdc0 <ksemaphore_get_by_id+0x50>
    {
        if (sem->id == sem_id) {
  601041cd94:	f9400fe0 	ldr	x0, [sp, #24]
  601041cd98:	b9400001 	ldr	w1, [x0]
  601041cd9c:	b94007e0 	ldr	w0, [sp, #4]
  601041cda0:	6b00003f 	cmp	w1, w0
  601041cda4:	54000061 	b.ne	601041cdb0 <ksemaphore_get_by_id+0x40>  // b.any
            return sem;
  601041cda8:	f9400fe0 	ldr	x0, [sp, #24]
  601041cdac:	1400000c 	b	601041cddc <ksemaphore_get_by_id+0x6c>
    DOUBLE_LIST_FOR_EACH_ENTRY(sem, &sem_pool->sem_list_guard, sem_list_node)
  601041cdb0:	f9400fe0 	ldr	x0, [sp, #24]
  601041cdb4:	f9400c00 	ldr	x0, [x0, #24]
  601041cdb8:	d1006000 	sub	x0, x0, #0x18
  601041cdbc:	f9000fe0 	str	x0, [sp, #24]
  601041cdc0:	f9400fe0 	ldr	x0, [sp, #24]
  601041cdc4:	91006001 	add	x1, x0, #0x18
  601041cdc8:	f94007e0 	ldr	x0, [sp, #8]
  601041cdcc:	91010000 	add	x0, x0, #0x40
  601041cdd0:	eb00003f 	cmp	x1, x0
  601041cdd4:	54fffe01 	b.ne	601041cd94 <ksemaphore_get_by_id+0x24>  // b.any
        }
    }
    return NULL;
  601041cdd8:	d2800000 	mov	x0, #0x0                   	// #0
}
  601041cddc:	910083ff 	add	sp, sp, #0x20
  601041cde0:	d65f03c0 	ret

000000601041cde4 <ksemaphore_alloc>:

int ksemaphore_alloc(struct XiziSemaphorePool* sem_pool, int val)
{
  601041cde4:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  601041cde8:	910003fd 	mov	x29, sp
  601041cdec:	f9000fe0 	str	x0, [sp, #24]
  601041cdf0:	b90017e1 	str	w1, [sp, #20]
    struct ksemaphore* sem = (struct ksemaphore*)slab_alloc(&sem_pool->allocator);
  601041cdf4:	f9400fe0 	ldr	x0, [sp, #24]
  601041cdf8:	91002000 	add	x0, x0, #0x8
  601041cdfc:	97ffed3a 	bl	60104182e4 <slab_alloc>
  601041ce00:	f9002fe0 	str	x0, [sp, #88]
    if (sem == NULL) {
  601041ce04:	f9402fe0 	ldr	x0, [sp, #88]
  601041ce08:	f100001f 	cmp	x0, #0x0
  601041ce0c:	54000181 	b.ne	601041ce3c <ksemaphore_alloc+0x58>  // b.any
        ERROR("No memeory to alloc new semaphore.\n");
  601041ce10:	52800602 	mov	w2, #0x30                  	// #48
  601041ce14:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041ce18:	91072001 	add	x1, x0, #0x1c8
  601041ce1c:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041ce20:	9103e000 	add	x0, x0, #0xf8
  601041ce24:	97ffdcd5 	bl	6010414178 <printf_>
  601041ce28:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041ce2c:	9104e000 	add	x0, x0, #0x138
  601041ce30:	97ffdcd2 	bl	6010414178 <printf_>
        return -1;
  601041ce34:	12800000 	mov	w0, #0xffffffff            	// #-1
  601041ce38:	1400004a 	b	601041cf60 <ksemaphore_alloc+0x17c>
    }

    /* No error down here */
    /* init ksemaphore since here */
    /// @warning sem->id could overflow
    sem->id = sem_pool->next_sem_id++;
  601041ce3c:	f9400fe0 	ldr	x0, [sp, #24]
  601041ce40:	b9400000 	ldr	w0, [x0]
  601041ce44:	11000402 	add	w2, w0, #0x1
  601041ce48:	f9400fe1 	ldr	x1, [sp, #24]
  601041ce4c:	b9000022 	str	w2, [x1]
  601041ce50:	f9402fe1 	ldr	x1, [sp, #88]
  601041ce54:	b9000020 	str	w0, [x1]
    if (UNLIKELY(sem->id == 0)) {
  601041ce58:	f9402fe0 	ldr	x0, [sp, #88]
  601041ce5c:	b9400000 	ldr	w0, [x0]
  601041ce60:	7100001f 	cmp	w0, #0x0
  601041ce64:	1a9f17e0 	cset	w0, eq  // eq = none
  601041ce68:	12001c00 	and	w0, w0, #0xff
  601041ce6c:	92401c00 	and	x0, x0, #0xff
  601041ce70:	f100001f 	cmp	x0, #0x0
  601041ce74:	540000e0 	b.eq	601041ce90 <ksemaphore_alloc+0xac>  // b.none
        slab_free(&sem_pool->allocator, sem);
  601041ce78:	f9400fe0 	ldr	x0, [sp, #24]
  601041ce7c:	91002000 	add	x0, x0, #0x8
  601041ce80:	f9402fe1 	ldr	x1, [sp, #88]
  601041ce84:	97ffedff 	bl	6010418680 <slab_free>
        return -1;
  601041ce88:	12800000 	mov	w0, #0xffffffff            	// #-1
  601041ce8c:	14000035 	b	601041cf60 <ksemaphore_alloc+0x17c>
    }
    sem->val = val;
  601041ce90:	f9402fe0 	ldr	x0, [sp, #88]
  601041ce94:	b94017e1 	ldr	w1, [sp, #20]
  601041ce98:	b9000401 	str	w1, [x0, #4]
    doubleListNodeInit(&sem->sem_list_node);
  601041ce9c:	f9402fe0 	ldr	x0, [sp, #88]
  601041cea0:	91006000 	add	x0, x0, #0x18
  601041cea4:	f90013e0 	str	x0, [sp, #32]
    list->next = list;
  601041cea8:	f94013e0 	ldr	x0, [sp, #32]
  601041ceac:	f94013e1 	ldr	x1, [sp, #32]
  601041ceb0:	f9000001 	str	x1, [x0]
    list->prev = list;
  601041ceb4:	f94013e0 	ldr	x0, [sp, #32]
  601041ceb8:	f94013e1 	ldr	x1, [sp, #32]
  601041cebc:	f9000401 	str	x1, [x0, #8]
}
  601041cec0:	d503201f 	nop
    doubleListNodeInit(&sem->wait_list_guard);
  601041cec4:	f9402fe0 	ldr	x0, [sp, #88]
  601041cec8:	91002000 	add	x0, x0, #0x8
  601041cecc:	f90017e0 	str	x0, [sp, #40]
    list->next = list;
  601041ced0:	f94017e0 	ldr	x0, [sp, #40]
  601041ced4:	f94017e1 	ldr	x1, [sp, #40]
  601041ced8:	f9000001 	str	x1, [x0]
    list->prev = list;
  601041cedc:	f94017e0 	ldr	x0, [sp, #40]
  601041cee0:	f94017e1 	ldr	x1, [sp, #40]
  601041cee4:	f9000401 	str	x1, [x0, #8]
}
  601041cee8:	d503201f 	nop

    /* list sem to sem_pool */
    doubleListAddOnHead(&sem->sem_list_node, &sem_pool->sem_list_guard);
  601041ceec:	f9402fe0 	ldr	x0, [sp, #88]
  601041cef0:	91006001 	add	x1, x0, #0x18
  601041cef4:	f9400fe0 	ldr	x0, [sp, #24]
  601041cef8:	91010000 	add	x0, x0, #0x40
  601041cefc:	f9002be1 	str	x1, [sp, #80]
  601041cf00:	f90027e0 	str	x0, [sp, #72]
    _double_list_add(new_node, head, head->next);
  601041cf04:	f94027e0 	ldr	x0, [sp, #72]
  601041cf08:	f9400000 	ldr	x0, [x0]
  601041cf0c:	f9402be1 	ldr	x1, [sp, #80]
  601041cf10:	f90023e1 	str	x1, [sp, #64]
  601041cf14:	f94027e1 	ldr	x1, [sp, #72]
  601041cf18:	f9001fe1 	str	x1, [sp, #56]
  601041cf1c:	f9001be0 	str	x0, [sp, #48]
    next->prev = new_node;
  601041cf20:	f9401be0 	ldr	x0, [sp, #48]
  601041cf24:	f94023e1 	ldr	x1, [sp, #64]
  601041cf28:	f9000401 	str	x1, [x0, #8]
    new_node->next = next;
  601041cf2c:	f94023e0 	ldr	x0, [sp, #64]
  601041cf30:	f9401be1 	ldr	x1, [sp, #48]
  601041cf34:	f9000001 	str	x1, [x0]
    new_node->prev = prev;
  601041cf38:	f94023e0 	ldr	x0, [sp, #64]
  601041cf3c:	f9401fe1 	ldr	x1, [sp, #56]
  601041cf40:	f9000401 	str	x1, [x0, #8]
    prev->next = new_node;
  601041cf44:	f9401fe0 	ldr	x0, [sp, #56]
  601041cf48:	f94023e1 	ldr	x1, [sp, #64]
  601041cf4c:	f9000001 	str	x1, [x0]
}
  601041cf50:	d503201f 	nop
}
  601041cf54:	d503201f 	nop

    return sem->id;
  601041cf58:	f9402fe0 	ldr	x0, [sp, #88]
  601041cf5c:	b9400000 	ldr	w0, [x0]
}
  601041cf60:	a8c67bfd 	ldp	x29, x30, [sp], #96
  601041cf64:	d65f03c0 	ret

000000601041cf68 <ksemaphore_wait>:

bool ksemaphore_wait(struct XiziSemaphorePool* sem_pool, struct Thread* thd, uint32_t sem_id)
{
  601041cf68:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  601041cf6c:	910003fd 	mov	x29, sp
  601041cf70:	f90017e0 	str	x0, [sp, #40]
  601041cf74:	f90013e1 	str	x1, [sp, #32]
  601041cf78:	b9001fe2 	str	w2, [sp, #28]
    assert(thd != NULL);
  601041cf7c:	f94013e0 	ldr	x0, [sp, #32]
  601041cf80:	f100001f 	cmp	x0, #0x0
  601041cf84:	540001e1 	b.ne	601041cfc0 <ksemaphore_wait+0x58>  // b.any
  601041cf88:	52800902 	mov	w2, #0x48                  	// #72
  601041cf8c:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041cf90:	91078001 	add	x1, x0, #0x1e0
  601041cf94:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041cf98:	9103e000 	add	x0, x0, #0xf8
  601041cf9c:	97ffdc77 	bl	6010414178 <printf_>
  601041cfa0:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041cfa4:	91058001 	add	x1, x0, #0x160
  601041cfa8:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041cfac:	91048000 	add	x0, x0, #0x120
  601041cfb0:	97ffdc72 	bl	6010414178 <printf_>
  601041cfb4:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041cfb8:	9104c000 	add	x0, x0, #0x130
  601041cfbc:	97ffc8bb 	bl	601040f2a8 <panic>
    assert(thd->state == RUNNING);
  601041cfc0:	f94013e0 	ldr	x0, [sp, #32]
  601041cfc4:	b940a800 	ldr	w0, [x0, #168]
  601041cfc8:	7100081f 	cmp	w0, #0x2
  601041cfcc:	540001e0 	b.eq	601041d008 <ksemaphore_wait+0xa0>  // b.none
  601041cfd0:	52800922 	mov	w2, #0x49                  	// #73
  601041cfd4:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041cfd8:	91078001 	add	x1, x0, #0x1e0
  601041cfdc:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041cfe0:	9103e000 	add	x0, x0, #0xf8
  601041cfe4:	97ffdc65 	bl	6010414178 <printf_>
  601041cfe8:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041cfec:	9105c001 	add	x1, x0, #0x170
  601041cff0:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041cff4:	91048000 	add	x0, x0, #0x120
  601041cff8:	97ffdc60 	bl	6010414178 <printf_>
  601041cffc:	f0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041d000:	9104c000 	add	x0, x0, #0x130
  601041d004:	97ffc8a9 	bl	601040f2a8 <panic>
    /* find sem */
    struct ksemaphore* sem = ksemaphore_get_by_id(sem_pool, sem_id);
  601041d008:	b9401fe0 	ldr	w0, [sp, #28]
  601041d00c:	2a0003e1 	mov	w1, w0
  601041d010:	f94017e0 	ldr	x0, [sp, #40]
  601041d014:	97ffff57 	bl	601041cd70 <ksemaphore_get_by_id>
  601041d018:	f9001fe0 	str	x0, [sp, #56]
    // invalid sem id
    if (sem == NULL) {
  601041d01c:	f9401fe0 	ldr	x0, [sp, #56]
  601041d020:	f100001f 	cmp	x0, #0x0
  601041d024:	54000061 	b.ne	601041d030 <ksemaphore_wait+0xc8>  // b.any
        return false;
  601041d028:	52800000 	mov	w0, #0x0                   	// #0
  601041d02c:	1400001f 	b	601041d0a8 <ksemaphore_wait+0x140>
    }

    // no need to wait
    if (sem->val > 0) {
  601041d030:	f9401fe0 	ldr	x0, [sp, #56]
  601041d034:	b9400400 	ldr	w0, [x0, #4]
  601041d038:	7100001f 	cmp	w0, #0x0
  601041d03c:	5400010d 	b.le	601041d05c <ksemaphore_wait+0xf4>
        sem->val--;
  601041d040:	f9401fe0 	ldr	x0, [sp, #56]
  601041d044:	b9400400 	ldr	w0, [x0, #4]
  601041d048:	51000401 	sub	w1, w0, #0x1
  601041d04c:	f9401fe0 	ldr	x0, [sp, #56]
  601041d050:	b9000401 	str	w1, [x0, #4]
        return true;
  601041d054:	52800020 	mov	w0, #0x1                   	// #1
  601041d058:	14000014 	b	601041d0a8 <ksemaphore_wait+0x140>
    }

    // waiting at the sem
    sem->val--;
  601041d05c:	f9401fe0 	ldr	x0, [sp, #56]
  601041d060:	b9400400 	ldr	w0, [x0, #4]
  601041d064:	51000401 	sub	w1, w0, #0x1
  601041d068:	f9401fe0 	ldr	x0, [sp, #56]
  601041d06c:	b9000401 	str	w1, [x0, #4]
    xizi_task_manager.task_yield_noschedule(thd, false);
  601041d070:	d0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041d074:	f942ec00 	ldr	x0, [x0, #1496]
  601041d078:	f941a802 	ldr	x2, [x0, #848]
  601041d07c:	52800001 	mov	w1, #0x0                   	// #0
  601041d080:	f94013e0 	ldr	x0, [sp, #32]
  601041d084:	d63f0040 	blr	x2
    xizi_task_manager.task_block(&sem->wait_list_guard, thd);
  601041d088:	d0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041d08c:	f942ec00 	ldr	x0, [x0, #1496]
  601041d090:	f941ac02 	ldr	x2, [x0, #856]
  601041d094:	f9401fe0 	ldr	x0, [sp, #56]
  601041d098:	91002000 	add	x0, x0, #0x8
  601041d09c:	f94013e1 	ldr	x1, [sp, #32]
  601041d0a0:	d63f0040 	blr	x2
    return true;
  601041d0a4:	52800020 	mov	w0, #0x1                   	// #1
}
  601041d0a8:	a8c47bfd 	ldp	x29, x30, [sp], #64
  601041d0ac:	d65f03c0 	ret

000000601041d0b0 <ksemaphore_signal>:

bool ksemaphore_signal(struct XiziSemaphorePool* sem_pool, uint32_t sem_id)
{
  601041d0b0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  601041d0b4:	910003fd 	mov	x29, sp
  601041d0b8:	f9000fe0 	str	x0, [sp, #24]
  601041d0bc:	b90017e1 	str	w1, [sp, #20]
    /* find sem */
    struct ksemaphore* sem = ksemaphore_get_by_id(sem_pool, sem_id);
  601041d0c0:	b94017e0 	ldr	w0, [sp, #20]
  601041d0c4:	2a0003e1 	mov	w1, w0
  601041d0c8:	f9400fe0 	ldr	x0, [sp, #24]
  601041d0cc:	97ffff29 	bl	601041cd70 <ksemaphore_get_by_id>
  601041d0d0:	f90017e0 	str	x0, [sp, #40]
    // invalid sem id
    if (sem == NULL) {
  601041d0d4:	f94017e0 	ldr	x0, [sp, #40]
  601041d0d8:	f100001f 	cmp	x0, #0x0
  601041d0dc:	54000061 	b.ne	601041d0e8 <ksemaphore_signal+0x38>  // b.any
        return false;
  601041d0e0:	52800000 	mov	w0, #0x0                   	// #0
  601041d0e4:	1400002f 	b	601041d1a0 <ksemaphore_signal+0xf0>
    }

    if (sem->val < 0) {
  601041d0e8:	f94017e0 	ldr	x0, [sp, #40]
  601041d0ec:	b9400400 	ldr	w0, [x0, #4]
  601041d0f0:	7100001f 	cmp	w0, #0x0
  601041d0f4:	540004aa 	b.ge	601041d188 <ksemaphore_signal+0xd8>  // b.tcont
        if (!IS_DOUBLE_LIST_EMPTY(&sem->wait_list_guard)) {
  601041d0f8:	f94017e0 	ldr	x0, [sp, #40]
  601041d0fc:	f9400401 	ldr	x1, [x0, #8]
  601041d100:	f94017e0 	ldr	x0, [sp, #40]
  601041d104:	91002000 	add	x0, x0, #0x8
  601041d108:	eb00003f 	cmp	x1, x0
  601041d10c:	540003e0 	b.eq	601041d188 <ksemaphore_signal+0xd8>  // b.none
            struct Thread* thd = CONTAINER_OF(sem->wait_list_guard.next, struct Thread, node);
  601041d110:	f94017e0 	ldr	x0, [sp, #40]
  601041d114:	f9400400 	ldr	x0, [x0, #8]
  601041d118:	d1026000 	sub	x0, x0, #0x98
  601041d11c:	f90013e0 	str	x0, [sp, #32]
            assert(thd != NULL && thd->state == BLOCKED);
  601041d120:	f94013e0 	ldr	x0, [sp, #32]
  601041d124:	f100001f 	cmp	x0, #0x0
  601041d128:	540000a0 	b.eq	601041d13c <ksemaphore_signal+0x8c>  // b.none
  601041d12c:	f94013e0 	ldr	x0, [sp, #32]
  601041d130:	b940a800 	ldr	w0, [x0, #168]
  601041d134:	7100101f 	cmp	w0, #0x4
  601041d138:	540001e0 	b.eq	601041d174 <ksemaphore_signal+0xc4>  // b.none
  601041d13c:	52800d42 	mov	w2, #0x6a                  	// #106
  601041d140:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041d144:	9107c001 	add	x1, x0, #0x1f0
  601041d148:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041d14c:	9103e000 	add	x0, x0, #0xf8
  601041d150:	97ffdc0a 	bl	6010414178 <printf_>
  601041d154:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041d158:	91062001 	add	x1, x0, #0x188
  601041d15c:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041d160:	91048000 	add	x0, x0, #0x120
  601041d164:	97ffdc05 	bl	6010414178 <printf_>
  601041d168:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041d16c:	9104c000 	add	x0, x0, #0x130
  601041d170:	97ffc84e 	bl	601040f2a8 <panic>
            xizi_task_manager.task_unblock(thd);
  601041d174:	d0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041d178:	f942ec00 	ldr	x0, [x0, #1496]
  601041d17c:	f941b001 	ldr	x1, [x0, #864]
  601041d180:	f94013e0 	ldr	x0, [sp, #32]
  601041d184:	d63f0020 	blr	x1
        }
    }

    sem->val++;
  601041d188:	f94017e0 	ldr	x0, [sp, #40]
  601041d18c:	b9400400 	ldr	w0, [x0, #4]
  601041d190:	11000401 	add	w1, w0, #0x1
  601041d194:	f94017e0 	ldr	x0, [sp, #40]
  601041d198:	b9000401 	str	w1, [x0, #4]
    return true;
  601041d19c:	52800020 	mov	w0, #0x1                   	// #1
}
  601041d1a0:	a8c37bfd 	ldp	x29, x30, [sp], #48
  601041d1a4:	d65f03c0 	ret

000000601041d1a8 <ksemaphore_free>:

bool ksemaphore_free(struct XiziSemaphorePool* sem_pool, uint32_t sem_id)
{
  601041d1a8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  601041d1ac:	910003fd 	mov	x29, sp
  601041d1b0:	f9000fe0 	str	x0, [sp, #24]
  601041d1b4:	b90017e1 	str	w1, [sp, #20]
    /* find sem */
    struct ksemaphore* sem = ksemaphore_get_by_id(sem_pool, sem_id);
  601041d1b8:	b94017e0 	ldr	w0, [sp, #20]
  601041d1bc:	2a0003e1 	mov	w1, w0
  601041d1c0:	f9400fe0 	ldr	x0, [sp, #24]
  601041d1c4:	97fffeeb 	bl	601041cd70 <ksemaphore_get_by_id>
  601041d1c8:	f90023e0 	str	x0, [sp, #64]
    // invalid sem id
    if (sem == NULL) {
  601041d1cc:	f94023e0 	ldr	x0, [sp, #64]
  601041d1d0:	f100001f 	cmp	x0, #0x0
  601041d1d4:	54000061 	b.ne	601041d1e0 <ksemaphore_free+0x38>  // b.any
        return false;
  601041d1d8:	52800000 	mov	w0, #0x0                   	// #0
  601041d1dc:	14000043 	b	601041d2e8 <ksemaphore_free+0x140>
    }

    struct Thread* thd = NULL;
  601041d1e0:	f90027ff 	str	xzr, [sp, #72]
    DOUBLE_LIST_FOR_EACH_ENTRY(thd, &sem->wait_list_guard, node)
  601041d1e4:	f94023e0 	ldr	x0, [sp, #64]
  601041d1e8:	f9400400 	ldr	x0, [x0, #8]
  601041d1ec:	d1026000 	sub	x0, x0, #0x98
  601041d1f0:	f90027e0 	str	x0, [sp, #72]
  601041d1f4:	1400001b 	b	601041d260 <ksemaphore_free+0xb8>
    {
        assert(thd != NULL);
  601041d1f8:	f94027e0 	ldr	x0, [sp, #72]
  601041d1fc:	f100001f 	cmp	x0, #0x0
  601041d200:	540001e1 	b.ne	601041d23c <ksemaphore_free+0x94>  // b.any
  601041d204:	52800fe2 	mov	w2, #0x7f                  	// #127
  601041d208:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041d20c:	91082001 	add	x1, x0, #0x208
  601041d210:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041d214:	9103e000 	add	x0, x0, #0xf8
  601041d218:	97ffdbd8 	bl	6010414178 <printf_>
  601041d21c:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041d220:	91058001 	add	x1, x0, #0x160
  601041d224:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041d228:	91048000 	add	x0, x0, #0x120
  601041d22c:	97ffdbd3 	bl	6010414178 <printf_>
  601041d230:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041d234:	9104c000 	add	x0, x0, #0x130
  601041d238:	97ffc81c 	bl	601040f2a8 <panic>
        xizi_task_manager.task_unblock(thd);
  601041d23c:	d0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041d240:	f942ec00 	ldr	x0, [x0, #1496]
  601041d244:	f941b001 	ldr	x1, [x0, #864]
  601041d248:	f94027e0 	ldr	x0, [sp, #72]
  601041d24c:	d63f0020 	blr	x1
    DOUBLE_LIST_FOR_EACH_ENTRY(thd, &sem->wait_list_guard, node)
  601041d250:	f94027e0 	ldr	x0, [sp, #72]
  601041d254:	f9404c00 	ldr	x0, [x0, #152]
  601041d258:	d1026000 	sub	x0, x0, #0x98
  601041d25c:	f90027e0 	str	x0, [sp, #72]
  601041d260:	f94027e0 	ldr	x0, [sp, #72]
  601041d264:	91026001 	add	x1, x0, #0x98
  601041d268:	f94023e0 	ldr	x0, [sp, #64]
  601041d26c:	91002000 	add	x0, x0, #0x8
  601041d270:	eb00003f 	cmp	x1, x0
  601041d274:	54fffc21 	b.ne	601041d1f8 <ksemaphore_free+0x50>  // b.any
    }

    doubleListDel(&sem->sem_list_node);
  601041d278:	f94023e0 	ldr	x0, [sp, #64]
  601041d27c:	91006000 	add	x0, x0, #0x18
  601041d280:	f9001fe0 	str	x0, [sp, #56]
    _double_list_del(entry->prev, entry->next);
  601041d284:	f9401fe0 	ldr	x0, [sp, #56]
  601041d288:	f9400401 	ldr	x1, [x0, #8]
  601041d28c:	f9401fe0 	ldr	x0, [sp, #56]
  601041d290:	f9400000 	ldr	x0, [x0]
  601041d294:	f9001be1 	str	x1, [sp, #48]
  601041d298:	f90017e0 	str	x0, [sp, #40]
    next->prev = prev;
  601041d29c:	f94017e0 	ldr	x0, [sp, #40]
  601041d2a0:	f9401be1 	ldr	x1, [sp, #48]
  601041d2a4:	f9000401 	str	x1, [x0, #8]
    prev->next = next;
  601041d2a8:	f9401be0 	ldr	x0, [sp, #48]
  601041d2ac:	f94017e1 	ldr	x1, [sp, #40]
  601041d2b0:	f9000001 	str	x1, [x0]
}
  601041d2b4:	d503201f 	nop
    entry->next = entry;
  601041d2b8:	f9401fe0 	ldr	x0, [sp, #56]
  601041d2bc:	f9401fe1 	ldr	x1, [sp, #56]
  601041d2c0:	f9000001 	str	x1, [x0]
    entry->prev = entry;
  601041d2c4:	f9401fe0 	ldr	x0, [sp, #56]
  601041d2c8:	f9401fe1 	ldr	x1, [sp, #56]
  601041d2cc:	f9000401 	str	x1, [x0, #8]
}
  601041d2d0:	d503201f 	nop
    slab_free(&sem_pool->allocator, sem);
  601041d2d4:	f9400fe0 	ldr	x0, [sp, #24]
  601041d2d8:	91002000 	add	x0, x0, #0x8
  601041d2dc:	f94023e1 	ldr	x1, [sp, #64]
  601041d2e0:	97ffece8 	bl	6010418680 <slab_free>

    return true;
  601041d2e4:	52800020 	mov	w0, #0x1                   	// #1
}
  601041d2e8:	a8c57bfd 	ldp	x29, x30, [sp], #80
  601041d2ec:	d65f03c0 	ret

000000601041d2f0 <cur_cpuid>:
{
  601041d2f0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601041d2f4:	910003fd 	mov	x29, sp
    return cpu_get_current();
  601041d2f8:	97ffc4e8 	bl	601040e698 <cpu_get_current>
}
  601041d2fc:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601041d300:	d65f03c0 	ret

000000601041d304 <cur_cpu>:
{
  601041d304:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601041d308:	910003fd 	mov	x29, sp
    return &global_cpus[cur_cpuid()];
  601041d30c:	97fffff9 	bl	601041d2f0 <cur_cpuid>
  601041d310:	93407c01 	sxtw	x1, w0
  601041d314:	d2800300 	mov	x0, #0x18                  	// #24
  601041d318:	9b007c21 	mul	x1, x1, x0
  601041d31c:	d0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041d320:	f942f400 	ldr	x0, [x0, #1512]
  601041d324:	8b000020 	add	x0, x1, x0
}
  601041d328:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601041d32c:	d65f03c0 	ret

000000601041d330 <syscall>:
#include "trap_common.h"

#include "syscall.h"

int syscall(int sys_num, uintptr_t param1, uintptr_t param2, uintptr_t param3, uintptr_t param4)
{
  601041d330:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  601041d334:	910003fd 	mov	x29, sp
  601041d338:	b9003fe0 	str	w0, [sp, #60]
  601041d33c:	f9001be1 	str	x1, [sp, #48]
  601041d340:	f90017e2 	str	x2, [sp, #40]
  601041d344:	f90013e3 	str	x3, [sp, #32]
  601041d348:	f9000fe4 	str	x4, [sp, #24]
    int ret = -1;
  601041d34c:	12800000 	mov	w0, #0xffffffff            	// #-1
  601041d350:	b9004fe0 	str	w0, [sp, #76]

    switch (sys_num) {
  601041d354:	b9403fe0 	ldr	w0, [sp, #60]
  601041d358:	7100341f 	cmp	w0, #0xd
  601041d35c:	54001380 	b.eq	601041d5cc <syscall+0x29c>  // b.none
  601041d360:	b9403fe0 	ldr	w0, [sp, #60]
  601041d364:	7100341f 	cmp	w0, #0xd
  601041d368:	5400142c 	b.gt	601041d5ec <syscall+0x2bc>
  601041d36c:	b9403fe0 	ldr	w0, [sp, #60]
  601041d370:	7100301f 	cmp	w0, #0xc
  601041d374:	54001240 	b.eq	601041d5bc <syscall+0x28c>  // b.none
  601041d378:	b9403fe0 	ldr	w0, [sp, #60]
  601041d37c:	7100301f 	cmp	w0, #0xc
  601041d380:	5400136c 	b.gt	601041d5ec <syscall+0x2bc>
  601041d384:	b9403fe0 	ldr	w0, [sp, #60]
  601041d388:	71002c1f 	cmp	w0, #0xb
  601041d38c:	54001080 	b.eq	601041d59c <syscall+0x26c>  // b.none
  601041d390:	b9403fe0 	ldr	w0, [sp, #60]
  601041d394:	71002c1f 	cmp	w0, #0xb
  601041d398:	540012ac 	b.gt	601041d5ec <syscall+0x2bc>
  601041d39c:	b9403fe0 	ldr	w0, [sp, #60]
  601041d3a0:	7100281f 	cmp	w0, #0xa
  601041d3a4:	54000d80 	b.eq	601041d554 <syscall+0x224>  // b.none
  601041d3a8:	b9403fe0 	ldr	w0, [sp, #60]
  601041d3ac:	7100281f 	cmp	w0, #0xa
  601041d3b0:	540011ec 	b.gt	601041d5ec <syscall+0x2bc>
  601041d3b4:	b9403fe0 	ldr	w0, [sp, #60]
  601041d3b8:	7100241f 	cmp	w0, #0x9
  601041d3bc:	540007a0 	b.eq	601041d4b0 <syscall+0x180>  // b.none
  601041d3c0:	b9403fe0 	ldr	w0, [sp, #60]
  601041d3c4:	7100241f 	cmp	w0, #0x9
  601041d3c8:	5400112c 	b.gt	601041d5ec <syscall+0x2bc>
  601041d3cc:	b9403fe0 	ldr	w0, [sp, #60]
  601041d3d0:	7100201f 	cmp	w0, #0x8
  601041d3d4:	54000b40 	b.eq	601041d53c <syscall+0x20c>  // b.none
  601041d3d8:	b9403fe0 	ldr	w0, [sp, #60]
  601041d3dc:	7100201f 	cmp	w0, #0x8
  601041d3e0:	5400106c 	b.gt	601041d5ec <syscall+0x2bc>
  601041d3e4:	b9403fe0 	ldr	w0, [sp, #60]
  601041d3e8:	71001c1f 	cmp	w0, #0x7
  601041d3ec:	540009e0 	b.eq	601041d528 <syscall+0x1f8>  // b.none
  601041d3f0:	b9403fe0 	ldr	w0, [sp, #60]
  601041d3f4:	71001c1f 	cmp	w0, #0x7
  601041d3f8:	54000fac 	b.gt	601041d5ec <syscall+0x2bc>
  601041d3fc:	b9403fe0 	ldr	w0, [sp, #60]
  601041d400:	7100181f 	cmp	w0, #0x6
  601041d404:	54000800 	b.eq	601041d504 <syscall+0x1d4>  // b.none
  601041d408:	b9403fe0 	ldr	w0, [sp, #60]
  601041d40c:	7100181f 	cmp	w0, #0x6
  601041d410:	54000eec 	b.gt	601041d5ec <syscall+0x2bc>
  601041d414:	b9403fe0 	ldr	w0, [sp, #60]
  601041d418:	7100141f 	cmp	w0, #0x5
  601041d41c:	540006c0 	b.eq	601041d4f4 <syscall+0x1c4>  // b.none
  601041d420:	b9403fe0 	ldr	w0, [sp, #60]
  601041d424:	7100141f 	cmp	w0, #0x5
  601041d428:	54000e2c 	b.gt	601041d5ec <syscall+0x2bc>
  601041d42c:	b9403fe0 	ldr	w0, [sp, #60]
  601041d430:	7100101f 	cmp	w0, #0x4
  601041d434:	54000a00 	b.eq	601041d574 <syscall+0x244>  // b.none
  601041d438:	b9403fe0 	ldr	w0, [sp, #60]
  601041d43c:	7100101f 	cmp	w0, #0x4
  601041d440:	54000d6c 	b.gt	601041d5ec <syscall+0x2bc>
  601041d444:	b9403fe0 	ldr	w0, [sp, #60]
  601041d448:	71000c1f 	cmp	w0, #0x3
  601041d44c:	540004c0 	b.eq	601041d4e4 <syscall+0x1b4>  // b.none
  601041d450:	b9403fe0 	ldr	w0, [sp, #60]
  601041d454:	71000c1f 	cmp	w0, #0x3
  601041d458:	54000cac 	b.gt	601041d5ec <syscall+0x2bc>
  601041d45c:	b9403fe0 	ldr	w0, [sp, #60]
  601041d460:	7100081f 	cmp	w0, #0x2
  601041d464:	54000360 	b.eq	601041d4d0 <syscall+0x1a0>  // b.none
  601041d468:	b9403fe0 	ldr	w0, [sp, #60]
  601041d46c:	7100081f 	cmp	w0, #0x2
  601041d470:	54000bec 	b.gt	601041d5ec <syscall+0x2bc>
  601041d474:	b9403fe0 	ldr	w0, [sp, #60]
  601041d478:	7100001f 	cmp	w0, #0x0
  601041d47c:	540000a0 	b.eq	601041d490 <syscall+0x160>  // b.none
  601041d480:	b9403fe0 	ldr	w0, [sp, #60]
  601041d484:	7100041f 	cmp	w0, #0x1
  601041d488:	54000080 	b.eq	601041d498 <syscall+0x168>  // b.none
  601041d48c:	14000058 	b	601041d5ec <syscall+0x2bc>
    case SYSCALL_TEST:
        ret = 0;
  601041d490:	b9004fff 	str	wzr, [sp, #76]
        break;
  601041d494:	14000063 	b	601041d620 <syscall+0x2f0>
    case SYSCALL_SPAWN:
        ret = sys_spawn((char*)param1, (char*)param2, (char**)param3);
  601041d498:	f9401be0 	ldr	x0, [sp, #48]
  601041d49c:	f94017e1 	ldr	x1, [sp, #40]
  601041d4a0:	f94013e2 	ldr	x2, [sp, #32]
  601041d4a4:	94000062 	bl	601041d62c <sys_spawn>
  601041d4a8:	b9004fe0 	str	w0, [sp, #76]
        break;
  601041d4ac:	1400005d 	b	601041d620 <syscall+0x2f0>
    case SYSCALL_THREAD:
        ret = sys_thread((uintptr_t)param1, (char*)param2, (char**)param3);
  601041d4b0:	f94017e0 	ldr	x0, [sp, #40]
  601041d4b4:	f94013e1 	ldr	x1, [sp, #32]
  601041d4b8:	aa0103e2 	mov	x2, x1
  601041d4bc:	aa0003e1 	mov	x1, x0
  601041d4c0:	f9401be0 	ldr	x0, [sp, #48]
  601041d4c4:	9400013f 	bl	601041d9c0 <sys_thread>
  601041d4c8:	b9004fe0 	str	w0, [sp, #76]
        break;
  601041d4cc:	14000055 	b	601041d620 <syscall+0x2f0>
    case SYSCALL_EXIT:
        ret = sys_exit(cur_cpu()->task);
  601041d4d0:	97ffff8d 	bl	601041d304 <cur_cpu>
  601041d4d4:	f9400400 	ldr	x0, [x0, #8]
  601041d4d8:	9400070c 	bl	601041f108 <sys_exit>
  601041d4dc:	b9004fe0 	str	w0, [sp, #76]
        break;
  601041d4e0:	14000050 	b	601041d620 <syscall+0x2f0>
    case SYSCALL_YIELD:
        ret = sys_yield((task_yield_reason)param1);
  601041d4e4:	f9401be0 	ldr	x0, [sp, #48]
  601041d4e8:	94000185 	bl	601041dafc <sys_yield>
  601041d4ec:	b9004fe0 	str	w0, [sp, #76]
        break;
  601041d4f0:	1400004c 	b	601041d620 <syscall+0x2f0>
    case SYSCALL_SERVER:
        ret = sys_register_as_server((char*)param1);
  601041d4f4:	f9401be0 	ldr	x0, [sp, #48]
  601041d4f8:	940001df 	bl	601041dc74 <sys_register_as_server>
  601041d4fc:	b9004fe0 	str	w0, [sp, #76]
        break;
  601041d500:	14000048 	b	601041d620 <syscall+0x2f0>
    case SYSCALL_SESSION:
        ret = sys_connect_session((char*)param1, (int)param2, (struct Session*)param3);
  601041d504:	f9401be0 	ldr	x0, [sp, #48]
  601041d508:	f94017e1 	ldr	x1, [sp, #40]
  601041d50c:	2a0103e3 	mov	w3, w1
  601041d510:	f94013e1 	ldr	x1, [sp, #32]
  601041d514:	aa0103e2 	mov	x2, x1
  601041d518:	2a0303e1 	mov	w1, w3
  601041d51c:	94000277 	bl	601041def8 <sys_connect_session>
  601041d520:	b9004fe0 	str	w0, [sp, #76]
        break;
  601041d524:	1400003f 	b	601041d620 <syscall+0x2f0>
    case SYSCALL_POLL_SESSION:
        ret = sys_poll_session((struct Session*)param1, (int)param2);
  601041d528:	f9401be0 	ldr	x0, [sp, #48]
  601041d52c:	f94017e1 	ldr	x1, [sp, #40]
  601041d530:	94000324 	bl	601041e1c0 <sys_poll_session>
  601041d534:	b9004fe0 	str	w0, [sp, #76]
        break;
  601041d538:	1400003a 	b	601041d620 <syscall+0x2f0>
    case SYSCALL_CLOSE_SESSION:
        ret = sys_close_session(cur_cpu()->task, (struct Session*)param1);
  601041d53c:	97ffff72 	bl	601041d304 <cur_cpu>
  601041d540:	f9400400 	ldr	x0, [x0, #8]
  601041d544:	f9401be1 	ldr	x1, [sp, #48]
  601041d548:	9400047b 	bl	601041e734 <sys_close_session>
  601041d54c:	b9004fe0 	str	w0, [sp, #76]
        break;
  601041d550:	14000034 	b	601041d620 <syscall+0x2f0>
    case SYSCALL_SYS_STATE:
        ret = sys_state(param1, (sys_state_info*)param2);
  601041d554:	f9401be0 	ldr	x0, [sp, #48]
  601041d558:	2a0003e2 	mov	w2, w0
  601041d55c:	f94017e0 	ldr	x0, [sp, #40]
  601041d560:	aa0003e1 	mov	x1, x0
  601041d564:	2a0203e0 	mov	w0, w2
  601041d568:	940008e4 	bl	601041f8f8 <sys_state>
  601041d56c:	b9004fe0 	str	w0, [sp, #76]
        break;
  601041d570:	1400002c 	b	601041d620 <syscall+0x2f0>
    case SYSCALL_MMAP:
        ret = sys_mmap(param1, param2, (int)param3, (int)param4);
  601041d574:	f94013e0 	ldr	x0, [sp, #32]
  601041d578:	2a0003e1 	mov	w1, w0
  601041d57c:	f9400fe0 	ldr	x0, [sp, #24]
  601041d580:	2a0003e3 	mov	w3, w0
  601041d584:	2a0103e2 	mov	w2, w1
  601041d588:	f94017e1 	ldr	x1, [sp, #40]
  601041d58c:	f9401be0 	ldr	x0, [sp, #48]
  601041d590:	94000923 	bl	601041fa1c <sys_mmap>
  601041d594:	b9004fe0 	str	w0, [sp, #76]
        break;
  601041d598:	14000022 	b	601041d620 <syscall+0x2f0>
    case SYSCALL_REGISTER_IRQ:
        ret = sys_register_irq((int)param1, (int)param2);
  601041d59c:	f9401be0 	ldr	x0, [sp, #48]
  601041d5a0:	2a0003e2 	mov	w2, w0
  601041d5a4:	f94017e0 	ldr	x0, [sp, #40]
  601041d5a8:	2a0003e1 	mov	w1, w0
  601041d5ac:	2a0203e0 	mov	w0, w2
  601041d5b0:	940005f5 	bl	601041ed84 <sys_register_irq>
  601041d5b4:	b9004fe0 	str	w0, [sp, #76]
        break;
  601041d5b8:	1400001a 	b	601041d620 <syscall+0x2f0>
    case SYSCALL_KILL:
        ret = sys_kill((int)param1);
  601041d5bc:	f9401be0 	ldr	x0, [sp, #48]
  601041d5c0:	9400097e 	bl	601041fbb8 <sys_kill>
  601041d5c4:	b9004fe0 	str	w0, [sp, #76]
        break;
  601041d5c8:	14000016 	b	601041d620 <syscall+0x2f0>
    case SYSCALL_SEMAPHORE:
        ret = sys_semaphore((sys_sem_option)param1, (int)param2);
  601041d5cc:	f9401be0 	ldr	x0, [sp, #48]
  601041d5d0:	2a0003e2 	mov	w2, w0
  601041d5d4:	f94017e0 	ldr	x0, [sp, #40]
  601041d5d8:	2a0003e1 	mov	w1, w0
  601041d5dc:	2a0203e0 	mov	w0, w2
  601041d5e0:	940009e8 	bl	601041fd80 <sys_semaphore>
  601041d5e4:	b9004fe0 	str	w0, [sp, #76]
        break;
  601041d5e8:	1400000e 	b	601041d620 <syscall+0x2f0>
    default:
        ERROR("Unsurport syscall(%d) right now\n", sys_num);
  601041d5ec:	52800a82 	mov	w2, #0x54                  	// #84
  601041d5f0:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041d5f4:	91094001 	add	x1, x0, #0x250
  601041d5f8:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041d5fc:	91086000 	add	x0, x0, #0x218
  601041d600:	97ffdade 	bl	6010414178 <printf_>
  601041d604:	b9403fe1 	ldr	w1, [sp, #60]
  601041d608:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041d60c:	9108a000 	add	x0, x0, #0x228
  601041d610:	97ffdada 	bl	6010414178 <printf_>
        ret = -1;
  601041d614:	12800000 	mov	w0, #0xffffffff            	// #-1
  601041d618:	b9004fe0 	str	w0, [sp, #76]
        break;
  601041d61c:	d503201f 	nop
    }

    return ret;
  601041d620:	b9404fe0 	ldr	w0, [sp, #76]
  601041d624:	a8c57bfd 	ldp	x29, x30, [sp], #80
  601041d628:	d65f03c0 	ret

000000601041d62c <sys_spawn>:
#include "syscall.h"
#include "task.h"

extern int sys_new_thread(struct MemSpace* pmemspace, struct Thread* task, uintptr_t entry, char* name, char** argv);
int sys_spawn(char* img_start, char* name, char** argv)
{
  601041d62c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  601041d630:	910003fd 	mov	x29, sp
  601041d634:	f90017e0 	str	x0, [sp, #40]
  601041d638:	f90013e1 	str	x1, [sp, #32]
  601041d63c:	f9000fe2 	str	x2, [sp, #24]
    // alloc a new memspace
    struct MemSpace* pmemspace = alloc_memspace();
  601041d640:	97fffac8 	bl	601041c160 <alloc_memspace>
  601041d644:	f90027e0 	str	x0, [sp, #72]
    if (pmemspace == NULL) {
  601041d648:	f94027e0 	ldr	x0, [sp, #72]
  601041d64c:	f100001f 	cmp	x0, #0x0
  601041d650:	54000061 	b.ne	601041d65c <sys_spawn+0x30>  // b.any
        return -1;
  601041d654:	12800000 	mov	w0, #0xffffffff            	// #-1
  601041d658:	1400004c 	b	601041d788 <sys_spawn+0x15c>
    }

    // load memspace
    uintptr_t* entry = load_memspace(pmemspace, img_start);
  601041d65c:	f94017e1 	ldr	x1, [sp, #40]
  601041d660:	f94027e0 	ldr	x0, [sp, #72]
  601041d664:	97fffb1f 	bl	601041c2e0 <load_memspace>
  601041d668:	f90023e0 	str	x0, [sp, #64]
    if (pmemspace->pgdir.pd_addr == NULL) {
  601041d66c:	f94027e0 	ldr	x0, [sp, #72]
  601041d670:	f9400000 	ldr	x0, [x0]
  601041d674:	f100001f 	cmp	x0, #0x0
  601041d678:	540001e1 	b.ne	601041d6b4 <sys_spawn+0x88>  // b.any
        ERROR("Loading memspace from %016x failed.\n", img_start);
  601041d67c:	52800622 	mov	w2, #0x31                  	// #49
  601041d680:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041d684:	910c2001 	add	x1, x0, #0x308
  601041d688:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041d68c:	91096000 	add	x0, x0, #0x258
  601041d690:	97ffdaba 	bl	6010414178 <printf_>
  601041d694:	f94017e1 	ldr	x1, [sp, #40]
  601041d698:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041d69c:	9109a000 	add	x0, x0, #0x268
  601041d6a0:	97ffdab6 	bl	6010414178 <printf_>
        free_memspace(pmemspace);
  601041d6a4:	f94027e0 	ldr	x0, [sp, #72]
  601041d6a8:	97fffadb 	bl	601041c214 <free_memspace>
        return -1;
  601041d6ac:	12800000 	mov	w0, #0xffffffff            	// #-1
  601041d6b0:	14000036 	b	601041d788 <sys_spawn+0x15c>
    }

    // alloc a new pcb
    struct Thread* new_task_cb = xizi_task_manager.new_task_cb(pmemspace);
  601041d6b4:	d0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041d6b8:	f942ec00 	ldr	x0, [x0, #1496]
  601041d6bc:	f9419401 	ldr	x1, [x0, #808]
  601041d6c0:	f94027e0 	ldr	x0, [sp, #72]
  601041d6c4:	d63f0020 	blr	x1
  601041d6c8:	f9001fe0 	str	x0, [sp, #56]
    if (UNLIKELY(!new_task_cb)) {
  601041d6cc:	f9401fe0 	ldr	x0, [sp, #56]
  601041d6d0:	f100001f 	cmp	x0, #0x0
  601041d6d4:	1a9f17e0 	cset	w0, eq  // eq = none
  601041d6d8:	12001c00 	and	w0, w0, #0xff
  601041d6dc:	92401c00 	and	x0, x0, #0xff
  601041d6e0:	f100001f 	cmp	x0, #0x0
  601041d6e4:	540001c0 	b.eq	601041d71c <sys_spawn+0xf0>  // b.none
        ERROR("Unable to new task control block.\n");
  601041d6e8:	52800722 	mov	w2, #0x39                  	// #57
  601041d6ec:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041d6f0:	910c2001 	add	x1, x0, #0x308
  601041d6f4:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041d6f8:	91096000 	add	x0, x0, #0x258
  601041d6fc:	97ffda9f 	bl	6010414178 <printf_>
  601041d700:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041d704:	910a4000 	add	x0, x0, #0x290
  601041d708:	97ffda9c 	bl	6010414178 <printf_>
        free_memspace(pmemspace);
  601041d70c:	f94027e0 	ldr	x0, [sp, #72]
  601041d710:	97fffac1 	bl	601041c214 <free_memspace>
        return -1;
  601041d714:	12800000 	mov	w0, #0xffffffff            	// #-1
  601041d718:	1400001c 	b	601041d788 <sys_spawn+0x15c>
    }
    assert(!IS_DOUBLE_LIST_EMPTY(&pmemspace->thread_list_guard));
  601041d71c:	f94027e0 	ldr	x0, [sp, #72]
  601041d720:	f9401401 	ldr	x1, [x0, #40]
  601041d724:	f94027e0 	ldr	x0, [sp, #72]
  601041d728:	9100a000 	add	x0, x0, #0x28
  601041d72c:	eb00003f 	cmp	x1, x0
  601041d730:	540001e1 	b.ne	601041d76c <sys_spawn+0x140>  // b.any
  601041d734:	528007a2 	mov	w2, #0x3d                  	// #61
  601041d738:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041d73c:	910c2001 	add	x1, x0, #0x308
  601041d740:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041d744:	91096000 	add	x0, x0, #0x258
  601041d748:	97ffda8c 	bl	6010414178 <printf_>
  601041d74c:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041d750:	910ae001 	add	x1, x0, #0x2b8
  601041d754:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041d758:	910bc000 	add	x0, x0, #0x2f0
  601041d75c:	97ffda87 	bl	6010414178 <printf_>
  601041d760:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041d764:	910c0000 	add	x0, x0, #0x300
  601041d768:	97ffc6d0 	bl	601040f2a8 <panic>

    return sys_new_thread(pmemspace, new_task_cb, (uintptr_t)entry, name, argv);
  601041d76c:	f94023e0 	ldr	x0, [sp, #64]
  601041d770:	f9400fe4 	ldr	x4, [sp, #24]
  601041d774:	f94013e3 	ldr	x3, [sp, #32]
  601041d778:	aa0003e2 	mov	x2, x0
  601041d77c:	f9401fe1 	ldr	x1, [sp, #56]
  601041d780:	f94027e0 	ldr	x0, [sp, #72]
  601041d784:	94000013 	bl	601041d7d0 <sys_new_thread>
  601041d788:	a8c57bfd 	ldp	x29, x30, [sp], #80
  601041d78c:	d65f03c0 	ret

000000601041d790 <cur_cpuid>:
{
  601041d790:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601041d794:	910003fd 	mov	x29, sp
    return cpu_get_current();
  601041d798:	97ffc3c0 	bl	601040e698 <cpu_get_current>
}
  601041d79c:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601041d7a0:	d65f03c0 	ret

000000601041d7a4 <cur_cpu>:
{
  601041d7a4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601041d7a8:	910003fd 	mov	x29, sp
    return &global_cpus[cur_cpuid()];
  601041d7ac:	97fffff9 	bl	601041d790 <cur_cpuid>
  601041d7b0:	93407c01 	sxtw	x1, w0
  601041d7b4:	d2800300 	mov	x0, #0x18                  	// #24
  601041d7b8:	9b007c21 	mul	x1, x1, x0
  601041d7bc:	d0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041d7c0:	f942f400 	ldr	x0, [x0, #1512]
  601041d7c4:	8b000020 	add	x0, x1, x0
}
  601041d7c8:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601041d7cc:	d65f03c0 	ret

000000601041d7d0 <sys_new_thread>:
#include "share_page.h"
#include "syscall.h"
#include "task.h"

int sys_new_thread(struct MemSpace* pmemspace, struct Thread* task, uintptr_t entry, char* name, char** argv)
{
  601041d7d0:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
  601041d7d4:	910003fd 	mov	x29, sp
  601041d7d8:	f9001fe0 	str	x0, [sp, #56]
  601041d7dc:	f9001be1 	str	x1, [sp, #48]
  601041d7e0:	f90017e2 	str	x2, [sp, #40]
  601041d7e4:	f90013e3 	str	x3, [sp, #32]
  601041d7e8:	f9000fe4 	str	x4, [sp, #24]
    struct ThreadStackPointer loaded_sp = load_user_stack(pmemspace, argv);
  601041d7ec:	910103e0 	add	x0, sp, #0x40
  601041d7f0:	aa0003e8 	mov	x8, x0
  601041d7f4:	f9400fe1 	ldr	x1, [sp, #24]
  601041d7f8:	f9401fe0 	ldr	x0, [sp, #56]
  601041d7fc:	97fffbef 	bl	601041c7b8 <load_user_stack>
    if (loaded_sp.stack_idx == -1) {
  601041d800:	b94047e0 	ldr	w0, [sp, #68]
  601041d804:	3100041f 	cmn	w0, #0x1
  601041d808:	54000221 	b.ne	601041d84c <sys_new_thread+0x7c>  // b.any
        ERROR("Uable to load params to memspace.\n");
  601041d80c:	52800542 	mov	w2, #0x2a                  	// #42
  601041d810:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041d814:	910f2001 	add	x1, x0, #0x3c8
  601041d818:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041d81c:	910c6000 	add	x0, x0, #0x318
  601041d820:	97ffda56 	bl	6010414178 <printf_>
  601041d824:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041d828:	910ca000 	add	x0, x0, #0x328
  601041d82c:	97ffda53 	bl	6010414178 <printf_>
        /* memspace is freed alone with free_pcb() */
        xizi_task_manager.free_pcb(task);
  601041d830:	d0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041d834:	f942ec00 	ldr	x0, [x0, #1496]
  601041d838:	f9419801 	ldr	x1, [x0, #816]
  601041d83c:	f9401be0 	ldr	x0, [sp, #48]
  601041d840:	d63f0020 	blr	x1
        return -1;
  601041d844:	12800000 	mov	w0, #0xffffffff            	// #-1
  601041d848:	1400005c 	b	601041d9b8 <sys_new_thread+0x1e8>
    }

    // init trapframe
    task->thread_context.user_stack_idx = loaded_sp.stack_idx;
  601041d84c:	b94047e1 	ldr	w1, [sp, #68]
  601041d850:	f9401be0 	ldr	x0, [sp, #48]
  601041d854:	b9002801 	str	w1, [x0, #40]
    task->thread_context.uspace_stack_addr = USER_MEM_TOP - ((loaded_sp.stack_idx + 1) * USER_STACK_SIZE);
  601041d858:	b94047e0 	ldr	w0, [sp, #68]
  601041d85c:	11000400 	add	w0, w0, #0x1
  601041d860:	53144c00 	lsl	w0, w0, #12
  601041d864:	93407c00 	sxtw	x0, w0
  601041d868:	d2c00801 	mov	x1, #0x4000000000          	// #274877906944
  601041d86c:	cb000021 	sub	x1, x1, x0
  601041d870:	f9401be0 	ldr	x0, [sp, #48]
  601041d874:	f9001801 	str	x1, [x0, #48]
    task->thread_context.ustack_kvaddr = loaded_sp.user_stack_vaddr;
  601041d878:	f9402be1 	ldr	x1, [sp, #80]
  601041d87c:	f9401be0 	ldr	x0, [sp, #48]
  601041d880:	f9001c01 	str	x1, [x0, #56]
    arch_init_trapframe(task->thread_context.trapframe, 0, 0);
  601041d884:	f9401be0 	ldr	x0, [sp, #48]
  601041d888:	f9402400 	ldr	x0, [x0, #72]
  601041d88c:	f9003be0 	str	x0, [sp, #112]
  601041d890:	f90037ff 	str	xzr, [sp, #104]
  601041d894:	f90033ff 	str	xzr, [sp, #96]
    memset(tf, 0, sizeof(*tf));
  601041d898:	d2802202 	mov	x2, #0x110                 	// #272
  601041d89c:	52800001 	mov	w1, #0x0                   	// #0
  601041d8a0:	f9403be0 	ldr	x0, [sp, #112]
  601041d8a4:	97ffc287 	bl	601040e2c0 <memset>
    tf->sp = sp;
  601041d8a8:	f9403be0 	ldr	x0, [sp, #112]
  601041d8ac:	f94037e1 	ldr	x1, [sp, #104]
  601041d8b0:	f9008401 	str	x1, [x0, #264]
    uint64_t val = 0;
  601041d8b4:	f9002fff 	str	xzr, [sp, #88]
    return val;
  601041d8b8:	f9402fe1 	ldr	x1, [sp, #88]
    tf->spsr = EL0_mode();
  601041d8bc:	f9403be0 	ldr	x0, [sp, #112]
  601041d8c0:	f9008001 	str	x1, [x0, #256]
    tf->pc = pc;
  601041d8c4:	f9403be0 	ldr	x0, [sp, #112]
  601041d8c8:	f94033e1 	ldr	x1, [sp, #96]
  601041d8cc:	f9007c01 	str	x1, [x0, #248]
}
  601041d8d0:	d503201f 	nop
    arch_trapframe_set_sp_pc(task->thread_context.trapframe, loaded_sp.user_sp, (uintptr_t)entry);
  601041d8d4:	f9401be0 	ldr	x0, [sp, #48]
  601041d8d8:	f9402401 	ldr	x1, [x0, #72]
  601041d8dc:	f94027e0 	ldr	x0, [sp, #72]
  601041d8e0:	f90047e1 	str	x1, [sp, #136]
  601041d8e4:	f90043e0 	str	x0, [sp, #128]
  601041d8e8:	f94017e0 	ldr	x0, [sp, #40]
  601041d8ec:	f9003fe0 	str	x0, [sp, #120]
    tf->sp = sp;
  601041d8f0:	f94047e0 	ldr	x0, [sp, #136]
  601041d8f4:	f94043e1 	ldr	x1, [sp, #128]
  601041d8f8:	f9008401 	str	x1, [x0, #264]
    tf->pc = pc;
  601041d8fc:	f94047e0 	ldr	x0, [sp, #136]
  601041d900:	f9403fe1 	ldr	x1, [sp, #120]
  601041d904:	f9007c01 	str	x1, [x0, #248]
}
  601041d908:	d503201f 	nop
    arch_set_main_params(task->thread_context.trapframe, loaded_sp.argc, loaded_sp.user_sp);
  601041d90c:	f9401be0 	ldr	x0, [sp, #48]
  601041d910:	f9402402 	ldr	x2, [x0, #72]
  601041d914:	b94043e1 	ldr	w1, [sp, #64]
  601041d918:	f94027e0 	ldr	x0, [sp, #72]
  601041d91c:	f90053e2 	str	x2, [sp, #160]
  601041d920:	b9009fe1 	str	w1, [sp, #156]
  601041d924:	f9004be0 	str	x0, [sp, #144]
    tf->x0 = (uint64_t)argc;
  601041d928:	b9809fe1 	ldrsw	x1, [sp, #156]
  601041d92c:	f94053e0 	ldr	x0, [sp, #160]
  601041d930:	f9000001 	str	x1, [x0]
    tf->x1 = (uint64_t)argv;
  601041d934:	f94053e0 	ldr	x0, [sp, #160]
  601041d938:	f9404be1 	ldr	x1, [sp, #144]
  601041d93c:	f9000401 	str	x1, [x0, #8]
}
  601041d940:	d503201f 	nop

    // init thread name
    char* last = NULL;
  601041d944:	f90057ff 	str	xzr, [sp, #168]
    for (last = name; *name; name++) {
  601041d948:	f94013e0 	ldr	x0, [sp, #32]
  601041d94c:	f90057e0 	str	x0, [sp, #168]
  601041d950:	1400000b 	b	601041d97c <sys_new_thread+0x1ac>
        if (*name == '/') {
  601041d954:	f94013e0 	ldr	x0, [sp, #32]
  601041d958:	39400000 	ldrb	w0, [x0]
  601041d95c:	7100bc1f 	cmp	w0, #0x2f
  601041d960:	54000081 	b.ne	601041d970 <sys_new_thread+0x1a0>  // b.any
            last = name + 1;
  601041d964:	f94013e0 	ldr	x0, [sp, #32]
  601041d968:	91000400 	add	x0, x0, #0x1
  601041d96c:	f90057e0 	str	x0, [sp, #168]
    for (last = name; *name; name++) {
  601041d970:	f94013e0 	ldr	x0, [sp, #32]
  601041d974:	91000400 	add	x0, x0, #0x1
  601041d978:	f90013e0 	str	x0, [sp, #32]
  601041d97c:	f94013e0 	ldr	x0, [sp, #32]
  601041d980:	39400000 	ldrb	w0, [x0]
  601041d984:	7100001f 	cmp	w0, #0x0
  601041d988:	54fffe61 	b.ne	601041d954 <sys_new_thread+0x184>  // b.any
        }
    }
    strncpy(task->name, last, sizeof(task->name));
  601041d98c:	f9401be0 	ldr	x0, [sp, #48]
  601041d990:	d2800202 	mov	x2, #0x10                  	// #16
  601041d994:	f94057e1 	ldr	x1, [sp, #168]
  601041d998:	94000b7a 	bl	6010420780 <strncpy>

    // init pcb schedule attributes
    xizi_task_manager.task_set_default_schedule_attr(task);
  601041d99c:	d0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041d9a0:	f942ec00 	ldr	x0, [x0, #1496]
  601041d9a4:	f9419c01 	ldr	x1, [x0, #824]
  601041d9a8:	f9401be0 	ldr	x0, [sp, #48]
  601041d9ac:	d63f0020 	blr	x1

    return task->tid;
  601041d9b0:	f9401be0 	ldr	x0, [sp, #48]
  601041d9b4:	b9401000 	ldr	w0, [x0, #16]
}
  601041d9b8:	a8cb7bfd 	ldp	x29, x30, [sp], #176
  601041d9bc:	d65f03c0 	ret

000000601041d9c0 <sys_thread>:

int sys_thread(uintptr_t entry, char* name, char** argv)
{
  601041d9c0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  601041d9c4:	910003fd 	mov	x29, sp
  601041d9c8:	f90017e0 	str	x0, [sp, #40]
  601041d9cc:	f90013e1 	str	x1, [sp, #32]
  601041d9d0:	f9000fe2 	str	x2, [sp, #24]
    struct Thread* cur_task = cur_cpu()->task;
  601041d9d4:	97ffff74 	bl	601041d7a4 <cur_cpu>
  601041d9d8:	f9400400 	ldr	x0, [x0, #8]
  601041d9dc:	f90027e0 	str	x0, [sp, #72]

    // use current task's memspace
    struct MemSpace* pmemspace = cur_task->memspace;
  601041d9e0:	f94027e0 	ldr	x0, [sp, #72]
  601041d9e4:	f9402800 	ldr	x0, [x0, #80]
  601041d9e8:	f90023e0 	str	x0, [sp, #64]

    struct Thread* task = xizi_task_manager.new_task_cb(pmemspace);
  601041d9ec:	d0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041d9f0:	f942ec00 	ldr	x0, [x0, #1496]
  601041d9f4:	f9419401 	ldr	x1, [x0, #808]
  601041d9f8:	f94023e0 	ldr	x0, [sp, #64]
  601041d9fc:	d63f0020 	blr	x1
  601041da00:	f9001fe0 	str	x0, [sp, #56]
    if (UNLIKELY(!task)) {
  601041da04:	f9401fe0 	ldr	x0, [sp, #56]
  601041da08:	f100001f 	cmp	x0, #0x0
  601041da0c:	1a9f17e0 	cset	w0, eq  // eq = none
  601041da10:	12001c00 	and	w0, w0, #0xff
  601041da14:	92401c00 	and	x0, x0, #0xff
  601041da18:	f100001f 	cmp	x0, #0x0
  601041da1c:	54000180 	b.eq	601041da4c <sys_thread+0x8c>  // b.none
        ERROR("Unable to new task control block.\n");
  601041da20:	52800a02 	mov	w2, #0x50                  	// #80
  601041da24:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041da28:	910f6001 	add	x1, x0, #0x3d8
  601041da2c:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041da30:	910c6000 	add	x0, x0, #0x318
  601041da34:	97ffd9d1 	bl	6010414178 <printf_>
  601041da38:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041da3c:	910d4000 	add	x0, x0, #0x350
  601041da40:	97ffd9ce 	bl	6010414178 <printf_>
        return -1;
  601041da44:	12800000 	mov	w0, #0xffffffff            	// #-1
  601041da48:	1400001b 	b	601041dab4 <sys_thread+0xf4>
    }
    assert(!IS_DOUBLE_LIST_EMPTY(&pmemspace->thread_list_guard));
  601041da4c:	f94023e0 	ldr	x0, [sp, #64]
  601041da50:	f9401401 	ldr	x1, [x0, #40]
  601041da54:	f94023e0 	ldr	x0, [sp, #64]
  601041da58:	9100a000 	add	x0, x0, #0x28
  601041da5c:	eb00003f 	cmp	x1, x0
  601041da60:	540001e1 	b.ne	601041da9c <sys_thread+0xdc>  // b.any
  601041da64:	52800a62 	mov	w2, #0x53                  	// #83
  601041da68:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041da6c:	910f6001 	add	x1, x0, #0x3d8
  601041da70:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041da74:	910c6000 	add	x0, x0, #0x318
  601041da78:	97ffd9c0 	bl	6010414178 <printf_>
  601041da7c:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041da80:	910de001 	add	x1, x0, #0x378
  601041da84:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041da88:	910ec000 	add	x0, x0, #0x3b0
  601041da8c:	97ffd9bb 	bl	6010414178 <printf_>
  601041da90:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041da94:	910f0000 	add	x0, x0, #0x3c0
  601041da98:	97ffc604 	bl	601040f2a8 <panic>

    return sys_new_thread(pmemspace, task, entry, name, argv);
  601041da9c:	f9400fe4 	ldr	x4, [sp, #24]
  601041daa0:	f94013e3 	ldr	x3, [sp, #32]
  601041daa4:	f94017e2 	ldr	x2, [sp, #40]
  601041daa8:	f9401fe1 	ldr	x1, [sp, #56]
  601041daac:	f94023e0 	ldr	x0, [sp, #64]
  601041dab0:	97ffff48 	bl	601041d7d0 <sys_new_thread>
  601041dab4:	a8c57bfd 	ldp	x29, x30, [sp], #80
  601041dab8:	d65f03c0 	ret

000000601041dabc <cur_cpuid>:
{
  601041dabc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601041dac0:	910003fd 	mov	x29, sp
    return cpu_get_current();
  601041dac4:	97ffc2f5 	bl	601040e698 <cpu_get_current>
}
  601041dac8:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601041dacc:	d65f03c0 	ret

000000601041dad0 <cur_cpu>:
{
  601041dad0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601041dad4:	910003fd 	mov	x29, sp
    return &global_cpus[cur_cpuid()];
  601041dad8:	97fffff9 	bl	601041dabc <cur_cpuid>
  601041dadc:	93407c01 	sxtw	x1, w0
  601041dae0:	d2800300 	mov	x0, #0x18                  	// #24
  601041dae4:	9b007c21 	mul	x1, x1, x0
  601041dae8:	d0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041daec:	f942f400 	ldr	x0, [x0, #1512]
  601041daf0:	8b000020 	add	x0, x1, x0
}
  601041daf4:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601041daf8:	d65f03c0 	ret

000000601041dafc <sys_yield>:
#include "task.h"

#include "assert.h"

int sys_yield(task_yield_reason reason)
{
  601041dafc:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  601041db00:	910003fd 	mov	x29, sp
  601041db04:	b9001fe0 	str	w0, [sp, #28]
    struct Thread* cur_task = cur_cpu()->task;
  601041db08:	97fffff2 	bl	601041dad0 <cur_cpu>
  601041db0c:	f9400400 	ldr	x0, [x0, #8]
  601041db10:	f9001be0 	str	x0, [sp, #48]
    xizi_task_manager.task_yield_noschedule(cur_task, false);
  601041db14:	d0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041db18:	f942ec00 	ldr	x0, [x0, #1496]
  601041db1c:	f941a802 	ldr	x2, [x0, #848]
  601041db20:	52800001 	mov	w1, #0x0                   	// #0
  601041db24:	f9401be0 	ldr	x0, [sp, #48]
  601041db28:	d63f0040 	blr	x2

    // handle ipc block
    if ((reason & SYS_TASK_YIELD_BLOCK_IPC) != 0) {
  601041db2c:	b9401fe0 	ldr	w0, [sp, #28]
  601041db30:	121f0000 	and	w0, w0, #0x2
  601041db34:	7100001f 	cmp	w0, #0x0
  601041db38:	54000200 	b.eq	601041db78 <sys_yield+0x7c>  // b.none
        if (cur_task->current_ipc_handled) {
  601041db3c:	f9401be0 	ldr	x0, [sp, #48]
  601041db40:	39422000 	ldrb	w0, [x0, #136]
  601041db44:	7100001f 	cmp	w0, #0x0
  601041db48:	54000080 	b.eq	601041db58 <sys_yield+0x5c>  // b.none
            cur_task->current_ipc_handled = false;
  601041db4c:	f9401be0 	ldr	x0, [sp, #48]
  601041db50:	3902201f 	strb	wzr, [x0, #136]
  601041db54:	14000009 	b	601041db78 <sys_yield+0x7c>
        } else {
            xizi_task_manager.task_block(&xizi_task_manager.task_blocked_list_head, cur_task);
  601041db58:	d0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041db5c:	f942ec00 	ldr	x0, [x0, #1496]
  601041db60:	f941ac02 	ldr	x2, [x0, #856]
  601041db64:	f9401be1 	ldr	x1, [sp, #48]
  601041db68:	d0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041db6c:	f942ec00 	ldr	x0, [x0, #1496]
  601041db70:	91084000 	add	x0, x0, #0x210
  601041db74:	d63f0040 	blr	x2
        }
    }

    // wake up all possible server
    struct client_session* client_session = NULL;
  601041db78:	f9001fff 	str	xzr, [sp, #56]
    DOUBLE_LIST_FOR_EACH_ENTRY(client_session, &cur_task->cli_sess_listhead, node)
  601041db7c:	f9401be0 	ldr	x0, [sp, #48]
  601041db80:	f9403400 	ldr	x0, [x0, #104]
  601041db84:	f9001fe0 	str	x0, [sp, #56]
  601041db88:	14000023 	b	601041dc14 <sys_yield+0x118>
    {
        assert(client_session != NULL);
  601041db8c:	f9401fe0 	ldr	x0, [sp, #56]
  601041db90:	f100001f 	cmp	x0, #0x0
  601041db94:	540001e1 	b.ne	601041dbd0 <sys_yield+0xd4>  // b.any
  601041db98:	528006c2 	mov	w2, #0x36                  	// #54
  601041db9c:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041dba0:	9110a001 	add	x1, x0, #0x428
  601041dba4:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041dba8:	910fa000 	add	x0, x0, #0x3e8
  601041dbac:	97ffd973 	bl	6010414178 <printf_>
  601041dbb0:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041dbb4:	910fe001 	add	x1, x0, #0x3f8
  601041dbb8:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041dbbc:	91104000 	add	x0, x0, #0x410
  601041dbc0:	97ffd96e 	bl	6010414178 <printf_>
  601041dbc4:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041dbc8:	91108000 	add	x0, x0, #0x420
  601041dbcc:	97ffc5b7 	bl	601040f2a8 <panic>
        struct session_backend* session_backend = CLIENT_SESSION_BACKEND(client_session);
  601041dbd0:	f9401fe0 	ldr	x0, [sp, #56]
  601041dbd4:	d100a000 	sub	x0, x0, #0x28
  601041dbd8:	f90017e0 	str	x0, [sp, #40]
        if (session_backend->server->state == BLOCKED) {
  601041dbdc:	f94017e0 	ldr	x0, [sp, #40]
  601041dbe0:	f9402c00 	ldr	x0, [x0, #88]
  601041dbe4:	b940a800 	ldr	w0, [x0, #168]
  601041dbe8:	7100101f 	cmp	w0, #0x4
  601041dbec:	540000e1 	b.ne	601041dc08 <sys_yield+0x10c>  // b.any
            xizi_task_manager.task_unblock(session_backend->server);
  601041dbf0:	d0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041dbf4:	f942ec00 	ldr	x0, [x0, #1496]
  601041dbf8:	f941b001 	ldr	x1, [x0, #864]
  601041dbfc:	f94017e0 	ldr	x0, [sp, #40]
  601041dc00:	f9402c00 	ldr	x0, [x0, #88]
  601041dc04:	d63f0020 	blr	x1
    DOUBLE_LIST_FOR_EACH_ENTRY(client_session, &cur_task->cli_sess_listhead, node)
  601041dc08:	f9401fe0 	ldr	x0, [sp, #56]
  601041dc0c:	f9400000 	ldr	x0, [x0]
  601041dc10:	f9001fe0 	str	x0, [sp, #56]
  601041dc14:	f9401fe1 	ldr	x1, [sp, #56]
  601041dc18:	f9401be0 	ldr	x0, [sp, #48]
  601041dc1c:	9101a000 	add	x0, x0, #0x68
  601041dc20:	eb00003f 	cmp	x1, x0
  601041dc24:	54fffb41 	b.ne	601041db8c <sys_yield+0x90>  // b.any
        }
    }

    return 0;
  601041dc28:	52800000 	mov	w0, #0x0                   	// #0
  601041dc2c:	a8c47bfd 	ldp	x29, x30, [sp], #64
  601041dc30:	d65f03c0 	ret

000000601041dc34 <cur_cpuid>:
{
  601041dc34:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601041dc38:	910003fd 	mov	x29, sp
    return cpu_get_current();
  601041dc3c:	97ffc297 	bl	601040e698 <cpu_get_current>
}
  601041dc40:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601041dc44:	d65f03c0 	ret

000000601041dc48 <cur_cpu>:
{
  601041dc48:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601041dc4c:	910003fd 	mov	x29, sp
    return &global_cpus[cur_cpuid()];
  601041dc50:	97fffff9 	bl	601041dc34 <cur_cpuid>
  601041dc54:	93407c01 	sxtw	x1, w0
  601041dc58:	d2800300 	mov	x0, #0x18                  	// #24
  601041dc5c:	9b007c21 	mul	x1, x1, x0
  601041dc60:	d0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041dc64:	f942f400 	ldr	x0, [x0, #1512]
  601041dc68:	8b000020 	add	x0, x1, x0
}
  601041dc6c:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601041dc70:	d65f03c0 	ret

000000601041dc74 <sys_register_as_server>:
#include "task.h"

#define SERVER_DIR_NAME_SIZE 14

int sys_register_as_server(char* name)
{
  601041dc74:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  601041dc78:	910003fd 	mov	x29, sp
  601041dc7c:	f9000fe0 	str	x0, [sp, #24]
    // get server thread
    struct Thread* server = cur_cpu()->task;
  601041dc80:	97fffff2 	bl	601041dc48 <cur_cpu>
  601041dc84:	f9400400 	ldr	x0, [x0, #8]
  601041dc88:	f90017e0 	str	x0, [sp, #40]
    assert(server != NULL);
  601041dc8c:	f94017e0 	ldr	x0, [sp, #40]
  601041dc90:	f100001f 	cmp	x0, #0x0
  601041dc94:	540001e1 	b.ne	601041dcd0 <sys_register_as_server+0x5c>  // b.any
  601041dc98:	52800582 	mov	w2, #0x2c                  	// #44
  601041dc9c:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041dca0:	91138001 	add	x1, x0, #0x4e0
  601041dca4:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041dca8:	9110e000 	add	x0, x0, #0x438
  601041dcac:	97ffd933 	bl	6010414178 <printf_>
  601041dcb0:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041dcb4:	91112001 	add	x1, x0, #0x448
  601041dcb8:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041dcbc:	91116000 	add	x0, x0, #0x458
  601041dcc0:	97ffd92e 	bl	6010414178 <printf_>
  601041dcc4:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041dcc8:	9111a000 	add	x0, x0, #0x468
  601041dccc:	97ffc577 	bl	601040f2a8 <panic>

    // get server tag owner
    struct TraceTag server_identifier_set_tag;
    if (!AchieveResourceTag(&server_identifier_set_tag, RequireRootTag(), "softkernel/server-identifier")) {
  601041dcd0:	97ffe05a 	bl	6010415e38 <RequireRootTag>
  601041dcd4:	aa0003e1 	mov	x1, x0
  601041dcd8:	910083e3 	add	x3, sp, #0x20
  601041dcdc:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041dce0:	9111c002 	add	x2, x0, #0x470
  601041dce4:	aa0303e0 	mov	x0, x3
  601041dce8:	97ffe057 	bl	6010415e44 <AchieveResourceTag>
  601041dcec:	12001c00 	and	w0, w0, #0xff
  601041dcf0:	52000000 	eor	w0, w0, #0x1
  601041dcf4:	12001c00 	and	w0, w0, #0xff
  601041dcf8:	7100001f 	cmp	w0, #0x0
  601041dcfc:	54000080 	b.eq	601041dd0c <sys_register_as_server+0x98>  // b.none
        panic("Server identifier not initialized.\b");
  601041dd00:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041dd04:	91124000 	add	x0, x0, #0x490
  601041dd08:	97ffc568 	bl	601040f2a8 <panic>
    }
    assert(server_identifier_set_tag.meta != NULL);
  601041dd0c:	f94013e0 	ldr	x0, [sp, #32]
  601041dd10:	f100001f 	cmp	x0, #0x0
  601041dd14:	540001e1 	b.ne	601041dd50 <sys_register_as_server+0xdc>  // b.any
  601041dd18:	52800662 	mov	w2, #0x33                  	// #51
  601041dd1c:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041dd20:	91138001 	add	x1, x0, #0x4e0
  601041dd24:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041dd28:	9110e000 	add	x0, x0, #0x438
  601041dd2c:	97ffd913 	bl	6010414178 <printf_>
  601041dd30:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041dd34:	9112e001 	add	x1, x0, #0x4b8
  601041dd38:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041dd3c:	91116000 	add	x0, x0, #0x458
  601041dd40:	97ffd90e 	bl	6010414178 <printf_>
  601041dd44:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041dd48:	9111a000 	add	x0, x0, #0x468
  601041dd4c:	97ffc557 	bl	601040f2a8 <panic>

    // create server tag under server tag owner
    if (!CreateResourceTag(&server->server_identifier, &server_identifier_set_tag, name, TRACER_SERVER_IDENTITY_AC_RESOURCE, server)) {
  601041dd50:	f94017e0 	ldr	x0, [sp, #40]
  601041dd54:	91024000 	add	x0, x0, #0x90
  601041dd58:	910083e1 	add	x1, sp, #0x20
  601041dd5c:	f94017e4 	ldr	x4, [sp, #40]
  601041dd60:	52800083 	mov	w3, #0x4                   	// #4
  601041dd64:	f9400fe2 	ldr	x2, [sp, #24]
  601041dd68:	97ffe0ae 	bl	6010416020 <CreateResourceTag>
  601041dd6c:	12001c00 	and	w0, w0, #0xff
  601041dd70:	52000000 	eor	w0, w0, #0x1
  601041dd74:	12001c00 	and	w0, w0, #0xff
  601041dd78:	7100001f 	cmp	w0, #0x0
  601041dd7c:	54000060 	b.eq	601041dd88 <sys_register_as_server+0x114>  // b.none
        return -1;
  601041dd80:	12800000 	mov	w0, #0xffffffff            	// #-1
  601041dd84:	14000002 	b	601041dd8c <sys_register_as_server+0x118>
    }

    return 0;
  601041dd88:	52800000 	mov	w0, #0x0                   	// #0
}
  601041dd8c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  601041dd90:	d65f03c0 	ret

000000601041dd94 <cur_cpuid>:
{
  601041dd94:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601041dd98:	910003fd 	mov	x29, sp
    return cpu_get_current();
  601041dd9c:	97ffc23f 	bl	601040e698 <cpu_get_current>
}
  601041dda0:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601041dda4:	d65f03c0 	ret

000000601041dda8 <cur_cpu>:
{
  601041dda8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601041ddac:	910003fd 	mov	x29, sp
    return &global_cpus[cur_cpuid()];
  601041ddb0:	97fffff9 	bl	601041dd94 <cur_cpuid>
  601041ddb4:	93407c01 	sxtw	x1, w0
  601041ddb8:	d2800300 	mov	x0, #0x18                  	// #24
  601041ddbc:	9b007c21 	mul	x1, x1, x0
  601041ddc0:	d0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041ddc4:	f942f400 	ldr	x0, [x0, #1512]
  601041ddc8:	8b000020 	add	x0, x1, x0
}
  601041ddcc:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601041ddd0:	d65f03c0 	ret

000000601041ddd4 <create_session_inner>:
#include "share_page.h"
#include "syscall.h"
#include "task.h"

struct session_backend* create_session_inner(struct Thread* client, struct Thread* server, int capacity, struct Session* user_session)
{
  601041ddd4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  601041ddd8:	910003fd 	mov	x29, sp
  601041dddc:	f90017e0 	str	x0, [sp, #40]
  601041dde0:	f90013e1 	str	x1, [sp, #32]
  601041dde4:	b9001fe2 	str	w2, [sp, #28]
  601041dde8:	f9000be3 	str	x3, [sp, #16]
    // create share pages
    assert(server != NULL && client != NULL);
  601041ddec:	f94013e0 	ldr	x0, [sp, #32]
  601041ddf0:	f100001f 	cmp	x0, #0x0
  601041ddf4:	54000080 	b.eq	601041de04 <create_session_inner+0x30>  // b.none
  601041ddf8:	f94017e0 	ldr	x0, [sp, #40]
  601041ddfc:	f100001f 	cmp	x0, #0x0
  601041de00:	540001e1 	b.ne	601041de3c <create_session_inner+0x68>  // b.any
  601041de04:	52800522 	mov	w2, #0x29                  	// #41
  601041de08:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041de0c:	9118a001 	add	x1, x0, #0x628
  601041de10:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041de14:	9113e000 	add	x0, x0, #0x4f8
  601041de18:	97ffd8d8 	bl	6010414178 <printf_>
  601041de1c:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041de20:	91142001 	add	x1, x0, #0x508
  601041de24:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041de28:	9114c000 	add	x0, x0, #0x530
  601041de2c:	97ffd8d3 	bl	6010414178 <printf_>
  601041de30:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041de34:	91150000 	add	x0, x0, #0x540
  601041de38:	97ffc51c 	bl	601040f2a8 <panic>
    struct session_backend* session_backend = xizi_share_page_manager.create_share_pages(client, server, capacity);
  601041de3c:	d0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041de40:	f942e400 	ldr	x0, [x0, #1480]
  601041de44:	f9400003 	ldr	x3, [x0]
  601041de48:	b9401fe2 	ldr	w2, [sp, #28]
  601041de4c:	f94013e1 	ldr	x1, [sp, #32]
  601041de50:	f94017e0 	ldr	x0, [sp, #40]
  601041de54:	d63f0060 	blr	x3
  601041de58:	f9001fe0 	str	x0, [sp, #56]
    if (UNLIKELY(session_backend == NULL)) {
  601041de5c:	f9401fe0 	ldr	x0, [sp, #56]
  601041de60:	f100001f 	cmp	x0, #0x0
  601041de64:	1a9f17e0 	cset	w0, eq  // eq = none
  601041de68:	12001c00 	and	w0, w0, #0xff
  601041de6c:	92401c00 	and	x0, x0, #0xff
  601041de70:	f100001f 	cmp	x0, #0x0
  601041de74:	540001a0 	b.eq	601041dea8 <create_session_inner+0xd4>  // b.none
        DEBUG("create_share_pages to server: %s failed\n", server->name);
  601041de78:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041de7c:	9118a001 	add	x1, x0, #0x628
  601041de80:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041de84:	91152000 	add	x0, x0, #0x548
  601041de88:	97ffd8bc 	bl	6010414178 <printf_>
  601041de8c:	f94013e0 	ldr	x0, [sp, #32]
  601041de90:	aa0003e1 	mov	x1, x0
  601041de94:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041de98:	91156000 	add	x0, x0, #0x558
  601041de9c:	97ffd8b7 	bl	6010414178 <printf_>
        return NULL;
  601041dea0:	d2800000 	mov	x0, #0x0                   	// #0
  601041dea4:	14000013 	b	601041def0 <create_session_inner+0x11c>
    }

    // init user_session
    user_session->buf = (void*)session_backend->client_side.buf_addr;
  601041dea8:	f9401fe0 	ldr	x0, [sp, #56]
  601041deac:	f9401c00 	ldr	x0, [x0, #56]
  601041deb0:	aa0003e1 	mov	x1, x0
  601041deb4:	f9400be0 	ldr	x0, [sp, #16]
  601041deb8:	f9000801 	str	x1, [x0, #16]
    user_session->capacity = session_backend->client_side.capacity;
  601041debc:	f9401fe0 	ldr	x0, [sp, #56]
  601041dec0:	b9404001 	ldr	w1, [x0, #64]
  601041dec4:	f9400be0 	ldr	x0, [sp, #16]
  601041dec8:	b9000401 	str	w1, [x0, #4]
    user_session->head = 0;
  601041decc:	f9400be0 	ldr	x0, [sp, #16]
  601041ded0:	b900081f 	str	wzr, [x0, #8]
    user_session->tail = 0;
  601041ded4:	f9400be0 	ldr	x0, [sp, #16]
  601041ded8:	b9000c1f 	str	wzr, [x0, #12]
    user_session->id = session_backend->session_id;
  601041dedc:	f9401fe0 	ldr	x0, [sp, #56]
  601041dee0:	b9404801 	ldr	w1, [x0, #72]
  601041dee4:	f9400be0 	ldr	x0, [sp, #16]
  601041dee8:	b9000001 	str	w1, [x0]

    return session_backend;
  601041deec:	f9401fe0 	ldr	x0, [sp, #56]
}
  601041def0:	a8c47bfd 	ldp	x29, x30, [sp], #64
  601041def4:	d65f03c0 	ret

000000601041def8 <sys_connect_session>:

int sys_connect_session(char* path, int capacity, struct Session* user_session)
{
  601041def8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  601041defc:	910003fd 	mov	x29, sp
  601041df00:	f90017e0 	str	x0, [sp, #40]
  601041df04:	b90027e1 	str	w1, [sp, #36]
  601041df08:	f9000fe2 	str	x2, [sp, #24]
    if (capacity <= 0) {
  601041df0c:	b94027e0 	ldr	w0, [sp, #36]
  601041df10:	7100001f 	cmp	w0, #0x0
  601041df14:	5400006c 	b.gt	601041df20 <sys_connect_session+0x28>
        return -1;
  601041df18:	12800000 	mov	w0, #0xffffffff            	// #-1
  601041df1c:	14000067 	b	601041e0b8 <sys_connect_session+0x1c0>
    }

    struct Thread* client = cur_cpu()->task;
  601041df20:	97ffffa2 	bl	601041dda8 <cur_cpu>
  601041df24:	f9400400 	ldr	x0, [x0, #8]
  601041df28:	f90027e0 	str	x0, [sp, #72]
    assert(client != NULL);
  601041df2c:	f94027e0 	ldr	x0, [sp, #72]
  601041df30:	f100001f 	cmp	x0, #0x0
  601041df34:	540001e1 	b.ne	601041df70 <sys_connect_session+0x78>  // b.any
  601041df38:	52800822 	mov	w2, #0x41                  	// #65
  601041df3c:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041df40:	91190001 	add	x1, x0, #0x640
  601041df44:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041df48:	9113e000 	add	x0, x0, #0x4f8
  601041df4c:	97ffd88b 	bl	6010414178 <printf_>
  601041df50:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041df54:	91162001 	add	x1, x0, #0x588
  601041df58:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041df5c:	9114c000 	add	x0, x0, #0x530
  601041df60:	97ffd886 	bl	6010414178 <printf_>
  601041df64:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041df68:	91150000 	add	x0, x0, #0x540
  601041df6c:	97ffc4cf 	bl	601040f2a8 <panic>

    /// get server
    struct TraceTag server_identifier_owner;
    if (!AchieveResourceTag(&server_identifier_owner, RequireRootTag(), "softkernel/server-identifier")) {
  601041df70:	97ffdfb2 	bl	6010415e38 <RequireRootTag>
  601041df74:	aa0003e1 	mov	x1, x0
  601041df78:	9100e3e3 	add	x3, sp, #0x38
  601041df7c:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041df80:	91166002 	add	x2, x0, #0x598
  601041df84:	aa0303e0 	mov	x0, x3
  601041df88:	97ffdfaf 	bl	6010415e44 <AchieveResourceTag>
  601041df8c:	12001c00 	and	w0, w0, #0xff
  601041df90:	52000000 	eor	w0, w0, #0x1
  601041df94:	12001c00 	and	w0, w0, #0xff
  601041df98:	7100001f 	cmp	w0, #0x0
  601041df9c:	54000080 	b.eq	601041dfac <sys_connect_session+0xb4>  // b.none
        panic("Server identifier not initialized.\b");
  601041dfa0:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041dfa4:	9116e000 	add	x0, x0, #0x5b8
  601041dfa8:	97ffc4c0 	bl	601040f2a8 <panic>
    }
    assert(server_identifier_owner.meta != NULL);
  601041dfac:	f9401fe0 	ldr	x0, [sp, #56]
  601041dfb0:	f100001f 	cmp	x0, #0x0
  601041dfb4:	540001e1 	b.ne	601041dff0 <sys_connect_session+0xf8>  // b.any
  601041dfb8:	52800902 	mov	w2, #0x48                  	// #72
  601041dfbc:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041dfc0:	91190001 	add	x1, x0, #0x640
  601041dfc4:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041dfc8:	9113e000 	add	x0, x0, #0x4f8
  601041dfcc:	97ffd86b 	bl	6010414178 <printf_>
  601041dfd0:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041dfd4:	91178001 	add	x1, x0, #0x5e0
  601041dfd8:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041dfdc:	9114c000 	add	x0, x0, #0x530
  601041dfe0:	97ffd866 	bl	6010414178 <printf_>
  601041dfe4:	d0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041dfe8:	91150000 	add	x0, x0, #0x540
  601041dfec:	97ffc4af 	bl	601040f2a8 <panic>

    struct TraceTag server_tag;
    if (!AchieveResourceTag(&server_tag, &server_identifier_owner, path)) {
  601041dff0:	9100e3e1 	add	x1, sp, #0x38
  601041dff4:	9100c3e0 	add	x0, sp, #0x30
  601041dff8:	f94017e2 	ldr	x2, [sp, #40]
  601041dffc:	97ffdf92 	bl	6010415e44 <AchieveResourceTag>
  601041e000:	12001c00 	and	w0, w0, #0xff
  601041e004:	52000000 	eor	w0, w0, #0x1
  601041e008:	12001c00 	and	w0, w0, #0xff
  601041e00c:	7100001f 	cmp	w0, #0x0
  601041e010:	54000180 	b.eq	601041e040 <sys_connect_session+0x148>  // b.none
        DEBUG("Not server: %s\n", path);
  601041e014:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e018:	91190001 	add	x1, x0, #0x640
  601041e01c:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e020:	91152000 	add	x0, x0, #0x548
  601041e024:	97ffd855 	bl	6010414178 <printf_>
  601041e028:	f94017e1 	ldr	x1, [sp, #40]
  601041e02c:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e030:	91182000 	add	x0, x0, #0x608
  601041e034:	97ffd851 	bl	6010414178 <printf_>
        return -1;
  601041e038:	12800000 	mov	w0, #0xffffffff            	// #-1
  601041e03c:	1400001f 	b	601041e0b8 <sys_connect_session+0x1c0>
    }
    struct Thread* server = AchieveResource(&server_tag);
  601041e040:	9100c3e0 	add	x0, sp, #0x30
  601041e044:	97ffdfd3 	bl	6010415f90 <AchieveResource>
  601041e048:	f90023e0 	str	x0, [sp, #64]
    assert(server != NULL);
  601041e04c:	f94023e0 	ldr	x0, [sp, #64]
  601041e050:	f100001f 	cmp	x0, #0x0
  601041e054:	540001e1 	b.ne	601041e090 <sys_connect_session+0x198>  // b.any
  601041e058:	52800a02 	mov	w2, #0x50                  	// #80
  601041e05c:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e060:	91190001 	add	x1, x0, #0x640
  601041e064:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e068:	9113e000 	add	x0, x0, #0x4f8
  601041e06c:	97ffd843 	bl	6010414178 <printf_>
  601041e070:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e074:	91186001 	add	x1, x0, #0x618
  601041e078:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e07c:	9114c000 	add	x0, x0, #0x530
  601041e080:	97ffd83e 	bl	6010414178 <printf_>
  601041e084:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e088:	91150000 	add	x0, x0, #0x540
  601041e08c:	97ffc487 	bl	601040f2a8 <panic>

    if (create_session_inner(client, server, capacity, user_session) == NULL) {
  601041e090:	f9400fe3 	ldr	x3, [sp, #24]
  601041e094:	b94027e2 	ldr	w2, [sp, #36]
  601041e098:	f94023e1 	ldr	x1, [sp, #64]
  601041e09c:	f94027e0 	ldr	x0, [sp, #72]
  601041e0a0:	97ffff4d 	bl	601041ddd4 <create_session_inner>
  601041e0a4:	f100001f 	cmp	x0, #0x0
  601041e0a8:	54000061 	b.ne	601041e0b4 <sys_connect_session+0x1bc>  // b.any
        return -1;
  601041e0ac:	12800000 	mov	w0, #0xffffffff            	// #-1
  601041e0b0:	14000002 	b	601041e0b8 <sys_connect_session+0x1c0>
    }

    return 0;
  601041e0b4:	52800000 	mov	w0, #0x0                   	// #0
  601041e0b8:	a8c57bfd 	ldp	x29, x30, [sp], #80
  601041e0bc:	d65f03c0 	ret

000000601041e0c0 <cur_cpuid>:
{
  601041e0c0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601041e0c4:	910003fd 	mov	x29, sp
    return cpu_get_current();
  601041e0c8:	97ffc174 	bl	601040e698 <cpu_get_current>
}
  601041e0cc:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601041e0d0:	d65f03c0 	ret

000000601041e0d4 <cur_cpu>:
{
  601041e0d4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601041e0d8:	910003fd 	mov	x29, sp
    return &global_cpus[cur_cpuid()];
  601041e0dc:	97fffff9 	bl	601041e0c0 <cur_cpuid>
  601041e0e0:	93407c01 	sxtw	x1, w0
  601041e0e4:	d2800300 	mov	x0, #0x18                  	// #24
  601041e0e8:	9b007c21 	mul	x1, x1, x0
  601041e0ec:	b0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041e0f0:	f942f400 	ldr	x0, [x0, #1512]
  601041e0f4:	8b000020 	add	x0, x1, x0
}
  601041e0f8:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601041e0fc:	d65f03c0 	ret

000000601041e100 <is_msg_needed>:
#include "task.h"

#define IPCSESSION_MSG(session) ((struct IpcMsg*)((char*)((session)->buf) + (session)->head))

static inline bool is_msg_needed(struct IpcMsg* msg)
{
  601041e100:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  601041e104:	910003fd 	mov	x29, sp
  601041e108:	f9000fe0 	str	x0, [sp, #24]
    assert(msg != NULL);
  601041e10c:	f9400fe0 	ldr	x0, [sp, #24]
  601041e110:	f100001f 	cmp	x0, #0x0
  601041e114:	540001e1 	b.ne	601041e150 <is_msg_needed+0x50>  // b.any
  601041e118:	52800522 	mov	w2, #0x29                  	// #41
  601041e11c:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e120:	911da001 	add	x1, x0, #0x768
  601041e124:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e128:	91196000 	add	x0, x0, #0x658
  601041e12c:	97ffd813 	bl	6010414178 <printf_>
  601041e130:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e134:	9119a001 	add	x1, x0, #0x668
  601041e138:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e13c:	9119e000 	add	x0, x0, #0x678
  601041e140:	97ffd80e 	bl	6010414178 <printf_>
  601041e144:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e148:	911a2000 	add	x0, x0, #0x688
  601041e14c:	97ffc457 	bl	601040f2a8 <panic>
    return msg->header.magic == IPC_MSG_MAGIC && msg->header.valid == 1 && msg->header.done == 0 && msg->header.delayed == 0;
  601041e150:	f9400fe0 	ldr	x0, [sp, #24]
  601041e154:	b9400401 	ldr	w1, [x0, #4]
  601041e158:	529b9740 	mov	w0, #0xdcba                	// #56506
  601041e15c:	72b579a0 	movk	w0, #0xabcd, lsl #16
  601041e160:	6b00003f 	cmp	w1, w0
  601041e164:	54000241 	b.ne	601041e1ac <is_msg_needed+0xac>  // b.any
  601041e168:	f9400fe0 	ldr	x0, [sp, #24]
  601041e16c:	f9400000 	ldr	x0, [x0]
  601041e170:	92400000 	and	x0, x0, #0x1
  601041e174:	f100001f 	cmp	x0, #0x0
  601041e178:	540001a0 	b.eq	601041e1ac <is_msg_needed+0xac>  // b.none
  601041e17c:	f9400fe0 	ldr	x0, [sp, #24]
  601041e180:	f9400000 	ldr	x0, [x0]
  601041e184:	927f0000 	and	x0, x0, #0x2
  601041e188:	f100001f 	cmp	x0, #0x0
  601041e18c:	54000101 	b.ne	601041e1ac <is_msg_needed+0xac>  // b.any
  601041e190:	f9400fe0 	ldr	x0, [sp, #24]
  601041e194:	f9400000 	ldr	x0, [x0]
  601041e198:	927d0000 	and	x0, x0, #0x8
  601041e19c:	f100001f 	cmp	x0, #0x0
  601041e1a0:	54000061 	b.ne	601041e1ac <is_msg_needed+0xac>  // b.any
  601041e1a4:	52800020 	mov	w0, #0x1                   	// #1
  601041e1a8:	14000002 	b	601041e1b0 <is_msg_needed+0xb0>
  601041e1ac:	52800000 	mov	w0, #0x0                   	// #0
  601041e1b0:	12000000 	and	w0, w0, #0x1
  601041e1b4:	12001c00 	and	w0, w0, #0xff
}
  601041e1b8:	a8c27bfd 	ldp	x29, x30, [sp], #32
  601041e1bc:	d65f03c0 	ret

000000601041e1c0 <sys_poll_session>:

int sys_poll_session(struct Session* userland_session_arr, int arr_capacity)
{
  601041e1c0:	a9b47bfd 	stp	x29, x30, [sp, #-192]!
  601041e1c4:	910003fd 	mov	x29, sp
  601041e1c8:	f9000fe0 	str	x0, [sp, #24]
  601041e1cc:	b90017e1 	str	w1, [sp, #20]
    struct Thread* cur_task = cur_cpu()->task;
  601041e1d0:	97ffffc1 	bl	601041e0d4 <cur_cpu>
  601041e1d4:	f9400400 	ldr	x0, [x0, #8]
  601041e1d8:	f90053e0 	str	x0, [sp, #160]
    if (cur_task == NULL) {
  601041e1dc:	f94053e0 	ldr	x0, [sp, #160]
  601041e1e0:	f100001f 	cmp	x0, #0x0
  601041e1e4:	54000181 	b.ne	601041e214 <sys_poll_session+0x54>  // b.any
        ERROR("%s by killed task\n");
  601041e1e8:	52800622 	mov	w2, #0x31                  	// #49
  601041e1ec:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e1f0:	911d4001 	add	x1, x0, #0x750
  601041e1f4:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e1f8:	91196000 	add	x0, x0, #0x658
  601041e1fc:	97ffd7df 	bl	6010414178 <printf_>
  601041e200:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e204:	911a4000 	add	x0, x0, #0x690
  601041e208:	97ffd7dc 	bl	6010414178 <printf_>
        return -1;
  601041e20c:	12800000 	mov	w0, #0xffffffff            	// #-1
  601041e210:	14000147 	b	601041e72c <sys_poll_session+0x56c>
    }

    struct double_list_node* cur_node = NULL;
  601041e214:	f9004fff 	str	xzr, [sp, #152]
    struct server_session* server_session = NULL;
  601041e218:	f9005fff 	str	xzr, [sp, #184]
    /* update old sessions */
    for (int i = 0; i < arr_capacity; i++) {
  601041e21c:	b900b7ff 	str	wzr, [sp, #180]
  601041e220:	14000091 	b	601041e464 <sys_poll_session+0x2a4>
        if (UNLIKELY(userland_session_arr[i].buf == NULL)) {
  601041e224:	b980b7e1 	ldrsw	x1, [sp, #180]
  601041e228:	d2800300 	mov	x0, #0x18                  	// #24
  601041e22c:	9b007c20 	mul	x0, x1, x0
  601041e230:	f9400fe1 	ldr	x1, [sp, #24]
  601041e234:	8b000020 	add	x0, x1, x0
  601041e238:	f9400800 	ldr	x0, [x0, #16]
  601041e23c:	f100001f 	cmp	x0, #0x0
  601041e240:	1a9f17e0 	cset	w0, eq  // eq = none
  601041e244:	12001c00 	and	w0, w0, #0xff
  601041e248:	92401c00 	and	x0, x0, #0xff
  601041e24c:	f100001f 	cmp	x0, #0x0
  601041e250:	54001141 	b.ne	601041e478 <sys_poll_session+0x2b8>  // b.any
            break;
        }
        cur_node = cur_task->svr_sess_listhead.next;
  601041e254:	f94053e0 	ldr	x0, [sp, #160]
  601041e258:	f9403c00 	ldr	x0, [x0, #120]
  601041e25c:	f9004fe0 	str	x0, [sp, #152]
        server_session = CONTAINER_OF(cur_node, struct server_session, node);
  601041e260:	f9404fe0 	ldr	x0, [sp, #152]
  601041e264:	f9005fe0 	str	x0, [sp, #184]
        if (UNLIKELY(server_session->buf_addr != (uintptr_t)userland_session_arr[i].buf)) {
  601041e268:	f9405fe0 	ldr	x0, [sp, #184]
  601041e26c:	f9400800 	ldr	x0, [x0, #16]
  601041e270:	b980b7e2 	ldrsw	x2, [sp, #180]
  601041e274:	d2800301 	mov	x1, #0x18                  	// #24
  601041e278:	9b017c41 	mul	x1, x2, x1
  601041e27c:	f9400fe2 	ldr	x2, [sp, #24]
  601041e280:	8b010041 	add	x1, x2, x1
  601041e284:	f9400821 	ldr	x1, [x1, #16]
  601041e288:	eb01001f 	cmp	x0, x1
  601041e28c:	1a9f07e0 	cset	w0, ne  // ne = any
  601041e290:	12001c00 	and	w0, w0, #0xff
  601041e294:	92401c00 	and	x0, x0, #0xff
  601041e298:	f100001f 	cmp	x0, #0x0
  601041e29c:	540002a0 	b.eq	601041e2f0 <sys_poll_session+0x130>  // b.none
            ERROR("mismatched old session addr, user buf: %x, server buf: %x\n", userland_session_arr[i].buf, server_session->buf_addr);
  601041e2a0:	528007e2 	mov	w2, #0x3f                  	// #63
  601041e2a4:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e2a8:	911d4001 	add	x1, x0, #0x750
  601041e2ac:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e2b0:	91196000 	add	x0, x0, #0x658
  601041e2b4:	97ffd7b1 	bl	6010414178 <printf_>
  601041e2b8:	b980b7e1 	ldrsw	x1, [sp, #180]
  601041e2bc:	d2800300 	mov	x0, #0x18                  	// #24
  601041e2c0:	9b007c20 	mul	x0, x1, x0
  601041e2c4:	f9400fe1 	ldr	x1, [sp, #24]
  601041e2c8:	8b000020 	add	x0, x1, x0
  601041e2cc:	f9400801 	ldr	x1, [x0, #16]
  601041e2d0:	f9405fe0 	ldr	x0, [sp, #184]
  601041e2d4:	f9400800 	ldr	x0, [x0, #16]
  601041e2d8:	aa0003e2 	mov	x2, x0
  601041e2dc:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e2e0:	911aa000 	add	x0, x0, #0x6a8
  601041e2e4:	97ffd7a5 	bl	6010414178 <printf_>
            return -1;
  601041e2e8:	12800000 	mov	w0, #0xffffffff            	// #-1
  601041e2ec:	14000110 	b	601041e72c <sys_poll_session+0x56c>
        }
        // update session_backend
        // if current session is handled
        if (server_session->head != userland_session_arr[i].head) {
  601041e2f0:	f9405fe0 	ldr	x0, [sp, #184]
  601041e2f4:	b9401c01 	ldr	w1, [x0, #28]
  601041e2f8:	b980b7e2 	ldrsw	x2, [sp, #180]
  601041e2fc:	d2800300 	mov	x0, #0x18                  	// #24
  601041e300:	9b007c40 	mul	x0, x2, x0
  601041e304:	f9400fe2 	ldr	x2, [sp, #24]
  601041e308:	8b000040 	add	x0, x2, x0
  601041e30c:	b9400800 	ldr	w0, [x0, #8]
  601041e310:	6b00003f 	cmp	w1, w0
  601041e314:	54000220 	b.eq	601041e358 <sys_poll_session+0x198>  // b.none
            struct Thread* client = SERVER_SESSION_BACKEND(server_session)->client;
  601041e318:	f9405fe0 	ldr	x0, [sp, #184]
  601041e31c:	f9402800 	ldr	x0, [x0, #80]
  601041e320:	f9004be0 	str	x0, [sp, #144]
            if (client->state == BLOCKED) {
  601041e324:	f9404be0 	ldr	x0, [sp, #144]
  601041e328:	b940a800 	ldr	w0, [x0, #168]
  601041e32c:	7100101f 	cmp	w0, #0x4
  601041e330:	540000e1 	b.ne	601041e34c <sys_poll_session+0x18c>  // b.any
                xizi_task_manager.task_unblock(client);
  601041e334:	b0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041e338:	f942ec00 	ldr	x0, [x0, #1496]
  601041e33c:	f941b001 	ldr	x1, [x0, #864]
  601041e340:	f9404be0 	ldr	x0, [sp, #144]
  601041e344:	d63f0020 	blr	x1
  601041e348:	14000004 	b	601041e358 <sys_poll_session+0x198>
            } else {
                client->current_ipc_handled = true;
  601041e34c:	f9404be0 	ldr	x0, [sp, #144]
  601041e350:	52800021 	mov	w1, #0x1                   	// #1
  601041e354:	39022001 	strb	w1, [x0, #136]
            }
        }
        server_session->head = userland_session_arr[i].head;
  601041e358:	b980b7e1 	ldrsw	x1, [sp, #180]
  601041e35c:	d2800300 	mov	x0, #0x18                  	// #24
  601041e360:	9b007c20 	mul	x0, x1, x0
  601041e364:	f9400fe1 	ldr	x1, [sp, #24]
  601041e368:	8b000020 	add	x0, x1, x0
  601041e36c:	b9400801 	ldr	w1, [x0, #8]
  601041e370:	f9405fe0 	ldr	x0, [sp, #184]
  601041e374:	b9001c01 	str	w1, [x0, #28]
        server_session->tail = userland_session_arr[i].tail;
  601041e378:	b980b7e1 	ldrsw	x1, [sp, #180]
  601041e37c:	d2800300 	mov	x0, #0x18                  	// #24
  601041e380:	9b007c20 	mul	x0, x1, x0
  601041e384:	f9400fe1 	ldr	x1, [sp, #24]
  601041e388:	8b000020 	add	x0, x1, x0
  601041e38c:	b9400c01 	ldr	w1, [x0, #12]
  601041e390:	f9405fe0 	ldr	x0, [sp, #184]
  601041e394:	b9002001 	str	w1, [x0, #32]
  601041e398:	f9404fe0 	ldr	x0, [sp, #152]
  601041e39c:	f9002be0 	str	x0, [sp, #80]
    _double_list_del(entry->prev, entry->next);
  601041e3a0:	f9402be0 	ldr	x0, [sp, #80]
  601041e3a4:	f9400401 	ldr	x1, [x0, #8]
  601041e3a8:	f9402be0 	ldr	x0, [sp, #80]
  601041e3ac:	f9400000 	ldr	x0, [x0]
  601041e3b0:	f90027e1 	str	x1, [sp, #72]
  601041e3b4:	f90023e0 	str	x0, [sp, #64]
    next->prev = prev;
  601041e3b8:	f94023e0 	ldr	x0, [sp, #64]
  601041e3bc:	f94027e1 	ldr	x1, [sp, #72]
  601041e3c0:	f9000401 	str	x1, [x0, #8]
    prev->next = next;
  601041e3c4:	f94027e0 	ldr	x0, [sp, #72]
  601041e3c8:	f94023e1 	ldr	x1, [sp, #64]
  601041e3cc:	f9000001 	str	x1, [x0]
}
  601041e3d0:	d503201f 	nop
    entry->next = entry;
  601041e3d4:	f9402be0 	ldr	x0, [sp, #80]
  601041e3d8:	f9402be1 	ldr	x1, [sp, #80]
  601041e3dc:	f9000001 	str	x1, [x0]
    entry->prev = entry;
  601041e3e0:	f9402be0 	ldr	x0, [sp, #80]
  601041e3e4:	f9402be1 	ldr	x1, [sp, #80]
  601041e3e8:	f9000401 	str	x1, [x0, #8]
}
  601041e3ec:	d503201f 	nop
        doubleListDel(cur_node);
        doubleListAddOnBack(cur_node, &cur_task->svr_sess_listhead);
  601041e3f0:	f94053e0 	ldr	x0, [sp, #160]
  601041e3f4:	9101e000 	add	x0, x0, #0x78
  601041e3f8:	f9404fe1 	ldr	x1, [sp, #152]
  601041e3fc:	f9003fe1 	str	x1, [sp, #120]
  601041e400:	f9003be0 	str	x0, [sp, #112]
    _double_list_add(new_node, head->prev, head);
  601041e404:	f9403be0 	ldr	x0, [sp, #112]
  601041e408:	f9400400 	ldr	x0, [x0, #8]
  601041e40c:	f9403fe1 	ldr	x1, [sp, #120]
  601041e410:	f90037e1 	str	x1, [sp, #104]
  601041e414:	f90033e0 	str	x0, [sp, #96]
  601041e418:	f9403be0 	ldr	x0, [sp, #112]
  601041e41c:	f9002fe0 	str	x0, [sp, #88]
    next->prev = new_node;
  601041e420:	f9402fe0 	ldr	x0, [sp, #88]
  601041e424:	f94037e1 	ldr	x1, [sp, #104]
  601041e428:	f9000401 	str	x1, [x0, #8]
    new_node->next = next;
  601041e42c:	f94037e0 	ldr	x0, [sp, #104]
  601041e430:	f9402fe1 	ldr	x1, [sp, #88]
  601041e434:	f9000001 	str	x1, [x0]
    new_node->prev = prev;
  601041e438:	f94037e0 	ldr	x0, [sp, #104]
  601041e43c:	f94033e1 	ldr	x1, [sp, #96]
  601041e440:	f9000401 	str	x1, [x0, #8]
    prev->next = new_node;
  601041e444:	f94033e0 	ldr	x0, [sp, #96]
  601041e448:	f94037e1 	ldr	x1, [sp, #104]
  601041e44c:	f9000001 	str	x1, [x0]
}
  601041e450:	d503201f 	nop
}
  601041e454:	d503201f 	nop
    for (int i = 0; i < arr_capacity; i++) {
  601041e458:	b940b7e0 	ldr	w0, [sp, #180]
  601041e45c:	11000400 	add	w0, w0, #0x1
  601041e460:	b900b7e0 	str	w0, [sp, #180]
  601041e464:	b940b7e1 	ldr	w1, [sp, #180]
  601041e468:	b94017e0 	ldr	w0, [sp, #20]
  601041e46c:	6b00003f 	cmp	w1, w0
  601041e470:	54ffedab 	b.lt	601041e224 <sys_poll_session+0x64>  // b.tstop
  601041e474:	14000002 	b	601041e47c <sys_poll_session+0x2bc>
            break;
  601041e478:	d503201f 	nop
    }

    /* poll with new sessions */
    int nr_sessions_need_to_handle = 0;
  601041e47c:	b900b3ff 	str	wzr, [sp, #176]
    bool has_middle_delete = false;
  601041e480:	3902bfff 	strb	wzr, [sp, #175]
    int session_idx = 0;
  601041e484:	b900abff 	str	wzr, [sp, #168]
    DOUBLE_LIST_FOR_EACH_ENTRY(server_session, &cur_task->svr_sess_listhead, node)
  601041e488:	f94053e0 	ldr	x0, [sp, #160]
  601041e48c:	f9403c00 	ldr	x0, [x0, #120]
  601041e490:	f9005fe0 	str	x0, [sp, #184]
  601041e494:	1400007e 	b	601041e68c <sys_poll_session+0x4cc>
    {
        if (session_idx >= arr_capacity) {
  601041e498:	b940abe1 	ldr	w1, [sp, #168]
  601041e49c:	b94017e0 	ldr	w0, [sp, #20]
  601041e4a0:	6b00003f 	cmp	w1, w0
  601041e4a4:	5400100a 	b.ge	601041e6a4 <sys_poll_session+0x4e4>  // b.tcont
            break;
        }

        if (SERVER_SESSION_BACKEND(server_session)->client_side.closed) {
  601041e4a8:	f9405fe0 	ldr	x0, [sp, #184]
  601041e4ac:	39411000 	ldrb	w0, [x0, #68]
  601041e4b0:	7100001f 	cmp	w0, #0x0
  601041e4b4:	540008a0 	b.eq	601041e5c8 <sys_poll_session+0x408>  // b.none
            // client had closed it, then server will close it too
            struct session_backend* session_backend = SERVER_SESSION_BACKEND(server_session);
  601041e4b8:	f9405fe0 	ldr	x0, [sp, #184]
  601041e4bc:	f90043e0 	str	x0, [sp, #128]
            assert(session_backend->server == cur_task);
  601041e4c0:	f94043e0 	ldr	x0, [sp, #128]
  601041e4c4:	f9402c00 	ldr	x0, [x0, #88]
  601041e4c8:	f94053e1 	ldr	x1, [sp, #160]
  601041e4cc:	eb00003f 	cmp	x1, x0
  601041e4d0:	540001e0 	b.eq	601041e50c <sys_poll_session+0x34c>  // b.none
  601041e4d4:	52800be2 	mov	w2, #0x5f                  	// #95
  601041e4d8:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e4dc:	911d4001 	add	x1, x0, #0x750
  601041e4e0:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e4e4:	91196000 	add	x0, x0, #0x658
  601041e4e8:	97ffd724 	bl	6010414178 <printf_>
  601041e4ec:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e4f0:	911ba001 	add	x1, x0, #0x6e8
  601041e4f4:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e4f8:	9119e000 	add	x0, x0, #0x678
  601041e4fc:	97ffd71f 	bl	6010414178 <printf_>
  601041e500:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e504:	911a2000 	add	x0, x0, #0x688
  601041e508:	97ffc368 	bl	601040f2a8 <panic>
            assert(session_backend->client == NULL);
  601041e50c:	f94043e0 	ldr	x0, [sp, #128]
  601041e510:	f9402800 	ldr	x0, [x0, #80]
  601041e514:	f100001f 	cmp	x0, #0x0
  601041e518:	540001e0 	b.eq	601041e554 <sys_poll_session+0x394>  // b.none
  601041e51c:	52800c02 	mov	w2, #0x60                  	// #96
  601041e520:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e524:	911d4001 	add	x1, x0, #0x750
  601041e528:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e52c:	91196000 	add	x0, x0, #0x658
  601041e530:	97ffd712 	bl	6010414178 <printf_>
  601041e534:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e538:	911c4001 	add	x1, x0, #0x710
  601041e53c:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e540:	9119e000 	add	x0, x0, #0x678
  601041e544:	97ffd70d 	bl	6010414178 <printf_>
  601041e548:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e54c:	911a2000 	add	x0, x0, #0x688
  601041e550:	97ffc356 	bl	601040f2a8 <panic>
            assert(server_session->closed == false);
  601041e554:	f9405fe0 	ldr	x0, [sp, #184]
  601041e558:	39409000 	ldrb	w0, [x0, #36]
  601041e55c:	7100001f 	cmp	w0, #0x0
  601041e560:	540001e0 	b.eq	601041e59c <sys_poll_session+0x3dc>  // b.none
  601041e564:	52800c22 	mov	w2, #0x61                  	// #97
  601041e568:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e56c:	911d4001 	add	x1, x0, #0x750
  601041e570:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e574:	91196000 	add	x0, x0, #0x658
  601041e578:	97ffd700 	bl	6010414178 <printf_>
  601041e57c:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e580:	911cc001 	add	x1, x0, #0x730
  601041e584:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e588:	9119e000 	add	x0, x0, #0x678
  601041e58c:	97ffd6fb 	bl	6010414178 <printf_>
  601041e590:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e594:	911a2000 	add	x0, x0, #0x688
  601041e598:	97ffc344 	bl	601040f2a8 <panic>
            server_session->closed = true;
  601041e59c:	f9405fe0 	ldr	x0, [sp, #184]
  601041e5a0:	52800021 	mov	w1, #0x1                   	// #1
  601041e5a4:	39009001 	strb	w1, [x0, #36]
            xizi_share_page_manager.delete_share_pages(session_backend);
  601041e5a8:	b0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041e5ac:	f942e400 	ldr	x0, [x0, #1480]
  601041e5b0:	f9400801 	ldr	x1, [x0, #16]
  601041e5b4:	f94043e0 	ldr	x0, [sp, #128]
  601041e5b8:	d63f0020 	blr	x1
            // signal that there is a middle deletion of session
            has_middle_delete = true;
  601041e5bc:	52800020 	mov	w0, #0x1                   	// #1
  601041e5c0:	3902bfe0 	strb	w0, [sp, #175]
            break;
  601041e5c4:	14000039 	b	601041e6a8 <sys_poll_session+0x4e8>
        }

        userland_session_arr[session_idx] = (struct Session) {
  601041e5c8:	b980abe1 	ldrsw	x1, [sp, #168]
  601041e5cc:	d2800300 	mov	x0, #0x18                  	// #24
  601041e5d0:	9b007c20 	mul	x0, x1, x0
  601041e5d4:	f9400fe1 	ldr	x1, [sp, #24]
  601041e5d8:	8b000020 	add	x0, x1, x0
            .buf = (void*)server_session->buf_addr,
            .capacity = server_session->capacity,
            .head = server_session->head,
            .tail = server_session->tail,
            .id = SERVER_SESSION_BACKEND(server_session)->session_id,
  601041e5dc:	f9405fe1 	ldr	x1, [sp, #184]
  601041e5e0:	b9404824 	ldr	w4, [x1, #72]
            .capacity = server_session->capacity,
  601041e5e4:	f9405fe1 	ldr	x1, [sp, #184]
  601041e5e8:	b9401823 	ldr	w3, [x1, #24]
            .head = server_session->head,
  601041e5ec:	f9405fe1 	ldr	x1, [sp, #184]
  601041e5f0:	b9401c22 	ldr	w2, [x1, #28]
            .tail = server_session->tail,
  601041e5f4:	f9405fe1 	ldr	x1, [sp, #184]
  601041e5f8:	b9402021 	ldr	w1, [x1, #32]
            .buf = (void*)server_session->buf_addr,
  601041e5fc:	f9405fe5 	ldr	x5, [sp, #184]
  601041e600:	f94008a5 	ldr	x5, [x5, #16]
        userland_session_arr[session_idx] = (struct Session) {
  601041e604:	b9000004 	str	w4, [x0]
  601041e608:	b9000403 	str	w3, [x0, #4]
  601041e60c:	b9000802 	str	w2, [x0, #8]
  601041e610:	b9000c01 	str	w1, [x0, #12]
  601041e614:	f9000805 	str	x5, [x0, #16]
        };

        struct IpcMsg* msg = IPCSESSION_MSG(&userland_session_arr[session_idx]);
  601041e618:	b980abe1 	ldrsw	x1, [sp, #168]
  601041e61c:	d2800300 	mov	x0, #0x18                  	// #24
  601041e620:	9b007c20 	mul	x0, x1, x0
  601041e624:	f9400fe1 	ldr	x1, [sp, #24]
  601041e628:	8b000020 	add	x0, x1, x0
  601041e62c:	f9400801 	ldr	x1, [x0, #16]
  601041e630:	b980abe2 	ldrsw	x2, [sp, #168]
  601041e634:	d2800300 	mov	x0, #0x18                  	// #24
  601041e638:	9b007c40 	mul	x0, x2, x0
  601041e63c:	f9400fe2 	ldr	x2, [sp, #24]
  601041e640:	8b000040 	add	x0, x2, x0
  601041e644:	b9400800 	ldr	w0, [x0, #8]
  601041e648:	93407c00 	sxtw	x0, w0
  601041e64c:	8b000020 	add	x0, x1, x0
  601041e650:	f90047e0 	str	x0, [sp, #136]
        if (is_msg_needed(msg)) {
  601041e654:	f94047e0 	ldr	x0, [sp, #136]
  601041e658:	97fffeaa 	bl	601041e100 <is_msg_needed>
  601041e65c:	12001c00 	and	w0, w0, #0xff
  601041e660:	7100001f 	cmp	w0, #0x0
  601041e664:	54000080 	b.eq	601041e674 <sys_poll_session+0x4b4>  // b.none
            nr_sessions_need_to_handle++;
  601041e668:	b940b3e0 	ldr	w0, [sp, #176]
  601041e66c:	11000400 	add	w0, w0, #0x1
  601041e670:	b900b3e0 	str	w0, [sp, #176]
        }

        session_idx++;
  601041e674:	b940abe0 	ldr	w0, [sp, #168]
  601041e678:	11000400 	add	w0, w0, #0x1
  601041e67c:	b900abe0 	str	w0, [sp, #168]
    DOUBLE_LIST_FOR_EACH_ENTRY(server_session, &cur_task->svr_sess_listhead, node)
  601041e680:	f9405fe0 	ldr	x0, [sp, #184]
  601041e684:	f9400000 	ldr	x0, [x0]
  601041e688:	f9005fe0 	str	x0, [sp, #184]
  601041e68c:	f9405fe1 	ldr	x1, [sp, #184]
  601041e690:	f94053e0 	ldr	x0, [sp, #160]
  601041e694:	9101e000 	add	x0, x0, #0x78
  601041e698:	eb00003f 	cmp	x1, x0
  601041e69c:	54ffefe1 	b.ne	601041e498 <sys_poll_session+0x2d8>  // b.any
  601041e6a0:	14000002 	b	601041e6a8 <sys_poll_session+0x4e8>
            break;
  601041e6a4:	d503201f 	nop
    }
    if (session_idx < arr_capacity) {
  601041e6a8:	b940abe1 	ldr	w1, [sp, #168]
  601041e6ac:	b94017e0 	ldr	w0, [sp, #20]
  601041e6b0:	6b00003f 	cmp	w1, w0
  601041e6b4:	540003aa 	b.ge	601041e728 <sys_poll_session+0x568>  // b.tcont
        userland_session_arr[session_idx].buf = NULL;
  601041e6b8:	b980abe1 	ldrsw	x1, [sp, #168]
  601041e6bc:	d2800300 	mov	x0, #0x18                  	// #24
  601041e6c0:	9b007c20 	mul	x0, x1, x0
  601041e6c4:	f9400fe1 	ldr	x1, [sp, #24]
  601041e6c8:	8b000020 	add	x0, x1, x0
  601041e6cc:	f900081f 	str	xzr, [x0, #16]
        if (!has_middle_delete && nr_sessions_need_to_handle == 0) {
  601041e6d0:	3942bfe0 	ldrb	w0, [sp, #175]
  601041e6d4:	52000000 	eor	w0, w0, #0x1
  601041e6d8:	12001c00 	and	w0, w0, #0xff
  601041e6dc:	7100001f 	cmp	w0, #0x0
  601041e6e0:	54000240 	b.eq	601041e728 <sys_poll_session+0x568>  // b.none
  601041e6e4:	b940b3e0 	ldr	w0, [sp, #176]
  601041e6e8:	7100001f 	cmp	w0, #0x0
  601041e6ec:	540001e1 	b.ne	601041e728 <sys_poll_session+0x568>  // b.any
            xizi_task_manager.task_yield_noschedule(cur_task, false);
  601041e6f0:	b0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041e6f4:	f942ec00 	ldr	x0, [x0, #1496]
  601041e6f8:	f941a802 	ldr	x2, [x0, #848]
  601041e6fc:	52800001 	mov	w1, #0x0                   	// #0
  601041e700:	f94053e0 	ldr	x0, [sp, #160]
  601041e704:	d63f0040 	blr	x2
            xizi_task_manager.task_block(&xizi_task_manager.task_blocked_list_head, cur_task);
  601041e708:	b0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041e70c:	f942ec00 	ldr	x0, [x0, #1496]
  601041e710:	f941ac02 	ldr	x2, [x0, #856]
  601041e714:	f94053e1 	ldr	x1, [sp, #160]
  601041e718:	b0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041e71c:	f942ec00 	ldr	x0, [x0, #1496]
  601041e720:	91084000 	add	x0, x0, #0x210
  601041e724:	d63f0040 	blr	x2
        }
    }

    return 0;
  601041e728:	52800000 	mov	w0, #0x0                   	// #0
  601041e72c:	a8cc7bfd 	ldp	x29, x30, [sp], #192
  601041e730:	d65f03c0 	ret

000000601041e734 <sys_close_session>:
/// @warning best to be called by a client
/// @param cur_task
/// @param session
/// @return
int sys_close_session(struct Thread* cur_task, struct Session* session)
{
  601041e734:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  601041e738:	910003fd 	mov	x29, sp
  601041e73c:	f9000fe0 	str	x0, [sp, #24]
  601041e740:	f9000be1 	str	x1, [sp, #16]
    assert(cur_task != NULL);
  601041e744:	f9400fe0 	ldr	x0, [sp, #24]
  601041e748:	f100001f 	cmp	x0, #0x0
  601041e74c:	540001e1 	b.ne	601041e788 <sys_close_session+0x54>  // b.any
  601041e750:	52800562 	mov	w2, #0x2b                  	// #43
  601041e754:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e758:	91212001 	add	x1, x0, #0x848
  601041e75c:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e760:	911de000 	add	x0, x0, #0x778
  601041e764:	97ffd685 	bl	6010414178 <printf_>
  601041e768:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e76c:	911e2001 	add	x1, x0, #0x788
  601041e770:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e774:	911e8000 	add	x0, x0, #0x7a0
  601041e778:	97ffd680 	bl	6010414178 <printf_>
  601041e77c:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e780:	911ec000 	add	x0, x0, #0x7b0
  601041e784:	97ffc2c9 	bl	601040f2a8 <panic>
    /* check if session is available */
    if (session->buf == NULL || (uintptr_t)session->buf < USER_IPC_SPACE_BASE || (uintptr_t)session->buf > USER_IPC_SPACE_TOP) {
  601041e788:	f9400be0 	ldr	x0, [sp, #16]
  601041e78c:	f9400800 	ldr	x0, [x0, #16]
  601041e790:	f100001f 	cmp	x0, #0x0
  601041e794:	540001c0 	b.eq	601041e7cc <sys_close_session+0x98>  // b.none
  601041e798:	f9400be0 	ldr	x0, [sp, #16]
  601041e79c:	f9400800 	ldr	x0, [x0, #16]
  601041e7a0:	aa0003e1 	mov	x1, x0
  601041e7a4:	d2c00600 	mov	x0, #0x3000000000          	// #206158430208
  601041e7a8:	eb00003f 	cmp	x1, x0
  601041e7ac:	54000103 	b.cc	601041e7cc <sys_close_session+0x98>  // b.lo, b.ul, b.last
  601041e7b0:	f9400be0 	ldr	x0, [sp, #16]
  601041e7b4:	f9400800 	ldr	x0, [x0, #16]
  601041e7b8:	aa0003e1 	mov	x1, x0
  601041e7bc:	d2a20000 	mov	x0, #0x10000000            	// #268435456
  601041e7c0:	f2c00600 	movk	x0, #0x30, lsl #32
  601041e7c4:	eb00003f 	cmp	x1, x0
  601041e7c8:	54000069 	b.ls	601041e7d4 <sys_close_session+0xa0>  // b.plast
        return -1;
  601041e7cc:	12800000 	mov	w0, #0xffffffff            	// #-1
  601041e7d0:	14000098 	b	601041ea30 <sys_close_session+0x2fc>
    }

    /* check if session is a client one or a server one */
    struct session_backend* session_backend = NULL;
  601041e7d4:	f9001fff 	str	xzr, [sp, #56]

    struct client_session* client_session = NULL;
  601041e7d8:	f9001bff 	str	xzr, [sp, #48]
    DOUBLE_LIST_FOR_EACH_ENTRY(client_session, &cur_task->cli_sess_listhead, node)
  601041e7dc:	f9400fe0 	ldr	x0, [sp, #24]
  601041e7e0:	f9403400 	ldr	x0, [x0, #104]
  601041e7e4:	f9001be0 	str	x0, [sp, #48]
  601041e7e8:	1400003c 	b	601041e8d8 <sys_close_session+0x1a4>
    {
        if ((uintptr_t)session->buf == client_session->buf_addr) {
  601041e7ec:	f9400be0 	ldr	x0, [sp, #16]
  601041e7f0:	f9400800 	ldr	x0, [x0, #16]
  601041e7f4:	aa0003e1 	mov	x1, x0
  601041e7f8:	f9401be0 	ldr	x0, [sp, #48]
  601041e7fc:	f9400800 	ldr	x0, [x0, #16]
  601041e800:	eb00003f 	cmp	x1, x0
  601041e804:	54000641 	b.ne	601041e8cc <sys_close_session+0x198>  // b.any
            session_backend = CLIENT_SESSION_BACKEND(client_session);
  601041e808:	f9401be0 	ldr	x0, [sp, #48]
  601041e80c:	d100a000 	sub	x0, x0, #0x28
  601041e810:	f9001fe0 	str	x0, [sp, #56]
            assert(session_backend->client == cur_task);
  601041e814:	f9401fe0 	ldr	x0, [sp, #56]
  601041e818:	f9402800 	ldr	x0, [x0, #80]
  601041e81c:	f9400fe1 	ldr	x1, [sp, #24]
  601041e820:	eb00003f 	cmp	x1, x0
  601041e824:	540001e0 	b.eq	601041e860 <sys_close_session+0x12c>  // b.none
  601041e828:	52800722 	mov	w2, #0x39                  	// #57
  601041e82c:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e830:	91212001 	add	x1, x0, #0x848
  601041e834:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e838:	911de000 	add	x0, x0, #0x778
  601041e83c:	97ffd64f 	bl	6010414178 <printf_>
  601041e840:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e844:	911ee001 	add	x1, x0, #0x7b8
  601041e848:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e84c:	911e8000 	add	x0, x0, #0x7a0
  601041e850:	97ffd64a 	bl	6010414178 <printf_>
  601041e854:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e858:	911ec000 	add	x0, x0, #0x7b0
  601041e85c:	97ffc293 	bl	601040f2a8 <panic>
            assert(client_session->closed == false);
  601041e860:	f9401be0 	ldr	x0, [sp, #48]
  601041e864:	39407000 	ldrb	w0, [x0, #28]
  601041e868:	7100001f 	cmp	w0, #0x0
  601041e86c:	540001e0 	b.eq	601041e8a8 <sys_close_session+0x174>  // b.none
  601041e870:	52800742 	mov	w2, #0x3a                  	// #58
  601041e874:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e878:	91212001 	add	x1, x0, #0x848
  601041e87c:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e880:	911de000 	add	x0, x0, #0x778
  601041e884:	97ffd63d 	bl	6010414178 <printf_>
  601041e888:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e88c:	911f8001 	add	x1, x0, #0x7e0
  601041e890:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e894:	911e8000 	add	x0, x0, #0x7a0
  601041e898:	97ffd638 	bl	6010414178 <printf_>
  601041e89c:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e8a0:	911ec000 	add	x0, x0, #0x7b0
  601041e8a4:	97ffc281 	bl	601040f2a8 <panic>
            client_session->closed = true;
  601041e8a8:	f9401be0 	ldr	x0, [sp, #48]
  601041e8ac:	52800021 	mov	w1, #0x1                   	// #1
  601041e8b0:	39007001 	strb	w1, [x0, #28]
            xizi_share_page_manager.delete_share_pages(session_backend);
  601041e8b4:	b0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041e8b8:	f942e400 	ldr	x0, [x0, #1480]
  601041e8bc:	f9400801 	ldr	x1, [x0, #16]
  601041e8c0:	f9401fe0 	ldr	x0, [sp, #56]
  601041e8c4:	d63f0020 	blr	x1
            break;
  601041e8c8:	14000009 	b	601041e8ec <sys_close_session+0x1b8>
    DOUBLE_LIST_FOR_EACH_ENTRY(client_session, &cur_task->cli_sess_listhead, node)
  601041e8cc:	f9401be0 	ldr	x0, [sp, #48]
  601041e8d0:	f9400000 	ldr	x0, [x0]
  601041e8d4:	f9001be0 	str	x0, [sp, #48]
  601041e8d8:	f9401be1 	ldr	x1, [sp, #48]
  601041e8dc:	f9400fe0 	ldr	x0, [sp, #24]
  601041e8e0:	9101a000 	add	x0, x0, #0x68
  601041e8e4:	eb00003f 	cmp	x1, x0
  601041e8e8:	54fff821 	b.ne	601041e7ec <sys_close_session+0xb8>  // b.any
        }
    }

    if (UNLIKELY(session_backend == NULL)) {
  601041e8ec:	f9401fe0 	ldr	x0, [sp, #56]
  601041e8f0:	f100001f 	cmp	x0, #0x0
  601041e8f4:	1a9f17e0 	cset	w0, eq  // eq = none
  601041e8f8:	12001c00 	and	w0, w0, #0xff
  601041e8fc:	92401c00 	and	x0, x0, #0xff
  601041e900:	f100001f 	cmp	x0, #0x0
  601041e904:	540008a0 	b.eq	601041ea18 <sys_close_session+0x2e4>  // b.none
        struct server_session* server_session = NULL;
  601041e908:	f90017ff 	str	xzr, [sp, #40]
        DOUBLE_LIST_FOR_EACH_ENTRY(server_session, &cur_task->svr_sess_listhead, node)
  601041e90c:	f9400fe0 	ldr	x0, [sp, #24]
  601041e910:	f9403c00 	ldr	x0, [x0, #120]
  601041e914:	f90017e0 	str	x0, [sp, #40]
  601041e918:	1400003b 	b	601041ea04 <sys_close_session+0x2d0>
        {
            if ((uintptr_t)session->buf == server_session->buf_addr) {
  601041e91c:	f9400be0 	ldr	x0, [sp, #16]
  601041e920:	f9400800 	ldr	x0, [x0, #16]
  601041e924:	aa0003e1 	mov	x1, x0
  601041e928:	f94017e0 	ldr	x0, [sp, #40]
  601041e92c:	f9400800 	ldr	x0, [x0, #16]
  601041e930:	eb00003f 	cmp	x1, x0
  601041e934:	54000621 	b.ne	601041e9f8 <sys_close_session+0x2c4>  // b.any
                session_backend = SERVER_SESSION_BACKEND(server_session);
  601041e938:	f94017e0 	ldr	x0, [sp, #40]
  601041e93c:	f9001fe0 	str	x0, [sp, #56]
                assert(session_backend->server == cur_task);
  601041e940:	f9401fe0 	ldr	x0, [sp, #56]
  601041e944:	f9402c00 	ldr	x0, [x0, #88]
  601041e948:	f9400fe1 	ldr	x1, [sp, #24]
  601041e94c:	eb00003f 	cmp	x1, x0
  601041e950:	540001e0 	b.eq	601041e98c <sys_close_session+0x258>  // b.none
  601041e954:	528008e2 	mov	w2, #0x47                  	// #71
  601041e958:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e95c:	91212001 	add	x1, x0, #0x848
  601041e960:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e964:	911de000 	add	x0, x0, #0x778
  601041e968:	97ffd604 	bl	6010414178 <printf_>
  601041e96c:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e970:	91200001 	add	x1, x0, #0x800
  601041e974:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e978:	911e8000 	add	x0, x0, #0x7a0
  601041e97c:	97ffd5ff 	bl	6010414178 <printf_>
  601041e980:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e984:	911ec000 	add	x0, x0, #0x7b0
  601041e988:	97ffc248 	bl	601040f2a8 <panic>
                assert(server_session->closed == false);
  601041e98c:	f94017e0 	ldr	x0, [sp, #40]
  601041e990:	39409000 	ldrb	w0, [x0, #36]
  601041e994:	7100001f 	cmp	w0, #0x0
  601041e998:	540001e0 	b.eq	601041e9d4 <sys_close_session+0x2a0>  // b.none
  601041e99c:	52800902 	mov	w2, #0x48                  	// #72
  601041e9a0:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e9a4:	91212001 	add	x1, x0, #0x848
  601041e9a8:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e9ac:	911de000 	add	x0, x0, #0x778
  601041e9b0:	97ffd5f2 	bl	6010414178 <printf_>
  601041e9b4:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e9b8:	9120a001 	add	x1, x0, #0x828
  601041e9bc:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e9c0:	911e8000 	add	x0, x0, #0x7a0
  601041e9c4:	97ffd5ed 	bl	6010414178 <printf_>
  601041e9c8:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041e9cc:	911ec000 	add	x0, x0, #0x7b0
  601041e9d0:	97ffc236 	bl	601040f2a8 <panic>
                server_session->closed = true;
  601041e9d4:	f94017e0 	ldr	x0, [sp, #40]
  601041e9d8:	52800021 	mov	w1, #0x1                   	// #1
  601041e9dc:	39009001 	strb	w1, [x0, #36]
                xizi_share_page_manager.delete_share_pages(session_backend);
  601041e9e0:	b0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041e9e4:	f942e400 	ldr	x0, [x0, #1480]
  601041e9e8:	f9400801 	ldr	x1, [x0, #16]
  601041e9ec:	f9401fe0 	ldr	x0, [sp, #56]
  601041e9f0:	d63f0020 	blr	x1
                break;
  601041e9f4:	14000009 	b	601041ea18 <sys_close_session+0x2e4>
        DOUBLE_LIST_FOR_EACH_ENTRY(server_session, &cur_task->svr_sess_listhead, node)
  601041e9f8:	f94017e0 	ldr	x0, [sp, #40]
  601041e9fc:	f9400000 	ldr	x0, [x0]
  601041ea00:	f90017e0 	str	x0, [sp, #40]
  601041ea04:	f94017e1 	ldr	x1, [sp, #40]
  601041ea08:	f9400fe0 	ldr	x0, [sp, #24]
  601041ea0c:	9101e000 	add	x0, x0, #0x78
  601041ea10:	eb00003f 	cmp	x1, x0
  601041ea14:	54fff841 	b.ne	601041e91c <sys_close_session+0x1e8>  // b.any
            }
        }
    }

    /* close this session */
    if (session_backend == NULL) {
  601041ea18:	f9401fe0 	ldr	x0, [sp, #56]
  601041ea1c:	f100001f 	cmp	x0, #0x0
  601041ea20:	54000061 	b.ne	601041ea2c <sys_close_session+0x2f8>  // b.any
        return -1;
  601041ea24:	12800000 	mov	w0, #0xffffffff            	// #-1
  601041ea28:	14000002 	b	601041ea30 <sys_close_session+0x2fc>
    }

    return 0;
  601041ea2c:	52800000 	mov	w0, #0x0                   	// #0
  601041ea30:	a8c47bfd 	ldp	x29, x30, [sp], #64
  601041ea34:	d65f03c0 	ret

000000601041ea38 <cur_cpuid>:
{
  601041ea38:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601041ea3c:	910003fd 	mov	x29, sp
    return cpu_get_current();
  601041ea40:	97ffbf16 	bl	601040e698 <cpu_get_current>
}
  601041ea44:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601041ea48:	d65f03c0 	ret

000000601041ea4c <cur_cpu>:
{
  601041ea4c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601041ea50:	910003fd 	mov	x29, sp
    return &global_cpus[cur_cpuid()];
  601041ea54:	97fffff9 	bl	601041ea38 <cur_cpuid>
  601041ea58:	93407c01 	sxtw	x1, w0
  601041ea5c:	d2800300 	mov	x0, #0x18                  	// #24
  601041ea60:	9b007c21 	mul	x1, x1, x0
  601041ea64:	b0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041ea68:	f942f400 	ldr	x0, [x0, #1512]
  601041ea6c:	8b000020 	add	x0, x1, x0
}
  601041ea70:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601041ea74:	d65f03c0 	ret

000000601041ea78 <send_irq_to_user>:
    struct session_backend* p_kernel_session;
    int opcode;
} irq_forward_table[NR_IRQS];

static void send_irq_to_user(int irq_num)
{
  601041ea78:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  601041ea7c:	910003fd 	mov	x29, sp
  601041ea80:	b9001fe0 	str	w0, [sp, #28]
    if (irq_forward_table[irq_num].handle_task != NULL) {
  601041ea84:	b000b920 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041ea88:	91320001 	add	x1, x0, #0xc80
  601041ea8c:	b9801fe2 	ldrsw	x2, [sp, #28]
  601041ea90:	d2800600 	mov	x0, #0x30                  	// #48
  601041ea94:	9b007c40 	mul	x0, x2, x0
  601041ea98:	8b000020 	add	x0, x1, x0
  601041ea9c:	f9400000 	ldr	x0, [x0]
  601041eaa0:	f100001f 	cmp	x0, #0x0
  601041eaa4:	54001180 	b.eq	601041ecd4 <send_irq_to_user+0x25c>  // b.none
        struct Session* session = &irq_forward_table[irq_num].session;
  601041eaa8:	b9801fe1 	ldrsw	x1, [sp, #28]
  601041eaac:	d2800600 	mov	x0, #0x30                  	// #48
  601041eab0:	9b007c21 	mul	x1, x1, x0
  601041eab4:	b000b920 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041eab8:	91320000 	add	x0, x0, #0xc80
  601041eabc:	8b000020 	add	x0, x1, x0
  601041eac0:	91002000 	add	x0, x0, #0x8
  601041eac4:	f9001fe0 	str	x0, [sp, #56]
        int len = IPC_ARG_INFO_BASE_OFFSET;
  601041eac8:	52800180 	mov	w0, #0xc                   	// #12
  601041eacc:	b90037e0 	str	w0, [sp, #52]
        len += sizeof(struct IpcArgInfo);
  601041ead0:	b94037e0 	ldr	w0, [sp, #52]
  601041ead4:	11001000 	add	w0, w0, #0x4
  601041ead8:	b90037e0 	str	w0, [sp, #52]

        /* get message space and add session tail */
        void* session_kern_vaddr = P2V(xizi_pager.address_translate(&kernel_irq_proxy->memspace->pgdir, (uintptr_t)session->buf));
  601041eadc:	b0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041eae0:	f942b000 	ldr	x0, [x0, #1376]
  601041eae4:	f9401402 	ldr	x2, [x0, #40]
  601041eae8:	b000b920 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041eaec:	9131e000 	add	x0, x0, #0xc78
  601041eaf0:	f9400000 	ldr	x0, [x0]
  601041eaf4:	f9402800 	ldr	x0, [x0, #80]
  601041eaf8:	aa0003e3 	mov	x3, x0
  601041eafc:	f9401fe0 	ldr	x0, [sp, #56]
  601041eb00:	f9400800 	ldr	x0, [x0, #16]
  601041eb04:	aa0003e1 	mov	x1, x0
  601041eb08:	aa0303e0 	mov	x0, x3
  601041eb0c:	d63f0040 	blr	x2
  601041eb10:	aa0003e1 	mov	x1, x0
  601041eb14:	d2c00c00 	mov	x0, #0x6000000000          	// #412316860416
  601041eb18:	8b000020 	add	x0, x1, x0
  601041eb1c:	f90017e0 	str	x0, [sp, #40]
        struct IpcMsg* buf = (struct IpcMsg*)((uintptr_t)session_kern_vaddr + session->tail);
  601041eb20:	f9401fe0 	ldr	x0, [sp, #56]
  601041eb24:	b9400c00 	ldr	w0, [x0, #12]
  601041eb28:	93407c01 	sxtw	x1, w0
  601041eb2c:	f94017e0 	ldr	x0, [sp, #40]
  601041eb30:	8b000020 	add	x0, x1, x0
  601041eb34:	f90013e0 	str	x0, [sp, #32]

        /* check if server session is full */
        if (buf->header.magic == IPC_MSG_MAGIC && buf->header.done == 0) {
  601041eb38:	f94013e0 	ldr	x0, [sp, #32]
  601041eb3c:	b9400401 	ldr	w1, [x0, #4]
  601041eb40:	529b9740 	mov	w0, #0xdcba                	// #56506
  601041eb44:	72b579a0 	movk	w0, #0xabcd, lsl #16
  601041eb48:	6b00003f 	cmp	w1, w0
  601041eb4c:	540001e1 	b.ne	601041eb88 <send_irq_to_user+0x110>  // b.any
  601041eb50:	f94013e0 	ldr	x0, [sp, #32]
  601041eb54:	f9400000 	ldr	x0, [x0]
  601041eb58:	927f0000 	and	x0, x0, #0x2
  601041eb5c:	f100001f 	cmp	x0, #0x0
  601041eb60:	54000141 	b.ne	601041eb88 <send_irq_to_user+0x110>  // b.any
            DEBUG("irq server cannot handle new interrupt by now.\n");
  601041eb64:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041eb68:	91240001 	add	x1, x0, #0x900
  601041eb6c:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041eb70:	91218000 	add	x0, x0, #0x860
  601041eb74:	97ffd581 	bl	6010414178 <printf_>
  601041eb78:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041eb7c:	9121c000 	add	x0, x0, #0x870
  601041eb80:	97ffd57e 	bl	6010414178 <printf_>
            return;
  601041eb84:	14000054 	b	601041ecd4 <send_irq_to_user+0x25c>
        }
        memset((void*)buf, 0, len);
  601041eb88:	b98037e0 	ldrsw	x0, [sp, #52]
  601041eb8c:	aa0003e2 	mov	x2, x0
  601041eb90:	52800001 	mov	w1, #0x0                   	// #0
  601041eb94:	f94013e0 	ldr	x0, [sp, #32]
  601041eb98:	97ffbdca 	bl	601040e2c0 <memset>
        session->tail = (session->tail + len) % session->capacity;
  601041eb9c:	f9401fe0 	ldr	x0, [sp, #56]
  601041eba0:	b9400c01 	ldr	w1, [x0, #12]
  601041eba4:	b94037e0 	ldr	w0, [sp, #52]
  601041eba8:	0b000020 	add	w0, w1, w0
  601041ebac:	f9401fe1 	ldr	x1, [sp, #56]
  601041ebb0:	b9400421 	ldr	w1, [x1, #4]
  601041ebb4:	1ac10c02 	sdiv	w2, w0, w1
  601041ebb8:	1b017c41 	mul	w1, w2, w1
  601041ebbc:	4b010001 	sub	w1, w0, w1
  601041ebc0:	f9401fe0 	ldr	x0, [sp, #56]
  601041ebc4:	b9000c01 	str	w1, [x0, #12]

        /* construct message */
        buf->header.len = len;
  601041ebc8:	b94037e0 	ldr	w0, [sp, #52]
  601041ebcc:	12003c01 	and	w1, w0, #0xffff
  601041ebd0:	f94013e0 	ldr	x0, [sp, #32]
  601041ebd4:	79000401 	strh	w1, [x0, #2]
        buf->header.nr_args = 1;
  601041ebd8:	f94013e1 	ldr	x1, [sp, #32]
  601041ebdc:	b9400020 	ldr	w0, [x1]
  601041ebe0:	52800022 	mov	w2, #0x1                   	// #1
  601041ebe4:	331c0c40 	bfi	w0, w2, #4, #4
  601041ebe8:	b9000020 	str	w0, [x1]
        buf->header.init = 1;
  601041ebec:	f94013e0 	ldr	x0, [sp, #32]
  601041ebf0:	f9400001 	ldr	x1, [x0]
  601041ebf4:	b27e0021 	orr	x1, x1, #0x4
  601041ebf8:	f9000001 	str	x1, [x0]
        buf->header.opcode = irq_forward_table[irq_num].opcode;
  601041ebfc:	b000b920 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041ec00:	91320001 	add	x1, x0, #0xc80
  601041ec04:	b9801fe2 	ldrsw	x2, [sp, #28]
  601041ec08:	d2800600 	mov	x0, #0x30                  	// #48
  601041ec0c:	9b007c40 	mul	x0, x2, x0
  601041ec10:	8b000020 	add	x0, x1, x0
  601041ec14:	b9402800 	ldr	w0, [x0, #40]
  601041ec18:	12001c01 	and	w1, w0, #0xff
  601041ec1c:	f94013e0 	ldr	x0, [sp, #32]
  601041ec20:	39000401 	strb	w1, [x0, #1]
        buf->header.done = 0;
  601041ec24:	f94013e0 	ldr	x0, [sp, #32]
  601041ec28:	f9400001 	ldr	x1, [x0]
  601041ec2c:	927ef821 	and	x1, x1, #0xfffffffffffffffd
  601041ec30:	f9000001 	str	x1, [x0]
        buf->header.magic = IPC_MSG_MAGIC;
  601041ec34:	f94013e0 	ldr	x0, [sp, #32]
  601041ec38:	529b9741 	mov	w1, #0xdcba                	// #56506
  601041ec3c:	72b579a1 	movk	w1, #0xabcd, lsl #16
  601041ec40:	b9000401 	str	w1, [x0, #4]
        buf->header.valid = 1;
  601041ec44:	f94013e0 	ldr	x0, [sp, #32]
  601041ec48:	f9400001 	ldr	x1, [x0]
  601041ec4c:	b2400021 	orr	x1, x1, #0x1
  601041ec50:	f9000001 	str	x1, [x0]

        if (irq_forward_table[irq_num].handle_task->state == BLOCKED) {
  601041ec54:	b000b920 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041ec58:	91320001 	add	x1, x0, #0xc80
  601041ec5c:	b9801fe2 	ldrsw	x2, [sp, #28]
  601041ec60:	d2800600 	mov	x0, #0x30                  	// #48
  601041ec64:	9b007c40 	mul	x0, x2, x0
  601041ec68:	8b000020 	add	x0, x1, x0
  601041ec6c:	f9400000 	ldr	x0, [x0]
  601041ec70:	b940a800 	ldr	w0, [x0, #168]
  601041ec74:	7100101f 	cmp	w0, #0x4
  601041ec78:	54000181 	b.ne	601041eca8 <send_irq_to_user+0x230>  // b.any
            xizi_task_manager.task_unblock(irq_forward_table[irq_num].handle_task);
  601041ec7c:	b0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041ec80:	f942ec00 	ldr	x0, [x0, #1496]
  601041ec84:	f941b001 	ldr	x1, [x0, #864]
  601041ec88:	b000b920 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041ec8c:	91320002 	add	x2, x0, #0xc80
  601041ec90:	b9801fe3 	ldrsw	x3, [sp, #28]
  601041ec94:	d2800600 	mov	x0, #0x30                  	// #48
  601041ec98:	9b007c60 	mul	x0, x3, x0
  601041ec9c:	8b000040 	add	x0, x2, x0
  601041eca0:	f9400000 	ldr	x0, [x0]
  601041eca4:	d63f0020 	blr	x1
        }

        /* add session head */
        session->head = (session->head + len) % session->capacity;
  601041eca8:	f9401fe0 	ldr	x0, [sp, #56]
  601041ecac:	b9400801 	ldr	w1, [x0, #8]
  601041ecb0:	b94037e0 	ldr	w0, [sp, #52]
  601041ecb4:	0b000020 	add	w0, w1, w0
  601041ecb8:	f9401fe1 	ldr	x1, [sp, #56]
  601041ecbc:	b9400421 	ldr	w1, [x1, #4]
  601041ecc0:	1ac10c02 	sdiv	w2, w0, w1
  601041ecc4:	1b017c41 	mul	w1, w2, w1
  601041ecc8:	4b010001 	sub	w1, w0, w1
  601041eccc:	f9401fe0 	ldr	x0, [sp, #56]
  601041ecd0:	b9000801 	str	w1, [x0, #8]
    }
}
  601041ecd4:	a8c47bfd 	ldp	x29, x30, [sp], #64
  601041ecd8:	d65f03c0 	ret

000000601041ecdc <user_irq_handler>:

int user_irq_handler(int irq, void* tf, void* arg)
{
  601041ecdc:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  601041ece0:	910003fd 	mov	x29, sp
  601041ece4:	f9000bf3 	str	x19, [sp, #16]
  601041ece8:	b9003fe0 	str	w0, [sp, #60]
  601041ecec:	f9001be1 	str	x1, [sp, #48]
  601041ecf0:	f90017e2 	str	x2, [sp, #40]
    if (irq_forward_table[irq].handle_task != NULL) {
  601041ecf4:	b000b920 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041ecf8:	91320001 	add	x1, x0, #0xc80
  601041ecfc:	b9803fe2 	ldrsw	x2, [sp, #60]
  601041ed00:	d2800600 	mov	x0, #0x30                  	// #48
  601041ed04:	9b007c40 	mul	x0, x2, x0
  601041ed08:	8b000020 	add	x0, x1, x0
  601041ed0c:	f9400000 	ldr	x0, [x0]
  601041ed10:	f100001f 	cmp	x0, #0x0
  601041ed14:	54000300 	b.eq	601041ed74 <user_irq_handler+0x98>  // b.none
        send_irq_to_user(irq);
  601041ed18:	b9403fe0 	ldr	w0, [sp, #60]
  601041ed1c:	97ffff57 	bl	601041ea78 <send_irq_to_user>

        next_task_emergency = irq_forward_table[irq].handle_task;
  601041ed20:	b000b920 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041ed24:	91320001 	add	x1, x0, #0xc80
  601041ed28:	b9803fe2 	ldrsw	x2, [sp, #60]
  601041ed2c:	d2800600 	mov	x0, #0x30                  	// #48
  601041ed30:	9b007c40 	mul	x0, x2, x0
  601041ed34:	8b000020 	add	x0, x1, x0
  601041ed38:	f9400001 	ldr	x1, [x0]
  601041ed3c:	b0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041ed40:	f9429400 	ldr	x0, [x0, #1320]
  601041ed44:	f9000001 	str	x1, [x0]
        if (cur_cpu()->task != NULL) {
  601041ed48:	97ffff41 	bl	601041ea4c <cur_cpu>
  601041ed4c:	f9400400 	ldr	x0, [x0, #8]
  601041ed50:	f100001f 	cmp	x0, #0x0
  601041ed54:	54000100 	b.eq	601041ed74 <user_irq_handler+0x98>  // b.none
            xizi_task_manager.task_yield_noschedule(cur_cpu()->task, false);
  601041ed58:	b0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041ed5c:	f942ec00 	ldr	x0, [x0, #1496]
  601041ed60:	f941a813 	ldr	x19, [x0, #848]
  601041ed64:	97ffff3a 	bl	601041ea4c <cur_cpu>
  601041ed68:	f9400400 	ldr	x0, [x0, #8]
  601041ed6c:	52800001 	mov	w1, #0x0                   	// #0
  601041ed70:	d63f0260 	blr	x19
        }
    }
    return 0;
  601041ed74:	52800000 	mov	w0, #0x0                   	// #0
}
  601041ed78:	f9400bf3 	ldr	x19, [sp, #16]
  601041ed7c:	a8c47bfd 	ldp	x29, x30, [sp], #64
  601041ed80:	d65f03c0 	ret

000000601041ed84 <sys_register_irq>:
extern struct session_backend* create_session_inner(struct Thread* client, struct Thread* server, int capacity, struct Session* user_session);
/// @warning no tested.

static struct XiziTrapDriver* p_intr_driver = NULL;
int sys_register_irq(int irq_num, int irq_opcode)
{
  601041ed84:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  601041ed88:	910003fd 	mov	x29, sp
  601041ed8c:	b9001fe0 	str	w0, [sp, #28]
  601041ed90:	b9001be1 	str	w1, [sp, #24]
    // init intr resource;
    if (p_intr_driver == NULL) {
  601041ed94:	9000b940 	adrp	x0, 6011b46000 <irq_forward_table+0x2380>
  601041ed98:	913c8000 	add	x0, x0, #0xf20
  601041ed9c:	f9400000 	ldr	x0, [x0]
  601041eda0:	f100001f 	cmp	x0, #0x0
  601041eda4:	540003c1 	b.ne	601041ee1c <sys_register_irq+0x98>  // b.any
        struct TraceTag intr_ac_tag;
        if (!AchieveResourceTag(&intr_ac_tag, RequireRootTag(), "hardkernel/intr-ac-resource")) {
  601041eda8:	97ffdc24 	bl	6010415e38 <RequireRootTag>
  601041edac:	aa0003e1 	mov	x1, x0
  601041edb0:	9100a3e3 	add	x3, sp, #0x28
  601041edb4:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041edb8:	91228002 	add	x2, x0, #0x8a0
  601041edbc:	aa0303e0 	mov	x0, x3
  601041edc0:	97ffdc21 	bl	6010415e44 <AchieveResourceTag>
  601041edc4:	12001c00 	and	w0, w0, #0xff
  601041edc8:	52000000 	eor	w0, w0, #0x1
  601041edcc:	12001c00 	and	w0, w0, #0xff
  601041edd0:	7100001f 	cmp	w0, #0x0
  601041edd4:	54000180 	b.eq	601041ee04 <sys_register_irq+0x80>  // b.none
            ERROR("intr not initialized.\n");
  601041edd8:	52800de2 	mov	w2, #0x6f                  	// #111
  601041eddc:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041ede0:	91246001 	add	x1, x0, #0x918
  601041ede4:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041ede8:	91230000 	add	x0, x0, #0x8c0
  601041edec:	97ffd4e3 	bl	6010414178 <printf_>
  601041edf0:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041edf4:	91234000 	add	x0, x0, #0x8d0
  601041edf8:	97ffd4e0 	bl	6010414178 <printf_>
            return -1;
  601041edfc:	12800000 	mov	w0, #0xffffffff            	// #-1
  601041ee00:	1400007a 	b	601041efe8 <sys_register_irq+0x264>
        }
        p_intr_driver = (struct XiziTrapDriver*)AchieveResource(&intr_ac_tag);
  601041ee04:	9100a3e0 	add	x0, sp, #0x28
  601041ee08:	97ffdc62 	bl	6010415f90 <AchieveResource>
  601041ee0c:	aa0003e1 	mov	x1, x0
  601041ee10:	9000b940 	adrp	x0, 6011b46000 <irq_forward_table+0x2380>
  601041ee14:	913c8000 	add	x0, x0, #0xf20
  601041ee18:	f9000001 	str	x1, [x0]
    }

    // init kerenl sender proxy
    if (kernel_irq_proxy == NULL) {
  601041ee1c:	b000b920 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041ee20:	9131e000 	add	x0, x0, #0xc78
  601041ee24:	f9400000 	ldr	x0, [x0]
  601041ee28:	f100001f 	cmp	x0, #0x0
  601041ee2c:	54000481 	b.ne	601041eebc <sys_register_irq+0x138>  // b.any
        /// @todo handle corner cases
        struct MemSpace* pmemspace = alloc_memspace();
  601041ee30:	97fff4cc 	bl	601041c160 <alloc_memspace>
  601041ee34:	f9001fe0 	str	x0, [sp, #56]
        if (pmemspace == NULL) {
  601041ee38:	f9401fe0 	ldr	x0, [sp, #56]
  601041ee3c:	f100001f 	cmp	x0, #0x0
  601041ee40:	54000061 	b.ne	601041ee4c <sys_register_irq+0xc8>  // b.any
            return -1;
  601041ee44:	12800000 	mov	w0, #0xffffffff            	// #-1
  601041ee48:	14000068 	b	601041efe8 <sys_register_irq+0x264>
        }
        xizi_pager.new_pgdir(&pmemspace->pgdir);
  601041ee4c:	b0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041ee50:	f942b000 	ldr	x0, [x0, #1376]
  601041ee54:	f9400001 	ldr	x1, [x0]
  601041ee58:	f9401fe0 	ldr	x0, [sp, #56]
  601041ee5c:	d63f0020 	blr	x1
        memcpy(pmemspace->pgdir.pd_addr, kern_pgdir.pd_addr, TOPLEVLE_PAGEDIR_SIZE);
  601041ee60:	f9401fe0 	ldr	x0, [sp, #56]
  601041ee64:	f9400003 	ldr	x3, [x0]
  601041ee68:	b0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041ee6c:	f942fc00 	ldr	x0, [x0, #1528]
  601041ee70:	f9400000 	ldr	x0, [x0]
  601041ee74:	d2820002 	mov	x2, #0x1000                	// #4096
  601041ee78:	aa0003e1 	mov	x1, x0
  601041ee7c:	aa0303e0 	mov	x0, x3
  601041ee80:	940004e0 	bl	6010420200 <memcpy>

        kernel_irq_proxy = xizi_task_manager.new_task_cb(pmemspace);
  601041ee84:	b0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041ee88:	f942ec00 	ldr	x0, [x0, #1496]
  601041ee8c:	f9419401 	ldr	x1, [x0, #808]
  601041ee90:	f9401fe0 	ldr	x0, [sp, #56]
  601041ee94:	d63f0020 	blr	x1
  601041ee98:	aa0003e1 	mov	x1, x0
  601041ee9c:	b000b920 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041eea0:	9131e000 	add	x0, x0, #0xc78
  601041eea4:	f9000001 	str	x1, [x0]
        kernel_irq_proxy->state = NEVER_RUN;
  601041eea8:	b000b920 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041eeac:	9131e000 	add	x0, x0, #0xc78
  601041eeb0:	f9400000 	ldr	x0, [x0]
  601041eeb4:	528000a1 	mov	w1, #0x5                   	// #5
  601041eeb8:	b900a801 	str	w1, [x0, #168]
    }

    // bind irq to session
    if (irq_forward_table[irq_num].handle_task != NULL) {
  601041eebc:	b000b920 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041eec0:	91320001 	add	x1, x0, #0xc80
  601041eec4:	b9801fe2 	ldrsw	x2, [sp, #28]
  601041eec8:	d2800600 	mov	x0, #0x30                  	// #48
  601041eecc:	9b007c40 	mul	x0, x2, x0
  601041eed0:	8b000020 	add	x0, x1, x0
  601041eed4:	f9400000 	ldr	x0, [x0]
  601041eed8:	f100001f 	cmp	x0, #0x0
  601041eedc:	540001a0 	b.eq	601041ef10 <sys_register_irq+0x18c>  // b.none
        ERROR("irq %d is occupied.\n", irq_num);
  601041eee0:	528010a2 	mov	w2, #0x85                  	// #133
  601041eee4:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041eee8:	91246001 	add	x1, x0, #0x918
  601041eeec:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041eef0:	91230000 	add	x0, x0, #0x8c0
  601041eef4:	97ffd4a1 	bl	6010414178 <printf_>
  601041eef8:	b9401fe1 	ldr	w1, [sp, #28]
  601041eefc:	b0000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041ef00:	9123a000 	add	x0, x0, #0x8e8
  601041ef04:	97ffd49d 	bl	6010414178 <printf_>
        return -1;
  601041ef08:	12800000 	mov	w0, #0xffffffff            	// #-1
  601041ef0c:	14000037 	b	601041efe8 <sys_register_irq+0x264>
    }
    struct Thread* cur_task = cur_cpu()->task;
  601041ef10:	97fffecf 	bl	601041ea4c <cur_cpu>
  601041ef14:	f9400400 	ldr	x0, [x0, #8]
  601041ef18:	f9001be0 	str	x0, [sp, #48]
    irq_forward_table[irq_num].handle_task = cur_task;
  601041ef1c:	b000b920 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041ef20:	91320001 	add	x1, x0, #0xc80
  601041ef24:	b9801fe2 	ldrsw	x2, [sp, #28]
  601041ef28:	d2800600 	mov	x0, #0x30                  	// #48
  601041ef2c:	9b007c40 	mul	x0, x2, x0
  601041ef30:	8b000020 	add	x0, x1, x0
  601041ef34:	f9401be1 	ldr	x1, [sp, #48]
  601041ef38:	f9000001 	str	x1, [x0]
    irq_forward_table[irq_num].opcode = irq_opcode;
  601041ef3c:	b000b920 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041ef40:	91320001 	add	x1, x0, #0xc80
  601041ef44:	b9801fe2 	ldrsw	x2, [sp, #28]
  601041ef48:	d2800600 	mov	x0, #0x30                  	// #48
  601041ef4c:	9b007c40 	mul	x0, x2, x0
  601041ef50:	8b000020 	add	x0, x1, x0
  601041ef54:	b9401be1 	ldr	w1, [sp, #24]
  601041ef58:	b9002801 	str	w1, [x0, #40]
    irq_forward_table[irq_num].p_kernel_session = create_session_inner(kernel_irq_proxy, cur_task, PAGE_SIZE, &irq_forward_table[irq_num].session);
  601041ef5c:	b000b920 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041ef60:	9131e000 	add	x0, x0, #0xc78
  601041ef64:	f9400004 	ldr	x4, [x0]
  601041ef68:	b9801fe1 	ldrsw	x1, [sp, #28]
  601041ef6c:	d2800600 	mov	x0, #0x30                  	// #48
  601041ef70:	9b007c21 	mul	x1, x1, x0
  601041ef74:	b000b920 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041ef78:	91320000 	add	x0, x0, #0xc80
  601041ef7c:	8b000020 	add	x0, x1, x0
  601041ef80:	91002000 	add	x0, x0, #0x8
  601041ef84:	aa0003e3 	mov	x3, x0
  601041ef88:	52820002 	mov	w2, #0x1000                	// #4096
  601041ef8c:	f9401be1 	ldr	x1, [sp, #48]
  601041ef90:	aa0403e0 	mov	x0, x4
  601041ef94:	97fffb90 	bl	601041ddd4 <create_session_inner>
  601041ef98:	aa0003e3 	mov	x3, x0
  601041ef9c:	b000b920 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041efa0:	91320001 	add	x1, x0, #0xc80
  601041efa4:	b9801fe2 	ldrsw	x2, [sp, #28]
  601041efa8:	d2800600 	mov	x0, #0x30                  	// #48
  601041efac:	9b007c40 	mul	x0, x2, x0
  601041efb0:	8b000020 	add	x0, x1, x0
  601041efb4:	f9001003 	str	x3, [x0, #32]
    p_intr_driver->bind_irq_handler(irq_num, user_irq_handler);
  601041efb8:	9000b940 	adrp	x0, 6011b46000 <irq_forward_table+0x2380>
  601041efbc:	913c8000 	add	x0, x0, #0xf20
  601041efc0:	f9400000 	ldr	x0, [x0]
  601041efc4:	f9445402 	ldr	x2, [x0, #2216]
  601041efc8:	b0008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041efcc:	f942c401 	ldr	x1, [x0, #1416]
  601041efd0:	b9401fe0 	ldr	w0, [sp, #28]
  601041efd4:	d63f0040 	blr	x2
    cur_task->bind_irq = true;
  601041efd8:	f9401be0 	ldr	x0, [sp, #48]
  601041efdc:	52800021 	mov	w1, #0x1                   	// #1
  601041efe0:	39005001 	strb	w1, [x0, #20]

    return 0;
  601041efe4:	52800000 	mov	w0, #0x0                   	// #0
}
  601041efe8:	a8c47bfd 	ldp	x29, x30, [sp], #64
  601041efec:	d65f03c0 	ret

000000601041eff0 <sys_unbind_irq>:

int sys_unbind_irq(struct Thread* task, int irq_num)
{
  601041eff0:	d10043ff 	sub	sp, sp, #0x10
  601041eff4:	f90007e0 	str	x0, [sp, #8]
  601041eff8:	b90007e1 	str	w1, [sp, #4]
    if (irq_forward_table[irq_num].handle_task != task) {
  601041effc:	b000b920 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041f000:	91320001 	add	x1, x0, #0xc80
  601041f004:	b98007e2 	ldrsw	x2, [sp, #4]
  601041f008:	d2800600 	mov	x0, #0x30                  	// #48
  601041f00c:	9b007c40 	mul	x0, x2, x0
  601041f010:	8b000020 	add	x0, x1, x0
  601041f014:	f9400000 	ldr	x0, [x0]
  601041f018:	f94007e1 	ldr	x1, [sp, #8]
  601041f01c:	eb00003f 	cmp	x1, x0
  601041f020:	54000060 	b.eq	601041f02c <sys_unbind_irq+0x3c>  // b.none
        return -1;
  601041f024:	12800000 	mov	w0, #0xffffffff            	// #-1
  601041f028:	14000009 	b	601041f04c <sys_unbind_irq+0x5c>
    }

    irq_forward_table[irq_num].handle_task = NULL;
  601041f02c:	9000b920 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041f030:	91320001 	add	x1, x0, #0xc80
  601041f034:	b98007e2 	ldrsw	x2, [sp, #4]
  601041f038:	d2800600 	mov	x0, #0x30                  	// #48
  601041f03c:	9b007c40 	mul	x0, x2, x0
  601041f040:	8b000020 	add	x0, x1, x0
  601041f044:	f900001f 	str	xzr, [x0]
    return 0;
  601041f048:	52800000 	mov	w0, #0x0                   	// #0
}
  601041f04c:	910043ff 	add	sp, sp, #0x10
  601041f050:	d65f03c0 	ret

000000601041f054 <sys_unbind_irq_all>:

int sys_unbind_irq_all(struct Thread* task)
{
  601041f054:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  601041f058:	910003fd 	mov	x29, sp
  601041f05c:	f9000fe0 	str	x0, [sp, #24]
    for (int idx = 0; idx < NR_IRQS; idx++) {
  601041f060:	b9002fff 	str	wzr, [sp, #44]
  601041f064:	14000011 	b	601041f0a8 <sys_unbind_irq_all+0x54>
        if (irq_forward_table[idx].handle_task == task) {
  601041f068:	9000b920 	adrp	x0, 6011b43000 <kern_free_pages.2+0x5ff548>
  601041f06c:	91320001 	add	x1, x0, #0xc80
  601041f070:	b9802fe2 	ldrsw	x2, [sp, #44]
  601041f074:	d2800600 	mov	x0, #0x30                  	// #48
  601041f078:	9b007c40 	mul	x0, x2, x0
  601041f07c:	8b000020 	add	x0, x1, x0
  601041f080:	f9400000 	ldr	x0, [x0]
  601041f084:	f9400fe1 	ldr	x1, [sp, #24]
  601041f088:	eb00003f 	cmp	x1, x0
  601041f08c:	54000081 	b.ne	601041f09c <sys_unbind_irq_all+0x48>  // b.any
            sys_unbind_irq(task, idx);
  601041f090:	b9402fe1 	ldr	w1, [sp, #44]
  601041f094:	f9400fe0 	ldr	x0, [sp, #24]
  601041f098:	97ffffd6 	bl	601041eff0 <sys_unbind_irq>
    for (int idx = 0; idx < NR_IRQS; idx++) {
  601041f09c:	b9402fe0 	ldr	w0, [sp, #44]
  601041f0a0:	11000400 	add	w0, w0, #0x1
  601041f0a4:	b9002fe0 	str	w0, [sp, #44]
  601041f0a8:	b9402fe0 	ldr	w0, [sp, #44]
  601041f0ac:	7104341f 	cmp	w0, #0x10d
  601041f0b0:	54fffdcd 	b.le	601041f068 <sys_unbind_irq_all+0x14>
        }
    }
    task->bind_irq = false;
  601041f0b4:	f9400fe0 	ldr	x0, [sp, #24]
  601041f0b8:	3900501f 	strb	wzr, [x0, #20]
    return 0;
  601041f0bc:	52800000 	mov	w0, #0x0                   	// #0
  601041f0c0:	a8c37bfd 	ldp	x29, x30, [sp], #48
  601041f0c4:	d65f03c0 	ret

000000601041f0c8 <cur_cpuid>:
{
  601041f0c8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601041f0cc:	910003fd 	mov	x29, sp
    return cpu_get_current();
  601041f0d0:	97ffbd72 	bl	601040e698 <cpu_get_current>
}
  601041f0d4:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601041f0d8:	d65f03c0 	ret

000000601041f0dc <cur_cpu>:
{
  601041f0dc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601041f0e0:	910003fd 	mov	x29, sp
    return &global_cpus[cur_cpuid()];
  601041f0e4:	97fffff9 	bl	601041f0c8 <cur_cpuid>
  601041f0e8:	93407c01 	sxtw	x1, w0
  601041f0ec:	d2800300 	mov	x0, #0x18                  	// #24
  601041f0f0:	9b007c21 	mul	x1, x1, x0
  601041f0f4:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041f0f8:	f942f400 	ldr	x0, [x0, #1512]
  601041f0fc:	8b000020 	add	x0, x1, x0
}
  601041f100:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601041f104:	d65f03c0 	ret

000000601041f108 <sys_exit>:
#include "multicores.h"
#include "syscall.h"
#include "task.h"

int sys_exit(struct Thread* ptask)
{
  601041f108:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  601041f10c:	910003fd 	mov	x29, sp
  601041f110:	f9000bf3 	str	x19, [sp, #16]
  601041f114:	f90017e0 	str	x0, [sp, #40]
    assert(ptask != NULL);
  601041f118:	f94017e0 	ldr	x0, [sp, #40]
  601041f11c:	f100001f 	cmp	x0, #0x0
  601041f120:	540001e1 	b.ne	601041f15c <sys_exit+0x54>  // b.any
  601041f124:	52800522 	mov	w2, #0x29                  	// #41
  601041f128:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f12c:	9125a001 	add	x1, x0, #0x968
  601041f130:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f134:	9124c000 	add	x0, x0, #0x930
  601041f138:	97ffd410 	bl	6010414178 <printf_>
  601041f13c:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f140:	91250001 	add	x1, x0, #0x940
  601041f144:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f148:	91254000 	add	x0, x0, #0x950
  601041f14c:	97ffd40b 	bl	6010414178 <printf_>
  601041f150:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f154:	91258000 	add	x0, x0, #0x960
  601041f158:	97ffc054 	bl	601040f2a8 <panic>
    ptask->dead = true;
  601041f15c:	f94017e0 	ldr	x0, [sp, #40]
  601041f160:	52800021 	mov	w1, #0x1                   	// #1
  601041f164:	39005401 	strb	w1, [x0, #21]
    // free that task straightly if it's a blocked task
    if (ptask->state == BLOCKED) {
  601041f168:	f94017e0 	ldr	x0, [sp, #40]
  601041f16c:	b940a800 	ldr	w0, [x0, #168]
  601041f170:	7100101f 	cmp	w0, #0x4
  601041f174:	540000c1 	b.ne	601041f18c <sys_exit+0x84>  // b.any
        xizi_task_manager.free_pcb(ptask);
  601041f178:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041f17c:	f942ec00 	ldr	x0, [x0, #1496]
  601041f180:	f9419801 	ldr	x1, [x0, #816]
  601041f184:	f94017e0 	ldr	x0, [sp, #40]
  601041f188:	d63f0020 	blr	x1
    }
    // yield current task in case it wants to exit itself
    xizi_task_manager.task_yield_noschedule(cur_cpu()->task, false);
  601041f18c:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041f190:	f942ec00 	ldr	x0, [x0, #1496]
  601041f194:	f941a813 	ldr	x19, [x0, #848]
  601041f198:	97ffffd1 	bl	601041f0dc <cur_cpu>
  601041f19c:	f9400400 	ldr	x0, [x0, #8]
  601041f1a0:	52800001 	mov	w1, #0x0                   	// #0
  601041f1a4:	d63f0260 	blr	x19
    return 0;
  601041f1a8:	52800000 	mov	w0, #0x0                   	// #0
}
  601041f1ac:	f9400bf3 	ldr	x19, [sp, #16]
  601041f1b0:	a8c37bfd 	ldp	x29, x30, [sp], #48
  601041f1b4:	d65f03c0 	ret

000000601041f1b8 <cur_cpuid>:
{
  601041f1b8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601041f1bc:	910003fd 	mov	x29, sp
    return cpu_get_current();
  601041f1c0:	97ffbd36 	bl	601040e698 <cpu_get_current>
}
  601041f1c4:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601041f1c8:	d65f03c0 	ret

000000601041f1cc <cur_cpu>:
{
  601041f1cc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601041f1d0:	910003fd 	mov	x29, sp
    return &global_cpus[cur_cpuid()];
  601041f1d4:	97fffff9 	bl	601041f1b8 <cur_cpuid>
  601041f1d8:	93407c01 	sxtw	x1, w0
  601041f1dc:	d2800300 	mov	x0, #0x18                  	// #24
  601041f1e0:	9b007c21 	mul	x1, x1, x0
  601041f1e4:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041f1e8:	f942f400 	ldr	x0, [x0, #1512]
  601041f1ec:	8b000020 	add	x0, x1, x0
}
  601041f1f0:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601041f1f4:	d65f03c0 	ret

000000601041f1f8 <show_tasks>:

#define SHOWINFO_BORDER_LINE() LOG_PRINTF("******************************************************\n");
#define SHOWTASK_TASK_BASE_INFO(task) LOG_PRINTF(" %-6d %-16s %-4d 0x%x(%-d)\n", task->tid, task->name, task->priority, task->memspace->mem_size >> 10, task->memspace->mem_size >> 10)

void show_tasks(void)
{
  601041f1f8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  601041f1fc:	910003fd 	mov	x29, sp
    struct Thread* task = NULL;
  601041f200:	f90017ff 	str	xzr, [sp, #40]
    SHOWINFO_BORDER_LINE();
  601041f204:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f208:	9125e000 	add	x0, x0, #0x978
  601041f20c:	97ffd3db 	bl	6010414178 <printf_>
    for (int i = 0; i < NR_CPU; i++) {
  601041f210:	b90027ff 	str	wzr, [sp, #36]
  601041f214:	1400001c 	b	601041f284 <show_tasks+0x8c>
        LOG_PRINTF("CPU %-2d: %s\n", i, (global_cpus[i].task == NULL ? "NULL" : global_cpus[i].task->name));
  601041f218:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041f21c:	f942f401 	ldr	x1, [x0, #1512]
  601041f220:	b98027e2 	ldrsw	x2, [sp, #36]
  601041f224:	d2800300 	mov	x0, #0x18                  	// #24
  601041f228:	9b007c40 	mul	x0, x2, x0
  601041f22c:	8b000020 	add	x0, x1, x0
  601041f230:	f9400400 	ldr	x0, [x0, #8]
  601041f234:	f100001f 	cmp	x0, #0x0
  601041f238:	54000120 	b.eq	601041f25c <show_tasks+0x64>  // b.none
  601041f23c:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041f240:	f942f401 	ldr	x1, [x0, #1512]
  601041f244:	b98027e2 	ldrsw	x2, [sp, #36]
  601041f248:	d2800300 	mov	x0, #0x18                  	// #24
  601041f24c:	9b007c40 	mul	x0, x2, x0
  601041f250:	8b000020 	add	x0, x1, x0
  601041f254:	f9400400 	ldr	x0, [x0, #8]
  601041f258:	14000003 	b	601041f264 <show_tasks+0x6c>
  601041f25c:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f260:	9126c000 	add	x0, x0, #0x9b0
  601041f264:	aa0003e2 	mov	x2, x0
  601041f268:	b94027e1 	ldr	w1, [sp, #36]
  601041f26c:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f270:	9126e000 	add	x0, x0, #0x9b8
  601041f274:	97ffd3c1 	bl	6010414178 <printf_>
    for (int i = 0; i < NR_CPU; i++) {
  601041f278:	b94027e0 	ldr	w0, [sp, #36]
  601041f27c:	11000400 	add	w0, w0, #0x1
  601041f280:	b90027e0 	str	w0, [sp, #36]
  601041f284:	b94027e0 	ldr	w0, [sp, #36]
  601041f288:	7100001f 	cmp	w0, #0x0
  601041f28c:	54fffc6d 	b.le	601041f218 <show_tasks+0x20>
    }
    SHOWINFO_BORDER_LINE();
  601041f290:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f294:	9125e000 	add	x0, x0, #0x978
  601041f298:	97ffd3b8 	bl	6010414178 <printf_>
    LOG_PRINTF("%-8s %-6s %-16s %-4s %-8s\n", "STAT", "ID", "TASK", "PRI", "MEM(KB)");
  601041f29c:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f2a0:	91272005 	add	x5, x0, #0x9c8
  601041f2a4:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f2a8:	91274004 	add	x4, x0, #0x9d0
  601041f2ac:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f2b0:	91276003 	add	x3, x0, #0x9d8
  601041f2b4:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f2b8:	91278002 	add	x2, x0, #0x9e0
  601041f2bc:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f2c0:	9127a001 	add	x1, x0, #0x9e8
  601041f2c4:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f2c8:	9127c000 	add	x0, x0, #0x9f0
  601041f2cc:	97ffd3ab 	bl	6010414178 <printf_>
    DOUBLE_LIST_FOR_EACH_ENTRY(task, &xizi_task_manager.task_running_list_head, node)
  601041f2d0:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041f2d4:	f942ec00 	ldr	x0, [x0, #1496]
  601041f2d8:	f9410000 	ldr	x0, [x0, #512]
  601041f2dc:	d1026000 	sub	x0, x0, #0x98
  601041f2e0:	f90017e0 	str	x0, [sp, #40]
  601041f2e4:	1400001b 	b	601041f350 <show_tasks+0x158>
    {
        LOG_PRINTF("%-8s", "RUNNING");
  601041f2e8:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f2ec:	91284001 	add	x1, x0, #0xa10
  601041f2f0:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f2f4:	91286000 	add	x0, x0, #0xa18
  601041f2f8:	97ffd3a0 	bl	6010414178 <printf_>
        SHOWTASK_TASK_BASE_INFO(task);
  601041f2fc:	f94017e0 	ldr	x0, [sp, #40]
  601041f300:	b9401001 	ldr	w1, [x0, #16]
  601041f304:	f94017e2 	ldr	x2, [sp, #40]
  601041f308:	f94017e0 	ldr	x0, [sp, #40]
  601041f30c:	b940ac03 	ldr	w3, [x0, #172]
  601041f310:	f94017e0 	ldr	x0, [sp, #40]
  601041f314:	f9402800 	ldr	x0, [x0, #80]
  601041f318:	f9400800 	ldr	x0, [x0, #16]
  601041f31c:	d34afc04 	lsr	x4, x0, #10
  601041f320:	f94017e0 	ldr	x0, [sp, #40]
  601041f324:	f9402800 	ldr	x0, [x0, #80]
  601041f328:	f9400800 	ldr	x0, [x0, #16]
  601041f32c:	d34afc00 	lsr	x0, x0, #10
  601041f330:	aa0003e5 	mov	x5, x0
  601041f334:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f338:	91288000 	add	x0, x0, #0xa20
  601041f33c:	97ffd38f 	bl	6010414178 <printf_>
    DOUBLE_LIST_FOR_EACH_ENTRY(task, &xizi_task_manager.task_running_list_head, node)
  601041f340:	f94017e0 	ldr	x0, [sp, #40]
  601041f344:	f9404c00 	ldr	x0, [x0, #152]
  601041f348:	d1026000 	sub	x0, x0, #0x98
  601041f34c:	f90017e0 	str	x0, [sp, #40]
  601041f350:	f94017e0 	ldr	x0, [sp, #40]
  601041f354:	91026001 	add	x1, x0, #0x98
  601041f358:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041f35c:	f942ec00 	ldr	x0, [x0, #1496]
  601041f360:	91080000 	add	x0, x0, #0x200
  601041f364:	eb00003f 	cmp	x1, x0
  601041f368:	54fffc01 	b.ne	601041f2e8 <show_tasks+0xf0>  // b.any
    }

    for (int i = 0; i < TASK_MAX_PRIORITY; i++) {
  601041f36c:	b90023ff 	str	wzr, [sp, #32]
  601041f370:	14000062 	b	601041f4f8 <show_tasks+0x300>
        if (IS_DOUBLE_LIST_EMPTY(&xizi_task_manager.task_list_head[i])) {
  601041f374:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041f378:	f942ec01 	ldr	x1, [x0, #1496]
  601041f37c:	b98023e0 	ldrsw	x0, [sp, #32]
  601041f380:	d37cec00 	lsl	x0, x0, #4
  601041f384:	8b000020 	add	x0, x1, x0
  601041f388:	f9400001 	ldr	x1, [x0]
  601041f38c:	b98023e0 	ldrsw	x0, [sp, #32]
  601041f390:	d37cec02 	lsl	x2, x0, #4
  601041f394:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041f398:	f942ec00 	ldr	x0, [x0, #1496]
  601041f39c:	8b000040 	add	x0, x2, x0
  601041f3a0:	eb00003f 	cmp	x1, x0
  601041f3a4:	54000a20 	b.eq	601041f4e8 <show_tasks+0x2f0>  // b.none
            continue;
        }
        DOUBLE_LIST_FOR_EACH_ENTRY(task, &xizi_task_manager.task_list_head[i], node)
  601041f3a8:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041f3ac:	f942ec01 	ldr	x1, [x0, #1496]
  601041f3b0:	b98023e0 	ldrsw	x0, [sp, #32]
  601041f3b4:	d37cec00 	lsl	x0, x0, #4
  601041f3b8:	8b000020 	add	x0, x1, x0
  601041f3bc:	f9400000 	ldr	x0, [x0]
  601041f3c0:	d1026000 	sub	x0, x0, #0x98
  601041f3c4:	f90017e0 	str	x0, [sp, #40]
  601041f3c8:	1400003e 	b	601041f4c0 <show_tasks+0x2c8>
        {
            switch (task->state) {
  601041f3cc:	f94017e0 	ldr	x0, [sp, #40]
  601041f3d0:	b940a800 	ldr	w0, [x0, #168]
  601041f3d4:	71000c1f 	cmp	w0, #0x3
  601041f3d8:	540003c0 	b.eq	601041f450 <show_tasks+0x258>  // b.none
  601041f3dc:	71000c1f 	cmp	w0, #0x3
  601041f3e0:	54000448 	b.hi	601041f468 <show_tasks+0x270>  // b.pmore
  601041f3e4:	7100081f 	cmp	w0, #0x2
  601041f3e8:	54000280 	b.eq	601041f438 <show_tasks+0x240>  // b.none
  601041f3ec:	7100081f 	cmp	w0, #0x2
  601041f3f0:	540003c8 	b.hi	601041f468 <show_tasks+0x270>  // b.pmore
  601041f3f4:	7100001f 	cmp	w0, #0x0
  601041f3f8:	54000080 	b.eq	601041f408 <show_tasks+0x210>  // b.none
  601041f3fc:	7100041f 	cmp	w0, #0x1
  601041f400:	54000100 	b.eq	601041f420 <show_tasks+0x228>  // b.none
                break;
            case DEAD:
                LOG_PRINTF("%-8s", "DEAD");
                break;
            default:
                break;
  601041f404:	14000019 	b	601041f468 <show_tasks+0x270>
                LOG_PRINTF("%-8s", "INIT");
  601041f408:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f40c:	91290001 	add	x1, x0, #0xa40
  601041f410:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f414:	91286000 	add	x0, x0, #0xa18
  601041f418:	97ffd358 	bl	6010414178 <printf_>
                break;
  601041f41c:	14000014 	b	601041f46c <show_tasks+0x274>
                LOG_PRINTF("%-8s", "READY");
  601041f420:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f424:	91292001 	add	x1, x0, #0xa48
  601041f428:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f42c:	91286000 	add	x0, x0, #0xa18
  601041f430:	97ffd352 	bl	6010414178 <printf_>
                break;
  601041f434:	1400000e 	b	601041f46c <show_tasks+0x274>
                LOG_PRINTF("%-8s", "RUNNING");
  601041f438:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f43c:	91284001 	add	x1, x0, #0xa10
  601041f440:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f444:	91286000 	add	x0, x0, #0xa18
  601041f448:	97ffd34c 	bl	6010414178 <printf_>
                break;
  601041f44c:	14000008 	b	601041f46c <show_tasks+0x274>
                LOG_PRINTF("%-8s", "DEAD");
  601041f450:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f454:	91294001 	add	x1, x0, #0xa50
  601041f458:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f45c:	91286000 	add	x0, x0, #0xa18
  601041f460:	97ffd346 	bl	6010414178 <printf_>
                break;
  601041f464:	14000002 	b	601041f46c <show_tasks+0x274>
                break;
  601041f468:	d503201f 	nop
            }

            SHOWTASK_TASK_BASE_INFO(task);
  601041f46c:	f94017e0 	ldr	x0, [sp, #40]
  601041f470:	b9401001 	ldr	w1, [x0, #16]
  601041f474:	f94017e2 	ldr	x2, [sp, #40]
  601041f478:	f94017e0 	ldr	x0, [sp, #40]
  601041f47c:	b940ac03 	ldr	w3, [x0, #172]
  601041f480:	f94017e0 	ldr	x0, [sp, #40]
  601041f484:	f9402800 	ldr	x0, [x0, #80]
  601041f488:	f9400800 	ldr	x0, [x0, #16]
  601041f48c:	d34afc04 	lsr	x4, x0, #10
  601041f490:	f94017e0 	ldr	x0, [sp, #40]
  601041f494:	f9402800 	ldr	x0, [x0, #80]
  601041f498:	f9400800 	ldr	x0, [x0, #16]
  601041f49c:	d34afc00 	lsr	x0, x0, #10
  601041f4a0:	aa0003e5 	mov	x5, x0
  601041f4a4:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f4a8:	91288000 	add	x0, x0, #0xa20
  601041f4ac:	97ffd333 	bl	6010414178 <printf_>
        DOUBLE_LIST_FOR_EACH_ENTRY(task, &xizi_task_manager.task_list_head[i], node)
  601041f4b0:	f94017e0 	ldr	x0, [sp, #40]
  601041f4b4:	f9404c00 	ldr	x0, [x0, #152]
  601041f4b8:	d1026000 	sub	x0, x0, #0x98
  601041f4bc:	f90017e0 	str	x0, [sp, #40]
  601041f4c0:	f94017e0 	ldr	x0, [sp, #40]
  601041f4c4:	91026001 	add	x1, x0, #0x98
  601041f4c8:	b98023e0 	ldrsw	x0, [sp, #32]
  601041f4cc:	d37cec02 	lsl	x2, x0, #4
  601041f4d0:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041f4d4:	f942ec00 	ldr	x0, [x0, #1496]
  601041f4d8:	8b000040 	add	x0, x2, x0
  601041f4dc:	eb00003f 	cmp	x1, x0
  601041f4e0:	54fff761 	b.ne	601041f3cc <show_tasks+0x1d4>  // b.any
  601041f4e4:	14000002 	b	601041f4ec <show_tasks+0x2f4>
            continue;
  601041f4e8:	d503201f 	nop
    for (int i = 0; i < TASK_MAX_PRIORITY; i++) {
  601041f4ec:	b94023e0 	ldr	w0, [sp, #32]
  601041f4f0:	11000400 	add	w0, w0, #0x1
  601041f4f4:	b90023e0 	str	w0, [sp, #32]
  601041f4f8:	b94023e0 	ldr	w0, [sp, #32]
  601041f4fc:	71007c1f 	cmp	w0, #0x1f
  601041f500:	54fff3ad 	b.le	601041f374 <show_tasks+0x17c>
        }
    }

    DOUBLE_LIST_FOR_EACH_ENTRY(task, &xizi_task_manager.task_blocked_list_head, node)
  601041f504:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041f508:	f942ec00 	ldr	x0, [x0, #1496]
  601041f50c:	f9410800 	ldr	x0, [x0, #528]
  601041f510:	d1026000 	sub	x0, x0, #0x98
  601041f514:	f90017e0 	str	x0, [sp, #40]
  601041f518:	1400001b 	b	601041f584 <show_tasks+0x38c>
    {
        LOG_PRINTF("%-8s", "BLOCK");
  601041f51c:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f520:	91296001 	add	x1, x0, #0xa58
  601041f524:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f528:	91286000 	add	x0, x0, #0xa18
  601041f52c:	97ffd313 	bl	6010414178 <printf_>
        SHOWTASK_TASK_BASE_INFO(task);
  601041f530:	f94017e0 	ldr	x0, [sp, #40]
  601041f534:	b9401001 	ldr	w1, [x0, #16]
  601041f538:	f94017e2 	ldr	x2, [sp, #40]
  601041f53c:	f94017e0 	ldr	x0, [sp, #40]
  601041f540:	b940ac03 	ldr	w3, [x0, #172]
  601041f544:	f94017e0 	ldr	x0, [sp, #40]
  601041f548:	f9402800 	ldr	x0, [x0, #80]
  601041f54c:	f9400800 	ldr	x0, [x0, #16]
  601041f550:	d34afc04 	lsr	x4, x0, #10
  601041f554:	f94017e0 	ldr	x0, [sp, #40]
  601041f558:	f9402800 	ldr	x0, [x0, #80]
  601041f55c:	f9400800 	ldr	x0, [x0, #16]
  601041f560:	d34afc00 	lsr	x0, x0, #10
  601041f564:	aa0003e5 	mov	x5, x0
  601041f568:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f56c:	91288000 	add	x0, x0, #0xa20
  601041f570:	97ffd302 	bl	6010414178 <printf_>
    DOUBLE_LIST_FOR_EACH_ENTRY(task, &xizi_task_manager.task_blocked_list_head, node)
  601041f574:	f94017e0 	ldr	x0, [sp, #40]
  601041f578:	f9404c00 	ldr	x0, [x0, #152]
  601041f57c:	d1026000 	sub	x0, x0, #0x98
  601041f580:	f90017e0 	str	x0, [sp, #40]
  601041f584:	f94017e0 	ldr	x0, [sp, #40]
  601041f588:	91026001 	add	x1, x0, #0x98
  601041f58c:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041f590:	f942ec00 	ldr	x0, [x0, #1496]
  601041f594:	91084000 	add	x0, x0, #0x210
  601041f598:	eb00003f 	cmp	x1, x0
  601041f59c:	54fffc01 	b.ne	601041f51c <show_tasks+0x324>  // b.any
    }

    struct ksemaphore* sem = NULL;
  601041f5a0:	f9000fff 	str	xzr, [sp, #24]
    DOUBLE_LIST_FOR_EACH_ENTRY(sem, &xizi_task_manager.semaphore_pool.sem_list_guard, sem_list_node)
  601041f5a4:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041f5a8:	f942ec00 	ldr	x0, [x0, #1496]
  601041f5ac:	f9413000 	ldr	x0, [x0, #608]
  601041f5b0:	d1006000 	sub	x0, x0, #0x18
  601041f5b4:	f9000fe0 	str	x0, [sp, #24]
  601041f5b8:	1400002b 	b	601041f664 <show_tasks+0x46c>
    {
        task = NULL;
  601041f5bc:	f90017ff 	str	xzr, [sp, #40]
        DOUBLE_LIST_FOR_EACH_ENTRY(task, &sem->wait_list_guard, node)
  601041f5c0:	f9400fe0 	ldr	x0, [sp, #24]
  601041f5c4:	f9400400 	ldr	x0, [x0, #8]
  601041f5c8:	d1026000 	sub	x0, x0, #0x98
  601041f5cc:	f90017e0 	str	x0, [sp, #40]
  601041f5d0:	1400001b 	b	601041f63c <show_tasks+0x444>
        {
            LOG_PRINTF("%-8s", "BLOCK");
  601041f5d4:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f5d8:	91296001 	add	x1, x0, #0xa58
  601041f5dc:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f5e0:	91286000 	add	x0, x0, #0xa18
  601041f5e4:	97ffd2e5 	bl	6010414178 <printf_>
            SHOWTASK_TASK_BASE_INFO(task);
  601041f5e8:	f94017e0 	ldr	x0, [sp, #40]
  601041f5ec:	b9401001 	ldr	w1, [x0, #16]
  601041f5f0:	f94017e2 	ldr	x2, [sp, #40]
  601041f5f4:	f94017e0 	ldr	x0, [sp, #40]
  601041f5f8:	b940ac03 	ldr	w3, [x0, #172]
  601041f5fc:	f94017e0 	ldr	x0, [sp, #40]
  601041f600:	f9402800 	ldr	x0, [x0, #80]
  601041f604:	f9400800 	ldr	x0, [x0, #16]
  601041f608:	d34afc04 	lsr	x4, x0, #10
  601041f60c:	f94017e0 	ldr	x0, [sp, #40]
  601041f610:	f9402800 	ldr	x0, [x0, #80]
  601041f614:	f9400800 	ldr	x0, [x0, #16]
  601041f618:	d34afc00 	lsr	x0, x0, #10
  601041f61c:	aa0003e5 	mov	x5, x0
  601041f620:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f624:	91288000 	add	x0, x0, #0xa20
  601041f628:	97ffd2d4 	bl	6010414178 <printf_>
        DOUBLE_LIST_FOR_EACH_ENTRY(task, &sem->wait_list_guard, node)
  601041f62c:	f94017e0 	ldr	x0, [sp, #40]
  601041f630:	f9404c00 	ldr	x0, [x0, #152]
  601041f634:	d1026000 	sub	x0, x0, #0x98
  601041f638:	f90017e0 	str	x0, [sp, #40]
  601041f63c:	f94017e0 	ldr	x0, [sp, #40]
  601041f640:	91026001 	add	x1, x0, #0x98
  601041f644:	f9400fe0 	ldr	x0, [sp, #24]
  601041f648:	91002000 	add	x0, x0, #0x8
  601041f64c:	eb00003f 	cmp	x1, x0
  601041f650:	54fffc21 	b.ne	601041f5d4 <show_tasks+0x3dc>  // b.any
    DOUBLE_LIST_FOR_EACH_ENTRY(sem, &xizi_task_manager.semaphore_pool.sem_list_guard, sem_list_node)
  601041f654:	f9400fe0 	ldr	x0, [sp, #24]
  601041f658:	f9400c00 	ldr	x0, [x0, #24]
  601041f65c:	d1006000 	sub	x0, x0, #0x18
  601041f660:	f9000fe0 	str	x0, [sp, #24]
  601041f664:	f9400fe0 	ldr	x0, [sp, #24]
  601041f668:	91006001 	add	x1, x0, #0x18
  601041f66c:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041f670:	f942ec00 	ldr	x0, [x0, #1496]
  601041f674:	91098000 	add	x0, x0, #0x260
  601041f678:	eb00003f 	cmp	x1, x0
  601041f67c:	54fffa01 	b.ne	601041f5bc <show_tasks+0x3c4>  // b.any
        }
    }

    SHOWINFO_BORDER_LINE();
  601041f680:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f684:	9125e000 	add	x0, x0, #0x978
  601041f688:	97ffd2bc 	bl	6010414178 <printf_>
    return;
  601041f68c:	d503201f 	nop
}
  601041f690:	a8c37bfd 	ldp	x29, x30, [sp], #48
  601041f694:	d65f03c0 	ret

000000601041f698 <show_mem>:

extern struct KBuddy user_phy_freemem_buddy;
extern struct KBuddy kern_virtmem_buddy;
extern uintptr_t kernel_data_end[];
void show_mem(void)
{
  601041f698:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  601041f69c:	910003fd 	mov	x29, sp
    SHOWINFO_BORDER_LINE();
  601041f6a0:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f6a4:	9125e000 	add	x0, x0, #0x978
  601041f6a8:	97ffd2b4 	bl	6010414178 <printf_>

    uint64_t total = (PHY_MEM_STOP - V2P(kernel_data_end));
  601041f6ac:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041f6b0:	f942c000 	ldr	x0, [x0, #1408]
  601041f6b4:	d2a80001 	mov	x1, #0x40000000            	// #1073741824
  601041f6b8:	f2c00c01 	movk	x1, #0x60, lsl #32
  601041f6bc:	cb000020 	sub	x0, x1, x0
  601041f6c0:	f9000be0 	str	x0, [sp, #16]
    uint64_t user_dynamic_free = 0;
  601041f6c4:	f90017ff 	str	xzr, [sp, #40]
    uint64_t kernel_free = 0;
  601041f6c8:	f90013ff 	str	xzr, [sp, #32]
    for (int j = 0; j < MAX_BUDDY_ORDER; j++) {
  601041f6cc:	b9001fff 	str	wzr, [sp, #28]
  601041f6d0:	14000024 	b	601041f760 <show_mem+0xc8>
        user_dynamic_free += user_phy_freemem_buddy.free_list[j].n_free_pages * (1 << j) * PAGE_SIZE;
  601041f6d4:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041f6d8:	f9429801 	ldr	x1, [x0, #1328]
  601041f6dc:	b9801fe2 	ldrsw	x2, [sp, #28]
  601041f6e0:	d2800300 	mov	x0, #0x18                  	// #24
  601041f6e4:	9b007c40 	mul	x0, x2, x0
  601041f6e8:	8b000020 	add	x0, x1, x0
  601041f6ec:	f9402001 	ldr	x1, [x0, #64]
  601041f6f0:	b9401fe0 	ldr	w0, [sp, #28]
  601041f6f4:	52800022 	mov	w2, #0x1                   	// #1
  601041f6f8:	1ac02040 	lsl	w0, w2, w0
  601041f6fc:	93407c00 	sxtw	x0, w0
  601041f700:	9b007c20 	mul	x0, x1, x0
  601041f704:	d374cc00 	lsl	x0, x0, #12
  601041f708:	f94017e1 	ldr	x1, [sp, #40]
  601041f70c:	8b000020 	add	x0, x1, x0
  601041f710:	f90017e0 	str	x0, [sp, #40]
        kernel_free += kern_virtmem_buddy.free_list[j].n_free_pages * (1 << j) * PAGE_SIZE;
  601041f714:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041f718:	f942d401 	ldr	x1, [x0, #1448]
  601041f71c:	b9801fe2 	ldrsw	x2, [sp, #28]
  601041f720:	d2800300 	mov	x0, #0x18                  	// #24
  601041f724:	9b007c40 	mul	x0, x2, x0
  601041f728:	8b000020 	add	x0, x1, x0
  601041f72c:	f9402001 	ldr	x1, [x0, #64]
  601041f730:	b9401fe0 	ldr	w0, [sp, #28]
  601041f734:	52800022 	mov	w2, #0x1                   	// #1
  601041f738:	1ac02040 	lsl	w0, w2, w0
  601041f73c:	93407c00 	sxtw	x0, w0
  601041f740:	9b007c20 	mul	x0, x1, x0
  601041f744:	d374cc00 	lsl	x0, x0, #12
  601041f748:	f94013e1 	ldr	x1, [sp, #32]
  601041f74c:	8b000020 	add	x0, x1, x0
  601041f750:	f90013e0 	str	x0, [sp, #32]
    for (int j = 0; j < MAX_BUDDY_ORDER; j++) {
  601041f754:	b9401fe0 	ldr	w0, [sp, #28]
  601041f758:	11000400 	add	w0, w0, #0x1
  601041f75c:	b9001fe0 	str	w0, [sp, #28]
  601041f760:	b9401fe0 	ldr	w0, [sp, #28]
  601041f764:	7100241f 	cmp	w0, #0x9
  601041f768:	54fffb6d 	b.le	601041f6d4 <show_mem+0x3c>
    }
    LOG_PRINTF("%-16s 0x%016lx\n", "TOTAL(B)", total);
  601041f76c:	f9400be2 	ldr	x2, [sp, #16]
  601041f770:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f774:	91298001 	add	x1, x0, #0xa60
  601041f778:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f77c:	9129c000 	add	x0, x0, #0xa70
  601041f780:	97ffd27e 	bl	6010414178 <printf_>
    LOG_PRINTF("%-16s 0x%016lx\n", "KERNEL USED(B)", (kern_virtmem_buddy.mem_end - kern_virtmem_buddy.mem_start - kernel_free));
  601041f784:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041f788:	f942d400 	ldr	x0, [x0, #1448]
  601041f78c:	f940a001 	ldr	x1, [x0, #320]
  601041f790:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041f794:	f942d400 	ldr	x0, [x0, #1448]
  601041f798:	f9409c00 	ldr	x0, [x0, #312]
  601041f79c:	cb000021 	sub	x1, x1, x0
  601041f7a0:	f94013e0 	ldr	x0, [sp, #32]
  601041f7a4:	cb000020 	sub	x0, x1, x0
  601041f7a8:	aa0003e2 	mov	x2, x0
  601041f7ac:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f7b0:	912a0001 	add	x1, x0, #0xa80
  601041f7b4:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f7b8:	9129c000 	add	x0, x0, #0xa70
  601041f7bc:	97ffd26f 	bl	6010414178 <printf_>
    LOG_PRINTF("%-16s 0x%016lx\n", "LIBMEM USED(B)", (user_phy_freemem_buddy.mem_end - user_phy_freemem_buddy.mem_start - user_dynamic_free));
  601041f7c0:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041f7c4:	f9429800 	ldr	x0, [x0, #1328]
  601041f7c8:	f940a001 	ldr	x1, [x0, #320]
  601041f7cc:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041f7d0:	f9429800 	ldr	x0, [x0, #1328]
  601041f7d4:	f9409c00 	ldr	x0, [x0, #312]
  601041f7d8:	cb000021 	sub	x1, x1, x0
  601041f7dc:	f94017e0 	ldr	x0, [sp, #40]
  601041f7e0:	cb000020 	sub	x0, x1, x0
  601041f7e4:	aa0003e2 	mov	x2, x0
  601041f7e8:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f7ec:	912a4001 	add	x1, x0, #0xa90
  601041f7f0:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f7f4:	9129c000 	add	x0, x0, #0xa70
  601041f7f8:	97ffd260 	bl	6010414178 <printf_>
    LOG_PRINTF("%-16s 0x%016lx\n", "FREE(B)", user_dynamic_free + kernel_free);
  601041f7fc:	f94017e1 	ldr	x1, [sp, #40]
  601041f800:	f94013e0 	ldr	x0, [sp, #32]
  601041f804:	8b000020 	add	x0, x1, x0
  601041f808:	aa0003e2 	mov	x2, x0
  601041f80c:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f810:	912a8001 	add	x1, x0, #0xaa0
  601041f814:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f818:	9129c000 	add	x0, x0, #0xa70
  601041f81c:	97ffd257 	bl	6010414178 <printf_>

    SHOWINFO_BORDER_LINE();
  601041f820:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f824:	9125e000 	add	x0, x0, #0x978
  601041f828:	97ffd254 	bl	6010414178 <printf_>
    return;
  601041f82c:	d503201f 	nop
}
  601041f830:	a8c37bfd 	ldp	x29, x30, [sp], #48
  601041f834:	d65f03c0 	ret

000000601041f838 <show_cpu>:

void show_cpu(void)
{
  601041f838:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  601041f83c:	910003fd 	mov	x29, sp
    LOG_PRINTF("**********************************************************\n");
  601041f840:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f844:	912aa000 	add	x0, x0, #0xaa8
  601041f848:	97ffd24c 	bl	6010414178 <printf_>
#ifdef ARCH_SMP
    /// @todo support smp
    KPrintf(" cpu  VALUE \n");
#endif

    int cpu_id = 0;
  601041f84c:	b9001fff 	str	wzr, [sp, #28]

    struct Thread* current_task = cur_cpu()->task;
  601041f850:	97fffe5f 	bl	601041f1cc <cur_cpu>
  601041f854:	f9400400 	ldr	x0, [x0, #8]
  601041f858:	f9000be0 	str	x0, [sp, #16]
    assert(current_task != NULL);
  601041f85c:	f9400be0 	ldr	x0, [sp, #16]
  601041f860:	f100001f 	cmp	x0, #0x0
  601041f864:	540001e1 	b.ne	601041f8a0 <show_cpu+0x68>  // b.any
  601041f868:	528011e2 	mov	w2, #0x8f                  	// #143
  601041f86c:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f870:	912ee001 	add	x1, x0, #0xbb8
  601041f874:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f878:	912ba000 	add	x0, x0, #0xae8
  601041f87c:	97ffd23f 	bl	6010414178 <printf_>
  601041f880:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f884:	912be001 	add	x1, x0, #0xaf8
  601041f888:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f88c:	912c4000 	add	x0, x0, #0xb10
  601041f890:	97ffd23a 	bl	6010414178 <printf_>
  601041f894:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f898:	912c8000 	add	x0, x0, #0xb20
  601041f89c:	97ffbe83 	bl	601040f2a8 <panic>

    LOG_PRINTF(" ID  COMMAND        USED_TICKS  FREE_TICKS \n");
  601041f8a0:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f8a4:	912ca000 	add	x0, x0, #0xb28
  601041f8a8:	97ffd234 	bl	6010414178 <printf_>
    LOG_PRINTF(" %d   %s   %d          %d\n", cpu_id, current_task->name, TASK_CLOCK_TICK - current_task->remain_tick, current_task->remain_tick);
  601041f8ac:	f9400be2 	ldr	x2, [sp, #16]
  601041f8b0:	f9400be0 	ldr	x0, [sp, #16]
  601041f8b4:	b940b000 	ldr	w0, [x0, #176]
  601041f8b8:	52800641 	mov	w1, #0x32                  	// #50
  601041f8bc:	4b000021 	sub	w1, w1, w0
  601041f8c0:	f9400be0 	ldr	x0, [sp, #16]
  601041f8c4:	b940b000 	ldr	w0, [x0, #176]
  601041f8c8:	2a0003e4 	mov	w4, w0
  601041f8cc:	2a0103e3 	mov	w3, w1
  601041f8d0:	b9401fe1 	ldr	w1, [sp, #28]
  601041f8d4:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f8d8:	912d6000 	add	x0, x0, #0xb58
  601041f8dc:	97ffd227 	bl	6010414178 <printf_>

    LOG_PRINTF("***********************************************************\n");
  601041f8e0:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041f8e4:	912de000 	add	x0, x0, #0xb78
  601041f8e8:	97ffd224 	bl	6010414178 <printf_>
    return;
  601041f8ec:	d503201f 	nop
}
  601041f8f0:	a8c27bfd 	ldp	x29, x30, [sp], #32
  601041f8f4:	d65f03c0 	ret

000000601041f8f8 <sys_state>:

int sys_state(sys_state_option option, sys_state_info* info)
{
  601041f8f8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  601041f8fc:	910003fd 	mov	x29, sp
  601041f900:	b9001fe0 	str	w0, [sp, #28]
  601041f904:	f9000be1 	str	x1, [sp, #16]
    if (option == SYS_STATE_MEMBLOCK_INFO) {
  601041f908:	b9401fe0 	ldr	w0, [sp, #28]
  601041f90c:	71000c1f 	cmp	w0, #0x3
  601041f910:	54000201 	b.ne	601041f950 <sys_state+0x58>  // b.any
        info->memblock_info.memblock_start = (uintptr_t)V2P(_binary_fs_img_start);
  601041f914:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041f918:	f9429c01 	ldr	x1, [x0, #1336]
  601041f91c:	d2dff400 	mov	x0, #0xffa000000000        	// #281062659850240
  601041f920:	f2ffffe0 	movk	x0, #0xffff, lsl #48
  601041f924:	8b000021 	add	x1, x1, x0
  601041f928:	f9400be0 	ldr	x0, [sp, #16]
  601041f92c:	f9000001 	str	x1, [x0]
        info->memblock_info.memblock_end = (uintptr_t)V2P(_binary_fs_img_end);
  601041f930:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041f934:	f942e801 	ldr	x1, [x0, #1488]
  601041f938:	d2dff400 	mov	x0, #0xffa000000000        	// #281062659850240
  601041f93c:	f2ffffe0 	movk	x0, #0xffff, lsl #48
  601041f940:	8b000021 	add	x1, x1, x0
  601041f944:	f9400be0 	ldr	x0, [sp, #16]
  601041f948:	f9000401 	str	x1, [x0, #8]
  601041f94c:	14000021 	b	601041f9d0 <sys_state+0xd8>
    } else if (option == SYS_STATE_GET_HEAP_BASE) {
  601041f950:	b9401fe0 	ldr	w0, [sp, #28]
  601041f954:	7100081f 	cmp	w0, #0x2
  601041f958:	540000c1 	b.ne	601041f970 <sys_state+0x78>  // b.any
        return cur_cpu()->task->memspace->heap_base;
  601041f95c:	97fffe1c 	bl	601041f1cc <cur_cpu>
  601041f960:	f9400400 	ldr	x0, [x0, #8]
  601041f964:	f9402800 	ldr	x0, [x0, #80]
  601041f968:	f9400400 	ldr	x0, [x0, #8]
  601041f96c:	1400001a 	b	601041f9d4 <sys_state+0xdc>
    } else if (option == SYS_STATE_SET_TASK_PRIORITY) {
  601041f970:	b9401fe0 	ldr	w0, [sp, #28]
  601041f974:	7100041f 	cmp	w0, #0x1
  601041f978:	54000101 	b.ne	601041f998 <sys_state+0xa0>  // b.any
        xizi_task_manager.set_cur_task_priority(info->priority);
  601041f97c:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041f980:	f942ec00 	ldr	x0, [x0, #1496]
  601041f984:	f941b401 	ldr	x1, [x0, #872]
  601041f988:	f9400be0 	ldr	x0, [sp, #16]
  601041f98c:	b9400000 	ldr	w0, [x0]
  601041f990:	d63f0020 	blr	x1
  601041f994:	1400000f 	b	601041f9d0 <sys_state+0xd8>
    } else if (option == SYS_STATE_SHOW_TASKS) {
  601041f998:	b9401fe0 	ldr	w0, [sp, #28]
  601041f99c:	7100101f 	cmp	w0, #0x4
  601041f9a0:	54000061 	b.ne	601041f9ac <sys_state+0xb4>  // b.any
        show_tasks();
  601041f9a4:	97fffe15 	bl	601041f1f8 <show_tasks>
  601041f9a8:	1400000a 	b	601041f9d0 <sys_state+0xd8>
    } else if (option == SYS_STATE_SHOW_MEM_INFO) {
  601041f9ac:	b9401fe0 	ldr	w0, [sp, #28]
  601041f9b0:	7100141f 	cmp	w0, #0x5
  601041f9b4:	54000061 	b.ne	601041f9c0 <sys_state+0xc8>  // b.any
        show_mem();
  601041f9b8:	97ffff38 	bl	601041f698 <show_mem>
  601041f9bc:	14000005 	b	601041f9d0 <sys_state+0xd8>
    } else if (option == SYS_STATE_SHOW_CPU_INFO) {
  601041f9c0:	b9401fe0 	ldr	w0, [sp, #28]
  601041f9c4:	7100181f 	cmp	w0, #0x6
  601041f9c8:	54000041 	b.ne	601041f9d0 <sys_state+0xd8>  // b.any
        show_cpu();
  601041f9cc:	97ffff9b 	bl	601041f838 <show_cpu>
    }

    return 0;
  601041f9d0:	52800000 	mov	w0, #0x0                   	// #0
  601041f9d4:	a8c27bfd 	ldp	x29, x30, [sp], #32
  601041f9d8:	d65f03c0 	ret

000000601041f9dc <cur_cpuid>:
{
  601041f9dc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601041f9e0:	910003fd 	mov	x29, sp
    return cpu_get_current();
  601041f9e4:	97ffbb2d 	bl	601040e698 <cpu_get_current>
}
  601041f9e8:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601041f9ec:	d65f03c0 	ret

000000601041f9f0 <cur_cpu>:
{
  601041f9f0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601041f9f4:	910003fd 	mov	x29, sp
    return &global_cpus[cur_cpuid()];
  601041f9f8:	97fffff9 	bl	601041f9dc <cur_cpuid>
  601041f9fc:	93407c01 	sxtw	x1, w0
  601041fa00:	d2800300 	mov	x0, #0x18                  	// #24
  601041fa04:	9b007c21 	mul	x1, x1, x0
  601041fa08:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041fa0c:	f942f400 	ldr	x0, [x0, #1512]
  601041fa10:	8b000020 	add	x0, x1, x0
}
  601041fa14:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601041fa18:	d65f03c0 	ret

000000601041fa1c <sys_mmap>:
#include "share_page.h"
#include "syscall.h"
#include "task.h"

int sys_mmap(uintptr_t vaddr, uintptr_t paddr, int len, int is_dev)
{
  601041fa1c:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  601041fa20:	910003fd 	mov	x29, sp
  601041fa24:	f90017e0 	str	x0, [sp, #40]
  601041fa28:	f90013e1 	str	x1, [sp, #32]
  601041fa2c:	b9001fe2 	str	w2, [sp, #28]
  601041fa30:	b9001be3 	str	w3, [sp, #24]
    struct Thread* cur_task = cur_cpu()->task;
  601041fa34:	97ffffef 	bl	601041f9f0 <cur_cpu>
  601041fa38:	f9400400 	ldr	x0, [x0, #8]
  601041fa3c:	f90027e0 	str	x0, [sp, #72]
    assert(cur_task != NULL);
  601041fa40:	f94027e0 	ldr	x0, [sp, #72]
  601041fa44:	f100001f 	cmp	x0, #0x0
  601041fa48:	540001e1 	b.ne	601041fa84 <sys_mmap+0x68>  // b.any
  601041fa4c:	52800542 	mov	w2, #0x2a                  	// #42
  601041fa50:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041fa54:	91302001 	add	x1, x0, #0xc08
  601041fa58:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041fa5c:	912f2000 	add	x0, x0, #0xbc8
  601041fa60:	97ffd1c6 	bl	6010414178 <printf_>
  601041fa64:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041fa68:	912f6001 	add	x1, x0, #0xbd8
  601041fa6c:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041fa70:	912fc000 	add	x0, x0, #0xbf0
  601041fa74:	97ffd1c1 	bl	6010414178 <printf_>
  601041fa78:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041fa7c:	91300000 	add	x0, x0, #0xc00
  601041fa80:	97ffbe0a 	bl	601040f2a8 <panic>

    int true_len = ALIGNUP(len, PAGE_SIZE);
  601041fa84:	b9401fe0 	ldr	w0, [sp, #28]
  601041fa88:	113ffc00 	add	w0, w0, #0xfff
  601041fa8c:	12144c00 	and	w0, w0, #0xfffff000
  601041fa90:	b90047e0 	str	w0, [sp, #68]

    if (paddr != (uintptr_t)NULL) {
  601041fa94:	f94013e0 	ldr	x0, [sp, #32]
  601041fa98:	f100001f 	cmp	x0, #0x0
  601041fa9c:	54000260 	b.eq	601041fae8 <sys_mmap+0xcc>  // b.none
        if (xizi_share_page_manager.task_map_pages(cur_task, vaddr, paddr, true_len / PAGE_SIZE, is_dev) == (uintptr_t)NULL) {
  601041faa0:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041faa4:	f942e400 	ldr	x0, [x0, #1480]
  601041faa8:	f9400c05 	ldr	x5, [x0, #24]
  601041faac:	b94047e0 	ldr	w0, [sp, #68]
  601041fab0:	113ffc01 	add	w1, w0, #0xfff
  601041fab4:	7100001f 	cmp	w0, #0x0
  601041fab8:	1a80b020 	csel	w0, w1, w0, lt  // lt = tstop
  601041fabc:	130c7c00 	asr	w0, w0, #12
  601041fac0:	b9401be4 	ldr	w4, [sp, #24]
  601041fac4:	2a0003e3 	mov	w3, w0
  601041fac8:	f94013e2 	ldr	x2, [sp, #32]
  601041facc:	f94017e1 	ldr	x1, [sp, #40]
  601041fad0:	f94027e0 	ldr	x0, [sp, #72]
  601041fad4:	d63f00a0 	blr	x5
  601041fad8:	f100001f 	cmp	x0, #0x0
  601041fadc:	54000521 	b.ne	601041fb80 <sys_mmap+0x164>  // b.any
            return -1;
  601041fae0:	12800000 	mov	w0, #0xffffffff            	// #-1
  601041fae4:	14000033 	b	601041fbb0 <sys_mmap+0x194>
        }
    } else {
        int load_len = 0;
  601041fae8:	b9005fff 	str	wzr, [sp, #92]
        uintptr_t load_vaddr = vaddr;
  601041faec:	f94017e0 	ldr	x0, [sp, #40]
  601041faf0:	f9002be0 	str	x0, [sp, #80]
        while (load_len < true_len) {
  601041faf4:	1400001f 	b	601041fb70 <sys_mmap+0x154>
            char* paddr = raw_alloc(PAGE_SIZE);
  601041faf8:	d2820000 	mov	x0, #0x1000                	// #4096
  601041fafc:	97ffdb1f 	bl	6010416778 <raw_alloc>
  601041fb00:	f9001fe0 	str	x0, [sp, #56]
            if (paddr == NULL) {
  601041fb04:	f9401fe0 	ldr	x0, [sp, #56]
  601041fb08:	f100001f 	cmp	x0, #0x0
  601041fb0c:	54000061 	b.ne	601041fb18 <sys_mmap+0xfc>  // b.any
                return -1;
  601041fb10:	12800000 	mov	w0, #0xffffffff            	// #-1
  601041fb14:	14000027 	b	601041fbb0 <sys_mmap+0x194>
            }
            if (xizi_share_page_manager.task_map_pages(cur_task, load_vaddr, (uintptr_t)paddr, 1, false) == (uintptr_t)NULL) {
  601041fb18:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041fb1c:	f942e400 	ldr	x0, [x0, #1480]
  601041fb20:	f9400c05 	ldr	x5, [x0, #24]
  601041fb24:	f9401fe0 	ldr	x0, [sp, #56]
  601041fb28:	52800004 	mov	w4, #0x0                   	// #0
  601041fb2c:	52800023 	mov	w3, #0x1                   	// #1
  601041fb30:	aa0003e2 	mov	x2, x0
  601041fb34:	f9402be1 	ldr	x1, [sp, #80]
  601041fb38:	f94027e0 	ldr	x0, [sp, #72]
  601041fb3c:	d63f00a0 	blr	x5
  601041fb40:	f100001f 	cmp	x0, #0x0
  601041fb44:	540000a1 	b.ne	601041fb58 <sys_mmap+0x13c>  // b.any
                raw_free(paddr);
  601041fb48:	f9401fe0 	ldr	x0, [sp, #56]
  601041fb4c:	97ffdb1b 	bl	60104167b8 <raw_free>
                return -1;
  601041fb50:	12800000 	mov	w0, #0xffffffff            	// #-1
  601041fb54:	14000017 	b	601041fbb0 <sys_mmap+0x194>
            }
            load_vaddr += PAGE_SIZE;
  601041fb58:	f9402be0 	ldr	x0, [sp, #80]
  601041fb5c:	91400400 	add	x0, x0, #0x1, lsl #12
  601041fb60:	f9002be0 	str	x0, [sp, #80]
            load_len += PAGE_SIZE;
  601041fb64:	b9405fe0 	ldr	w0, [sp, #92]
  601041fb68:	11400400 	add	w0, w0, #0x1, lsl #12
  601041fb6c:	b9005fe0 	str	w0, [sp, #92]
        while (load_len < true_len) {
  601041fb70:	b9405fe1 	ldr	w1, [sp, #92]
  601041fb74:	b94047e0 	ldr	w0, [sp, #68]
  601041fb78:	6b00003f 	cmp	w1, w0
  601041fb7c:	54fffbeb 	b.lt	601041faf8 <sys_mmap+0xdc>  // b.tstop
        }
    }

    cur_task->memspace->mem_size += true_len;
  601041fb80:	f94027e0 	ldr	x0, [sp, #72]
  601041fb84:	f9402800 	ldr	x0, [x0, #80]
  601041fb88:	f9400802 	ldr	x2, [x0, #16]
  601041fb8c:	b98047e1 	ldrsw	x1, [sp, #68]
  601041fb90:	f94027e0 	ldr	x0, [sp, #72]
  601041fb94:	f9402800 	ldr	x0, [x0, #80]
  601041fb98:	8b010041 	add	x1, x2, x1
  601041fb9c:	f9000801 	str	x1, [x0, #16]
    return vaddr + true_len;
  601041fba0:	f94017e0 	ldr	x0, [sp, #40]
  601041fba4:	2a0003e1 	mov	w1, w0
  601041fba8:	b94047e0 	ldr	w0, [sp, #68]
  601041fbac:	0b000020 	add	w0, w1, w0
  601041fbb0:	a8c67bfd 	ldp	x29, x30, [sp], #96
  601041fbb4:	d65f03c0 	ret

000000601041fbb8 <sys_kill>:

#include "task.h"

extern int sys_exit(struct Thread* task);
int sys_kill(int id)
{
  601041fbb8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  601041fbbc:	910003fd 	mov	x29, sp
  601041fbc0:	b9001fe0 	str	w0, [sp, #28]
    struct Thread* task = NULL;
  601041fbc4:	f90017ff 	str	xzr, [sp, #40]
    // check if task is a running one
    DOUBLE_LIST_FOR_EACH_ENTRY(task, &xizi_task_manager.task_running_list_head, node)
  601041fbc8:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041fbcc:	f942ec00 	ldr	x0, [x0, #1496]
  601041fbd0:	f9410000 	ldr	x0, [x0, #512]
  601041fbd4:	d1026000 	sub	x0, x0, #0x98
  601041fbd8:	f90017e0 	str	x0, [sp, #40]
  601041fbdc:	1400000e 	b	601041fc14 <sys_kill+0x5c>
    {
        if (task->tid == id) {
  601041fbe0:	f94017e0 	ldr	x0, [sp, #40]
  601041fbe4:	b9401000 	ldr	w0, [x0, #16]
  601041fbe8:	b9401fe1 	ldr	w1, [sp, #28]
  601041fbec:	6b00003f 	cmp	w1, w0
  601041fbf0:	540000a1 	b.ne	601041fc04 <sys_kill+0x4c>  // b.any
            sys_exit(task);
  601041fbf4:	f94017e0 	ldr	x0, [sp, #40]
  601041fbf8:	97fffd44 	bl	601041f108 <sys_exit>
            return 0;
  601041fbfc:	52800000 	mov	w0, #0x0                   	// #0
  601041fc00:	1400004e 	b	601041fd38 <sys_kill+0x180>
    DOUBLE_LIST_FOR_EACH_ENTRY(task, &xizi_task_manager.task_running_list_head, node)
  601041fc04:	f94017e0 	ldr	x0, [sp, #40]
  601041fc08:	f9404c00 	ldr	x0, [x0, #152]
  601041fc0c:	d1026000 	sub	x0, x0, #0x98
  601041fc10:	f90017e0 	str	x0, [sp, #40]
  601041fc14:	f94017e0 	ldr	x0, [sp, #40]
  601041fc18:	91026001 	add	x1, x0, #0x98
  601041fc1c:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041fc20:	f942ec00 	ldr	x0, [x0, #1496]
  601041fc24:	91080000 	add	x0, x0, #0x200
  601041fc28:	eb00003f 	cmp	x1, x0
  601041fc2c:	54fffda1 	b.ne	601041fbe0 <sys_kill+0x28>  // b.any
        }
    }

    // check if task is a blocking one
    DOUBLE_LIST_FOR_EACH_ENTRY(task, &xizi_task_manager.task_blocked_list_head, node)
  601041fc30:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041fc34:	f942ec00 	ldr	x0, [x0, #1496]
  601041fc38:	f9410800 	ldr	x0, [x0, #528]
  601041fc3c:	d1026000 	sub	x0, x0, #0x98
  601041fc40:	f90017e0 	str	x0, [sp, #40]
  601041fc44:	1400000e 	b	601041fc7c <sys_kill+0xc4>
    {
        if (task->tid == id) {
  601041fc48:	f94017e0 	ldr	x0, [sp, #40]
  601041fc4c:	b9401000 	ldr	w0, [x0, #16]
  601041fc50:	b9401fe1 	ldr	w1, [sp, #28]
  601041fc54:	6b00003f 	cmp	w1, w0
  601041fc58:	540000a1 	b.ne	601041fc6c <sys_kill+0xb4>  // b.any
            sys_exit(task);
  601041fc5c:	f94017e0 	ldr	x0, [sp, #40]
  601041fc60:	97fffd2a 	bl	601041f108 <sys_exit>
            return 0;
  601041fc64:	52800000 	mov	w0, #0x0                   	// #0
  601041fc68:	14000034 	b	601041fd38 <sys_kill+0x180>
    DOUBLE_LIST_FOR_EACH_ENTRY(task, &xizi_task_manager.task_blocked_list_head, node)
  601041fc6c:	f94017e0 	ldr	x0, [sp, #40]
  601041fc70:	f9404c00 	ldr	x0, [x0, #152]
  601041fc74:	d1026000 	sub	x0, x0, #0x98
  601041fc78:	f90017e0 	str	x0, [sp, #40]
  601041fc7c:	f94017e0 	ldr	x0, [sp, #40]
  601041fc80:	91026001 	add	x1, x0, #0x98
  601041fc84:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041fc88:	f942ec00 	ldr	x0, [x0, #1496]
  601041fc8c:	91084000 	add	x0, x0, #0x210
  601041fc90:	eb00003f 	cmp	x1, x0
  601041fc94:	54fffda1 	b.ne	601041fc48 <sys_kill+0x90>  // b.any
        }
    }

    // check if task is a ready one
    for (int prio = 0; prio < TASK_MAX_PRIORITY; prio++) {
  601041fc98:	b90027ff 	str	wzr, [sp, #36]
  601041fc9c:	14000023 	b	601041fd28 <sys_kill+0x170>
        DOUBLE_LIST_FOR_EACH_ENTRY(task, &xizi_task_manager.task_list_head[prio], node)
  601041fca0:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041fca4:	f942ec01 	ldr	x1, [x0, #1496]
  601041fca8:	b98027e0 	ldrsw	x0, [sp, #36]
  601041fcac:	d37cec00 	lsl	x0, x0, #4
  601041fcb0:	8b000020 	add	x0, x1, x0
  601041fcb4:	f9400000 	ldr	x0, [x0]
  601041fcb8:	d1026000 	sub	x0, x0, #0x98
  601041fcbc:	f90017e0 	str	x0, [sp, #40]
  601041fcc0:	1400000e 	b	601041fcf8 <sys_kill+0x140>
        {
            if (task->tid == id) {
  601041fcc4:	f94017e0 	ldr	x0, [sp, #40]
  601041fcc8:	b9401000 	ldr	w0, [x0, #16]
  601041fccc:	b9401fe1 	ldr	w1, [sp, #28]
  601041fcd0:	6b00003f 	cmp	w1, w0
  601041fcd4:	540000a1 	b.ne	601041fce8 <sys_kill+0x130>  // b.any
                sys_exit(task);
  601041fcd8:	f94017e0 	ldr	x0, [sp, #40]
  601041fcdc:	97fffd0b 	bl	601041f108 <sys_exit>
                return 0;
  601041fce0:	52800000 	mov	w0, #0x0                   	// #0
  601041fce4:	14000015 	b	601041fd38 <sys_kill+0x180>
        DOUBLE_LIST_FOR_EACH_ENTRY(task, &xizi_task_manager.task_list_head[prio], node)
  601041fce8:	f94017e0 	ldr	x0, [sp, #40]
  601041fcec:	f9404c00 	ldr	x0, [x0, #152]
  601041fcf0:	d1026000 	sub	x0, x0, #0x98
  601041fcf4:	f90017e0 	str	x0, [sp, #40]
  601041fcf8:	f94017e0 	ldr	x0, [sp, #40]
  601041fcfc:	91026001 	add	x1, x0, #0x98
  601041fd00:	b98027e0 	ldrsw	x0, [sp, #36]
  601041fd04:	d37cec02 	lsl	x2, x0, #4
  601041fd08:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041fd0c:	f942ec00 	ldr	x0, [x0, #1496]
  601041fd10:	8b000040 	add	x0, x2, x0
  601041fd14:	eb00003f 	cmp	x1, x0
  601041fd18:	54fffd61 	b.ne	601041fcc4 <sys_kill+0x10c>  // b.any
    for (int prio = 0; prio < TASK_MAX_PRIORITY; prio++) {
  601041fd1c:	b94027e0 	ldr	w0, [sp, #36]
  601041fd20:	11000400 	add	w0, w0, #0x1
  601041fd24:	b90027e0 	str	w0, [sp, #36]
  601041fd28:	b94027e0 	ldr	w0, [sp, #36]
  601041fd2c:	71007c1f 	cmp	w0, #0x1f
  601041fd30:	54fffb8d 	b.le	601041fca0 <sys_kill+0xe8>
            }
        }
    }

    return -1;
  601041fd34:	12800000 	mov	w0, #0xffffffff            	// #-1
  601041fd38:	a8c37bfd 	ldp	x29, x30, [sp], #48
  601041fd3c:	d65f03c0 	ret

000000601041fd40 <cur_cpuid>:
{
  601041fd40:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601041fd44:	910003fd 	mov	x29, sp
    return cpu_get_current();
  601041fd48:	97ffba54 	bl	601040e698 <cpu_get_current>
}
  601041fd4c:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601041fd50:	d65f03c0 	ret

000000601041fd54 <cur_cpu>:
{
  601041fd54:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601041fd58:	910003fd 	mov	x29, sp
    return &global_cpus[cur_cpuid()];
  601041fd5c:	97fffff9 	bl	601041fd40 <cur_cpuid>
  601041fd60:	93407c01 	sxtw	x1, w0
  601041fd64:	d2800300 	mov	x0, #0x18                  	// #24
  601041fd68:	9b007c21 	mul	x1, x1, x0
  601041fd6c:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041fd70:	f942f400 	ldr	x0, [x0, #1512]
  601041fd74:	8b000020 	add	x0, x1, x0
}
  601041fd78:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601041fd7c:	d65f03c0 	ret

000000601041fd80 <sys_semaphore>:
#include "syscall.h"
#include "task.h"

extern bool ksemaphore_wait(struct XiziSemaphorePool* sem_pool, struct Thread* thd, uint32_t sem_id);
int sys_semaphore(sys_sem_option op, int param)
{
  601041fd80:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  601041fd84:	910003fd 	mov	x29, sp
  601041fd88:	b9001fe0 	str	w0, [sp, #28]
  601041fd8c:	b9001be1 	str	w1, [sp, #24]
    bool ret = false;
  601041fd90:	3900bfff 	strb	wzr, [sp, #47]
    switch (op) {
  601041fd94:	b9401fe0 	ldr	w0, [sp, #28]
  601041fd98:	71000c1f 	cmp	w0, #0x3
  601041fd9c:	540004e0 	b.eq	601041fe38 <sys_semaphore+0xb8>  // b.none
  601041fda0:	b9401fe0 	ldr	w0, [sp, #28]
  601041fda4:	71000c1f 	cmp	w0, #0x3
  601041fda8:	540005e8 	b.hi	601041fe64 <sys_semaphore+0xe4>  // b.pmore
  601041fdac:	b9401fe0 	ldr	w0, [sp, #28]
  601041fdb0:	7100081f 	cmp	w0, #0x2
  601041fdb4:	54000320 	b.eq	601041fe18 <sys_semaphore+0x98>  // b.none
  601041fdb8:	b9401fe0 	ldr	w0, [sp, #28]
  601041fdbc:	7100081f 	cmp	w0, #0x2
  601041fdc0:	54000528 	b.hi	601041fe64 <sys_semaphore+0xe4>  // b.pmore
  601041fdc4:	b9401fe0 	ldr	w0, [sp, #28]
  601041fdc8:	7100001f 	cmp	w0, #0x0
  601041fdcc:	540000a0 	b.eq	601041fde0 <sys_semaphore+0x60>  // b.none
  601041fdd0:	b9401fe0 	ldr	w0, [sp, #28]
  601041fdd4:	7100041f 	cmp	w0, #0x1
  601041fdd8:	54000100 	b.eq	601041fdf8 <sys_semaphore+0x78>  // b.none
  601041fddc:	14000022 	b	601041fe64 <sys_semaphore+0xe4>
    case SYS_SEM_NEW: {
        // here, param is treat as val
        return ksemaphore_alloc(&xizi_task_manager.semaphore_pool, param);
  601041fde0:	b9401be1 	ldr	w1, [sp, #24]
  601041fde4:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041fde8:	f942ec00 	ldr	x0, [x0, #1496]
  601041fdec:	91088000 	add	x0, x0, #0x220
  601041fdf0:	97fff3fd 	bl	601041cde4 <ksemaphore_alloc>
  601041fdf4:	14000022 	b	601041fe7c <sys_semaphore+0xfc>
    }
    case SYS_SEM_FREE: {
        // here, param is treat as sem_id
        ret = ksemaphore_free(&xizi_task_manager.semaphore_pool, param);
  601041fdf8:	b9401be0 	ldr	w0, [sp, #24]
  601041fdfc:	2a0003e1 	mov	w1, w0
  601041fe00:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041fe04:	f942ec00 	ldr	x0, [x0, #1496]
  601041fe08:	91088000 	add	x0, x0, #0x220
  601041fe0c:	97fff4e7 	bl	601041d1a8 <ksemaphore_free>
  601041fe10:	3900bfe0 	strb	w0, [sp, #47]
        break;
  601041fe14:	14000014 	b	601041fe64 <sys_semaphore+0xe4>
    }
    case SYS_SEM_SIGNAL: {
        ret = ksemaphore_signal(&xizi_task_manager.semaphore_pool, param);
  601041fe18:	b9401be0 	ldr	w0, [sp, #24]
  601041fe1c:	2a0003e1 	mov	w1, w0
  601041fe20:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041fe24:	f942ec00 	ldr	x0, [x0, #1496]
  601041fe28:	91088000 	add	x0, x0, #0x220
  601041fe2c:	97fff4a1 	bl	601041d0b0 <ksemaphore_signal>
  601041fe30:	3900bfe0 	strb	w0, [sp, #47]
        break;
  601041fe34:	1400000c 	b	601041fe64 <sys_semaphore+0xe4>
    }
    case SYS_SEM_WAIT: {
        ret = ksemaphore_wait(&xizi_task_manager.semaphore_pool, cur_cpu()->task, param);
  601041fe38:	97ffffc7 	bl	601041fd54 <cur_cpu>
  601041fe3c:	f9400400 	ldr	x0, [x0, #8]
  601041fe40:	b9401be1 	ldr	w1, [sp, #24]
  601041fe44:	2a0103e2 	mov	w2, w1
  601041fe48:	aa0003e1 	mov	x1, x0
  601041fe4c:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041fe50:	f942ec00 	ldr	x0, [x0, #1496]
  601041fe54:	91088000 	add	x0, x0, #0x220
  601041fe58:	97fff444 	bl	601041cf68 <ksemaphore_wait>
  601041fe5c:	3900bfe0 	strb	w0, [sp, #47]
        break;
  601041fe60:	d503201f 	nop
    }
    }

    if (LIKELY(ret)) {
  601041fe64:	3940bfe0 	ldrb	w0, [sp, #47]
  601041fe68:	f100001f 	cmp	x0, #0x0
  601041fe6c:	54000060 	b.eq	601041fe78 <sys_semaphore+0xf8>  // b.none
        return 0;
  601041fe70:	52800000 	mov	w0, #0x0                   	// #0
  601041fe74:	14000002 	b	601041fe7c <sys_semaphore+0xfc>
    }
    return -1;
  601041fe78:	12800000 	mov	w0, #0xffffffff            	// #-1
  601041fe7c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  601041fe80:	d65f03c0 	ret

000000601041fe84 <cur_cpuid>:
{
  601041fe84:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  601041fe88:	910003fd 	mov	x29, sp
    return cpu_get_current();
  601041fe8c:	97ffba03 	bl	601040e698 <cpu_get_current>
}
  601041fe90:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601041fe94:	d65f03c0 	ret

000000601041fe98 <main>:
extern int sys_spawn(char* img_start, char* name, char** argv);

static struct TraceTag hardkernel_tag, softkernel_tag;
static volatile int core_init_done = 0;
int main(void)
{
  601041fe98:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  601041fe9c:	910003fd 	mov	x29, sp
    /* init tracer */
    uint32_t cpu_id = cur_cpuid();
  601041fea0:	97fffff9 	bl	601041fe84 <cur_cpuid>
  601041fea4:	b9004be0 	str	w0, [sp, #72]

    if (cpu_id == 0) {
  601041fea8:	b9404be0 	ldr	w0, [sp, #72]
  601041feac:	7100001f 	cmp	w0, #0x0
  601041feb0:	54000741 	b.ne	601041ff98 <main+0x100>  // b.any
        /* init memory management first */
        module_phymem_init(); // init buddy management system
  601041feb4:	97ffd9c4 	bl	60104165c4 <module_phymem_init>
        /* init tracer system */
        sys_tracer_init();
  601041feb8:	97ffd751 	bl	6010415bfc <sys_tracer_init>
        if (!CreateResourceTag(&hardkernel_tag, RequireRootTag(), "hardkernel", TRACER_OWNER, NULL) || //
  601041febc:	97ffd7df 	bl	6010415e38 <RequireRootTag>
  601041fec0:	aa0003e1 	mov	x1, x0
  601041fec4:	d2800004 	mov	x4, #0x0                   	// #0
  601041fec8:	52800023 	mov	w3, #0x1                   	// #1
  601041fecc:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041fed0:	91306002 	add	x2, x0, #0xc18
  601041fed4:	f000b920 	adrp	x0, 6011b46000 <irq_forward_table+0x2380>
  601041fed8:	913d8000 	add	x0, x0, #0xf60
  601041fedc:	97ffd851 	bl	6010416020 <CreateResourceTag>
  601041fee0:	12001c00 	and	w0, w0, #0xff
  601041fee4:	52000000 	eor	w0, w0, #0x1
  601041fee8:	12001c00 	and	w0, w0, #0xff
  601041feec:	7100001f 	cmp	w0, #0x0
  601041fef0:	540001e1 	b.ne	601041ff2c <main+0x94>  // b.any
            !CreateResourceTag(&softkernel_tag, RequireRootTag(), "softkernel", TRACER_OWNER, NULL)) {
  601041fef4:	97ffd7d1 	bl	6010415e38 <RequireRootTag>
  601041fef8:	aa0003e1 	mov	x1, x0
  601041fefc:	d2800004 	mov	x4, #0x0                   	// #0
  601041ff00:	52800023 	mov	w3, #0x1                   	// #1
  601041ff04:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041ff08:	9130a002 	add	x2, x0, #0xc28
  601041ff0c:	f000b920 	adrp	x0, 6011b46000 <irq_forward_table+0x2380>
  601041ff10:	913da000 	add	x0, x0, #0xf68
  601041ff14:	97ffd843 	bl	6010416020 <CreateResourceTag>
  601041ff18:	12001c00 	and	w0, w0, #0xff
  601041ff1c:	52000000 	eor	w0, w0, #0x1
  601041ff20:	12001c00 	and	w0, w0, #0xff
        if (!CreateResourceTag(&hardkernel_tag, RequireRootTag(), "hardkernel", TRACER_OWNER, NULL) || //
  601041ff24:	7100001f 	cmp	w0, #0x0
  601041ff28:	54000180 	b.eq	601041ff58 <main+0xc0>  // b.none
            ERROR("Failed to create hardkernel owner and softkernel owner.\n");
  601041ff2c:	52800742 	mov	w2, #0x3a                  	// #58
  601041ff30:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041ff34:	91376001 	add	x1, x0, #0xdd8
  601041ff38:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041ff3c:	9130e000 	add	x0, x0, #0xc38
  601041ff40:	97ffd08e 	bl	6010414178 <printf_>
  601041ff44:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041ff48:	91312000 	add	x0, x0, #0xc48
  601041ff4c:	97ffd08b 	bl	6010414178 <printf_>
            return -1;
  601041ff50:	12800000 	mov	w0, #0xffffffff            	// #-1
  601041ff54:	140000a1 	b	60104201d8 <main+0x340>
        }
        /* init hardkernel */
        if (!hardkernel_init(&hardkernel_tag)) {
  601041ff58:	f000b920 	adrp	x0, 6011b46000 <irq_forward_table+0x2380>
  601041ff5c:	913d8000 	add	x0, x0, #0xf60
  601041ff60:	97ffd676 	bl	6010415938 <hardkernel_init>
  601041ff64:	12001c00 	and	w0, w0, #0xff
  601041ff68:	52000000 	eor	w0, w0, #0x1
  601041ff6c:	12001c00 	and	w0, w0, #0xff
  601041ff70:	7100001f 	cmp	w0, #0x0
  601041ff74:	54000060 	b.eq	601041ff80 <main+0xe8>  // b.none
            return -1;
  601041ff78:	12800000 	mov	w0, #0xffffffff            	// #-1
  601041ff7c:	14000097 	b	60104201d8 <main+0x340>
        }

        spinlock_init(&whole_kernel_lock, "wklock");
  601041ff80:	90000020 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601041ff84:	91322001 	add	x1, x0, #0xc88
  601041ff88:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041ff8c:	f9429000 	ldr	x0, [x0, #1312]
  601041ff90:	97ffc50c 	bl	60104113c0 <spinlock_init>
  601041ff94:	1400000c 	b	601041ffc4 <main+0x12c>
    } else {
        spinlock_lock(&whole_kernel_lock);
  601041ff98:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041ff9c:	f9429000 	ldr	x0, [x0, #1312]
  601041ffa0:	97ffc517 	bl	60104113fc <spinlock_lock>
        secondary_cpu_hardkernel_init(cpu_id, &hardkernel_tag);
  601041ffa4:	b9404be2 	ldr	w2, [sp, #72]
  601041ffa8:	f000b920 	adrp	x0, 6011b46000 <irq_forward_table+0x2380>
  601041ffac:	913d8001 	add	x1, x0, #0xf60
  601041ffb0:	2a0203e0 	mov	w0, w2
  601041ffb4:	97ffd68e 	bl	60104159ec <secondary_cpu_hardkernel_init>
        spinlock_unlock(&whole_kernel_lock);
  601041ffb8:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041ffbc:	f9429000 	ldr	x0, [x0, #1312]
  601041ffc0:	97ffc563 	bl	601041154c <spinlock_unlock>
    }

    spinlock_lock(&whole_kernel_lock);
  601041ffc4:	90008920 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  601041ffc8:	f9429000 	ldr	x0, [x0, #1312]
  601041ffcc:	97ffc50c 	bl	60104113fc <spinlock_lock>
    if (cpu_id == 0) {
  601041ffd0:	b9404be0 	ldr	w0, [sp, #72]
  601041ffd4:	7100001f 	cmp	w0, #0x0
  601041ffd8:	54000601 	b.ne	6010420098 <main+0x200>  // b.any
        /* init softkernel */
        if (!softkernel_init(&hardkernel_tag, &softkernel_tag)) {
  601041ffdc:	f000b920 	adrp	x0, 6011b46000 <irq_forward_table+0x2380>
  601041ffe0:	913da001 	add	x1, x0, #0xf68
  601041ffe4:	f000b920 	adrp	x0, 6011b46000 <irq_forward_table+0x2380>
  601041ffe8:	913d8000 	add	x0, x0, #0xf60
  601041ffec:	97ffd92c 	bl	601041649c <softkernel_init>
  601041fff0:	12001c00 	and	w0, w0, #0xff
  601041fff4:	52000000 	eor	w0, w0, #0x1
  601041fff8:	12001c00 	and	w0, w0, #0xff
  601041fffc:	7100001f 	cmp	w0, #0x0
  6010420000:	54000060 	b.eq	601042000c <main+0x174>  // b.none
            return -1;
  6010420004:	12800000 	mov	w0, #0xffffffff            	// #-1
  6010420008:	14000074 	b	60104201d8 <main+0x340>
        }
        show_xizi_bar();
  601042000c:	97ffd95a 	bl	6010416574 <show_xizi_bar>

        for (int i = 1; i < NR_CPU; i++) {
  6010420010:	52800020 	mov	w0, #0x1                   	// #1
  6010420014:	b9004fe0 	str	w0, [sp, #76]
  6010420018:	14000007 	b	6010420034 <main+0x19c>
            // start secondary cpus
            cpu_start_secondary(i);
  601042001c:	b9404fe0 	ldr	w0, [sp, #76]
  6010420020:	12001c00 	and	w0, w0, #0xff
  6010420024:	97ffb98a 	bl	601040e64c <cpu_start_secondary>
        for (int i = 1; i < NR_CPU; i++) {
  6010420028:	b9404fe0 	ldr	w0, [sp, #76]
  601042002c:	11000400 	add	w0, w0, #0x1
  6010420030:	b9004fe0 	str	w0, [sp, #76]
  6010420034:	b9404fe0 	ldr	w0, [sp, #76]
  6010420038:	7100001f 	cmp	w0, #0x0
  601042003c:	54ffff0d 	b.le	601042001c <main+0x184>
        }

        /* start first task */
        char* init_task_param[2] = { "/app/init", 0 };
  6010420040:	f0000000 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  6010420044:	91324000 	add	x0, x0, #0xc90
  6010420048:	f90017e0 	str	x0, [sp, #40]
  601042004c:	f9001bff 	str	xzr, [sp, #48]
        sys_spawn((char*)_binary_init_start, "init", init_task_param);
  6010420050:	9100a3e0 	add	x0, sp, #0x28
  6010420054:	aa0003e2 	mov	x2, x0
  6010420058:	f0000000 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601042005c:	91328001 	add	x1, x0, #0xca0
  6010420060:	f0008900 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010420064:	f942dc00 	ldr	x0, [x0, #1464]
  6010420068:	97fff571 	bl	601041d62c <sys_spawn>
        char* fs_server_task_param[2] = { "/app/fs_server", 0 };
  601042006c:	f0000000 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  6010420070:	9132a000 	add	x0, x0, #0xca8
  6010420074:	f9000fe0 	str	x0, [sp, #24]
  6010420078:	f90013ff 	str	xzr, [sp, #32]
        sys_spawn((char*)_binary_default_fs_start, "memfs", fs_server_task_param);
  601042007c:	910063e0 	add	x0, sp, #0x18
  6010420080:	aa0003e2 	mov	x2, x0
  6010420084:	f0000000 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  6010420088:	9132e001 	add	x1, x0, #0xcb8
  601042008c:	f0008900 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  6010420090:	f942cc00 	ldr	x0, [x0, #1432]
  6010420094:	97fff566 	bl	601041d62c <sys_spawn>
    }
    /* start scheduler */
    struct SchedulerRightGroup scheduler_rights;
    assert(AchieveResourceTag(&scheduler_rights.mmu_driver_tag, &hardkernel_tag, "mmu-ac-resource"));
  6010420098:	9100e3e0 	add	x0, sp, #0x38
  601042009c:	91002003 	add	x3, x0, #0x8
  60104200a0:	f0000000 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  60104200a4:	91330002 	add	x2, x0, #0xcc0
  60104200a8:	d000b920 	adrp	x0, 6011b46000 <irq_forward_table+0x2380>
  60104200ac:	913d8001 	add	x1, x0, #0xf60
  60104200b0:	aa0303e0 	mov	x0, x3
  60104200b4:	97ffd764 	bl	6010415e44 <AchieveResourceTag>
  60104200b8:	12001c00 	and	w0, w0, #0xff
  60104200bc:	52000000 	eor	w0, w0, #0x1
  60104200c0:	12001c00 	and	w0, w0, #0xff
  60104200c4:	7100001f 	cmp	w0, #0x0
  60104200c8:	540001e0 	b.eq	6010420104 <main+0x26c>  // b.none
  60104200cc:	52800bc2 	mov	w2, #0x5e                  	// #94
  60104200d0:	f0000000 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  60104200d4:	91376001 	add	x1, x0, #0xdd8
  60104200d8:	f0000000 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  60104200dc:	9130e000 	add	x0, x0, #0xc38
  60104200e0:	97ffd026 	bl	6010414178 <printf_>
  60104200e4:	f0000000 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  60104200e8:	91334001 	add	x1, x0, #0xcd0
  60104200ec:	f0000000 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  60104200f0:	9134c000 	add	x0, x0, #0xd30
  60104200f4:	97ffd021 	bl	6010414178 <printf_>
  60104200f8:	f0000000 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  60104200fc:	91350000 	add	x0, x0, #0xd40
  6010420100:	97ffbc6a 	bl	601040f2a8 <panic>
    assert(AchieveResourceTag(&scheduler_rights.intr_driver_tag, &hardkernel_tag, "intr-ac-resource"));
  6010420104:	9100e3e3 	add	x3, sp, #0x38
  6010420108:	f0000000 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601042010c:	91352002 	add	x2, x0, #0xd48
  6010420110:	d000b920 	adrp	x0, 6011b46000 <irq_forward_table+0x2380>
  6010420114:	913d8001 	add	x1, x0, #0xf60
  6010420118:	aa0303e0 	mov	x0, x3
  601042011c:	97ffd74a 	bl	6010415e44 <AchieveResourceTag>
  6010420120:	12001c00 	and	w0, w0, #0xff
  6010420124:	52000000 	eor	w0, w0, #0x1
  6010420128:	12001c00 	and	w0, w0, #0xff
  601042012c:	7100001f 	cmp	w0, #0x0
  6010420130:	540001e0 	b.eq	601042016c <main+0x2d4>  // b.none
  6010420134:	52800be2 	mov	w2, #0x5f                  	// #95
  6010420138:	f0000000 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601042013c:	91376001 	add	x1, x0, #0xdd8
  6010420140:	f0000000 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  6010420144:	9130e000 	add	x0, x0, #0xc38
  6010420148:	97ffd00c 	bl	6010414178 <printf_>
  601042014c:	f0000000 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  6010420150:	91358001 	add	x1, x0, #0xd60
  6010420154:	f0000000 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  6010420158:	9134c000 	add	x0, x0, #0xd30
  601042015c:	97ffd007 	bl	6010414178 <printf_>
  6010420160:	f0000000 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  6010420164:	91350000 	add	x0, x0, #0xd40
  6010420168:	97ffbc50 	bl	601040f2a8 <panic>
    core_init_done |= (1 << cpu_id);
  601042016c:	b9404be0 	ldr	w0, [sp, #72]
  6010420170:	52800021 	mov	w1, #0x1                   	// #1
  6010420174:	1ac02021 	lsl	w1, w1, w0
  6010420178:	d000b920 	adrp	x0, 6011b46000 <irq_forward_table+0x2380>
  601042017c:	913dc000 	add	x0, x0, #0xf70
  6010420180:	b9400000 	ldr	w0, [x0]
  6010420184:	2a000021 	orr	w1, w1, w0
  6010420188:	d000b920 	adrp	x0, 6011b46000 <irq_forward_table+0x2380>
  601042018c:	913dc000 	add	x0, x0, #0xf70
  6010420190:	b9000001 	str	w1, [x0]
    LOG_PRINTF("CPU %d init done\n", cpu_id);
  6010420194:	b9404be1 	ldr	w1, [sp, #72]
  6010420198:	f0000000 	adrp	x0, 6010423000 <__func__.0+0x2a0>
  601042019c:	91370000 	add	x0, x0, #0xdc0
  60104201a0:	97ffcff6 	bl	6010414178 <printf_>
    spinlock_unlock(&whole_kernel_lock);
  60104201a4:	f0008900 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  60104201a8:	f9429000 	ldr	x0, [x0, #1312]
  60104201ac:	97ffc4e8 	bl	601041154c <spinlock_unlock>

    // sync memory
    __sync_synchronize();
  60104201b0:	d5033bbf 	dmb	ish
    start_smp_cache_broadcast(cpu_id);
  60104201b4:	b9404be0 	ldr	w0, [sp, #72]
  60104201b8:	97ffb933 	bl	601040e684 <start_smp_cache_broadcast>
    // enter kernel seriously
    xizi_enter_kernel();
  60104201bc:	97ffe745 	bl	6010419ed0 <xizi_enter_kernel>
    xizi_task_manager.task_scheduler(scheduler_rights);
  60104201c0:	f0008900 	adrp	x0, 6011543000 <_binary_default_fs_start+0x96000>
  60104201c4:	f942ec00 	ldr	x0, [x0, #1496]
  60104201c8:	f941a402 	ldr	x2, [x0, #840]
  60104201cc:	a94387e0 	ldp	x0, x1, [sp, #56]
  60104201d0:	d63f0040 	blr	x2

    // never reached
    return 0;
  60104201d4:	52800000 	mov	w0, #0x0                   	// #0
}
  60104201d8:	a8c57bfd 	ldp	x29, x30, [sp], #80
  60104201dc:	d65f03c0 	ret

00000060104201e0 <_exit>:

__attribute__((weak)) void _exit(int32_t status)
{
  60104201e0:	d10043ff 	sub	sp, sp, #0x10
  60104201e4:	b9000fe0 	str	w0, [sp, #12]
    (void)status;
    while (1) {
  60104201e8:	14000000 	b	60104201e8 <_exit+0x8>
	...

0000006010420200 <memcpy>:
  6010420200:	f9800020 	prfm	pldl1keep, [x1]
  6010420204:	8b020024 	add	x4, x1, x2
  6010420208:	8b020005 	add	x5, x0, x2
  601042020c:	f100405f 	cmp	x2, #0x10
  6010420210:	54000209 	b.ls	6010420250 <memcpy+0x50>  // b.plast
  6010420214:	f101805f 	cmp	x2, #0x60
  6010420218:	54000648 	b.hi	60104202e0 <memcpy+0xe0>  // b.pmore
  601042021c:	d1000449 	sub	x9, x2, #0x1
  6010420220:	a9401c26 	ldp	x6, x7, [x1]
  6010420224:	37300469 	tbnz	w9, #6, 60104202b0 <memcpy+0xb0>
  6010420228:	a97f348c 	ldp	x12, x13, [x4, #-16]
  601042022c:	362800a9 	tbz	w9, #5, 6010420240 <memcpy+0x40>
  6010420230:	a9412428 	ldp	x8, x9, [x1, #16]
  6010420234:	a97e2c8a 	ldp	x10, x11, [x4, #-32]
  6010420238:	a9012408 	stp	x8, x9, [x0, #16]
  601042023c:	a93e2caa 	stp	x10, x11, [x5, #-32]
  6010420240:	a9001c06 	stp	x6, x7, [x0]
  6010420244:	a93f34ac 	stp	x12, x13, [x5, #-16]
  6010420248:	d65f03c0 	ret
  601042024c:	d503201f 	nop
  6010420250:	f100205f 	cmp	x2, #0x8
  6010420254:	540000e3 	b.cc	6010420270 <memcpy+0x70>  // b.lo, b.ul, b.last
  6010420258:	f9400026 	ldr	x6, [x1]
  601042025c:	f85f8087 	ldur	x7, [x4, #-8]
  6010420260:	f9000006 	str	x6, [x0]
  6010420264:	f81f80a7 	stur	x7, [x5, #-8]
  6010420268:	d65f03c0 	ret
  601042026c:	d503201f 	nop
  6010420270:	361000c2 	tbz	w2, #2, 6010420288 <memcpy+0x88>
  6010420274:	b9400026 	ldr	w6, [x1]
  6010420278:	b85fc087 	ldur	w7, [x4, #-4]
  601042027c:	b9000006 	str	w6, [x0]
  6010420280:	b81fc0a7 	stur	w7, [x5, #-4]
  6010420284:	d65f03c0 	ret
  6010420288:	b4000102 	cbz	x2, 60104202a8 <memcpy+0xa8>
  601042028c:	d341fc49 	lsr	x9, x2, #1
  6010420290:	39400026 	ldrb	w6, [x1]
  6010420294:	385ff087 	ldurb	w7, [x4, #-1]
  6010420298:	38696828 	ldrb	w8, [x1, x9]
  601042029c:	39000006 	strb	w6, [x0]
  60104202a0:	38296808 	strb	w8, [x0, x9]
  60104202a4:	381ff0a7 	sturb	w7, [x5, #-1]
  60104202a8:	d65f03c0 	ret
  60104202ac:	d503201f 	nop
  60104202b0:	a9412428 	ldp	x8, x9, [x1, #16]
  60104202b4:	a9422c2a 	ldp	x10, x11, [x1, #32]
  60104202b8:	a943342c 	ldp	x12, x13, [x1, #48]
  60104202bc:	a97e0881 	ldp	x1, x2, [x4, #-32]
  60104202c0:	a97f0c84 	ldp	x4, x3, [x4, #-16]
  60104202c4:	a9001c06 	stp	x6, x7, [x0]
  60104202c8:	a9012408 	stp	x8, x9, [x0, #16]
  60104202cc:	a9022c0a 	stp	x10, x11, [x0, #32]
  60104202d0:	a903340c 	stp	x12, x13, [x0, #48]
  60104202d4:	a93e08a1 	stp	x1, x2, [x5, #-32]
  60104202d8:	a93f0ca4 	stp	x4, x3, [x5, #-16]
  60104202dc:	d65f03c0 	ret
  60104202e0:	92400c09 	and	x9, x0, #0xf
  60104202e4:	927cec03 	and	x3, x0, #0xfffffffffffffff0
  60104202e8:	a940342c 	ldp	x12, x13, [x1]
  60104202ec:	cb090021 	sub	x1, x1, x9
  60104202f0:	8b090042 	add	x2, x2, x9
  60104202f4:	a9411c26 	ldp	x6, x7, [x1, #16]
  60104202f8:	a900340c 	stp	x12, x13, [x0]
  60104202fc:	a9422428 	ldp	x8, x9, [x1, #32]
  6010420300:	a9432c2a 	ldp	x10, x11, [x1, #48]
  6010420304:	a9c4342c 	ldp	x12, x13, [x1, #64]!
  6010420308:	f1024042 	subs	x2, x2, #0x90
  601042030c:	54000169 	b.ls	6010420338 <memcpy+0x138>  // b.plast
  6010420310:	a9011c66 	stp	x6, x7, [x3, #16]
  6010420314:	a9411c26 	ldp	x6, x7, [x1, #16]
  6010420318:	a9022468 	stp	x8, x9, [x3, #32]
  601042031c:	a9422428 	ldp	x8, x9, [x1, #32]
  6010420320:	a9032c6a 	stp	x10, x11, [x3, #48]
  6010420324:	a9432c2a 	ldp	x10, x11, [x1, #48]
  6010420328:	a984346c 	stp	x12, x13, [x3, #64]!
  601042032c:	a9c4342c 	ldp	x12, x13, [x1, #64]!
  6010420330:	f1010042 	subs	x2, x2, #0x40
  6010420334:	54fffee8 	b.hi	6010420310 <memcpy+0x110>  // b.pmore
  6010420338:	a97c0881 	ldp	x1, x2, [x4, #-64]
  601042033c:	a9011c66 	stp	x6, x7, [x3, #16]
  6010420340:	a97d1c86 	ldp	x6, x7, [x4, #-48]
  6010420344:	a9022468 	stp	x8, x9, [x3, #32]
  6010420348:	a97e2488 	ldp	x8, x9, [x4, #-32]
  601042034c:	a9032c6a 	stp	x10, x11, [x3, #48]
  6010420350:	a97f2c8a 	ldp	x10, x11, [x4, #-16]
  6010420354:	a904346c 	stp	x12, x13, [x3, #64]
  6010420358:	a93c08a1 	stp	x1, x2, [x5, #-64]
  601042035c:	a93d1ca6 	stp	x6, x7, [x5, #-48]
  6010420360:	a93e24a8 	stp	x8, x9, [x5, #-32]
  6010420364:	a93f2caa 	stp	x10, x11, [x5, #-16]
  6010420368:	d65f03c0 	ret
	...

0000006010420380 <strcmp>:
  6010420380:	ca010007 	eor	x7, x0, x1
  6010420384:	b200c3ea 	mov	x10, #0x101010101010101     	// #72340172838076673
  6010420388:	f24008ff 	tst	x7, #0x7
  601042038c:	540003e1 	b.ne	6010420408 <strcmp+0x88>  // b.any
  6010420390:	f2400807 	ands	x7, x0, #0x7
  6010420394:	54000241 	b.ne	60104203dc <strcmp+0x5c>  // b.any
  6010420398:	f8408402 	ldr	x2, [x0], #8
  601042039c:	f8408423 	ldr	x3, [x1], #8
  60104203a0:	cb0a0047 	sub	x7, x2, x10
  60104203a4:	b200d848 	orr	x8, x2, #0x7f7f7f7f7f7f7f7f
  60104203a8:	ca030045 	eor	x5, x2, x3
  60104203ac:	8a2800e4 	bic	x4, x7, x8
  60104203b0:	aa0400a6 	orr	x6, x5, x4
  60104203b4:	b4ffff26 	cbz	x6, 6010420398 <strcmp+0x18>
  60104203b8:	dac00cc6 	rev	x6, x6
  60104203bc:	dac00c42 	rev	x2, x2
  60104203c0:	dac010cb 	clz	x11, x6
  60104203c4:	dac00c63 	rev	x3, x3
  60104203c8:	9acb2042 	lsl	x2, x2, x11
  60104203cc:	9acb2063 	lsl	x3, x3, x11
  60104203d0:	d378fc42 	lsr	x2, x2, #56
  60104203d4:	cb43e040 	sub	x0, x2, x3, lsr #56
  60104203d8:	d65f03c0 	ret
  60104203dc:	927df000 	and	x0, x0, #0xfffffffffffffff8
  60104203e0:	927df021 	and	x1, x1, #0xfffffffffffffff8
  60104203e4:	d37df0e7 	lsl	x7, x7, #3
  60104203e8:	f8408402 	ldr	x2, [x0], #8
  60104203ec:	cb0703e7 	neg	x7, x7
  60104203f0:	f8408423 	ldr	x3, [x1], #8
  60104203f4:	92800008 	mov	x8, #0xffffffffffffffff    	// #-1
  60104203f8:	9ac72508 	lsr	x8, x8, x7
  60104203fc:	aa080042 	orr	x2, x2, x8
  6010420400:	aa080063 	orr	x3, x3, x8
  6010420404:	17ffffe7 	b	60104203a0 <strcmp+0x20>
  6010420408:	f240081f 	tst	x0, #0x7
  601042040c:	54000100 	b.eq	601042042c <strcmp+0xac>  // b.none
  6010420410:	38401402 	ldrb	w2, [x0], #1
  6010420414:	38401423 	ldrb	w3, [x1], #1
  6010420418:	7100045f 	cmp	w2, #0x1
  601042041c:	7a432040 	ccmp	w2, w3, #0x0, cs  // cs = hs, nlast
  6010420420:	540001e1 	b.ne	601042045c <strcmp+0xdc>  // b.any
  6010420424:	f240081f 	tst	x0, #0x7
  6010420428:	54ffff41 	b.ne	6010420410 <strcmp+0x90>  // b.any
  601042042c:	927d2027 	and	x7, x1, #0xff8
  6010420430:	d27d20e7 	eor	x7, x7, #0xff8
  6010420434:	b4fffee7 	cbz	x7, 6010420410 <strcmp+0x90>
  6010420438:	f8408402 	ldr	x2, [x0], #8
  601042043c:	f8408423 	ldr	x3, [x1], #8
  6010420440:	cb0a0047 	sub	x7, x2, x10
  6010420444:	b200d848 	orr	x8, x2, #0x7f7f7f7f7f7f7f7f
  6010420448:	ca030045 	eor	x5, x2, x3
  601042044c:	8a2800e4 	bic	x4, x7, x8
  6010420450:	aa0400a6 	orr	x6, x5, x4
  6010420454:	b4fffec6 	cbz	x6, 601042042c <strcmp+0xac>
  6010420458:	17ffffd8 	b	60104203b8 <strcmp+0x38>
  601042045c:	cb030040 	sub	x0, x2, x3
  6010420460:	d65f03c0 	ret
	...

0000006010420480 <strcpy>:
  6010420480:	92402c29 	and	x9, x1, #0xfff
  6010420484:	b200c3ec 	mov	x12, #0x101010101010101     	// #72340172838076673
  6010420488:	92400c31 	and	x17, x1, #0xf
  601042048c:	f13fc13f 	cmp	x9, #0xff0
  6010420490:	cb1103e8 	neg	x8, x17
  6010420494:	540008cc 	b.gt	60104205ac <strcpy+0x12c>
  6010420498:	a9401424 	ldp	x4, x5, [x1]
  601042049c:	cb0c0088 	sub	x8, x4, x12
  60104204a0:	b200d889 	orr	x9, x4, #0x7f7f7f7f7f7f7f7f
  60104204a4:	ea290106 	bics	x6, x8, x9
  60104204a8:	540001c1 	b.ne	60104204e0 <strcpy+0x60>  // b.any
  60104204ac:	cb0c00aa 	sub	x10, x5, x12
  60104204b0:	b200d8ab 	orr	x11, x5, #0x7f7f7f7f7f7f7f7f
  60104204b4:	ea2b0147 	bics	x7, x10, x11
  60104204b8:	54000440 	b.eq	6010420540 <strcpy+0xc0>  // b.none
  60104204bc:	dac00ce7 	rev	x7, x7
  60104204c0:	dac010ef 	clz	x15, x7
  60104204c4:	d2800709 	mov	x9, #0x38                  	// #56
  60104204c8:	8b4f0c03 	add	x3, x0, x15, lsr #3
  60104204cc:	cb0f012f 	sub	x15, x9, x15
  60104204d0:	9acf20a5 	lsl	x5, x5, x15
  60104204d4:	f8001065 	stur	x5, [x3, #1]
  60104204d8:	f9000004 	str	x4, [x0]
  60104204dc:	d65f03c0 	ret
  60104204e0:	dac00cc6 	rev	x6, x6
  60104204e4:	dac010cf 	clz	x15, x6
  60104204e8:	8b4f0c03 	add	x3, x0, x15, lsr #3
  60104204ec:	f10061e9 	subs	x9, x15, #0x18
  60104204f0:	540000ab 	b.lt	6010420504 <strcpy+0x84>  // b.tstop
  60104204f4:	9ac92485 	lsr	x5, x4, x9
  60104204f8:	b81fd065 	stur	w5, [x3, #-3]
  60104204fc:	b9000004 	str	w4, [x0]
  6010420500:	d65f03c0 	ret
  6010420504:	b400004f 	cbz	x15, 601042050c <strcpy+0x8c>
  6010420508:	79000004 	strh	w4, [x0]
  601042050c:	3900007f 	strb	wzr, [x3]
  6010420510:	d65f03c0 	ret
  6010420514:	d503201f 	nop
  6010420518:	d503201f 	nop
  601042051c:	d503201f 	nop
  6010420520:	d503201f 	nop
  6010420524:	d503201f 	nop
  6010420528:	d503201f 	nop
  601042052c:	d503201f 	nop
  6010420530:	d503201f 	nop
  6010420534:	d503201f 	nop
  6010420538:	d503201f 	nop
  601042053c:	d503201f 	nop
  6010420540:	d1004231 	sub	x17, x17, #0x10
  6010420544:	a9001404 	stp	x4, x5, [x0]
  6010420548:	cb110022 	sub	x2, x1, x17
  601042054c:	cb110003 	sub	x3, x0, x17
  6010420550:	14000002 	b	6010420558 <strcpy+0xd8>
  6010420554:	a8811464 	stp	x4, x5, [x3], #16
  6010420558:	a8c11444 	ldp	x4, x5, [x2], #16
  601042055c:	cb0c0088 	sub	x8, x4, x12
  6010420560:	b200d889 	orr	x9, x4, #0x7f7f7f7f7f7f7f7f
  6010420564:	cb0c00aa 	sub	x10, x5, x12
  6010420568:	b200d8ab 	orr	x11, x5, #0x7f7f7f7f7f7f7f7f
  601042056c:	8a290106 	bic	x6, x8, x9
  6010420570:	ea2b0147 	bics	x7, x10, x11
  6010420574:	fa4008c0 	ccmp	x6, #0x0, #0x0, eq  // eq = none
  6010420578:	54fffee0 	b.eq	6010420554 <strcpy+0xd4>  // b.none
  601042057c:	f10000df 	cmp	x6, #0x0
  6010420580:	9a8710c6 	csel	x6, x6, x7, ne  // ne = any
  6010420584:	dac00cc6 	rev	x6, x6
  6010420588:	dac010cf 	clz	x15, x6
  601042058c:	910121e8 	add	x8, x15, #0x48
  6010420590:	910021ef 	add	x15, x15, #0x8
  6010420594:	9a8811ef 	csel	x15, x15, x8, ne  // ne = any
  6010420598:	8b4f0c42 	add	x2, x2, x15, lsr #3
  601042059c:	8b4f0c63 	add	x3, x3, x15, lsr #3
  60104205a0:	a97e1444 	ldp	x4, x5, [x2, #-32]
  60104205a4:	a93f1464 	stp	x4, x5, [x3, #-16]
  60104205a8:	d65f03c0 	ret
  60104205ac:	927cec22 	and	x2, x1, #0xfffffffffffffff0
  60104205b0:	a9401444 	ldp	x4, x5, [x2]
  60104205b4:	d37df108 	lsl	x8, x8, #3
  60104205b8:	f2400a3f 	tst	x17, #0x7
  60104205bc:	da9f03e9 	csetm	x9, ne  // ne = any
  60104205c0:	9ac82529 	lsr	x9, x9, x8
  60104205c4:	aa090084 	orr	x4, x4, x9
  60104205c8:	aa0900ae 	orr	x14, x5, x9
  60104205cc:	f100223f 	cmp	x17, #0x8
  60104205d0:	da9fb084 	csinv	x4, x4, xzr, lt  // lt = tstop
  60104205d4:	9a8eb0a5 	csel	x5, x5, x14, lt  // lt = tstop
  60104205d8:	cb0c0088 	sub	x8, x4, x12
  60104205dc:	b200d889 	orr	x9, x4, #0x7f7f7f7f7f7f7f7f
  60104205e0:	cb0c00aa 	sub	x10, x5, x12
  60104205e4:	b200d8ab 	orr	x11, x5, #0x7f7f7f7f7f7f7f7f
  60104205e8:	8a290106 	bic	x6, x8, x9
  60104205ec:	ea2b0147 	bics	x7, x10, x11
  60104205f0:	fa4008c0 	ccmp	x6, #0x0, #0x0, eq  // eq = none
  60104205f4:	54fff520 	b.eq	6010420498 <strcpy+0x18>  // b.none
  60104205f8:	d37df228 	lsl	x8, x17, #3
  60104205fc:	cb110fe9 	neg	x9, x17, lsl #3
  6010420600:	9ac8248d 	lsr	x13, x4, x8
  6010420604:	9ac920ab 	lsl	x11, x5, x9
  6010420608:	9ac824a5 	lsr	x5, x5, x8
  601042060c:	aa0d016b 	orr	x11, x11, x13
  6010420610:	f100223f 	cmp	x17, #0x8
  6010420614:	9a85b164 	csel	x4, x11, x5, lt  // lt = tstop
  6010420618:	cb0c0088 	sub	x8, x4, x12
  601042061c:	b200d889 	orr	x9, x4, #0x7f7f7f7f7f7f7f7f
  6010420620:	cb0c00aa 	sub	x10, x5, x12
  6010420624:	b200d8ab 	orr	x11, x5, #0x7f7f7f7f7f7f7f7f
  6010420628:	8a290106 	bic	x6, x8, x9
  601042062c:	b5fff5a6 	cbnz	x6, 60104204e0 <strcpy+0x60>
  6010420630:	8a2b0147 	bic	x7, x10, x11
  6010420634:	17ffffa2 	b	60104204bc <strcpy+0x3c>
	...

0000006010420640 <strlen>:
  6010420640:	92402c04 	and	x4, x0, #0xfff
  6010420644:	b200c3e8 	mov	x8, #0x101010101010101     	// #72340172838076673
  6010420648:	f13fc09f 	cmp	x4, #0xff0
  601042064c:	5400082c 	b.gt	6010420750 <strlen+0x110>
  6010420650:	a9400c02 	ldp	x2, x3, [x0]
  6010420654:	cb080044 	sub	x4, x2, x8
  6010420658:	b200d845 	orr	x5, x2, #0x7f7f7f7f7f7f7f7f
  601042065c:	cb080066 	sub	x6, x3, x8
  6010420660:	b200d867 	orr	x7, x3, #0x7f7f7f7f7f7f7f7f
  6010420664:	ea250084 	bics	x4, x4, x5
  6010420668:	8a2700c5 	bic	x5, x6, x7
  601042066c:	fa4008a0 	ccmp	x5, #0x0, #0x0, eq  // eq = none
  6010420670:	54000100 	b.eq	6010420690 <strlen+0x50>  // b.none
  6010420674:	9a853084 	csel	x4, x4, x5, cc  // cc = lo, ul, last
  6010420678:	d2800100 	mov	x0, #0x8                   	// #8
  601042067c:	dac00c84 	rev	x4, x4
  6010420680:	dac01084 	clz	x4, x4
  6010420684:	9a8033e0 	csel	x0, xzr, x0, cc  // cc = lo, ul, last
  6010420688:	8b440c00 	add	x0, x0, x4, lsr #3
  601042068c:	d65f03c0 	ret
  6010420690:	927cec01 	and	x1, x0, #0xfffffffffffffff0
  6010420694:	d1004021 	sub	x1, x1, #0x10
  6010420698:	a9c20c22 	ldp	x2, x3, [x1, #32]!
  601042069c:	cb080044 	sub	x4, x2, x8
  60104206a0:	cb080066 	sub	x6, x3, x8
  60104206a4:	aa060085 	orr	x5, x4, x6
  60104206a8:	ea081cbf 	tst	x5, x8, lsl #7
  60104206ac:	54000101 	b.ne	60104206cc <strlen+0x8c>  // b.any
  60104206b0:	a9410c22 	ldp	x2, x3, [x1, #16]
  60104206b4:	cb080044 	sub	x4, x2, x8
  60104206b8:	cb080066 	sub	x6, x3, x8
  60104206bc:	aa060085 	orr	x5, x4, x6
  60104206c0:	ea081cbf 	tst	x5, x8, lsl #7
  60104206c4:	54fffea0 	b.eq	6010420698 <strlen+0x58>  // b.none
  60104206c8:	91004021 	add	x1, x1, #0x10
  60104206cc:	b200d845 	orr	x5, x2, #0x7f7f7f7f7f7f7f7f
  60104206d0:	b200d867 	orr	x7, x3, #0x7f7f7f7f7f7f7f7f
  60104206d4:	ea250084 	bics	x4, x4, x5
  60104206d8:	8a2700c5 	bic	x5, x6, x7
  60104206dc:	fa4008a0 	ccmp	x5, #0x0, #0x0, eq  // eq = none
  60104206e0:	54000120 	b.eq	6010420704 <strlen+0xc4>  // b.none
  60104206e4:	9a853084 	csel	x4, x4, x5, cc  // cc = lo, ul, last
  60104206e8:	cb000020 	sub	x0, x1, x0
  60104206ec:	dac00c84 	rev	x4, x4
  60104206f0:	91002005 	add	x5, x0, #0x8
  60104206f4:	dac01084 	clz	x4, x4
  60104206f8:	9a853000 	csel	x0, x0, x5, cc  // cc = lo, ul, last
  60104206fc:	8b440c00 	add	x0, x0, x4, lsr #3
  6010420700:	d65f03c0 	ret
  6010420704:	a9c10c22 	ldp	x2, x3, [x1, #16]!
  6010420708:	cb080044 	sub	x4, x2, x8
  601042070c:	b200d845 	orr	x5, x2, #0x7f7f7f7f7f7f7f7f
  6010420710:	cb080066 	sub	x6, x3, x8
  6010420714:	b200d867 	orr	x7, x3, #0x7f7f7f7f7f7f7f7f
  6010420718:	ea250084 	bics	x4, x4, x5
  601042071c:	8a2700c5 	bic	x5, x6, x7
  6010420720:	fa4008a0 	ccmp	x5, #0x0, #0x0, eq  // eq = none
  6010420724:	54fffe01 	b.ne	60104206e4 <strlen+0xa4>  // b.any
  6010420728:	a9c10c22 	ldp	x2, x3, [x1, #16]!
  601042072c:	cb080044 	sub	x4, x2, x8
  6010420730:	b200d845 	orr	x5, x2, #0x7f7f7f7f7f7f7f7f
  6010420734:	cb080066 	sub	x6, x3, x8
  6010420738:	b200d867 	orr	x7, x3, #0x7f7f7f7f7f7f7f7f
  601042073c:	ea250084 	bics	x4, x4, x5
  6010420740:	8a2700c5 	bic	x5, x6, x7
  6010420744:	fa4008a0 	ccmp	x5, #0x0, #0x0, eq  // eq = none
  6010420748:	54fffde0 	b.eq	6010420704 <strlen+0xc4>  // b.none
  601042074c:	17ffffe6 	b	60104206e4 <strlen+0xa4>
  6010420750:	927cec01 	and	x1, x0, #0xfffffffffffffff0
  6010420754:	a9400c22 	ldp	x2, x3, [x1]
  6010420758:	d37df004 	lsl	x4, x0, #3
  601042075c:	92800007 	mov	x7, #0xffffffffffffffff    	// #-1
  6010420760:	9ac420e4 	lsl	x4, x7, x4
  6010420764:	b201c084 	orr	x4, x4, #0x8080808080808080
  6010420768:	aa240042 	orn	x2, x2, x4
  601042076c:	aa240065 	orn	x5, x3, x4
  6010420770:	f27d001f 	tst	x0, #0x8
  6010420774:	9a870042 	csel	x2, x2, x7, eq  // eq = none
  6010420778:	9a850063 	csel	x3, x3, x5, eq  // eq = none
  601042077c:	17ffffc8 	b	601042069c <strlen+0x5c>

0000006010420780 <strncpy>:
  6010420780:	aa000023 	orr	x3, x1, x0
  6010420784:	f240087f 	tst	x3, #0x7
  6010420788:	aa0003e3 	mov	x3, x0
  601042078c:	fa470840 	ccmp	x2, #0x7, #0x0, eq  // eq = none
  6010420790:	540002c8 	b.hi	60104207e8 <strncpy+0x68>  // b.pmore
  6010420794:	d1000445 	sub	x5, x2, #0x1
  6010420798:	d2800027 	mov	x7, #0x1                   	// #1
  601042079c:	8b050025 	add	x5, x1, x5
  60104207a0:	14000007 	b	60104207bc <strncpy+0x3c>
  60104207a4:	386468a4 	ldrb	w4, [x5, x4]
  60104207a8:	d1000446 	sub	x6, x2, #0x1
  60104207ac:	38001424 	strb	w4, [x1], #1
  60104207b0:	340000e4 	cbz	w4, 60104207cc <strncpy+0x4c>
  60104207b4:	aa0103e3 	mov	x3, x1
  60104207b8:	aa0603e2 	mov	x2, x6
  60104207bc:	cb0200e4 	sub	x4, x7, x2
  60104207c0:	aa0303e1 	mov	x1, x3
  60104207c4:	b5ffff02 	cbnz	x2, 60104207a4 <strncpy+0x24>
  60104207c8:	d65f03c0 	ret
  60104207cc:	8b020062 	add	x2, x3, x2
  60104207d0:	b4ffffc6 	cbz	x6, 60104207c8 <strncpy+0x48>
  60104207d4:	d503201f 	nop
  60104207d8:	3800143f 	strb	wzr, [x1], #1
  60104207dc:	eb02003f 	cmp	x1, x2
  60104207e0:	54ffffc1 	b.ne	60104207d8 <strncpy+0x58>  // b.any
  60104207e4:	d65f03c0 	ret
  60104207e8:	b207dbe6 	mov	x6, #0xfefefefefefefefe    	// #-72340172838076674
  60104207ec:	f29fdfe6 	movk	x6, #0xfeff
  60104207f0:	f9400025 	ldr	x5, [x1]
  60104207f4:	8b0600a4 	add	x4, x5, x6
  60104207f8:	8a250084 	bic	x4, x4, x5
  60104207fc:	f201c09f 	tst	x4, #0x8080808080808080
  6010420800:	54fffca1 	b.ne	6010420794 <strncpy+0x14>  // b.any
  6010420804:	d1002042 	sub	x2, x2, #0x8
  6010420808:	f8008465 	str	x5, [x3], #8
  601042080c:	91002021 	add	x1, x1, #0x8
  6010420810:	f1001c5f 	cmp	x2, #0x7
  6010420814:	54fffee8 	b.hi	60104207f0 <strncpy+0x70>  // b.pmore
  6010420818:	17ffffdf 	b	6010420794 <strncpy+0x14>

Disassembly of section .init:

000000601042081c <_init>:
  601042081c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  6010420820:	a9bf73fb 	stp	x27, x28, [sp, #-16]!
  6010420824:	a9bf6bf9 	stp	x25, x26, [sp, #-16]!
  6010420828:	a9bf63f7 	stp	x23, x24, [sp, #-16]!
  601042082c:	a9bf5bf5 	stp	x21, x22, [sp, #-16]!
  6010420830:	a9bf53f3 	stp	x19, x20, [sp, #-16]!
  6010420834:	a8c153f3 	ldp	x19, x20, [sp], #16
  6010420838:	a8c15bf5 	ldp	x21, x22, [sp], #16
  601042083c:	a8c163f7 	ldp	x23, x24, [sp], #16
  6010420840:	a8c16bf9 	ldp	x25, x26, [sp], #16
  6010420844:	a8c173fb 	ldp	x27, x28, [sp], #16
  6010420848:	a8c17bfd 	ldp	x29, x30, [sp], #16
  601042084c:	d65f03c0 	ret

Disassembly of section .fini:

0000006010420850 <_fini>:
  6010420850:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  6010420854:	a9bf73fb 	stp	x27, x28, [sp, #-16]!
  6010420858:	a9bf6bf9 	stp	x25, x26, [sp, #-16]!
  601042085c:	a9bf63f7 	stp	x23, x24, [sp, #-16]!
  6010420860:	a9bf5bf5 	stp	x21, x22, [sp, #-16]!
  6010420864:	a9bf53f3 	stp	x19, x20, [sp, #-16]!
  6010420868:	a8c153f3 	ldp	x19, x20, [sp], #16
  601042086c:	a8c15bf5 	ldp	x21, x22, [sp], #16
  6010420870:	a8c163f7 	ldp	x23, x24, [sp], #16
  6010420874:	a8c16bf9 	ldp	x25, x26, [sp], #16
  6010420878:	a8c173fb 	ldp	x27, x28, [sp], #16
  601042087c:	a8c17bfd 	ldp	x29, x30, [sp], #16
  6010420880:	d65f03c0 	ret
